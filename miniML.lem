(* By Scott Owens, University of Cambridge, Copyright 2011, 2012
 *                 University of Kent 2012, 2013
 *
 * MiniML is a simple ML-like language. It has no type abbreviations, or
 * records, and only simple top-level modules.  It has mutually recursive
 * datatypes (at the top-level and module top-level only) and functions, as
 * well as higher-order functions.  It also supports pattern matching for
 * nested patterns (which can fail due to non-exhaustive patterns).  Only
 * booleans and integer types are built-in.  Syntactic sugar is generally
 * omitted.
 *
 * In some ways it makes more sense to write these kind of semantics in Ott (to
 * get a presentation that looks like ML concrete-syntax-wise, and that has the
 * usual syntax for type systems and operational semantics, i.e., with |- and
 * horizontal lines).  Here in Lem, everything looks like abstract syntax;
 * however, unlike Ott, we get good support for functions, and not just
 * relations.
 *
 * The small-step operational semantics is based on the CEK machine.  The type
 * system is typical.  The big step semantics is also typical.  The small-step
 * and big-step semantics agree even on untyped programs. *)

val i : num -> Int.int
let inline {hol} i = Hol.(&)

val all_distinct : forall 'a. list 'a -> bool
let inline {hol} all_distinct = Hol.ALL_DISTINCT

val rtc : forall 'a. ('a -> 'a -> bool) -> ('a -> 'a -> bool)
let inline {hol} rtc = Hol.RTC

val count_list : num -> list num
let inline {hol} count_list = Hol.COUNT_LIST

val option_map : forall 'a 'b. ('a -> 'b) -> option 'a -> option 'b
let option_map f x = 
  match x with
    | None -> None
    | Some y -> Some (f y)
  end

(* Change the nth element in the list to 'a *)
val LUPDATE : forall 'a. 'a -> num -> list 'a -> list 'a
let inline {hol} LUPDATE = Hol.LUPDATE


(* ------------------------------------------------------------------------ *) 
(*   The Semantics                                                          *)
(* ------------------------------------------------------------------------ *) 


(* Type substitution *)

(* Increment the deBruijn indices in a type by n levels, skipping all levels
 * less than skip. *)
val deBruijn_inc : num -> num -> t -> t
let rec
deBruijn_inc skip n (Tvar tv) = Tvar tv
and
deBruijn_inc skip n (Tvar_db m) =
  if m < skip then
    Tvar_db m
  else
    Tvar_db (m + n)
and
deBruijn_inc skip n (Tapp ts tn) = Tapp (List.map (deBruijn_inc skip n) ts) tn

(* skip the lowest given indices and replace the next (LENGTH ts) with the given types and reduce all the higher ones *)
val deBruijn_subst : num -> list t -> t -> t
let rec
deBruijn_subst skip ts (Tvar tv) = Tvar tv
and
deBruijn_subst skip ts (Tvar_db n) =
  if not (n < skip) && n < List.length ts + skip then
    List.nth ts (n - skip)
  else if not (n < skip) then
    Tvar_db (n - List.length ts)
  else
    Tvar_db n
and
deBruijn_subst skip ts (Tapp ts' tn) =
  Tapp (List.map (deBruijn_subst skip ts) ts') tn

(* ------------------------------------------------------------------------ *) 
(*   Auxiliary definitions used in the proofs                               *)
(* ------------------------------------------------------------------------ *) 

(* Store typing *)
type tenvS = env num t

(* A value has a type *)
(* The number is how many deBruijn type variables are bound in the context. *)
val type_v : num -> tenvM -> tenvC -> tenvS -> v -> t -> bool

(* A value environment has a corresponding type environment.  Since all of the
 * entries in the environment are values, and values have no free variables,
 * each entry in the environment can be typed in the empty environment (if at
 * all) *)
val type_env : tenvM -> tenvC -> tenvS -> envE -> tenvE -> bool

(* The type of the store *)
val type_s : tenvM -> tenvC -> tenvS -> store -> bool

(* An evaluation context has the second type when its hole is filled with a
 * value of the first type. *)
(* The number is how many deBruijn type variables are bound in the context.
 * This is only used for constructor contexts, because the value restriction 
 * ensures that no other contexts can be created under a let binding. *)
val type_ctxt : num -> tenvM -> tenvC -> tenvS -> tenvE -> ctxt_frame -> t -> t -> bool
val type_ctxts : num -> tenvM -> tenvC -> tenvS -> list ctxt -> t -> t -> bool
val type_state : num -> tenvM -> tenvC -> tenvS -> state -> t -> bool
val context_invariant : num -> list ctxt -> num -> bool

(* Type programs without imposing signatures.  This is needed for the type
 * soundness proof *)
val type_prog_ignore_sig : tenvM -> tenvC -> tenvE -> list top -> tenvM -> tenvC -> env varN (num * t) -> bool


indreln

forall menv cenv tenv.
true
==>
type_prog_ignore_sig menv cenv tenv [] emp emp emp

and

forall menv cenv tenv d ds cenv' tenv' menv'' cenv'' tenv''.
type_d None menv cenv tenv d cenv' tenv' &&
type_prog_ignore_sig menv (merge cenv' cenv) (bind_var_list2 tenv' tenv) ds menv'' cenv'' tenv''
==>
type_prog_ignore_sig menv cenv tenv (Tdec d :: ds) menv'' (merge cenv'' cenv') (merge tenv'' tenv')

and

forall menv cenv tenv mn spec ds1 ds2 cenv' menv'' tenv' cenv'' tenv''.
not (List.mem mn (List.map fst menv)) &&
type_ds (Some mn) menv cenv tenv ds1 cenv' tenv' &&
type_prog_ignore_sig (bind mn tenv' menv) (merge cenv' cenv) tenv ds2 menv'' cenv'' tenv''
==>
type_prog_ignore_sig menv cenv tenv (Tmod mn spec ds1 :: ds2) (merge menv'' [(mn,tenv')]) (merge cenv'' cenv') tenv''


indreln

forall tvs menv cenv senv b.
true
==>
type_v tvs menv cenv senv (Litv (Bool b)) Tbool

and

forall tvs menv cenv senv n.
true
==>
type_v tvs menv cenv senv (Litv (IntLit n)) Tint

and

forall tvs menv cenv senv.
true
==>
type_v tvs menv cenv senv (Litv Unit) Tunit

and

forall tvs menv cenv senv cn vs tvs' tn ts' ts.
List.for_all (check_freevars tvs []) ts' &&
List.length tvs' = List.length ts' &&
type_vs tvs menv cenv senv vs (List.map (type_subst (List.combine tvs' ts')) ts) &&
lookup cn cenv = Some (tvs', ts, tn)
==>
type_v tvs menv cenv senv (Conv cn vs) (Tapp ts' (TC_name tn))

and

forall tvs menv cenv senv env tenv n e t1 t2.
type_env menv cenv senv env tenv &&
check_freevars tvs [] t1 &&
type_e menv cenv (bind_tenv n 0 t1 (bind_tvar tvs tenv)) e t2
==>
type_v tvs menv cenv senv (Closure env n e) (Tfn t1 t2)

and

forall tvs menv cenv senv env funs n t tenv tenv'.
type_env menv cenv senv env tenv &&
type_funs menv cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv' &&
lookup n tenv' = Some t
==>
type_v tvs menv cenv senv (Recclosure env funs n) t

and

forall tvs menv cenv senv n t.
check_freevars 0 [] t &&
(lookup n senv = Some t)
==>
type_v tvs menv cenv senv (Loc n) (Tref t)

and

forall tvs menv cenv senv.
true
==>
type_vs tvs menv cenv senv [] []

and

forall tvs menv cenv senv v vs t ts.
type_v tvs menv cenv senv v t &&
type_vs tvs menv cenv senv vs ts
==>
type_vs tvs menv cenv senv (v::vs) (t::ts)

and

forall menv cenv senv.
true
==>
type_env menv cenv senv emp Empty

and

forall menv cenv senv n v env t tenv tvs.
type_v tvs menv cenv senv v t &&
type_env menv cenv senv env tenv
==>
type_env menv cenv senv (bind n v env) (bind_tenv n tvs t tenv)

let type_s menv cenv senv s =
  forall l. 
    ((exists t. lookup l senv = Some t) = (exists v. store_lookup l s = Some v)) &&
    forall t v. ((lookup l senv = Some t) && (store_lookup l s = Some v)) --> type_v 0 menv cenv senv v t

indreln 

forall n.
true
==>
context_invariant n [] n

and

forall dec_tvs c x e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Chandle () x e,env) :: c) 0

and

forall dec_tvs c op e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Capp1 op () e,env) :: c) 0

and

forall dec_tvs c op v env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Capp2 op v (),env) :: c) 0

and

forall dec_tvs c l e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Clog l () e,env) :: c) 0

and

forall dec_tvs c e1 e2 env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cif () e1 e2,env) :: c) 0

and

forall dec_tvs c pes env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cmat () pes,env) :: c) 0

and

forall dec_tvs c tvs x e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Clet x () e,env) :: c) tvs

and

forall dec_tvs c cn vs es tvs env.
context_invariant dec_tvs c tvs &&
(tvs <> 0 --> List.for_all is_value es)
==>
context_invariant dec_tvs ((Ccon cn vs () es,env) :: c) tvs

and

forall dec_tvs c op env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cuapp op (),env) :: c) 0

indreln

forall tvs menv cenv senv tenv x e t.
type_e menv cenv (bind_tenv x 0 Tint tenv) e t
==>
type_ctxt tvs menv cenv senv tenv (Chandle () x e) t t

and

forall tvs menv cenv senv tenv uop t1 t2.
check_freevars tvs [] t1 &&
check_freevars tvs [] t2 &&
type_uop uop t1 t2
==>
type_ctxt tvs menv cenv senv tenv (Cuapp uop ()) t1 t2

and

forall tvs menv cenv senv tenv e op t1 t2 t3.
check_freevars tvs [] t1 &&
check_freevars tvs [] t3 &&
type_e menv cenv tenv e t2 &&
type_op op t1 t2 t3
==>
type_ctxt tvs menv cenv senv tenv (Capp1 op () e) t1 t3

and

forall tvs menv cenv senv tenv op v t1 t2 t3.
check_freevars tvs [] t2 &&
check_freevars tvs [] t3 &&
type_v 0 menv cenv senv v t1 &&
type_op op t1 t2 t3
==>
type_ctxt tvs menv cenv senv tenv (Capp2 op v ()) t2 t3

and

forall tvs menv cenv senv tenv op e.
type_e menv cenv tenv e Tbool
==>
type_ctxt tvs menv cenv senv tenv (Clog op () e) Tbool Tbool

and

forall tvs menv cenv senv tenv e1 e2 t.
type_e menv cenv tenv e1 t &&
type_e menv cenv tenv e2 t
==>
type_ctxt tvs menv cenv senv tenv (Cif () e1 e2) Tbool t

and

forall tvs menv cenv senv tenv t1 t2 pes.
((pes = []) --> (check_freevars tvs [] t1 && check_freevars 0 [] t2)) &&
(forall ((p,e) MEM pes) . exists tenv'.
   all_distinct (pat_bindings p []) &&
   type_p tvs cenv p t1 tenv' &&
   type_e menv cenv (bind_var_list 0 tenv' tenv) e t2)
==>
type_ctxt tvs menv cenv senv tenv (Cmat () pes) t1 t2

and

forall tvs menv cenv senv tenv e t1 t2 n.
check_freevars tvs [] t1 &&
type_e menv cenv (bind_tenv n tvs t1 tenv) e t2
==>
type_ctxt tvs menv cenv senv tenv (Clet n () e) t1 t2

and

forall tvs menv cenv senv tenv cn vs es ts1 ts2 t tn ts' tvs'.
List.for_all (check_freevars tvs []) ts' &&
List.length tvs' = List.length ts' &&
type_vs tvs menv cenv senv (List.rev vs)
        (List.map (type_subst (List.combine tvs' ts')) ts1) &&
type_es menv cenv (bind_tvar tvs tenv) es (List.map (type_subst (List.combine tvs' ts')) ts2) &&
lookup cn cenv = Some (tvs', ts1@[t]@ts2, tn)
==>
type_ctxt tvs menv cenv senv tenv (Ccon cn vs () es) (type_subst (List.combine tvs' ts') t)
          (Tapp ts' (TC_name tn))

let poly_context cs = 
  match cs with
    | (Ccon cn vs () es,env) :: cs -> List.for_all is_value es
    | (Clet x () e,env) :: cs -> true
    | [] -> true
    | _ -> false
  end

let is_ccon c = 
  match c with
    | Ccon cn vs () es -> true
    | _ -> false
  end

indreln

forall tvs tenvM tenvC senv t.
check_freevars tvs [] t
==>
type_ctxts tvs tenvM tenvC senv [] t t

and

forall tvs tenvM tenvC senv c env cs tenv t1 t2 t3.
type_env tenvM tenvC senv env tenv &&
type_ctxt tvs tenvM tenvC senv tenv c t1 t2 &&
type_ctxts (if is_ccon c && poly_context cs then tvs else 0) tenvM tenvC senv cs t2 t3
==>
type_ctxts tvs tenvM tenvC senv ((c,env)::cs) t1 t3

indreln

forall dec_tvs tenvM tenvC senv envM envC s env e c t1 t2 tenv tvs.
context_invariant dec_tvs c tvs &&
type_ctxts tvs tenvM tenvC senv c t1 t2 &&
type_env tenvM tenvC senv env tenv &&
type_s tenvM tenvC senv s &&
type_e tenvM tenvC (bind_tvar tvs tenv) e t1 &&
((tvs <> 0) --> is_value e)
==>
type_state dec_tvs tenvM tenvC senv (envM,envC, s, env, Exp e, c) t2

and

forall dec_tvs tenvM tenvC senv envM envC s env v c t1 t2 tenv tvs.
context_invariant dec_tvs c tvs &&
type_ctxts tvs tenvM tenvC senv c t1 t2 &&
type_env tenvM tenvC senv env tenv &&
type_s tenvM tenvC senv s &&
type_v tvs tenvM tenvC senv v t1
==>
type_state dec_tvs tenvM tenvC senv (envM, envC, s, env, Val v, c) t2

(* ------ Auxiliary relations for proving big/small step equivalence ------ *)

val evaluate_ctxt : envM -> envC -> store -> envE -> ctxt_frame -> v -> store * result v -> bool
val evaluate_ctxts : envM -> envC -> store -> list ctxt -> result v -> store * result v -> bool
val evaluate_state : state -> store * result v -> bool

indreln

forall menv cenv s env v1 e2 var.
true
==>
evaluate_ctxt menv cenv s env (Chandle () var e2) v1 (s, Rval v1)

and

forall menv cenv env op e2 v1 v2 env' e3 bv s1 s2 s3.
evaluate menv cenv s1 env e2 (s2, Rval v2) &&
do_app s2 env op v1 v2 = Some (s3,env', e3) &&
evaluate menv cenv s3 env' e3 bv
==>
evaluate_ctxt menv cenv s1 env (Capp1 op () e2) v1 bv

and

forall menv cenv env op e2 v1 v2 s1 s2.
evaluate menv cenv s1 env e2 (s2, Rval v2) &&
do_app s2 env op v1 v2 = None
==>
evaluate_ctxt menv cenv s1 env (Capp1 op () e2) v1 (s2, Rerr Rtype_error)

and

forall menv cenv env op e2 v1 err s s'.
evaluate menv cenv s env e2 (s', Rerr err)
==>
evaluate_ctxt menv cenv s env (Capp1 op () e2) v1 (s', Rerr err)

and

forall menv cenv env op v1 v2 env' e3 bv s1 s2.
do_app s1 env op v1 v2 = Some (s2, env', e3) &&
evaluate menv cenv s2 env' e3 bv
==>
evaluate_ctxt menv cenv s1 env (Capp2 op v1 ()) v2 bv

and

forall menv cenv env op v1 v2 s.
(do_app s env op v1 v2 = None)
==>
evaluate_ctxt menv cenv s env (Capp2 op v1 ()) v2 (s, Rerr Rtype_error)

and

forall menv cenv env uop v v' s1 s2.
(do_uapp s1 uop v = Some (s2,v'))
==>
evaluate_ctxt menv cenv s1 env (Cuapp uop ()) v (s2, Rval v')

and

forall menv cenv env uop v s.
(do_uapp s uop v = None)
==>
evaluate_ctxt menv cenv s env (Cuapp uop ()) v (s, Rerr Rtype_error)

and

forall menv cenv env op e2 v e' bv s.
do_log op v e2 = Some e' &&
evaluate menv cenv s env e' bv
==>
evaluate_ctxt menv cenv s env (Clog op () e2) v bv

and

forall menv cenv env op e2 v s.
(do_log op v e2 = None)
==>
evaluate_ctxt menv cenv s env (Clog op () e2) v (s, Rerr Rtype_error)

and
forall menv cenv env e2 e3 v e' bv s.
do_if v e2 e3 = Some e' &&
evaluate menv cenv s env e' bv
==>
evaluate_ctxt menv cenv s env (Cif () e2 e3) v bv

and

forall menv cenv env e2 e3 v s.
(do_if v e2 e3 = None)
==>
evaluate_ctxt menv cenv s env (Cif () e2 e3) v (s, Rerr Rtype_error)

and

forall menv cenv env pes v bv s.
evaluate_match menv cenv s env v pes bv
==>
evaluate_ctxt menv cenv s env (Cmat () pes) v bv

and

forall menv cenv env n e2 v bv s.
evaluate menv cenv s (bind n v env) e2 bv
==>
evaluate_ctxt menv cenv s env (Clet n () e2) v bv

and

forall menv cenv env cn es vs v vs' s1 s2.
do_con_check cenv cn (List.length vs + List.length es + 1) &&
evaluate_list menv cenv s1 env es (s2, Rval vs')
==>
evaluate_ctxt menv cenv s1 env (Ccon cn vs () es) v (s2, Rval (Conv cn (List.rev vs @ [v] @ vs')))

and

forall menv cenv env cn es vs v s.
not (do_con_check cenv cn (List.length vs + List.length es + 1))
==>
evaluate_ctxt menv cenv s env (Ccon cn vs () es) v (s, Rerr Rtype_error)

and

forall menv cenv env cn es vs v err s s'.
do_con_check cenv cn (List.length vs + List.length es + 1) &&
evaluate_list menv cenv s env es (s', Rerr err)
==>
evaluate_ctxt menv cenv s env (Ccon cn vs () es) v (s', Rerr err)

indreln

forall menv cenv res s.
true
==>
evaluate_ctxts menv cenv s [] res (s, res)

and

forall menv cenv c cs env v res bv s1 s2.
evaluate_ctxt menv cenv s1 env c v (s2, res) &&
evaluate_ctxts menv cenv s2 cs res bv
==>
evaluate_ctxts menv cenv s1 ((c,env)::cs) (Rval v) bv

and

forall menv cenv c cs env err s bv.
evaluate_ctxts menv cenv s cs (Rerr err) bv &&
((forall i e'. c <> Chandle () i e') ||
 (forall i. err <> Rraise (Int_error i)))
==>
evaluate_ctxts menv cenv s ((c,env)::cs) (Rerr err) bv

and

forall menv cenv cs env s s' var res1 res2 i e'.
evaluate menv cenv s (bind var (Litv (IntLit i)) env) e' (s', res1) &&
evaluate_ctxts menv cenv s' cs res1 res2
==>
evaluate_ctxts menv cenv s ((Chandle () var e',env)::cs) (Rerr (Rraise (Int_error i))) res2

indreln

forall menv cenv env e c res bv s1 s2.
evaluate menv cenv s1 env e (s2, res) &&
evaluate_ctxts menv cenv s2 c res bv
==>
evaluate_state (menv, cenv, s1, env, Exp e, c) bv

and

forall menv cenv s env v c bv.
evaluate_ctxts menv cenv s c (Rval v) bv
==>
evaluate_state (menv, cenv, s, env, Val v, c) bv


(* ------------------------------------------------------------------------ *) 
(*   Alternate big-step semantics                                           *)
(* ------------------------------------------------------------------------ *) 

(* A version of the big-step expression semantics that doesn't use the
 * constructor environment to know if a value is ok or not.  It also has no
 * module environment. Is equivalent to the normal one for well-typed programs
 * that don't contain module references. *)

val pmatch' : store -> pat -> v -> envE -> match_result
let rec
pmatch' s (Pvar n) v' env = Match (bind n v' env)
and
pmatch' s (Plit l) (Litv l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error
and
pmatch' s (Pcon cn ps) (Conv cn' vs) env =
  if List.length ps = List.length vs && cn = cn' then
    pmatch_list' s ps vs env
  else
    No_match
and
pmatch' s (Pref p) (Loc lnum) env =
  match store_lookup lnum s with
    | Some v -> pmatch' s p v env
    | None -> Match_type_error
  end
and
pmatch' _ _ _ env = Match_type_error
and
pmatch_list' s [] [] env = Match env
and
pmatch_list' s (p::ps) (v::vs) env =
  match pmatch' s p v env with
    | No_match -> No_match
    | Match_type_error -> Match_type_error
    | Match env' -> pmatch_list' s ps vs env'
  end
and
pmatch_list' _ _ _ env = Match_type_error


indreln

forall env l s.
true
==>
evaluate' s env (Lit l) (s, Rval (Litv l))

and

forall env err s.
true
==>
evaluate' s env (Raise err) (s, Rerr (Rraise err))

and

forall s1 s2 env e1 e2 v var.
evaluate' s1 env e1 (s2, Rval v)
==>
evaluate' s1 env (Handle e1 var e2) (s2, Rval v)

and

forall s1 s2 env e1 e2 n var bv.
evaluate' s1 env e1 (s2, Rerr (Rraise (Int_error n))) &&
evaluate' s2 (bind var (Litv (IntLit n)) env) e2 bv
==>
evaluate' s1 env (Handle e1 var e2) bv

and

forall s1 s2 env e1 e2 var err.
evaluate' s1 env e1 (s2, Rerr err) &&
(err = Rtype_error || err = Rraise Bind_error || err = Rraise Div_error)
==>
evaluate' s1 env (Handle e1 var e2) (s2, Rerr err)

and

forall env cn es vs s1 s2.
evaluate_list' s1 env es (s2, Rval vs)
==>
evaluate' s1 env (Con cn es) (s2, Rval (Conv cn vs))

and

forall env cn es err s s'.
evaluate_list' s env es (s', Rerr err)
==>
evaluate' s env (Con cn es) (s', Rerr err)

and

forall env n v s.
(lookup n env = Some v)
==>
evaluate' s env (Var (Short n)) (s, Rval v)

and

forall env n s.
(lookup n env = None)
==>
evaluate' s env (Var (Short n)) (s, Rerr Rtype_error)

and

forall env n e s.
true
==>
evaluate' s env (Fun n e) (s, Rval (Closure env n e))

and

forall env uop e v v' s1 s2 s3.
evaluate' s1 env e (s2, Rval v) &&
do_uapp s2 uop v = Some (s3,v')
==>
evaluate' s1 env (Uapp uop e) (s3, Rval v')

and

forall env uop e v s1 s2.
evaluate' s1 env e (s2, Rval v) &&
do_uapp s2 uop v = None
==>
evaluate' s1 env (Uapp uop e) (s2, Rerr Rtype_error)

and

forall env uop e err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate' s env (Uapp uop e) (s', Rerr err)

and

forall env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 s4.
evaluate' s1 env e1 (s2, Rval v1) &&
evaluate' s2 env e2 (s3, Rval v2) &&
do_app s3 env op v1 v2 = Some (s4, env', e3) &&
evaluate' s4 env' e3 bv
==>
evaluate' s1 env (App op e1 e2) bv

and

forall env op e1 e2 v1 v2 s1 s2 s3.
evaluate' s1 env e1 (s2, Rval v1) &&
evaluate' s2 env e2 (s3, Rval v2) &&
do_app s3 env op v1 v2 = None
==>
evaluate' s1 env (App op e1 e2) (s3, Rerr Rtype_error)

and

forall env op e1 e2 v1 err s1 s2 s3.
evaluate' s1 env e1 (s2, Rval v1) &&
evaluate' s2 env e2 (s3, Rerr err)
==>
evaluate' s1 env (App op e1 e2) (s3, Rerr err)

and

forall env op e1 e2 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (App op e1 e2) (s', Rerr err)

and

forall env op e1 e2 v e' bv s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
do_log op v e2 = Some e' &&
evaluate' s2 env e' bv
==>
evaluate' s1 env (Log op e1 e2) bv

and

forall env op e1 e2 v s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
do_log op v e2 = None
==>
evaluate' s1 env (Log op e1 e2) (s2, Rerr Rtype_error)

and

forall env op e1 e2 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (Log op e1 e2) (s', Rerr err)

and

forall env e1 e2 e3 v e' bv s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
do_if v e2 e3 = Some e' &&
evaluate' s2 env e' bv
==>
evaluate' s1 env (If e1 e2 e3) bv

and

forall env e1 e2 e3 v s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
do_if v e2 e3 = None
==>
evaluate' s1 env (If e1 e2 e3) (s2, Rerr Rtype_error)

and


forall env e1 e2 e3 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (If e1 e2 e3) (s', Rerr err)

and

forall env e pes v bv s1 s2.
evaluate' s1 env e (s2, Rval v) &&
evaluate_match' s2 env v pes bv
==>
evaluate' s1 env (Mat e pes) bv

and

forall env e pes err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate' s env (Mat e pes) (s', Rerr err)

and

forall env n e1 e2 v bv s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
evaluate' s2 (bind n v env) e2 bv
==>
evaluate' s1 env (Let n e1 e2) bv

and

forall env n e1 e2 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (Let n e1 e2) (s', Rerr err)

and

forall env funs e bv s.
all_distinct (List.map (fun (x,y,z) -> x) funs) &&
evaluate' s (build_rec_env funs env env) e bv
==>
evaluate' s env (Letrec funs e) bv

and

forall env funs e s.
not (all_distinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate' s env (Letrec funs e) (s, Rerr Rtype_error)

and

forall env s.
true
==>
evaluate_list' s env [] (s, Rval [])

and

forall env e es v vs s1 s2 s3.
evaluate' s1 env e (s2, Rval v) &&
evaluate_list' s2 env es (s3, Rval vs)
==>
evaluate_list' s1 env (e::es) (s3, Rval (v::vs))

and

forall env e es err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate_list' s env (e::es) (s', Rerr err)

and

forall env e es v err s1 s2 s3.
evaluate' s1 env e (s2, Rval v) &&
evaluate_list' s2 env es (s3, Rerr err)
==>
evaluate_list' s1 env (e::es) (s3, Rerr err)

and

forall env v s.
true
==>
evaluate_match' s env v [] (s, Rerr (Rraise Bind_error))

and

forall env v p e pes env' bv s.
all_distinct (pat_bindings p []) &&
(pmatch' s p v env = Match env') &&
evaluate' s env' e bv
==>
evaluate_match' s env v ((p,e)::pes) bv

and

forall env v p e pes bv s.
all_distinct (pat_bindings p []) &&
(pmatch' s p v env = No_match) &&
evaluate_match' s env v pes bv
==>
evaluate_match' s env v ((p,e)::pes) bv

and

forall env v p e pes s.
(pmatch' s p v env = Match_type_error)
==>
evaluate_match' s env v ((p,e)::pes) (s, Rerr Rtype_error)

and

forall env v p e pes s.
not (all_distinct (pat_bindings p []))
==>
evaluate_match' s env v ((p,e)::pes) (s, Rerr Rtype_error)

indreln

forall mn menv cenv env p e v env' s1 s2.
evaluate' s1 env e (s2, Rval v) &&
all_distinct (pat_bindings p []) &&
(pmatch' s2 p v emp = Match env')
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rval (emp, env'))

and

forall mn menv cenv env p e v s1 s2.
evaluate' s1 env e (s2, Rval v) &&
all_distinct (pat_bindings p []) &&
(pmatch' s2 p v emp = No_match)
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rerr (Rraise Bind_error))

and

forall mn menv cenv env p e v s1 s2.
evaluate' s1 env e (s2, Rval v) &&
(pmatch' s2 p v emp = Match_type_error)
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rerr Rtype_error)

and

forall mn menv cenv env p e v s1 s2.
evaluate' s1 env e (s2, Rval v) &&
not (all_distinct (pat_bindings p []))
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rerr Rtype_error)

and

forall mn menv cenv env p e err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate_dec' mn menv cenv s env (Dlet p e) (s', Rerr err)

and

forall mn menv cenv env funs s.
all_distinct (List.map (fun (x,y,z) -> x) funs)
==>
evaluate_dec' mn menv cenv s env (Dletrec funs) (s, Rval (emp, build_rec_env funs env emp))

and

forall mn menv cenv env funs s.
not (all_distinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate_dec' mn menv cenv s env (Dletrec funs) (s, Rerr Rtype_error)

and

forall mn menv cenv env tds s.
check_dup_ctors mn cenv tds
==>
evaluate_dec' mn menv cenv s env (Dtype tds) (s, Rval (build_tdefs mn tds, emp))

and

forall mn menv cenv env tds s.
not (check_dup_ctors mn cenv tds)
==>
evaluate_dec' mn menv cenv s env (Dtype tds) (s, Rerr Rtype_error)

indreln

forall mn menv cenv s env.
true
==>
evaluate_decs' mn menv cenv s env [] (s, Rval (emp, emp))

and

forall mn menv cenv s1 s2 env d ds e.
evaluate_dec' mn menv cenv s1 env d (s2, Rerr e)
==>
evaluate_decs' mn menv cenv s1 env (d::ds) (s2, Rerr e)

and

forall mn menv cenv s1 s2 s3 env d ds new_tds new_env r.
evaluate_dec' mn menv cenv s1 env d (s2, Rval (new_tds,new_env)) &&
evaluate_decs' mn menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, r)
==>
evaluate_decs' mn menv cenv s1 env (d::ds) (s3, combine_dec_result new_tds new_env r)

indreln

forall menv cenv s env.
true
==>
evaluate_prog' menv cenv s env [] (s, Rval (emp, emp, emp))

and

forall menv cenv s1 s2 s3 env d ds new_tds new_env r.
evaluate_dec' None menv cenv s1 env d (s2, Rval (new_tds,new_env)) &&
evaluate_prog' menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, r)
==>
evaluate_prog' menv cenv s1 env (Tdec d::ds) (s3, combine_mod_result emp new_tds new_env r)

and

forall menv cenv s1 s2 env d ds e.
evaluate_dec' None menv cenv s1 env d (s2, Rerr e)
==>
evaluate_prog' menv cenv s1 env (Tdec d::ds) (s2, Rerr e)

and

forall menv cenv s1 s2 s3 env ds1 ds2 mn specs new_tds new_env r.
not (List.mem mn (List.map fst menv)) &&
evaluate_decs' (Some mn) menv cenv s1 env ds1 (s2, Rval (new_tds,new_env)) &&
evaluate_prog' (bind mn new_env menv) (merge new_tds cenv) s2 env ds2 (s3, r)
==>
evaluate_prog' menv cenv s1 env (Tmod mn specs ds1::ds2) (s3, combine_mod_result [(mn,new_env)] new_tds emp r)

and

forall menv cenv s1 s2 env mn specs ds1 ds2 e.
not (List.mem mn (List.map fst menv)) &&
evaluate_decs' (Some mn) menv cenv s1 env ds1 (s2, Rerr e)
==>
evaluate_prog' menv cenv s1 env (Tmod mn specs ds1::ds2) (s2, Rerr e)

and

forall menv cenv s env mn specs ds1 ds2.
List.mem mn (List.map fst menv)
==>
evaluate_prog' menv cenv s env (Tmod mn specs ds1::ds2) (s, Rerr Rtype_error)

