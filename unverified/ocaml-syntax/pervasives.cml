(* Name format:
   Letter-like names stay as they are. Symbol-like names are transcribed
   symbol-for-symbol into words separated by underscores. All names here are
   letter-like and not infix.

   To avoid CakeML builtins, the following substitutions are made:
     mod |-> oc_mod
   raise |-> oc_raise
   *)
(* Reference:
   http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html *)

(* First, some super-pervasives: *)
exception Invalid_argument of string;
exception Failure of string;
exception Exit;
exception Sys_error;
exception End_of_file;
exception Division_by_zero;

exception Not_found;

structure Pervasives = struct
  fun oc_raise e = raise e;
  val raise_notrace = oc_raise;
  fun invalid_arg s = raise (Invalid_argument s);
  fun failwith s = raise (Failure s);

  fun equals x y = x = y handle Eq => invalid_arg "equal: functional value";
  (*fun lt_gt x y = x <> y;*) (* Defined below *)
  fun lt x y = x < y;
  fun gt x y = x > y;
  fun lt_equals x y = x <= y;
  fun gt_equals x y = x >= y;
  fun compare x y =
    if x = y then
      0
    else if x < y then
      ~1
    else
      1;
  fun min x y = if x <= y then x else y;
  fun max x y = if x >= y then x else y;

  fun not x = case x of
      false => true
    | true => false
    ;
  (* These will have been dealt with earlier *)
  fun amp_amp x y = x andalso y;
  fun bar_bar x y = x orelse y;
  val amp = amp_amp;
  val or = bar_bar;

  fun lt_gt x y = not (x = y);

  fun bar_gt x f = f x;
  fun at_at f x = f x;

  fun tilde_minus x = ~x;
  fun tilde_plus x = x;
  fun succ x = 1 + x;
  fun pred x = x - 1;
  fun plus x y = x + y;
  fun minus x y = x - y;
  fun star x y = x * y;
  (* OCaml:         |  CakeML:
     # ~-5 / 3;;    |  ~5 div 3;
     - : int = -1   |  val it:<int> = ~2
     # ~-5 mod 3;;  |  ~5 mod 3;
     - : int = -2   |  val it:<int> = 1
   *)
  fun slash x y =
    if y = 0 then
      oc_raise Division_by_zero
    else
      if y < 0 then
        if x < 0 then ~x div ~y else ~(x div ~y)
      else
        if x < 0 then ~(~x div y) else x div y
    ;
  fun oc_mod x y = x - y * slash x y;
  fun abs x = if x < 0 then ~x else x;

  val int_of_char = Char.ord;
  val char_of_int = Char.chr;

  fun at xs ys = case xs of
      [] => ys
    | x :: xs => x :: at xs ys
    ;

  fun hat s t = String.implode (at (String.explode s) (String.explode t));

  fun string_of_bool x = if x then "true" else "false";
  fun bool_of_string x = case x of
      "true" => true
    | "false" => false
    | x => invalid_arg x
    ;
  (*fun string_of_int x =
    let
      fun digit x =
        case x of 0 => "0" | 1 => "1" | 2 => "2" | 3 => "3" | 4 => "4"
                | 5 => "5" | 6 => "6" | 7 => "7" | 8 => "8" | 9 => "9"
                | x => invalid_arg x;
      fun f x = case x of
          0 => ""
        | x => hat (f (x div 10)) (digit (x mod 10));
    in
      if x = 0 then "0"
      else if x > 0 then f x
      else hat "-" (f (~x)))
    end;*)

  fun fst x = case x of (y, z) => y;
  fun snd x = case x of (y, z) => z;

  type 'a oc_ref = 'a ref;
  fun oc_ref x = ref x;
  fun bang x = !x;
  fun colon_equals r x = r := x;
  fun incr r = r := succ (!r);
  fun decr r = r := pred (!r);

  fun ignore x = ();
end;

structure List = struct
  fun length xs = case xs of
      [] => 0
    | x :: xs => 1 + length xs;
  fun hd xs = case xs of
      [] => Pervasives.failwith "hd"
    | x :: xs => x;
  fun tl xs = case xs of
      [] => Pervasives.failwith "tl"
    | x :: xs => xs;
  fun nth xs i =
    let
      fun inner xs i = case xs of
          [] => Pervasives.failwith "nth"
        | x :: xs => inner xs (i - 1)
    in
      if i < 0 then Pervasives.invalid_arg "List.nth" else inner xs i
    end;
  fun rev xs =
    let
      fun inner acc xs = case xs of
          [] => acc
        | x :: xs => inner (x :: acc) xs
    in
      inner [] xs
    end;
  fun append xs ys = case xs of
      [] => ys
    | x :: xs => x :: append xs ys;
  fun rev_append xs ys = case xs of
      [] => ys
    | x :: xs => append xs (x :: ys);
  fun concat xss = case xss of
      [] => []
    | xs :: xss => append xs (concat xss);
  val flatten = concat;

  fun iter f =
    let
      fun inner xs = case xs of
          [] => ()
        | x :: xs => (f x; inner xs)
    in
      inner
    end;
  fun iteri f =
    let
      fun inner i xs = case xs of
          [] => ()
        | x :: xs => (f i x; inner (1 + i) xs)
    in
      inner 0
    end;
  fun map f =
    let
      fun inner xs = case xs of
          [] => []
        | x :: xs => f x :: inner xs
    in
      inner
    end;
  fun mapi f =
    let
      fun inner i xs = case xs of
          [] => []
        | x :: xs => f i x :: inner (1 + i) xs
    in
      inner 0
    end;
  fun rev_map f =
    let
      fun inner acc xs = case xs of
          [] => acc
        | x :: xs => inner (f x :: acc) xs
    in
      inner []
    end;
  fun fold_left f =
    let
      fun inner acc xs = case xs of
          [] => acc
        | x :: xs => inner (f acc x) xs
    in
      inner
    end;
  fun fold_right f xs acc =
    let
      fun inner xs = case xs of
          [] => acc
        | x :: xs => f x (inner xs)
    in
      inner xs
    end;

  fun iter2 f =
    let
      fun inner xs ys = case (xs, ys) of
          ([], []) => ()
        | (x :: xs, y :: ys) => (f x y; inner xs ys)
        | z => Pervasives.invalid_arg "List.iter2"
    in
      inner
    end;
  fun map2 f =
    let
      fun inner xs ys = case (xs, ys) of
          ([], []) => []
        | (x :: xs, y :: ys) => f x y :: inner xs ys
        | z => Pervasives.invalid_arg "List.map2"
    in
      inner
    end;
  fun rev_map2 f =
    let
      fun inner acc xs ys = case (xs, ys) of
          ([], []) => acc
        | (x :: xs, y :: ys) => inner (f x y :: acc) xs ys
        | z => Pervasives.invalid_arg "List.rev_map2"
    in
      inner []
    end;
  fun fold_left2 f =
    let
      fun inner acc xs ys = case (xs, ys) of
          ([], []) => acc
        | (x :: xs, y :: ys) => inner (f acc x y) xs ys
        | z => Pervasives.invalid_arg "List.fold_left2"
    in
      inner []
    end;
  fun fold_right2 f xs ys acc =
    let
      fun inner xs ys = case (xs, ys) of
          ([], []) => acc
        | (x :: xs, y :: ys) => f x y (inner xs ys)
        | z => Pervasives.invalid_arg "List.fold_right2"
    in
      inner xs ys
    end;

  fun for_all p =
    let
      fun inner xs = case xs of
          [] => true
        | x :: xs => if p x then inner xs else false
    in
      inner
    end;
  fun exists p =
    let
      fun inner xs = case xs of
          [] => false
        | x :: xs => if p x then true else inner xs
    in
      inner
    end;
  fun for_all2 p =
    let
      fun inner xs ys = case (xs, ys) of
          ([], []) => true
        | (x :: xs, y :: ys) => if p x y then inner xs ys else false
        | z => Pervasives.invalid_arg "List.for_all2"
    in
      inner
    end;
  fun exists2 p =
    let
      fun inner xs ys = case (xs, ys) of
          ([], []) => false
        | (x :: xs, y :: ys) => if p x y then true else inner xs ys
        | z => Pervasives.invalid_arg "List.exists2"
    in
      inner
    end;
  fun mem x = exists (fn y => x = y);

  fun find p =
    let
      fun inner xs = case xs of
          [] => Pervasives.oc_raise Not_found
        | x :: xs => if p x then x else inner xs
    in
      inner
    end;
  fun filter p =
    let
      fun inner xs = case xs of
          [] => []
        | x :: xs => if p x then x :: inner xs else inner xs
    in
      inner
    end;
  val find_all = filter;
  fun partition p =
    let
      fun inner xs = case xs of
          [] => ([], [])
        | x :: xs =>
          case inner xs of (ys, zs) =>
            if p x then (x :: ys, zs) else (ys, x :: zs)
    in
      inner
    end;

  fun assoc x =
    let
      fun inner xs = case xs of
          [] => Pervasives.oc_raise Not_found
        | (k, v) :: xs => if k = x then v else inner xs
    in
      inner
    end;
  fun mem_assoc x = exists (fn kv => case kv of (k, v) => k = x);
  fun remove_assoc x =
    let
      fun inner xs = case xs of
          [] => []
        | (k, v) :: xs => if k = x then xs else (k, v) :: inner xs
    in
      inner
    end;

  fun split xs = case xs of
      [] => ([], [])
    | (y, z) :: xs => case split xs of (ys, zs) => (y :: ys, z :: zs)
    ;
  fun combine xs ys = map2 (fn x => fn y => (x, y)) xs ys
    handle Invalid_argument _ => Pervasives.invalid_arg "List.combine";

  fun merge cmp =
    let
      fun inner xs ys = case (xs, ys) of
          ([], ys) => ys
        | (xs, []) => xs
        | (x :: xs, y :: ys) => if cmp x y <= 0
            then x :: inner xs (y :: ys)
            else y :: inner (x :: xs) ys
    in
      inner
    end;
  fun sort cmp =
    let
      val mg = merge cmp
      fun part xs = case xs of
          [] => ([], [])
        | [x] => ([x], [])
        | y :: z :: xs => case part xs of (ys, zs) => (y :: ys, z :: zs)
      fun inner xs = case xs of
          [] => []
        | [x] => [x]
        | xs => case part xs of (ys, zs) => mg (inner ys) (inner zs)
    in
      inner
    end;
  val stable_sort = sort;
  val fast_sort = sort;
  fun sort_uniq cmp xs =
    let
      fun remove_duplicates xs = case xs of
          [] => []
        | [x] => [x]
        | x :: y :: xs =>
          if cmp x y = 0
            then      remove_duplicates (y :: xs)
            else x :: remove_duplicates (y :: xs)
    in
      remove_duplicates (sort cmp xs)
    end;
end;
