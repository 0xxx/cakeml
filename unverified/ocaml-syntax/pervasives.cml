(* Name format:
   Letter-like names stay as they are. Symbol-like names are transcribed
   symbol-for-symbol into words separated by underscores. All names here are
   letter-like and not infix.

   To avoid CakeML builtins, the following substitutions are made:
     mod |-> oc_mod
   raise |-> oc_raise
   *)
(* Reference:
   http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html *)

(* First, some super-pervasives: *)
exception Invalid_argument of string;
exception Failure of string;
exception Exit;
exception Sys_error;
exception End_of_file;
exception Division_by_zero;

structure Pervasives = struct
  fun oc_raise e = raise e;
  val raise_notrace = oc_raise;
  fun invalid_arg s = raise (Invalid_argument s);
  fun failwith s = raise (Failure s);

  fun equals x y = x = y handle Eq => invalid_arg "";
  (*fun lt_gt x y = x <> y;*) (* Defined below *)
  fun lt x y = x < y;
  fun gt x y = x > y;
  fun lt_equals x y = x <= y;
  fun gt_equals x y = x >= y;
  fun compare x y =
    if x = y then
      0
    else if x < y then
      ~1
    else
      1;
  fun min x y = if x <= y then x else y;
  fun max x y = if x >= y then x else y;

  fun not x = case x of
      false => true
    | true => false
    ;
  (* These will have been dealt with earlier *)
  fun amp_amp x y = x andalso y;
  fun bar_bar x y = x orelse y;
  val amp = amp_amp;
  val or = bar_bar;

  fun lt_gt x y = not (x = y);

  fun bar_gt x f = f x;
  fun at_at f x = f x;

  fun tilde_minus x = ~x;
  fun tilde_plus x = x;
  fun succ x = 1 + x;
  fun pred x = x - 1;
  fun plus x y = x + y;
  fun minus x y = x - y;
  fun star x y = x * y;
  (* OCaml:         |  CakeML:
     # ~-5 / 3;;    |  ~5 div 3;
     - : int = -1   |  val it:<int> = ~2
     # ~-5 mod 3;;  |  ~5 mod 3;
     - : int = -2   |  val it:<int> = 1
   *)
  fun slash x y =
    if y = 0 then
      oc_raise Division_by_zero
    else
      if y < 0 then
        if x < 0 then ~x div ~y else ~(x div ~y)
      else
        if x < 0 then ~(~x div y) else x div y
    ;
  fun oc_mod x y = x - y * slash x y;
  fun abs x = if x < 0 then ~x else x;

  val int_of_char = Char.ord;
  val char_of_int = Char.chr;

  fun at xs ys = case xs of
      [] => ys
    | x :: xs => x :: at xs ys
    ;

  fun hat s t = String.implode (at (String.explode s) (String.explode t));

  fun string_of_bool x = if x then "true" else "false";
  fun bool_of_string x = case x of
      "true" => true
    | "false" => false
    | x => invalid_arg x
    ;
  (*fun string_of_int x =
    let
      fun digit x =
        case x of 0 => "0" | 1 => "1" | 2 => "2" | 3 => "3" | 4 => "4"
                | 5 => "5" | 6 => "6" | 7 => "7" | 8 => "8" | 9 => "9"
                | x => invalid_arg x;
      fun f x = case x of
          0 => ""
        | x => hat (f (x div 10)) (digit (x mod 10));
    in
      if x = 0 then "0"
      else if x > 0 then f x
      else hat "-" (f (~x)))
    end;*)

  fun fst x = case x of (y, z) => y;
  fun snd x = case x of (y, z) => z;

  type 'a ref = 'a ref;
  fun bang x = !x;
  fun colon_equals r x = r := x;
  fun incr r = r := succ (!r);
  fun decr r = r := pred (!r);

  fun ignore x = ();
end;
