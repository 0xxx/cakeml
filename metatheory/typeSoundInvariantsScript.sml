(*Generated by Lem from typeSoundInvariants.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory libTheory astTheory semanticPrimitivesTheory smallStepTheory typeSystemTheory lem_list_extraTheory;

val _ = numLib.prefer_num();



val _ = new_theory "typeSoundInvariants"

(* Type system for values, evaluation contexts, and the small-step sematnics'
 * states. The invariant that is used for type soundness. *)

(*open import Pervasives*)
(*open import Lib*)
(*open import Ast*)
(*open import SemanticPrimitives*)
(*open import SmallStep*)
(*open import TypeSystem*)
(*import List_extra*)

val _ = Hol_datatype `
 store_t = Ref_t of t | W8array_t`;


(* Store typing *)
val _ = type_abbrev( "tenvS" , ``: (num, store_t) env``);

(* Check that the type names map to valid types *)
(*val flat_tenvT_ok : flat_tenvT -> bool*)
val _ = Define `
 (flat_tenvT_ok tenvT =  
(EVERY (\ (tn,(tvs,t)) .  check_freevars( 0) tvs t) tenvT))`;


(*val tenvT_ok : tenvT -> bool*)
val _ = Define `
 (tenvT_ok (mtenvT, tenvT) =  
(EVERY (\p .  (case (p ) of ( (_,tenvT) ) => flat_tenvT_ok tenvT )) mtenvT /\
  flat_tenvT_ok tenvT))`;


(* Global constructor type environments keyed by constructor name and type *)
val _ = type_abbrev( "ctMap" , ``: ((conN # tid_or_exn), ( tvarN list # t list)) fmap``);

(*val flat_tenvC_ok : flat_tenvC -> bool*)
val _ = Define `
 (flat_tenvC_ok tenvC =  
(EVERY (\ (cn,(tvs,ts,tn)) .  EVERY (check_freevars( 0) tvs) ts) tenvC))`;


(*val tenvC_ok : tenvC -> bool*)
val _ = Define `
 (tenvC_ok (mtenvC, tenvC) =  
(EVERY (\p .  (case (p ) of ( (_,tenvC) ) => flat_tenvC_ok tenvC )) mtenvC /\
  flat_tenvC_ok tenvC))`;


(*val ctMap_ok : ctMap -> bool*)
val _ = Define `
 (ctMap_ok ctMap =  
(FEVERY (UNCURRY (\ (cn,tn) (tvs,ts) .  EVERY (check_freevars( 0) tvs) ts)) ctMap))`;


(* Convert from a lexically scoped constructor environment to the global one *)
(*val flat_to_ctMap_list : flat_tenvC -> env (conN * tid_or_exn) (list tvarN * list t)*)
val _ = Define `
 (flat_to_ctMap_list tenvC =  
 (MAP (\ (cn,(tvs,ts,t)) .  ((cn,t),(tvs,ts))) tenvC))`;


(*val flat_to_ctMap : flat_tenvC -> ctMap*)
val _ = Define `
 (flat_to_ctMap tenvC = (FUPDATE_LIST FEMPTY (REVERSE (flat_to_ctMap_list tenvC))))`;


(* Get the modules that are used by the type and exception definitions *)
(*val decls_to_mods : decls -> set (maybe modN)*)
val _ = Define `
 (decls_to_mods (mdecls,tdecls,edecls) =  
((({ SOME mn |  mn | ? tn. (Long mn tn) IN tdecls } UNION
  { SOME mn |  mn | ? cn. (Long mn cn) IN edecls }) UNION
  { NONE |  tn | Short tn IN tdecls }) UNION
  { NONE |  tn | Short tn IN edecls }))`;


(* Check that a constructor type environment is consistent with a runtime type
 * enviroment, using the full type keyed constructor type environment to ensure
 * that the correct types are used. *)
(*val consistent_con_env : ctMap -> envC -> tenvC -> bool*)
val _ = Define `
 (consistent_con_env ctMap envC tenvC =  
(tenvC_ok tenvC /\
  ctMap_ok ctMap /\
  (! cn n t.    
(lookup_con_id cn envC = SOME (n, t))
    ==>    
(? tvs ts.      
(lookup_con_id cn tenvC = SOME (tvs, ts, t)) /\      
(FLOOKUP ctMap (id_to_n cn,t) = SOME (tvs, ts)) /\      
(LENGTH ts = n)))
  /\
  (! cn.    
(lookup_con_id cn envC = NONE)
    ==>    
(lookup_con_id cn tenvC = NONE))))`;


(* A value has a type *)
(* The number is how many deBruijn type variables are bound in the context. *)
(*val type_v : nat -> ctMap -> tenvS -> v -> t -> bool*)

(* A value environment has a corresponding type environment.  Since all of the
 * entries in the environment are values, and values have no free variables,
 * each entry in the environment can be typed in the empty environment (if at
 * all) *)
(*val type_env : ctMap -> tenvS -> envE -> tenvE -> bool*)

(* The type of the store *)
(*val type_s : ctMap -> tenvS -> store v -> bool*)

(* An evaluation context has the second type when its hole is filled with a
 * value of the first type. *)
(* The number is how many deBruijn type variables are bound in the context.
 * This is only used for constructor contexts, because the value restriction 
 * ensures that no other contexts can be created under a let binding. *)
(*val type_ctxt : nat -> tenvM -> ctMap -> tenvC -> tenvS -> tenvE -> ctxt_frame -> t -> t -> bool*)
(*val type_ctxts : nat -> ctMap -> tenvS -> list ctxt -> t -> t -> bool*)
(*val type_state : nat -> ctMap -> tenvS -> state -> t -> bool*)
(*val context_invariant : nat -> list ctxt -> nat -> bool*)

 val _ = Define `
 
(tenv_ok Empty = T)
/\
(tenv_ok (Bind_tvar n tenv) = (tenv_ok tenv))
/\
(tenv_ok (Bind_name x tvs t tenv) =  
(check_freevars (tvs + num_tvs tenv) [] t /\ tenv_ok tenv))`;


val _ = Define `
 (tenvM_ok tenvM = (EVERY (\ (mn,tenv) .  tenv_ok (bind_var_list2 tenv Empty)) tenvM))`;


val _ = Hol_reln ` (! tvs cenv senv b.
T
==>
type_v tvs cenv senv (Litv (Bool b)) Tbool)

/\ (! tvs cenv senv n.
T
==>
type_v tvs cenv senv (Litv (IntLit n)) Tint)

/\ (! tvs cenv senv s.
T
==>
type_v tvs cenv senv (Litv (StrLit s)) Tstring)

/\ (! tvs cenv senv.
T
==>
type_v tvs cenv senv (Litv Unit) Tunit)

/\ (! tvs cenv senv w.
T
==>
type_v tvs cenv senv (Litv (Word8 w)) Tword8)

/\ (! tvs cenv senv cn vs tvs' tn ts' ts.
(EVERY (check_freevars tvs []) ts' /\
(LENGTH tvs' = LENGTH ts') /\
type_vs tvs cenv senv vs (MAP (type_subst (ZIP (tvs', ts'))) ts) /\
(FLOOKUP cenv (cn, tn) = SOME (tvs',ts)))
==>
type_v tvs cenv senv (Conv (SOME (cn,tn)) vs) (Tapp ts' (tid_exn_to_tc tn)))

/\ (! tvs cenv senv vs ts.
(type_vs tvs cenv senv vs ts)
==>
type_v tvs cenv senv (Conv NONE vs) (Tapp ts TC_tup))

/\ (! tvs menv tenvC ctMap senv envC envM env tenv n e t1 t2.
(consistent_con_env ctMap envC tenvC /\
tenvM_ok menv /\
consistent_mod_env senv ctMap envM menv /\
type_env ctMap senv env tenv /\
check_freevars tvs [] t1 /\
type_e menv tenvC (bind_tenv n( 0) t1 (bind_tvar tvs tenv)) e t2)
==>
type_v tvs ctMap senv (Closure (envM, envC, env) n e) (Tfn t1 t2))

/\ (! tvs menv tenvC ctMap senv envM envC env funs n t tenv tenv'.
(consistent_con_env ctMap envC tenvC /\
tenvM_ok menv /\
consistent_mod_env senv ctMap envM menv /\
type_env ctMap senv env tenv /\
type_funs menv tenvC (bind_var_list( 0) tenv' (bind_tvar tvs tenv)) funs tenv' /\
(lib$lookup n tenv' = SOME t) /\
ALL_DISTINCT (MAP (\ (f,x,e) .  f) funs) /\
MEM n (MAP (\ (f,x,e) .  f) funs))
==>
type_v tvs ctMap senv (Recclosure (envM, envC, env) funs n) t)

/\ (! tvs cenv senv n t.
(check_freevars( 0) [] t /\
(lib$lookup n senv = SOME (Ref_t t)))
==>
type_v tvs cenv senv (Loc n) (Tref t))

/\ (! tvs cenv senv n.
(lib$lookup n senv = SOME W8array_t)
==>
type_v tvs cenv senv (Loc n) Tword8array)

/\ (! tvs cenv senv.
T
==>
type_vs tvs cenv senv [] [])

/\ (! tvs cenv senv v vs t ts.
(type_v tvs cenv senv v t /\
type_vs tvs cenv senv vs ts)
==>
type_vs tvs cenv senv (v::vs) (t::ts))

/\ (! cenv senv.
T
==>
type_env cenv senv emp Empty)

/\ (! cenv senv n v env t tenv tvs.
(type_v tvs cenv senv v t /\
type_env cenv senv env tenv)
==>
type_env cenv senv (bind n v env) (bind_tenv n tvs t tenv))

/\ (! tenvS tenvC.
T
==>
consistent_mod_env tenvS tenvC [] [])

/\ (! tenvS tenvC mn env menv mn' tenv tenvM.
((mn = mn') /\
type_env tenvC tenvS env (bind_var_list2 tenv Empty) /\
consistent_mod_env tenvS tenvC menv tenvM)
==>
consistent_mod_env tenvS tenvC ((mn,env)::menv) ((mn',tenv)::tenvM))`;

val _ = Define `
 (type_s cenv senv s =  
(! l. 
    ((? st. lib$lookup l senv = SOME st) <=> (? v. store_lookup l s = SOME v)) /\
    (! st sv. ((lib$lookup l senv = SOME st) /\ (store_lookup l s = SOME sv)) ==> 
       (case (sv,st) of
           (Refv v, Ref_t t) => type_v( 0) cenv senv v t
         | (W8array es, W8array_t) => T
         | _ => F
       ))))`;


val _ = Hol_reln ` (! n.
T
==>
context_invariant n [] n)

/\ (! dec_tvs c env.
(context_invariant dec_tvs c( 0))
==>
context_invariant dec_tvs ((Craise () ,env) :: c) 0)

/\ (! dec_tvs c pes env.
(context_invariant dec_tvs c( 0))
==>
context_invariant dec_tvs ((Chandle ()  pes,env) :: c) 0)

/\ (! dec_tvs c op vs es env.
(context_invariant dec_tvs c( 0))
==>
context_invariant dec_tvs ((Capp op vs ()  es,env) :: c) 0)

/\ (! dec_tvs c l e env.
(context_invariant dec_tvs c( 0))
==>
context_invariant dec_tvs ((Clog l ()  e,env) :: c) 0)

/\ (! dec_tvs c e1 e2 env.
(context_invariant dec_tvs c( 0))
==>
context_invariant dec_tvs ((Cif ()  e1 e2,env) :: c) 0)

/\ (! dec_tvs c pes env err_v.
(context_invariant dec_tvs c( 0))
==>
context_invariant dec_tvs ((Cmat ()  pes err_v,env) :: c) 0)

/\ (! dec_tvs c tvs x e env.
(context_invariant dec_tvs c( 0))
==>
context_invariant dec_tvs ((Clet x ()  e,env) :: c) tvs)

/\ (! dec_tvs c cn vs es tvs env.
(context_invariant dec_tvs c tvs /\
( ~ (tvs =( 0)) ==> EVERY is_value es))
==>
context_invariant dec_tvs ((Ccon cn vs ()  es,env) :: c) tvs)`;

val _ = Hol_reln ` (! tvs menv all_cenv cenv senv tenv t.
(check_freevars tvs [] t)
 ==>
type_ctxt tvs menv all_cenv cenv senv tenv (Craise () ) Texn t)

/\ (! tvs menv all_cenv cenv senv tenv pes t.
(! ((p,e) :: LIST_TO_SET pes). ? tenv'.
   ALL_DISTINCT (pat_bindings p []) /\
   type_p (num_tvs tenv) cenv p Texn tenv' /\
   type_e menv cenv (bind_var_list( 0) tenv' tenv) e t)
==>
type_ctxt tvs menv all_cenv cenv senv tenv (Chandle ()  pes) t t)

/\ (! tvs menv all_cenv cenv senv tenv vs es op t1 t2 ts1 ts2.
(check_freevars tvs [] t1 /\
check_freevars tvs [] t2 /\
type_vs( 0) all_cenv senv vs ts1 /\
type_es menv cenv tenv es ts2 /\
type_op op ((REVERSE ts1 ++ [t1]) ++ ts2) t2) 
==>
type_ctxt tvs menv all_cenv cenv senv tenv (Capp op vs ()  es) t1 t2)

/\ (! tvs menv all_cenv cenv senv tenv op e.
(type_e menv cenv tenv e Tbool)
==>
type_ctxt tvs menv all_cenv cenv senv tenv (Clog op ()  e) Tbool Tbool)

/\ (! tvs menv all_cenv cenv senv tenv e1 e2 t.
(type_e menv cenv tenv e1 t /\
type_e menv cenv tenv e2 t)
==>
type_ctxt tvs menv all_cenv cenv senv tenv (Cif ()  e1 e2) Tbool t)

/\ (! tvs menv all_cenv cenv senv tenv t1 t2 pes err_v.
(((pes = []) ==> (check_freevars tvs [] t1 /\ check_freevars( 0) [] t2)) /\
(! ((p,e) :: LIST_TO_SET pes) . ? tenv'.
   ALL_DISTINCT (pat_bindings p []) /\
   type_p tvs cenv p t1 tenv' /\
   type_e menv cenv (bind_var_list( 0) tenv' tenv) e t2) /\
type_v( 0) all_cenv senv err_v Texn)
==>
type_ctxt tvs menv all_cenv cenv senv tenv (Cmat ()  pes err_v) t1 t2)

/\ (! tvs menv all_cenv cenv senv tenv e t1 t2 n.
(check_freevars tvs [] t1 /\
type_e menv cenv (opt_bind_tenv n tvs t1 tenv) e t2)
==>
type_ctxt tvs menv all_cenv cenv senv tenv (Clet n ()  e) t1 t2)

/\ (! tvs menv all_cenv cenv senv tenv cn vs es ts1 ts2 t tn ts' tvs'.
(EVERY (check_freevars tvs []) ts' /\
(LENGTH tvs' = LENGTH ts') /\
type_vs tvs all_cenv senv (REVERSE vs)
        (MAP (type_subst (ZIP (tvs', ts'))) ts1) /\
type_es menv cenv (bind_tvar tvs tenv) es (MAP (type_subst (ZIP (tvs', ts'))) ts2) /\
(lookup_con_id cn cenv = SOME (tvs', ((ts1++[t])++ts2), tn)))
==>
type_ctxt tvs menv all_cenv cenv senv tenv (Ccon (SOME cn) vs ()  es) (type_subst (ZIP (tvs', ts')) t)
          (Tapp ts' (tid_exn_to_tc tn)))

/\ (! tvs menv all_cenv cenv senv tenv vs es t ts1 ts2.
(check_freevars tvs [] t /\
type_vs tvs all_cenv senv (REVERSE vs) ts1 /\
type_es menv cenv (bind_tvar tvs tenv) es ts2)
==>
type_ctxt tvs menv all_cenv cenv senv tenv (Ccon NONE vs ()  es) t (Tapp ((ts1++[t])++ts2) TC_tup))`;

val _ = Define `
 (poly_context cs =  
 ((case cs of
      (Ccon cn vs ()  es,env) :: cs => EVERY is_value es
    | (Clet x ()  e,env) :: cs => T
    | [] => T
    | _ => F
  )))`;


val _ = Define `
 (is_ccon c =  
 ((case c of
      Ccon cn vs ()  es => T
    | _ => F
  )))`;


val _ = Hol_reln ` (! tvs tenvC senv t.
(check_freevars tvs [] t)
==>
type_ctxts tvs tenvC senv [] t t)

/\ (! tvs tenvM tenvC ctMap senv c envM envC env cs tenv t1 t2 t3.
(type_env ctMap senv env tenv /\
consistent_con_env ctMap envC tenvC /\
tenvM_ok tenvM /\
consistent_mod_env senv ctMap envM tenvM /\
type_ctxt tvs tenvM ctMap tenvC senv tenv c t1 t2 /\
type_ctxts (if is_ccon c /\ poly_context cs then tvs else  0) ctMap senv cs t2 t3)
==>
type_ctxts tvs ctMap senv ((c,(envM,envC,env))::cs) t1 t3)`;

val _ = Hol_reln ` (! dec_tvs tenvM tenvC ctMap senv envM envC s env e c t1 t2 tenv tvs.
(context_invariant dec_tvs c tvs /\
consistent_con_env ctMap envC tenvC /\
tenvM_ok tenvM /\
consistent_mod_env senv ctMap envM tenvM /\
type_ctxts tvs ctMap senv c t1 t2 /\
type_env ctMap senv env tenv /\
type_s ctMap senv s /\
type_e tenvM tenvC (bind_tvar tvs tenv) e t1 /\
(( ~ (tvs =( 0))) ==> is_value e))
==>
type_state dec_tvs ctMap senv ((envM, envC, env), s, Exp e, c) t2)

/\ (! dec_tvs ctMap senv envM envC s env v c t1 t2 tvs.
(context_invariant dec_tvs c tvs /\
type_ctxts tvs ctMap senv c t1 t2 /\
type_s ctMap senv s /\
type_v tvs ctMap senv v t1)
==>
type_state dec_tvs ctMap senv ((envM, envC, env), s, Val v, c) t2)`;

(* The first argument has strictly more bindings than the second. *)
(*val weakM_def : tenvM -> tenvM -> bool*)
val _ = Define `
 (weakM tenvM tenvM' =  
(! mn tenv'.
    (lib$lookup mn tenvM' = SOME tenv')
    ==>
    (? tenv. (lib$lookup mn tenvM = SOME tenv) /\ weakE tenv tenv')))`;


(*val weakC_def : tenvC -> tenvC -> bool*)
val _ = Define `
 (weakC tenvC tenvC' =  
(flat_weakC (SND tenvC) (SND tenvC') /\  
(! mn flat_tenvC'.    
(lib$lookup mn (FST tenvC') = SOME flat_tenvC')
    ==>    
(? flat_tenvC. (lib$lookup mn (FST tenvC) = SOME flat_tenvC) /\ flat_weakC flat_tenvC flat_tenvC'))))`;


(* The global constructor type environment has the primitive exceptions in it *)
(*val ctMap_has_exns : ctMap -> bool*)
val _ = Define `
 (ctMap_has_exns ctMap =  
((FLOOKUP ctMap ("Bind", TypeExn (Short "Bind")) = SOME ([],[])) /\
  (FLOOKUP ctMap ("Div", TypeExn (Short "Div")) = SOME ([],[])) /\
  (FLOOKUP ctMap ("Eq", TypeExn (Short "Eq")) = SOME ([],[])) /\
  (FLOOKUP ctMap ("Subscript", TypeExn (Short "Subscript")) = SOME ([],[]))))`;


(* The types and exceptions that are missing are all declared in modules. *)
(*val weak_decls_only_mods : decls -> decls -> bool*)
val _ = Define `
  (weak_decls_only_mods (mdecls1,tdecls1,edecls1) (mdecls2,tdecls2,edecls2) =    
((! tn. 
       ((Short tn IN tdecls1) ==> (Short tn IN tdecls2))) /\
    (! cn. 
       ((Short cn IN edecls1) ==> (Short cn IN edecls2)))))`;


(* The run-time declared constructors and exceptions are all either declared in
 * the type system, or from modules that have been declared *)

(*val consistent_decls : set tid_or_exn -> decls -> bool*)
val _ = Define `
 (consistent_decls decls (mdecls,tdecls,edecls) =  
(! (d :: decls).
    (case d of
        TypeExn cid => (cid IN edecls) \/ (? mn cn. (cid = Long mn cn) /\ (mn IN mdecls))
      | TypeId tid => (tid IN tdecls) \/ (? mn tn. (tid = Long mn tn) /\ (mn IN mdecls))
    )))`;


(*val consistent_ctMap : decls -> ctMap -> bool*)
val _ = Define `
 (consistent_ctMap (mdecls,tdecls,edecls) ctMap =  
(! ((cn,tid) :: FDOM ctMap).
    (case tid of
        TypeId tn => tn IN tdecls
      | TypeExn cn => cn IN edecls
    )))`;


(*val decls_ok : decls -> bool*)
val _ = Define `
 (decls_ok (mdecls,tdecls,edecls) =  
(decls_to_mods (mdecls,tdecls,edecls) SUBSET ({NONE} UNION IMAGE SOME mdecls)))`;


(* For using the type soundess theorem, we have to know there are good
 * constructor and module type environments that don't have bits hidden by a
 * signature. *)
val _ = Define `
 (type_sound_invariants r (decls1,tenvT,tenvM,tenvC,tenv,decls2,envM,envC,envE,store) =  
(? ctMap tenvS decls_no_sig tenvM_no_sig tenvC_no_sig. 
    consistent_decls decls2 decls_no_sig /\
    consistent_ctMap decls_no_sig ctMap /\
    ctMap_has_exns ctMap /\
    tenvT_ok tenvT /\
    tenvM_ok tenvM_no_sig /\ 
    tenvM_ok tenvM /\
    consistent_mod_env tenvS ctMap envM tenvM_no_sig /\
    consistent_con_env ctMap envC tenvC_no_sig /\
    type_env ctMap tenvS envE tenv /\
    type_s ctMap tenvS store /\
    weakM tenvM_no_sig tenvM /\
    weakC tenvC_no_sig tenvC /\
    decls_ok decls_no_sig /\
    weak_decls decls_no_sig decls1 /\
    weak_decls_only_mods decls_no_sig decls1 /\
    (! err. (r = SOME (Rerr (Rraise err))) ==> type_v( 0) ctMap tenvS err Texn)))`;


val _ = Define `
 (update_type_sound_inv ((decls1:decls),(tenvT:tenvT),(tenvM:tenvM),(tenvC:tenvC),(tenv:tenvE),(decls2: tid_or_exn set),(envM:envM),(envC:envC),(envE:envE),store) decls1' tenvT' tenvM' tenvC' tenv' store' decls2' envC' r =  
((case r of
       Rval (envM',envE') => 
         (union_decls decls1' decls1,merge_tenvT tenvT' tenvT, (tenvM'++tenvM),merge_tenvC tenvC' tenvC,bind_var_list2 tenv' tenv,
          decls2',(envM'++envM),merge_envC envC' envC,(envE'++envE),store')
     | Rerr _ => (union_decls decls1' decls1,tenvT,tenvM,tenvC,tenv,decls2',envM,envC,envE,store')
  )))`;

val _ = export_theory()

