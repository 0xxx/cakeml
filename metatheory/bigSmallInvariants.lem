open import Pervasives
open import Lib
open import Ast
open import SemanticPrimitives
open import SmallStep
open import BigStep

(* ------ Auxiliary relations for proving big/small step equivalence ------ *)

val evaluate_ctxt : all_env -> count_store v -> ctxt_frame -> v -> count_store v * result v v -> bool
val evaluate_ctxts : count_store v -> list ctxt -> result v v -> count_store v * result v v -> bool
val evaluate_state : state -> count_store v * result v v -> bool

indreln
[evaluate_ctxt : all_env -> count_store v -> ctxt_frame -> v -> count_store v * result v v -> bool]

raise : forall env s v.
true
==>
evaluate_ctxt env s (Craise ()) v (s, Rerr (Rraise v))

and

handle : forall env s v pes.
true
==>
evaluate_ctxt env s (Chandle () pes) v (s, Rval v)

and

app1 : forall env op e2 v1 v2 env' e3 bv s1 s2 count s3.
evaluate false env s1 e2 ((count,s2), Rval v2) &&
do_app env s2 op v1 v2 = Just (env',s3,e3) &&
evaluate false env' (count, s3) e3 bv
==>
evaluate_ctxt env s1 (Capp1 op () e2) v1 bv

and

app2 : forall env op e2 v1 v2 s1 s2 count.
evaluate false env s1 e2 ((count,s2), Rval v2) &&
do_app env s2 op v1 v2 = Nothing
==>
evaluate_ctxt env s1 (Capp1 op () e2) v1 ((count, s2), Rerr Rtype_error)

and

app3 : forall env op e2 v1 err s s'.
evaluate false env s e2 (s', Rerr err)
==>
evaluate_ctxt env s (Capp1 op () e2) v1 (s', Rerr err)

and

app4 : forall env op v1 v2 env' e3 bv s1 s2 count.
do_app env s1 op v1 v2 = Just (env',s2,e3) &&
evaluate false env' (count, s2) e3 bv
==>
evaluate_ctxt env (count,s1) (Capp2 op v1 ()) v2 bv

and

app5 : forall env op v1 v2 s count.
(do_app env s op v1 v2 = Nothing)
==>
evaluate_ctxt env (count,s) (Capp2 op v1 ()) v2 ((count, s), Rerr Rtype_error)

and

uapp1 : forall env uop v v' s1 s2 count.
(do_uapp s1 uop v = Just (s2,v'))
==>
evaluate_ctxt env (count,s1) (Cuapp uop ()) v ((count,s2), Rval v')

and

uapp2 : forall env uop v s count.
(do_uapp s uop v = Nothing)
==>
evaluate_ctxt env (count,s) (Cuapp uop ()) v ((count,s), Rerr Rtype_error)

and

log1 : forall env op e2 v e' bv s.
do_log op v e2 = Just e' &&
evaluate false env s e' bv
==>
evaluate_ctxt env s (Clog op () e2) v bv

and

log2 : forall env op e2 v s.
(do_log op v e2 = Nothing)
==>
evaluate_ctxt env s (Clog op () e2) v (s, Rerr Rtype_error)

and
if1 : forall env e2 e3 v e' bv s.
do_if v e2 e3 = Just e' &&
evaluate false env s e' bv
==>
evaluate_ctxt env s (Cif () e2 e3) v bv

and

if2 : forall env e2 e3 v s.
(do_if v e2 e3 = Nothing)
==>
evaluate_ctxt env s (Cif () e2 e3) v (s, Rerr Rtype_error)

and

mat : forall env pes v bv s err_v.
evaluate_match false env s v pes err_v bv
==>
evaluate_ctxt env s (Cmat () pes err_v) v bv

and

lt : forall menv cenv env n e2 v bv s.
evaluate false (menv, cenv, opt_bind n v env) s e2 bv
==>
evaluate_ctxt (menv,cenv,env) s (Clet n () e2) v bv

and

con1 : forall env cn es vs v vs' s1 s2 v'.
do_con_check (all_env_to_cenv env) cn (List.length vs + List.length es + 1) &&
build_conv (all_env_to_cenv env) cn (List.reverse vs ++ [v] ++ vs') = Just v' &&
evaluate_list false env s1 es (s2, Rval vs')
==>
evaluate_ctxt env s1 (Ccon cn vs () es) v (s2, Rval v')

and

con2 : forall env cn es vs v s.
not (do_con_check (all_env_to_cenv env) cn (List.length vs + List.length es + 1))
==>
evaluate_ctxt env s (Ccon cn vs () es) v (s, Rerr Rtype_error)

and

con3 : forall env cn es vs v err s s'.
do_con_check (all_env_to_cenv env) cn (List.length vs + List.length es + 1) &&
evaluate_list false env s es (s', Rerr err)
==>
evaluate_ctxt env s (Ccon cn vs () es) v (s', Rerr err)

indreln
[evaluate_ctxts : count_store v -> list ctxt -> result v v -> count_store v * result v v -> bool]

empty : forall res s.
true
==>
evaluate_ctxts s [] res (s, res)

and

cons_val : forall c cs env v res bv s1 s2.
evaluate_ctxt env s1 c v (s2, res) &&
evaluate_ctxts s2 cs res bv
==>
evaluate_ctxts s1 ((c,env)::cs) (Rval v) bv

and

cons_err : forall c cs env err s bv.
evaluate_ctxts s cs (Rerr err) bv &&
((forall pes. c <> Chandle () pes) ||
 (forall v. err <> Rraise v))
==>
evaluate_ctxts s ((c,env)::cs) (Rerr err) bv

and

cons_handle : forall cs env s s' res1 res2 pes v.
evaluate_match false env s v pes v (s', res1) &&
evaluate_ctxts s' cs res1 res2
==>
evaluate_ctxts s ((Chandle () pes,env)::cs) (Rerr (Rraise v)) res2

indreln
[evaluate_state : state -> count_store v * result v v -> bool]

exp : forall env e c res bv s1 s2.
evaluate false env (0,s1) e (s2, res) &&
evaluate_ctxts s2 c res bv
==>
evaluate_state (env, s1, Exp e, c) bv

and

vl : forall env s v c bv.
evaluate_ctxts (0,s) c (Rval v) bv
==>
evaluate_state (env, s, Val v, c) bv
