open Lib
open Ast
open SemanticPrimitives
open SmallStep
open BigStep

(* ------ Auxiliary relations for proving big/small step equivalence ------ *)

val evaluate_ctxt : envM -> envC -> store -> envE -> ctxt_frame -> v -> store * result v -> bool
val evaluate_ctxts : envM -> envC -> store -> list ctxt -> result v -> store * result v -> bool
val evaluate_state : state -> store * result v -> bool

indreln

forall menv cenv s env v1 e2 var.
true
==>
evaluate_ctxt menv cenv s env (Chandle () var e2) v1 (s, Rval v1)

and

forall menv cenv env op e2 v1 v2 env' e3 bv s1 s2 s3.
evaluate menv cenv s1 env e2 (s2, Rval v2) &&
do_app s2 env op v1 v2 = Some (s3,env', e3) &&
evaluate menv cenv s3 env' e3 bv
==>
evaluate_ctxt menv cenv s1 env (Capp1 op () e2) v1 bv

and

forall menv cenv env op e2 v1 v2 s1 s2.
evaluate menv cenv s1 env e2 (s2, Rval v2) &&
do_app s2 env op v1 v2 = None
==>
evaluate_ctxt menv cenv s1 env (Capp1 op () e2) v1 (s2, Rerr Rtype_error)

and

forall menv cenv env op e2 v1 err s s'.
evaluate menv cenv s env e2 (s', Rerr err)
==>
evaluate_ctxt menv cenv s env (Capp1 op () e2) v1 (s', Rerr err)

and

forall menv cenv env op v1 v2 env' e3 bv s1 s2.
do_app s1 env op v1 v2 = Some (s2, env', e3) &&
evaluate menv cenv s2 env' e3 bv
==>
evaluate_ctxt menv cenv s1 env (Capp2 op v1 ()) v2 bv

and

forall menv cenv env op v1 v2 s.
(do_app s env op v1 v2 = None)
==>
evaluate_ctxt menv cenv s env (Capp2 op v1 ()) v2 (s, Rerr Rtype_error)

and

forall menv cenv env uop v v' s1 s2.
(do_uapp s1 uop v = Some (s2,v'))
==>
evaluate_ctxt menv cenv s1 env (Cuapp uop ()) v (s2, Rval v')

and

forall menv cenv env uop v s.
(do_uapp s uop v = None)
==>
evaluate_ctxt menv cenv s env (Cuapp uop ()) v (s, Rerr Rtype_error)

and

forall menv cenv env op e2 v e' bv s.
do_log op v e2 = Some e' &&
evaluate menv cenv s env e' bv
==>
evaluate_ctxt menv cenv s env (Clog op () e2) v bv

and

forall menv cenv env op e2 v s.
(do_log op v e2 = None)
==>
evaluate_ctxt menv cenv s env (Clog op () e2) v (s, Rerr Rtype_error)

and
forall menv cenv env e2 e3 v e' bv s.
do_if v e2 e3 = Some e' &&
evaluate menv cenv s env e' bv
==>
evaluate_ctxt menv cenv s env (Cif () e2 e3) v bv

and

forall menv cenv env e2 e3 v s.
(do_if v e2 e3 = None)
==>
evaluate_ctxt menv cenv s env (Cif () e2 e3) v (s, Rerr Rtype_error)

and

forall menv cenv env pes v bv s.
evaluate_match menv cenv s env v pes bv
==>
evaluate_ctxt menv cenv s env (Cmat () pes) v bv

and

forall menv cenv env n e2 v bv s.
evaluate menv cenv s (bind n v env) e2 bv
==>
evaluate_ctxt menv cenv s env (Clet n () e2) v bv

and

forall menv cenv env cn es vs v vs' s1 s2.
do_con_check cenv cn (List.length vs + List.length es + 1) &&
evaluate_list menv cenv s1 env es (s2, Rval vs')
==>
evaluate_ctxt menv cenv s1 env (Ccon cn vs () es) v (s2, Rval (Conv cn (List.rev vs @ [v] @ vs')))

and

forall menv cenv env cn es vs v s.
not (do_con_check cenv cn (List.length vs + List.length es + 1))
==>
evaluate_ctxt menv cenv s env (Ccon cn vs () es) v (s, Rerr Rtype_error)

and

forall menv cenv env cn es vs v err s s'.
do_con_check cenv cn (List.length vs + List.length es + 1) &&
evaluate_list menv cenv s env es (s', Rerr err)
==>
evaluate_ctxt menv cenv s env (Ccon cn vs () es) v (s', Rerr err)

indreln

forall menv cenv res s.
true
==>
evaluate_ctxts menv cenv s [] res (s, res)

and

forall menv cenv c cs env v res bv s1 s2.
evaluate_ctxt menv cenv s1 env c v (s2, res) &&
evaluate_ctxts menv cenv s2 cs res bv
==>
evaluate_ctxts menv cenv s1 ((c,env)::cs) (Rval v) bv

and

forall menv cenv c cs env err s bv.
evaluate_ctxts menv cenv s cs (Rerr err) bv &&
((forall i e'. c <> Chandle () i e') ||
 (forall i. err <> Rraise (Int_error i)))
==>
evaluate_ctxts menv cenv s ((c,env)::cs) (Rerr err) bv

and

forall menv cenv cs env s s' var res1 res2 i e'.
evaluate menv cenv s (bind var (Litv (IntLit i)) env) e' (s', res1) &&
evaluate_ctxts menv cenv s' cs res1 res2
==>
evaluate_ctxts menv cenv s ((Chandle () var e',env)::cs) (Rerr (Rraise (Int_error i))) res2

indreln

forall menv cenv env e c res bv s1 s2.
evaluate menv cenv s1 env e (s2, res) &&
evaluate_ctxts menv cenv s2 c res bv
==>
evaluate_state (menv, cenv, s1, env, Exp e, c) bv

and

forall menv cenv s env v c bv.
evaluate_ctxts menv cenv s c (Rval v) bv
==>
evaluate_state (menv, cenv, s, env, Val v, c) bv
