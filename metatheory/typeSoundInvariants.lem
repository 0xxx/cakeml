open import Pervasives
open import Lib
open import Ast
open import SemanticPrimitives
open import SmallStep
open import TypeSystem

(* Store typing *)
type tenvS = env nat t

(* A value has a type *)
(* The number is how many deBruijn type variables are bound in the context. *)
val type_v : nat -> tenvM -> tenvC -> tenvS -> v -> t -> bool

(* A value environment has a corresponding type environment.  Since all of the
 * entries in the environment are values, and values have no free variables,
 * each entry in the environment can be typed in the empty environment (if at
 * all) *)
val type_env : tenvM -> tenvC -> tenvS -> envE -> tenvE -> bool

(* The type of the store *)
val type_s : tenvM -> tenvC -> tenvS -> store -> bool

(* An evaluation context has the second type when its hole is filled with a
 * value of the first type. *)
(* The number is how many deBruijn type variables are bound in the context.
 * This is only used for constructor contexts, because the value restriction 
 * ensures that no other contexts can be created under a let binding. *)
val type_ctxt : nat -> tenvM -> tenvC -> tenvS -> tenvE -> ctxt_frame -> t -> t -> bool
val type_ctxts : nat -> tenvM -> tenvC -> tenvS -> list ctxt -> t -> t -> bool
val type_state : nat -> tenvM -> tenvC -> tenvS -> state -> t -> bool
val context_invariant : nat -> list ctxt -> nat -> bool

(* Type programs without imposing signatures.  This is needed for the type
 * soundness proof *)
val type_top_ignore_sig : tenvM -> tenvC -> tenvE -> top -> tenvM -> tenvC -> env varN (nat * t) -> bool


indreln
[type_top_ignore_sig : tenvM -> tenvC -> tenvE -> top -> tenvM -> tenvC -> env varN (nat * t) -> bool]

dec : forall menv cenv tenv d cenv' tenv'.
type_d Nothing menv cenv tenv d cenv' tenv'
==>
type_top_ignore_sig menv cenv tenv (Tdec d) emp cenv' tenv'

and

md : forall menv cenv tenv mn spec ds cenv' tenv'. 
not (List.elem mn (List.map fst menv)) &&
type_ds (Just mn) menv cenv tenv ds cenv' tenv'
==>
type_top_ignore_sig menv cenv tenv (Tmod mn spec ds) [(mn,tenv')] cenv' emp


indreln
[type_v : nat -> tenvM -> tenvC -> tenvS -> v -> t -> bool]
and
[type_vs : nat -> tenvM -> tenvC -> tenvS -> list v -> list t -> bool]
and
[type_env : tenvM -> tenvC -> tenvS -> envE -> tenvE -> bool]

lit_bool : forall tvs menv cenv senv b.
true
==>
type_v tvs menv cenv senv (Litv (Bool b)) Tbool

and

lit_int : forall tvs menv cenv senv n.
true
==>
type_v tvs menv cenv senv (Litv (IntLit n)) Tint

and

lit_string : forall tvs menv cenv senv s.
true
==>
type_v tvs menv cenv senv (Litv (String s)) Tstring

and

lit_unit : forall tvs menv cenv senv.
true
==>
type_v tvs menv cenv senv (Litv Unit) Tunit

and

conv_some : forall tvs menv cenv senv cn vs tvs' tn ts' ts.
List.all (check_freevars tvs []) ts' &&
List.length tvs' = List.length ts' &&
type_vs tvs menv cenv senv vs (List.map (type_subst (ZIP tvs' ts')) ts) &&
lookup cn cenv = Just (tvs', ts, tn)
==>
type_v tvs menv cenv senv (Conv (Just cn) vs) (Tapp ts' (tid_exn_to_tc tn))

and

conv_none : forall tvs menv cenv senv vs ts.
type_vs tvs menv cenv senv vs ts
==>
type_v tvs menv cenv senv (Conv Nothing vs) (Tapp ts TC_tup)

and

closure : forall tvs menv cenv senv env tenv n e t1 t2.
type_env menv cenv senv env tenv &&
check_freevars tvs [] t1 &&
type_e menv cenv (bind_tenv n 0 t1 (bind_tvar tvs tenv)) e t2
==>
type_v tvs menv cenv senv (Closure env n e) (Tfn t1 t2)

and

recclosure : forall tvs menv cenv senv env funs n t tenv tenv'.
type_env menv cenv senv env tenv &&
type_funs menv cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv' &&
lookup n tenv' = Just t
==>
type_v tvs menv cenv senv (Recclosure env funs n) t

and

loc : forall tvs menv cenv senv n t.
check_freevars 0 [] t &&
(lookup n senv = Just t)
==>
type_v tvs menv cenv senv (Loc n) (Tref t)

and

empty : forall tvs menv cenv senv.
true
==>
type_vs tvs menv cenv senv [] []

and

cons : forall tvs menv cenv senv v vs t ts.
type_v tvs menv cenv senv v t &&
type_vs tvs menv cenv senv vs ts
==>
type_vs tvs menv cenv senv (v::vs) (t::ts)

and

empty : forall menv cenv senv.
true
==>
type_env menv cenv senv emp Empty

and

bind : forall menv cenv senv n v env t tenv tvs.
type_v tvs menv cenv senv v t &&
type_env menv cenv senv env tenv
==>
type_env menv cenv senv (bind n v env) (bind_tenv n tvs t tenv)

let rec 
consistent_mod_env tenvS tenvC [] [] = true
and
consistent_mod_env tenvS tenvC ((mn,env)::menv) ((mn',tenv)::tenvM) =
  (mn = mn') &&
  not (List.elem mn (List.map fst tenvM)) &&
  type_env tenvM tenvC tenvS env (bind_var_list2 tenv Empty) &&
  consistent_mod_env tenvS tenvC menv tenvM
and
consistent_mod_env tenvS tenvC _ _ = false

let type_s menv cenv senv s =
  forall l. 
    ((exists t. lookup l senv = Just t) = (exists v. store_lookup l s = Just v)) &&
    forall t v. ((lookup l senv = Just t) && (store_lookup l s = Just v)) --> type_v 0 menv cenv senv v t

indreln 
[context_invariant : nat -> list ctxt -> nat -> bool]

empty : forall n.
true
==>
context_invariant n [] n

and

raise : forall dec_tvs c env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Craise (),env) :: c) 0

and

handle : forall dec_tvs c pes env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Chandle () pes,env) :: c) 0

and

app1 : forall dec_tvs c op e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Capp1 op () e,env) :: c) 0

and

app2 : forall dec_tvs c op v env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Capp2 op v (),env) :: c) 0

and

log : forall dec_tvs c l e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Clog l () e,env) :: c) 0

and

if_ : forall dec_tvs c e1 e2 env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cif () e1 e2,env) :: c) 0

and

mat : forall dec_tvs c pes env err_v.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cmat () pes err_v,env) :: c) 0

and

lt : forall dec_tvs c tvs x e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Clet x () e,env) :: c) tvs

and

con : forall dec_tvs c cn vs es tvs env.
context_invariant dec_tvs c tvs &&
(tvs <> 0 --> List.all is_value es)
==>
context_invariant dec_tvs ((Ccon cn vs () es,env) :: c) tvs

and

uapp : forall dec_tvs c op env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cuapp op (),env) :: c) 0

indreln
[type_ctxt : nat -> tenvM -> tenvC -> tenvS -> tenvE -> ctxt_frame -> t -> t -> bool]

raise : forall tvs menv cenv senv tenv t.
check_freevars tvs [] t
 ==>
type_ctxt tvs menv cenv senv tenv (Craise ()) Texn t

and

handle : forall tvs menv cenv senv tenv pes t.
(forall ((p,e) MEM pes). exists tenv'.
   all_distinct (pat_bindings p []) &&
   type_p (num_tvs tenv) cenv p Texn tenv' &&
   type_e menv cenv (bind_var_list 0 tenv' tenv) e t)
==>
type_ctxt tvs menv cenv senv tenv (Chandle () pes) t t

and

uapp : forall tvs menv cenv senv tenv uop t1 t2.
check_freevars tvs [] t1 &&
check_freevars tvs [] t2 &&
type_uop uop t1 t2
==>
type_ctxt tvs menv cenv senv tenv (Cuapp uop ()) t1 t2

and

app1 : forall tvs menv cenv senv tenv e op t1 t2 t3.
check_freevars tvs [] t1 &&
check_freevars tvs [] t3 &&
type_e menv cenv tenv e t2 &&
type_op op t1 t2 t3
==>
type_ctxt tvs menv cenv senv tenv (Capp1 op () e) t1 t3

and

app2 : forall tvs menv cenv senv tenv op v t1 t2 t3.
check_freevars tvs [] t2 &&
check_freevars tvs [] t3 &&
type_v 0 menv cenv senv v t1 &&
type_op op t1 t2 t3
==>
type_ctxt tvs menv cenv senv tenv (Capp2 op v ()) t2 t3

and

log : forall tvs menv cenv senv tenv op e.
type_e menv cenv tenv e Tbool
==>
type_ctxt tvs menv cenv senv tenv (Clog op () e) Tbool Tbool

and

if_ : forall tvs menv cenv senv tenv e1 e2 t.
type_e menv cenv tenv e1 t &&
type_e menv cenv tenv e2 t
==>
type_ctxt tvs menv cenv senv tenv (Cif () e1 e2) Tbool t

and

mat : forall tvs menv cenv senv tenv t1 t2 pes err_v.
((pes = []) --> (check_freevars tvs [] t1 && check_freevars 0 [] t2)) &&
(forall ((p,e) MEM pes) . exists tenv'.
   all_distinct (pat_bindings p []) &&
   type_p tvs cenv p t1 tenv' &&
   type_e menv cenv (bind_var_list 0 tenv' tenv) e t2) &&
type_v 0 menv cenv senv err_v Texn
==>
type_ctxt tvs menv cenv senv tenv (Cmat () pes err_v) t1 t2

and

lt : forall tvs menv cenv senv tenv e t1 t2 n.
check_freevars tvs [] t1 &&
type_e menv cenv (bind_tenv n tvs t1 tenv) e t2
==>
type_ctxt tvs menv cenv senv tenv (Clet n () e) t1 t2

and

con_some : forall tvs menv cenv senv tenv cn vs es ts1 ts2 t tn ts' tvs'.
List.all (check_freevars tvs []) ts' &&
List.length tvs' = List.length ts' &&
type_vs tvs menv cenv senv (List.reverse vs)
        (List.map (type_subst (ZIP tvs' ts')) ts1) &&
type_es menv cenv (bind_tvar tvs tenv) es (List.map (type_subst (ZIP tvs' ts')) ts2) &&
lookup cn cenv = Just (tvs', ts1++[t]++ts2, tn)
==>
type_ctxt tvs menv cenv senv tenv (Ccon (Just cn) vs () es) (type_subst (ZIP tvs' ts') t)
          (Tapp ts' (tid_exn_to_tc tn))

and

con_none : forall tvs menv cenv senv tenv vs es t ts1 ts2.
check_freevars tvs [] t &&
type_vs tvs menv cenv senv (List.reverse vs) ts1 &&
type_es menv cenv (bind_tvar tvs tenv) es ts2
==>
type_ctxt tvs menv cenv senv tenv (Ccon Nothing vs () es) t (Tapp (ts1++[t]++ts2) TC_tup)

let poly_context cs = 
  match cs with
    | (Ccon cn vs () es,env) :: cs -> List.all is_value es
    | (Clet x () e,env) :: cs -> true
    | [] -> true
    | _ -> false
  end

let is_ccon c = 
  match c with
    | Ccon cn vs () es -> true
    | _ -> false
  end

indreln
[type_ctxts : nat -> tenvM -> tenvC -> tenvS -> list ctxt -> t -> t -> bool]

empty : forall tvs tenvM tenvC senv t.
check_freevars tvs [] t
==>
type_ctxts tvs tenvM tenvC senv [] t t

and

cons : forall tvs tenvM tenvC senv c env cs tenv t1 t2 t3.
type_env tenvM tenvC senv env tenv &&
type_ctxt tvs tenvM tenvC senv tenv c t1 t2 &&
type_ctxts (if is_ccon c && poly_context cs then tvs else 0) tenvM tenvC senv cs t2 t3
==>
type_ctxts tvs tenvM tenvC senv ((c,env)::cs) t1 t3

indreln
[type_state : nat -> tenvM -> tenvC -> tenvS -> state -> t -> bool]

exp : forall dec_tvs tenvM tenvC senv envM envC s env e c t1 t2 tenv tvs.
context_invariant dec_tvs c tvs &&
type_ctxts tvs tenvM tenvC senv c t1 t2 &&
type_env tenvM tenvC senv env tenv &&
type_s tenvM tenvC senv s &&
type_e tenvM tenvC (bind_tvar tvs tenv) e t1 &&
((tvs <> 0) --> is_value e)
==>
type_state dec_tvs tenvM tenvC senv (envM,envC, s, env, Exp e, c) t2

and

vl : forall dec_tvs tenvM tenvC senv envM envC s env v c t1 t2 tenv tvs.
context_invariant dec_tvs c tvs &&
type_ctxts tvs tenvM tenvC senv c t1 t2 &&
type_env tenvM tenvC senv env tenv &&
type_s tenvM tenvC senv s &&
type_v tvs tenvM tenvC senv v t1
==>
type_state dec_tvs tenvM tenvC senv (envM, envC, s, env, Val v, c) t2
