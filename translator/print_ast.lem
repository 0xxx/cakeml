open import Pervasives
open import Lib
open import Ast
open import Tokens
open import String_extra

val int_to_string : integer -> string
let int_to_string n =
  if n = 0 then
    "0"
  else if n > 0 then
    show (naturalFromInteger n)
  else
    "~" ^ show (naturalFromInteger (0 - n))

val spaces : nat -> string -> string
let rec
spaces n s =
  if (n:nat) = 0 then
    s
  else
    " " ^ spaces (n - 1) s

let space_append s1 s2 =
  if s2 = "" then
    s1
  else
    let f = nth s2 0 in
      if f = #')'  || f = #' ' || f = #',' then
    s1 ^ s2
  else
    s1 ^ " " ^ s2

let rec
tok_to_string NewlineT s = "\n" ^ s
and
tok_to_string (WhitespaceT n) s = spaces n s
and
tok_to_string (IntT i) s = space_append (int_to_string i) s
and
tok_to_string (LongidT mn id) s = space_append (if mn = "" then id else mn^"."^id) s
and
tok_to_string (TyvarT tv) s = space_append tv s
and
tok_to_string AndT s = "and " ^ s
and
tok_to_string AndalsoT s = "andalso " ^ s
and
tok_to_string CaseT s = "case " ^ s
and
tok_to_string DatatypeT s = "datatype " ^ s
and
tok_to_string ElseT s = "else " ^ s
and
tok_to_string EndT s = "end " ^ s
and
tok_to_string FnT s = "fn " ^ s
and
tok_to_string FunT s = "fun " ^ s
and
tok_to_string IfT s = "if " ^ s
and
tok_to_string InT s = "in " ^ s
and
tok_to_string LetT s = "let " ^ s
and
tok_to_string OfT s = "of " ^ s
and
tok_to_string OpT s = "op " ^ s
and
tok_to_string OrelseT s = "orelse " ^ s
and
tok_to_string RecT s = "rec " ^ s
and
tok_to_string ThenT s = "then " ^ s
and
tok_to_string ValT s = "val " ^ s
and
tok_to_string LparT s =
  if s = "" then
    "("
  else if nth s 0 = #'*' then
    "( " ^ s
  else
    "(" ^ s
and
tok_to_string RparT s = space_append ")" s
and
tok_to_string CommaT s = ", " ^ s
and
tok_to_string SemicolonT s = ";" ^ s
and
tok_to_string BarT s = "| " ^ s
and
tok_to_string EqualsT s = "= " ^ s
and
tok_to_string DarrowT s = "=> " ^ s
and
tok_to_string ArrowT s = "-> " ^ s
and
tok_to_string StarT s = "* " ^ s
and
tok_to_string TypeT s = "type " ^ s
and
tok_to_string WithT s = "with " ^ s

let rec
tok_list_to_string [] = ""
and
tok_list_to_string (t::l) =
  tok_to_string t (tok_list_to_string l)

(*type 'a tree = L of 'a | N of 'a tree * 'a tree*)
type tok_tree = L of token | N of tok_tree * tok_tree

(*val (^^) : forall 'a. 'a tree -> 'a tree -> 'a tree*)
val (^^) : tok_tree -> tok_tree -> tok_tree
let inline (^^) x y = N x y

(*val tree_to_list : forall 'a. 'a tree -> 'a list -> 'a list*)
val tree_to_list : tok_tree -> list token -> list token
let rec
tree_to_list (L x) acc = x::acc
and
tree_to_list (N x1 x2) acc = tree_to_list x1 (tree_to_list x2 acc)

(* Should include "^", but I don't know how to get that into HOL, since
 * antiquote seem stronger than strings.  See the specification in
 * print_astProofsScript. *)
let is_sml_infix s =
  let c = ord (nth s 0) in
    if c < 65 (* "A" *) then
      if c < 60 (* "<" *) then
        s = "*" ||
        s = "+" ||
        s = "-" ||
        s = "/" ||
        s = "::" ||
        s = ":="
      else
        s = "<" ||
        s = "<=" ||
        s = "<>" ||
        s = "=" ||
        s = ">" ||
        s = ">=" ||
        s = "@"
    else
      if c < 109 (* "m" *) then
        if c < 100 then
          s = "before"
        else
          s = "div"
      else
        if c < 111 then
          s = "mod"
        else
          s = "o"

(*val join_trees : forall 'a. 'a tree -> 'a tree list -> 'a tree*)
val join_trees : tok_tree -> list tok_tree -> tok_tree
let rec
join_trees sep [x] = x
and
join_trees sep (x::y::l) =
  x ^^ sep ^^ join_trees sep (y::l)

let rec
lit_to_tok_tree (Bool true) = L (LongidT "" "true")
and
lit_to_tok_tree (Bool false) = L (LongidT "" "false")
and
lit_to_tok_tree (IntLit n) = L (IntT n)
and
lit_to_tok_tree Unit = N (L LparT) (L RparT)
and
lit_to_tok_tree Unit = N (L LparT) (L RparT)


let var_to_tok_tree v =
  if is_sml_infix v then
    L OpT ^^ L (LongidT "" v)
  else
    L (LongidT "" v)

let id_to_tok_tree v =
  match v with
    | Short v ->
        L (LongidT "" v)
    | Long m v ->
        L (LongidT m v)
  end

let rec
pat_to_tok_tree (Pvar v) = var_to_tok_tree v
and
pat_to_tok_tree (Plit l) = lit_to_tok_tree l
and
pat_to_tok_tree (Pcon (Just c) []) = id_to_tok_tree c
and
pat_to_tok_tree (Pcon (Just (Short "::")) [p1;p2]) =
  L LparT ^^
  pat_to_tok_tree p1 ^^
  id_to_tok_tree (Short "::") ^^
  pat_to_tok_tree p2 ^^
  L RparT
and
pat_to_tok_tree (Pcon (Just c) ps) =
  L LparT ^^ id_to_tok_tree c ^^
    L LparT ^^ join_trees (L CommaT) (List.map pat_to_tok_tree ps) ^^
    L RparT ^^ L RparT
and
pat_to_tok_tree (Pcon Nothing ps) =
    L LparT ^^ join_trees (L CommaT) (List.map pat_to_tok_tree ps) ^^ L RparT
and
pat_to_tok_tree (Pref p) =
  L LparT ^^ L (LongidT "" "ref") ^^ pat_to_tok_tree p ^^ L RparT

let inc_indent i =
  if (i:nat) < 30 then
    i + 2
  else
    i

let newline indent =
  L NewlineT ^^ L (WhitespaceT indent)

let rec
exp_to_tok_tree indent (Raise r) =
  L LparT ^^ L (LongidT "" "raise") ^^ L (LongidT "" "Bind") ^^ L RparT
and
exp_to_tok_tree indent (Lit l) =
  lit_to_tok_tree l
and
exp_to_tok_tree indent (Con (Just c) []) =
  id_to_tok_tree c
and
exp_to_tok_tree indent (Con (Just (Short "::")) [e1; e2]) =
  L LparT ^^
  exp_to_tok_tree indent e1 ^^
  id_to_tok_tree (Short "::") ^^
  exp_to_tok_tree indent e2 ^^
  L RparT
and
exp_to_tok_tree indent (Con (Just c) es) =
  L LparT ^^
  id_to_tok_tree c ^^
  L LparT ^^
  join_trees (L CommaT) (List.map (exp_to_tok_tree indent) es) ^^
  L RparT ^^ L RparT
and
exp_to_tok_tree indent (Con Nothing es) =
  L LparT ^^
  join_trees (L CommaT) (List.map (exp_to_tok_tree indent) es) ^^
  L RparT
and
exp_to_tok_tree indent (Var vid) =
  id_to_tok_tree vid
and
exp_to_tok_tree indent (Fun v e) =
  newline indent ^^
  L LparT ^^
  L FnT ^^
  var_to_tok_tree v ^^
  L DarrowT ^^
  exp_to_tok_tree (inc_indent indent) e ^^
  L RparT
and
exp_to_tok_tree indent (Uapp uop e) =
  let s =
    match uop with
      | Opref -> "ref"
      | Opderef -> "!"
    end
  in
    L LparT ^^
    L (LongidT "" s) ^^
    exp_to_tok_tree indent e ^^
    L RparT
and
exp_to_tok_tree indent (App Opapp e1 e2) =
  L LparT ^^
  exp_to_tok_tree indent e1 ^^
  exp_to_tok_tree indent e2 ^^
  L RparT
and
exp_to_tok_tree indent (App Equality e1 e2) =
  L LparT ^^
  exp_to_tok_tree indent e1 ^^
  L EqualsT ^^
  exp_to_tok_tree indent e2 ^^
  L RparT
and
exp_to_tok_tree indent (App (Opn o) e1 e2) =
  let s = match o with
    | Plus -> "+"
    | Minus -> "-"
    | Times -> "*"
    | Divide -> "div"
    | Modulo -> "mod"
  end
  in
    L LparT ^^
    exp_to_tok_tree indent e1 ^^
    L (LongidT "" s) ^^
    exp_to_tok_tree indent e2 ^^
    L RparT
and
exp_to_tok_tree indent (App (Opb o') e1 e2) =
  let s = match o' with
    | Lt -> "<"
    | Gt -> ">"
    | Leq -> "<="
    | Geq -> ">"
  end
  in
    L LparT ^^
    exp_to_tok_tree indent e1 ^^
    L (LongidT "" s) ^^
    exp_to_tok_tree indent e2 ^^
    L RparT
and
exp_to_tok_tree indent (App Opassign e1 e2) =
  L LparT ^^
  exp_to_tok_tree indent e1 ^^
  L (LongidT "" ":=") ^^
  exp_to_tok_tree indent e2 ^^
  L RparT
and
exp_to_tok_tree indent (Log lop e1 e2) =
  L LparT ^^
  exp_to_tok_tree indent e1 ^^
  (if lop = And then
     L AndalsoT
   else
     L OrelseT)^^
  exp_to_tok_tree indent e2 ^^
  L RparT
and
exp_to_tok_tree indent (If e1 e2 e3) =
  newline indent ^^
  L LparT ^^
  L IfT ^^
  exp_to_tok_tree indent e1 ^^
  newline indent ^^
  L ThenT ^^
  exp_to_tok_tree (inc_indent indent) e2 ^^
  newline indent ^^
  L ElseT ^^
  exp_to_tok_tree (inc_indent indent) e3 ^^
  L RparT
and
exp_to_tok_tree indent (Mat e pes) =
  newline indent ^^
  L LparT ^^
  L CaseT ^^
  exp_to_tok_tree indent e ^^
  L OfT ^^
  newline (inc_indent (inc_indent indent)) ^^
  join_trees (newline (inc_indent indent) ^^ L BarT)
               (List.map (pat_exp_to_tok_tree (inc_indent indent)) pes) ^^
  L RparT
and
exp_to_tok_tree indent (Let (Just v) e1 e2) =
  newline indent ^^
  L LparT ^^
  exp_to_tok_tree indent e1 ^^
  L SemicolonT ^^
  exp_to_tok_tree indent e2 ^^
  L RparT
and
exp_to_tok_tree indent (Let (Just v) e1 e2) =
  newline indent ^^
  L LetT ^^ L ValT ^^
  var_to_tok_tree v ^^
  L EqualsT ^^
  exp_to_tok_tree indent e1 ^^
  newline indent ^^
  L InT ^^
  exp_to_tok_tree (inc_indent indent) e2 ^^
  newline indent ^^ L EndT
and
exp_to_tok_tree indent (Letrec funs e) =
  newline indent ^^
  L LetT ^^ L FunT ^^
  join_trees (newline indent ^^ L AndT)
               (List.map (fun_to_tok_tree indent) funs) ^^
  newline indent ^^
  L InT ^^
  exp_to_tok_tree indent e ^^
  newline indent ^^ L EndT
and
pat_exp_to_tok_tree indent (p,e) =
  pat_to_tok_tree p ^^
  L DarrowT ^^
  exp_to_tok_tree (inc_indent (inc_indent indent)) e
and
fun_to_tok_tree indent (v1,v2,e) =
  var_to_tok_tree v1 ^^
  var_to_tok_tree v2 ^^
  L EqualsT ^^
  exp_to_tok_tree (inc_indent indent) e

let rec
tc_to_tok_tree TC_int =
  L (LongidT "" "int")
and
tc_to_tok_tree TC_bool =
  L (LongidT "" "bool")
and
tc_to_tok_tree TC_unit =
  L (LongidT "" "unit")
and
tc_to_tok_tree TC_ref =
  L (LongidT "" "ref")
and
tc_to_tok_tree (TC_name n) =
  id_to_tok_tree n

let rec
type_to_tok_tree (Tvar tn) =
  L (TyvarT tn)
and
type_to_tok_tree (Tapp [t1;t2] TC_fn) =
  L LparT ^^ type_to_tok_tree t1 ^^ L ArrowT ^^ type_to_tok_tree t2 ^^
  L RparT
and
type_to_tok_tree (Tapp ts tc) =
  if ts = [] then
    (tc_to_tok_tree tc)
  else
    L LparT ^^
    join_trees (L CommaT) (List.map type_to_tok_tree ts) ^^ L RparT ^^
    (tc_to_tok_tree tc)

let variant_to_tok_tree (c,ts) =
  if ts = [] then
    var_to_tok_tree c
  else
    var_to_tok_tree c ^^ L OfT ^^
    join_trees (L StarT) (List.map type_to_tok_tree ts)

(*val typedef_to_tok_tree : num -> tvarN list * typeN * (conN * t list) list -> token tree*)
val typedef_to_tok_tree : nat -> list tvarN * typeN * list (conN * list t) -> tok_tree
let typedef_to_tok_tree indent (tvs, name, variants) =
  (if tvs = [] then
     L (LongidT "" name)
   else
     L LparT ^^
     join_trees (L CommaT) (List.map (fun tv -> L (TyvarT tv)) tvs) ^^
     L RparT ^^
     L (LongidT "" name)) ^^
  L EqualsT ^^
  newline (inc_indent (inc_indent indent)) ^^
  join_trees (newline (inc_indent indent) ^^ L BarT)
               (List.map variant_to_tok_tree variants)

let rec
dec_to_tok_tree indent (Dlet p e) =
  L ValT ^^
  pat_to_tok_tree p ^^
  L EqualsT ^^
  exp_to_tok_tree (inc_indent indent) e ^^
  L SemicolonT
and
dec_to_tok_tree indent (Dletrec funs) =
  L FunT ^^
  join_trees (newline indent ^^ L AndT)
             (List.map (fun_to_tok_tree indent) funs) ^^
  L SemicolonT
and
dec_to_tok_tree indent (Dtype types) =
  L DatatypeT ^^
  join_trees (newline indent ^^ L AndT)
             (List.map (typedef_to_tok_tree indent) types) ^^
  L SemicolonT

let dec_to_sml_string d =
  tok_list_to_string (tree_to_list (dec_to_tok_tree 0 d) [])
