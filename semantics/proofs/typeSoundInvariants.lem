(* Type system for values. The invariant that is used for type soundness. *)

open import Pervasives
open import Lib
open import Ast
open import Environment
open import SemanticPrimitives
open import TypeSystem
import List_extra

let cof env = env.SemanticPrimitives.c
let vof env = env.SemanticPrimitives.v
let dmof env = env.SemanticPrimitives.defined_mods
let dtof env = env.SemanticPrimitives.defined_types
declare hol target_rep function cof env = `environment_c` env
declare hol target_rep function vof env = `environment_v` env
declare hol target_rep function dmof env = `state_defined_mods` env
declare hol target_rep function dtof env = `state_defined_types` env

type store_t = Ref_t of t | W8array_t | Varray_t of t

(* Store typing *)
type tenv_store = Map.map nat store_t

(* Check that the type names map to valid types *)
val tenv_abbrev_ok : tenv_abbrev -> bool
let tenv_abbrev_ok tenvT =
  eAll (fun (tvs,t) -> check_freevars 0 tvs t) tenvT

val tenv_ctor_ok : tenv_ctor -> bool
let tenv_ctor_ok tenvC =
  eAll (fun (tvs,ts,tn) -> List.all (check_freevars 0 tvs) ts) tenvC

val tenv_val_ok : tenv_val -> bool
let tenv_val_ok tenvV =
  eAll (fun (tvs,t) -> check_freevars tvs [] t) tenvV

val tenv_ok : type_env -> bool
let tenv_ok tenv =
  tenv_val_ok tenv.v &&
  tenv_ctor_ok tenv.c &&
  tenv_abbrev_ok tenv.t

val tenv_val_ok_exp : tenv_val_exp -> bool
let rec
tenv_val_ok_exp Empty = true
and
tenv_val_ok_exp (Bind_tvar n tenv) = tenv_val_ok_exp tenv
and
tenv_val_ok_exp (Bind_name x tvs t tenv) =
  check_freevars (tvs + num_tvs tenv) [] t && tenv_val_ok_exp tenv

declare termination_argument tenv_val_ok_exp = automatic

(* Global constructor type environments keyed by constructor name and type *)
type ctMap = Map.map (conN * tid_or_exn) (list tvarN * list t)

val ctMap_ok : ctMap -> bool
let ctMap_ok ctMap =
  Map.all (fun (cn,tn) (tvs,ts) -> List.all (check_freevars 0 tvs) ts) ctMap

val type_decs_to_ctMap : list modN -> tenv_abbrev -> type_def -> ctMap
let type_decs_to_ctMap mn tenvT tds =
  Map.fromList
    (List.concat
      (List.map (fun (tvs,tn,ctors) ->
        List.map (fun (cn,ts) -> ((cn,TypeId (mk_id mn tn)), (tvs, List.map (type_name_subst tenvT) ts))) ctors) tds))

(* Get the modules that are used by the type and exception definitions *)
val decls_to_mods : decls -> set (list modN)
let decls_to_mods d =
  Set.map id_to_mods d.defined_types union Set.map id_to_mods d.defined_exns

(* Check that a constructor type environment is consistent with a runtime type
 * enviroment, using the full type keyed constructor type environment to ensure
 * that the correct types are used. *)
val type_ctor : ctMap -> id conN -> (nat * tid_or_exn) -> (list tvarN * list t * tid_or_exn) -> bool
let type_ctor ctMap cn (n, t1) (tvs, ts, t2) =
  t1 = t2 &&
  Map.lookup (id_to_n cn,t1) ctMap = Just (tvs, ts) &&
  List.length ts = n

indreln
(* A value has a type *)
(* The number is how many deBruijn type variables are bound in the context. *)
[type_v : nat -> ctMap -> tenv_store -> v -> t -> bool]

lit_int : forall tvs ctMap tenvS n.
true
==>
type_v tvs ctMap tenvS (Litv (IntLit n)) Tint

and

lit_char : forall tvs ctMap tenvS c.
true
==>
type_v tvs ctMap tenvS (Litv (Char c)) Tchar

and

lit_string : forall tvs ctMap tenvS s.
true
==>
type_v tvs ctMap tenvS (Litv (StrLit s)) Tstring

and

lit_word8 : forall tvs ctMap tenvS w.
true
==>
type_v tvs ctMap tenvS (Litv (Word8 w)) Tword8

and

lit_word64 : forall tvs ctMap tenvS w.
true
==>
type_v tvs ctMap tenvS (Litv (Word64 w)) Tword64

and

conv_some : forall tvs ctMap tenvS cn vs tvs' tn ts' ts.
List.all (check_freevars tvs []) ts' &&
List.length tvs' = List.length ts' &&
all2 (type_v tvs ctMap tenvS) vs (List.map (type_subst (Map.fromList (List.reverse (List_extra.zipSameLength tvs' ts')))) ts) &&
Map.lookup (cn, tn) ctMap = Just (tvs',ts)
==>
type_v tvs ctMap tenvS (Conv (Just (cn,tn)) vs) (Tapp ts' (tid_exn_to_tc tn))

and

conv_none : forall tvs ctMap tenvS vs ts.
all2 (type_v tvs ctMap tenvS) vs ts
==>
type_v tvs ctMap tenvS (Conv Nothing vs) (Tapp ts TC_tup)

and

closure : forall tvs ctMap tenvS env tenv n e t1 t2.
tenv_ok tenv &&
eAll2 (type_ctor ctMap) (cof env) tenv.c &&
eAll2 (fun _ v (tvs,t) -> type_v tvs ctMap tenvS v t) (vof env) tenv.v &&
check_freevars tvs [] t1 &&
type_e tenv (Bind_name n 0 t1 (bind_tvar tvs Empty)) e t2
==>
type_v tvs ctMap tenvS (Closure env n e) (Tfn t1 t2)

and

recclosure : forall tvs ctMap tenvS env funs n t tenv bindings.
tenv_ok tenv &&
eAll2 (type_ctor ctMap) (cof env) tenv.c &&
eAll2 (fun _ v (tvs,t) -> type_v tvs ctMap tenvS v t) (vof env) tenv.v &&
type_funs tenv (bind_var_list 0 bindings (bind_tvar tvs Empty)) funs bindings &&
lookup n bindings = Just t &&
allDistinct (List.map (fun (f,x,e) -> f) funs) &&
List.elem n (List.map (fun (f,x,e) -> f) funs)
==>
type_v tvs ctMap tenvS (Recclosure env funs n) t

and

loc1 : forall tvs ctMap tenvS n t.
check_freevars 0 [] t &&
Map.lookup n tenvS = Just (Ref_t t)
==>
type_v tvs ctMap tenvS (Loc n) (Tref t)

and

loc2 : forall tvs ctMap tenvS n.
Map.lookup n tenvS = Just W8array_t
==>
type_v tvs ctMap tenvS (Loc n) Tword8array

and

loc3 : forall tvs ctMap tenvS n t.
check_freevars 0 [] t &&
Map.lookup n tenvS = Just (Varray_t t)
==>
type_v tvs ctMap tenvS (Loc n) (Tapp [t] TC_array)

and

vec : forall tvs ctMap tenvS vs t.
check_freevars 0 [] t &&
List.all (fun v -> type_v tvs ctMap tenvS v t) vs
==>
type_v tvs ctMap tenvS (Vectorv vs) (Tapp [t] TC_vector)

let rec type_sv ctMap tenvS (Refv v) (Ref_t t) = type_v 0 ctMap tenvS v t
and type_sv ctMap tenvS (W8array v) W8array_t = true
and type_sv ctMap tenvS (Varray vs) (Varray_t t) =
    List.all (fun v -> type_v 0 ctMap tenvS v t) vs
and type_sv _ _ _ _ = false

(* The type of the store *)
val type_s : ctMap -> store v -> tenv_store -> bool
let type_s ctMap envS tenvS =
  forall l.
    ((exists st. Map.lookup l tenvS = Just st) = (exists v. store_lookup l envS = Just v)) &&
    (forall st sv. ((Map.lookup l tenvS = Just st) && (store_lookup l envS = Just sv)) -->
       type_sv ctMap tenvS sv st)

(* The global constructor type environment has the primitive exceptions in it *)
val ctMap_has_exns : ctMap -> bool
let ctMap_has_exns ctMap =
  (Map.lookup ("Bind", TypeExn (Short "Bind")) ctMap = Just ([],[])) &&
  (Map.lookup ("Chr", TypeExn (Short "Chr")) ctMap = Just ([],[])) &&
  (Map.lookup ("Div", TypeExn (Short "Div")) ctMap = Just ([],[])) &&
  (Map.lookup ("Subscript", TypeExn (Short "Subscript")) ctMap = Just ([],[]))

(* The global constructor type environment has the list primitives in it *)
val ctMap_has_lists : ctMap -> bool
let ctMap_has_lists ctMap =
  (Map.lookup ("nil", TypeId (Short "list")) ctMap = Just (["'a"],[])) &&
  (Map.lookup ("::", TypeId (Short "list")) ctMap =
   Just (["'a"],[Tvar "'a"; Tapp [Tvar "'a"] (TC_name (Short "list"))])) &&
  (forall cn. cn <> "::" && cn <> "nil" --> Map.lookup (cn, TypeId (Short "list")) ctMap = Nothing)

(* The global constructor type environment has the bool primitives in it *)
val ctMap_has_bools : ctMap -> bool
let ctMap_has_bools ctMap =
  (Map.lookup ("true", TypeId (Short "bool")) ctMap = Just ([],[])) &&
  (Map.lookup ("false", TypeId (Short "bool")) ctMap = Just ([],[])) &&
  (forall cn. cn <> "true" && cn <> "false" --> Map.lookup (cn, TypeId (Short "bool")) ctMap = Nothing)

val good_ctMap : ctMap -> bool
let good_ctMap ctMap =
  ctMap_ok ctMap &&
  ctMap_has_bools ctMap &&
  ctMap_has_exns ctMap &&
  ctMap_has_lists ctMap

(* The types and exceptions that are missing are all declared in modules. *)
val weak_decls_only_mods : decls -> decls -> bool
let  weak_decls_only_mods d1 d2 =
    (forall tn.
       (Short tn IN d1.defined_types --> Short tn IN d2.defined_types)) &&
    (forall cn.
       (Short cn IN d1.defined_exns --> Short cn IN d2.defined_exns))

(* The run-time declared constructors and exceptions are all either declared in
 * the type system, or from modules that have been declared *)

val consistent_decls : set tid_or_exn -> decls -> bool
let consistent_decls tes d =
  forall (te IN tes).
    match te with
    | TypeExn cid -> cid IN d.defined_exns || exists mn cn. cid = Long mn (Short cn) && [mn] IN d.defined_mods
    | TypeId tid -> tid IN d.defined_types || exists mn tn. tid = Long mn (Short tn) && [mn] IN d.defined_mods
    end

val consistent_ctMap : decls -> ctMap -> bool
let consistent_ctMap d ctMap =
  forall ((cn,tid) IN Map.domain ctMap).
    match tid with
      | TypeId tn -> tn IN d.defined_types
      | TypeExn cn -> cn IN d.defined_exns
    end

val decls_ok : decls -> bool
let decls_ok d = decls_to_mods d subset d.defined_mods

val type_all_env : ctMap -> tenv_store -> sem_env v -> type_env -> bool
let type_all_env ctMap tenvS env tenv =
  eAll2 (type_ctor ctMap) (cof env) tenv.c &&
  eAll2 (fun _ v (tvs,t) -> type_v tvs ctMap tenvS v t) (vof env) tenv.v
