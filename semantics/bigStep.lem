open Lib
open Ast 
open SemanticPrimitives

(* To get the definition of expression divergence to use in defining definition
 * divergence *)
open SmallStep

(* ------------------------ Big step semantics -------------------------- *)

(* If the first argument is true, the big step semantics counts down how many
   functions applications have happened, and raises an exception when the counter
   runs out. *)

type count_store = num * store

val evaluate : bool -> envM -> envC -> count_store -> envE -> exp -> count_store * result v -> bool
val evaluate_list : bool -> envM -> envC -> count_store -> envE -> list exp -> count_store * result (list v) -> bool
val evaluate_match : bool -> envM -> envC -> count_store -> envE -> v -> list (pat * exp) -> count_store * result v -> bool
val evaluate_dec : option modN -> envM -> envC -> store -> envE -> dec -> store * result (envC * envE) -> bool
val evaluate_decs : option modN -> envM -> envC -> store -> envE -> list dec -> store * result (envC * envE) -> bool
val evaluate_top : envM -> envC -> store -> envE -> top -> store * result (envM * envC * envE) -> bool
val evaluate_prog : envM -> envC -> store -> envE -> prog -> store * result (envM * envC * envE) -> bool

val dec_count : op -> num -> num
let dec_count op count = 
  if op = Opapp then
    count - 1
  else
    count

indreln

forall ck menv cenv env l s.
true
==>
evaluate ck menv cenv s env (Lit l) (s, Rval (Litv l))

and

forall ck menv cenv env err s.
true
==>
evaluate ck menv cenv s env (Raise err) (s, Rerr (Rraise err))

and

forall ck menv cenv s1 s2 env e1 e2 v var.
evaluate ck menv cenv s1 env e1 (s2, Rval v)
==>
evaluate ck menv cenv s1 env (Handle e1 var e2) (s2, Rval v)

and

forall ck menv cenv s1 s2 env e1 e2 n var bv.
evaluate ck menv cenv s1 env e1 (s2, Rerr (Rraise (Int_error n))) &&
evaluate ck menv cenv s2 (bind var (Litv (IntLit n)) env) e2 bv
==>
evaluate ck menv cenv s1 env (Handle e1 var e2) bv

and

forall ck menv cenv s1 s2 env e1 e2 var err.
evaluate ck menv cenv s1 env e1 (s2, Rerr err) &&
(err = Rtimeout_error || err = Rtype_error || err = Rraise Bind_error || err = Rraise Div_error)
==>
evaluate ck menv cenv s1 env (Handle e1 var e2) (s2, Rerr err)

and

forall ck menv cenv env cn es vs s s'.
do_con_check cenv cn (List.length es) &&
evaluate_list ck menv cenv s env es (s', Rval vs)
==>
evaluate ck menv cenv s env (Con cn es) (s', Rval (Conv cn vs))

and

forall ck menv cenv env cn es s.
not (do_con_check cenv cn (List.length es))
==>
evaluate ck menv cenv s env (Con cn es) (s, Rerr Rtype_error)

and

forall ck menv cenv env cn es err s s'.
do_con_check cenv cn (List.length es) &&
evaluate_list ck menv cenv s env es (s', Rerr err)
==>
evaluate ck menv cenv s env (Con cn es) (s', Rerr err)

and

forall ck menv cenv env n v s.
(lookup_var_id n menv env = Some v)
==>
evaluate ck menv cenv s env (Var n) (s, Rval v)

and

forall ck menv cenv env n s.
(lookup_var_id n menv env = None)
==>
evaluate ck menv cenv s env (Var n) (s, Rerr Rtype_error)

and

forall ck menv cenv env n e s.
true
==>
evaluate ck menv cenv s env (Fun n e) (s, Rval (Closure env n e))

and

forall ck menv cenv env uop e v v' s1 s2 count s3.
evaluate ck menv cenv s1 env e ((count,s2), Rval v) &&
do_uapp s2 uop v = Some (s3,v')
==>
evaluate ck menv cenv s1 env (Uapp uop e) ((count,s3), Rval v')

and

forall ck menv cenv env uop e v s1 s2 count.
evaluate ck menv cenv s1 env e ((count,s2), Rval v) &&
do_uapp s2 uop v = None
==>
evaluate ck menv cenv s1 env (Uapp uop e) ((count,s2), Rerr Rtype_error)

and

forall ck menv cenv env uop e err s s'.
evaluate ck menv cenv s env e (s', Rerr err)
==>
evaluate ck menv cenv s env (Uapp uop e) (s', Rerr err)

and

forall ck menv cenv env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 count s4.
evaluate ck menv cenv s1 env e1 (s2, Rval v1) &&
evaluate ck menv cenv s2 env e2 ((count,s3), Rval v2) &&
do_app s3 env op v1 v2 = Some (s4, env', e3) &&
(ck && op = Opapp --> count <> 0) &&
evaluate ck menv cenv ((if ck then dec_count op count else count),s4) env' e3 bv
==>
evaluate ck menv cenv s1 env (App op e1 e2) bv

and

forall ck menv cenv env op e1 e2 v1 v2 env' e3 s1 s2 s3 count s4.
evaluate ck menv cenv s1 env e1 (s2, Rval v1) &&
evaluate ck menv cenv s2 env e2 ((count,s3), Rval v2) &&
do_app s3 env op v1 v2 = Some (s4, env', e3) &&
count = 0 &&
op = Opapp &&
ck
==>
evaluate ck menv cenv s1 env (App op e1 e2) ((0,s4), Rerr Rtimeout_error)

and

forall ck menv cenv env op e1 e2 v1 v2 s1 s2 s3 count.
evaluate ck menv cenv s1 env e1 (s2, Rval v1) &&
evaluate ck menv cenv s2 env e2 ((count,s3), Rval v2) &&
do_app s3 env op v1 v2 = None
==>
evaluate ck menv cenv s1 env (App op e1 e2) ((count,s3), Rerr Rtype_error)

and

forall ck menv cenv env op e1 e2 v1 err s1 s2 s3.
evaluate ck menv cenv s1 env e1 (s2, Rval v1) &&
evaluate ck menv cenv s2 env e2 (s3, Rerr err)
==>
evaluate ck menv cenv s1 env (App op e1 e2) (s3, Rerr err)

and

forall ck menv cenv env op e1 e2 err s s'.
evaluate ck menv cenv s env e1 (s', Rerr err)
==>
evaluate ck menv cenv s env (App op e1 e2) (s', Rerr err)

and

forall ck menv cenv env op e1 e2 v e' bv s1 s2.
evaluate ck menv cenv s1 env e1 (s2, Rval v) &&
do_log op v e2 = Some e' &&
evaluate ck menv cenv s2 env e' bv
==>
evaluate ck menv cenv s1 env (Log op e1 e2) bv

and

forall ck menv cenv env op e1 e2 v s1 s2.
evaluate ck menv cenv s1 env e1 (s2, Rval v) &&
do_log op v e2 = None
==>
evaluate ck menv cenv s1 env (Log op e1 e2) (s2, Rerr Rtype_error)

and

forall ck menv cenv env op e1 e2 err s s'.
evaluate ck menv cenv s env e1 (s', Rerr err)
==>
evaluate ck menv cenv s env (Log op e1 e2) (s', Rerr err)

and

forall ck menv cenv env e1 e2 e3 v e' bv s1 s2.
evaluate ck menv cenv s1 env e1 (s2, Rval v) &&
do_if v e2 e3 = Some e' &&
evaluate ck menv cenv s2 env e' bv
==>
evaluate ck menv cenv s1 env (If e1 e2 e3) bv

and

forall ck menv cenv env e1 e2 e3 v s1 s2.
evaluate ck menv cenv s1 env e1 (s2, Rval v) &&
do_if v e2 e3 = None
==>
evaluate ck menv cenv s1 env (If e1 e2 e3) (s2, Rerr Rtype_error)

and

forall ck menv cenv env e1 e2 e3 err s s'.
evaluate ck menv cenv s env e1 (s', Rerr err)
==>
evaluate ck menv cenv s env (If e1 e2 e3) (s', Rerr err)

and

forall ck menv cenv env e pes v bv s1 s2.
evaluate ck menv cenv s1 env e (s2, Rval v) &&
evaluate_match ck menv cenv s2 env v pes bv
==>
evaluate ck menv cenv s1 env (Mat e pes) bv

and

forall ck menv cenv env e pes err s s'.
evaluate ck menv cenv s env e (s', Rerr err)
==>
evaluate ck menv cenv s env (Mat e pes) (s', Rerr err)

and

forall ck menv cenv env n e1 e2 v bv s1 s2.
evaluate ck menv cenv s1 env e1 (s2, Rval v) &&
evaluate ck menv cenv s2 (bind n v env) e2 bv
==>
evaluate ck menv cenv s1 env (Let n e1 e2) bv

and

forall ck menv cenv env n e1 e2 err s s'.
evaluate ck menv cenv s env e1 (s', Rerr err)
==>
evaluate ck menv cenv s env (Let n e1 e2) (s', Rerr err)

and

forall ck menv cenv env funs e bv s.
all_distinct (List.map (fun (x,y,z) -> x) funs) &&
evaluate ck menv cenv s (build_rec_env funs env env) e bv
==>
evaluate ck menv cenv s env (Letrec funs e) bv

and

forall ck menv cenv env funs e s.
not (all_distinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate ck menv cenv s env (Letrec funs e) (s, Rerr Rtype_error)

and

forall ck menv cenv env s.
true
==>
evaluate_list ck menv cenv s env [] (s, Rval [])

and

forall ck menv cenv env e es v vs s1 s2 s3.
evaluate ck menv cenv s1 env e (s2, Rval v) &&
evaluate_list ck menv cenv s2 env es (s3, Rval vs)
==>
evaluate_list ck menv cenv s1 env (e::es) (s3, Rval (v::vs))

and

forall ck menv cenv env e es err s s'.
evaluate ck menv cenv s env e (s', Rerr err)
==>
evaluate_list ck menv cenv s env (e::es) (s', Rerr err)

and

forall ck menv cenv env e es v err s1 s2 s3.
evaluate ck menv cenv s1 env e (s2, Rval v) &&
evaluate_list ck menv cenv s2 env es (s3, Rerr err)
==>
evaluate_list ck menv cenv s1 env (e::es) (s3, Rerr err)

and

forall ck menv cenv env v s.
true
==>
evaluate_match ck menv cenv s env v [] (s, Rerr (Rraise Bind_error))

and

forall ck menv cenv env v p e pes env' bv s count.
all_distinct (pat_bindings p []) &&
(pmatch cenv s p v env = Match env') &&
evaluate ck menv cenv (count,s) env' e bv
==>
evaluate_match ck menv cenv (count,s) env v ((p,e)::pes) bv

and

forall ck menv cenv env v p e pes bv s count.
all_distinct (pat_bindings p []) &&
(pmatch cenv s p v env = No_match) &&
evaluate_match ck menv cenv (count,s) env v pes bv
==>
evaluate_match ck menv cenv (count,s) env v ((p,e)::pes) bv

and

forall ck menv cenv env v p e pes s count.
(pmatch cenv s p v env = Match_type_error)
==>
evaluate_match ck menv cenv (count,s) env v ((p,e)::pes) ((count,s), Rerr Rtype_error)

and

forall ck menv cenv env v p e pes s.
not (all_distinct (pat_bindings p []))
==>
evaluate_match ck menv cenv s env v ((p,e)::pes) (s, Rerr Rtype_error)


indreln

forall mn menv cenv env p e v env' s1 s2 count.
evaluate false menv cenv (0,s1) env e ((count,s2), Rval v) &&
all_distinct (pat_bindings p []) &&
(pmatch cenv s2 p v emp = Match env')
==>
evaluate_dec mn menv cenv s1 env (Dlet p e) (s2, Rval (emp, env'))

and

forall mn menv cenv env p e v s1 s2 count.
evaluate false menv cenv (0,s1) env e ((count,s2), Rval v) &&
all_distinct (pat_bindings p []) &&
(pmatch cenv s2 p v emp = No_match)
==>
evaluate_dec mn menv cenv s1 env (Dlet p e) (s2, Rerr (Rraise Bind_error))

and

forall mn menv cenv env p e v s1 s2 count.
evaluate false menv cenv (0,s1) env e ((count,s2), Rval v) &&
all_distinct (pat_bindings p []) &&
(pmatch cenv s2 p v emp = Match_type_error)
==>
evaluate_dec mn menv cenv s1 env (Dlet p e) (s2, Rerr Rtype_error)

and

forall mn menv cenv env p e s.
not (all_distinct (pat_bindings p []))
==>
evaluate_dec mn menv cenv s env (Dlet p e) (s, Rerr Rtype_error)

and

forall mn menv cenv env p e err s count s'.
evaluate false menv cenv (0,s) env e ((count,s'), Rerr err) &&
all_distinct (pat_bindings p [])
==>
evaluate_dec mn menv cenv s env (Dlet p e) (s', Rerr err)

and

forall mn menv cenv env funs s.
all_distinct (List.map (fun (x,y,z) -> x) funs)
==>
evaluate_dec mn menv cenv s env (Dletrec funs) (s, Rval (emp, build_rec_env funs env emp))

and

forall mn menv cenv env funs s.
not (all_distinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate_dec mn menv cenv s env (Dletrec funs) (s, Rerr Rtype_error)

and

forall mn menv cenv env tds s.
check_dup_ctors mn cenv tds
==>
evaluate_dec mn menv cenv s env (Dtype tds) (s, Rval (build_tdefs mn tds, emp))

and

forall mn menv cenv env tds s.
not (check_dup_ctors mn cenv tds)
==>
evaluate_dec mn menv cenv s env (Dtype tds) (s, Rerr Rtype_error)

indreln

forall mn menv cenv s env.
true
==>
evaluate_decs mn menv cenv s env [] (s, Rval (emp, emp))

and

forall mn menv cenv s1 s2 env d ds e.
evaluate_dec mn menv cenv s1 env d (s2, Rerr e)
==>
evaluate_decs mn menv cenv s1 env (d::ds) (s2, Rerr e)

and

forall mn menv cenv s1 s2 s3 env d ds new_tds new_env r.
evaluate_dec mn menv cenv s1 env d (s2, Rval (new_tds,new_env)) &&
evaluate_decs mn menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, r)
==>
evaluate_decs mn menv cenv s1 env (d::ds) (s3, combine_dec_result new_tds new_env r)

indreln

forall menv cenv s1 s2 env d new_tds new_env.
evaluate_dec None menv cenv s1 env d (s2, Rval (new_tds, new_env))
==>
evaluate_top menv cenv s1 env (Tdec d) (s2, Rval (emp, new_tds, new_env))

and

forall menv cenv s1 s2 env d err.
evaluate_dec None menv cenv s1 env d (s2, Rerr err)
==>
evaluate_top menv cenv s1 env (Tdec d) (s2, Rerr err)

and

forall menv cenv s1 s2 env ds mn specs new_tds new_env. 
not (List.mem mn (List.map fst menv)) &&
evaluate_decs (Some mn) menv cenv s1 env ds (s2, Rval (new_tds, new_env))
==>
evaluate_top menv cenv s1 env (Tmod mn specs ds) (s2, Rval ([(mn,new_env)], new_tds, emp))

and

forall menv cenv s1 s2 env ds mn specs err. 
not (List.mem mn (List.map fst menv)) &&
evaluate_decs (Some mn) menv cenv s1 env ds (s2, Rerr err)
==>
evaluate_top menv cenv s1 env (Tmod mn specs ds) (s2, Rerr err)

and

forall menv cenv s env mn specs ds.
List.mem mn (List.map fst menv)
==>
evaluate_top menv cenv s env (Tmod mn specs ds) (s, Rerr Rtype_error)

indreln

forall menv cenv s env.
true
==>
evaluate_prog menv cenv s env [] (s, Rval (emp, emp, emp))

and

forall menv cenv s1 s2 s3 env top tops new_mods new_tds new_env r.
evaluate_top menv cenv s1 env top (s2, Rval (new_mods,new_tds,new_env)) &&
evaluate_prog (merge new_mods menv) (merge new_tds cenv) s2 (merge new_env env) tops (s3, r)
==>
evaluate_prog menv cenv s1 env (top::tops) (s3, combine_mod_result new_mods new_tds new_env r)

and

forall menv cenv s1 s2 env top tops err.
evaluate_top menv cenv s1 env top (s2, Rerr err)
==>
evaluate_prog menv cenv s1 env (top::tops) (s2, Rerr err)

val dec_diverges : envM -> envC -> store -> envE -> dec -> bool
val decs_diverges : option modN -> envM -> envC -> store -> envE -> decs -> bool
val top_diverges : envM -> envC -> store -> envE -> top -> bool
val prog_diverges : envM -> envC -> store -> envE -> prog -> bool

let dec_diverges menv cenv st env d =
  match d with
    | Dlet p e -> all_distinct (pat_bindings p []) && e_diverges menv cenv st env e
    | Dletrec funs -> false
    | Dtype tds -> false
  end

indreln

forall mn menv cenv st env d ds.
dec_diverges menv cenv st env d
==>
decs_diverges mn menv cenv st env (d::ds) 

and

forall mn menv cenv s1 s2 env d ds new_tds new_env.
evaluate_dec mn menv cenv s1 env d (s2, Rval (new_tds, new_env)) &&
decs_diverges mn menv (merge new_tds cenv) s2 (merge new_env env) ds
==>
decs_diverges mn menv cenv s1 env (d::ds)

indreln

forall menv cenv st env d.
dec_diverges menv cenv st env d
==>
top_diverges menv cenv st env (Tdec d)

and

forall menv cenv s1 env ds mn specs.
not (List.mem mn (List.map fst menv)) &&
decs_diverges (Some mn) menv cenv s1 env ds
==>
top_diverges menv cenv s1 env (Tmod mn specs ds)

indreln

forall menv cenv st env top tops.
top_diverges menv cenv st env top
==>
prog_diverges menv cenv st env (top::tops)

and

forall menv cenv s1 s2 env top tops new_mods new_tds new_env.
evaluate_top menv cenv s1 env top (s2, Rval (new_mods, new_tds, new_env)) &&
prog_diverges (merge new_mods menv) (merge new_tds cenv) s2 (merge new_env env) tops
==>
prog_diverges menv cenv s1 env (top::tops)
