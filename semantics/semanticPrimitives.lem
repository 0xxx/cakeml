open import Pervasives
import List_extra
open import Lib
open import Ast

(* The type that a constructor builds is either a named datatype or an exception.
 * For exceptions, we also keep the module that the exception was declared in. *)
type tid_or_exn = 
  | TypeId of id typeN
  | TypeExn of maybe modN

(* Maps each constructor to its arity and which type it is from *)
type envC = env (id conN) (nat * tid_or_exn)

(* Value forms *)
type v =
  | Litv of lit
  (* Constructor application. *)
  | Conv of maybe (conN * tid_or_exn) * list v 
  (* Function closures
     The environment is used for the free variables in the function *)
  | Closure of (env modN (env varN v) * envC * env varN v) * varN * exp
  (* Function closure for recursive functions
   * See Closure and Letrec above
   * The last variable name indicates which function from the mutually
   * recursive bundle this closure value represents *)
  | Recclosure of (env modN (env varN v) * envC * env varN v) * list (varN * varN * exp) * varN
  | Loc of nat

type envE = env varN v

(* The bindings of a module *)
type envM = env modN envE

type all_env = envM * envC * envE

let all_env_to_menv (menv,cenv,env) = menv
let all_env_to_cenv (menv,cenv,env) = cenv
let all_env_to_env (menv,cenv,env) = env

(* The result of evaluation *)
type error_result 'a =
  | Rtype_error
  | Rraise of 'a (* Should only be a value of type exn *)
  | Rtimeout_error

type result 'a 'b =
  | Rval of 'a
  | Rerr of error_result 'b

(* Stores *)
(* The nth item in the list is the value at location n *)
type store 'a = list 'a

val empty_store : forall 'a. store 'a
let empty_store = []

val store_lookup : forall 'a. nat -> store 'a -> maybe 'a
let store_lookup l st =
  if l < List.length st then
    Just (List_extra.nth st l)
  else
    Nothing

val store_alloc : forall 'a. 'a -> store 'a -> store 'a * nat
let store_alloc v st =
  ((st ++ [v]), List.length st)

val store_assign : forall 'a. nat -> 'a -> store 'a -> maybe (store 'a)
let store_assign n v st =
  if n < List.length st then
    Just (List.update st n v)
  else
    Nothing

val lookup_var_id : id varN -> all_env -> maybe v
let lookup_var_id id (menv,cenv,env) =
  match id with
    | Short x -> lookup x env
    | Long x y ->
        match lookup x menv with
          | Nothing -> Nothing
          | Just env -> lookup y env
        end
  end

(* Other primitives *)
(* Check that a constructor is properly applied *)
val do_con_check : envC -> maybe (id conN) -> nat -> bool
let do_con_check cenv n_opt l =
  match n_opt with
    | Nothing -> true
    | Just n ->
        match lookup n cenv with
          | Nothing -> false
          | Just (l',ns) -> l = l'
        end
  end

val build_conv : envC -> maybe (id conN) -> list v -> maybe v
let build_conv envC cn vs =
  match cn with
    | Nothing -> 
        Just (Conv Nothing vs)
    | Just id -> 
        match lookup id envC with
          | Nothing -> Nothing
          | Just (len,t) -> Just (Conv (Just (id_to_n id, t)) vs)
        end
  end

val lit_same_type : lit -> lit -> bool
let lit_same_type l1 l2 =
  match (l1,l2) with
    | (IntLit _, IntLit _) -> true
    | (Bool _, Bool _) -> true
    | (Unit, Unit) -> true
    | _ -> false
  end

type match_result 'a =
  | No_match
  | Match_type_error
  | Match of 'a

val same_tid : tid_or_exn -> tid_or_exn -> bool
let rec same_tid (TypeId tn1) (TypeId tn2) = tn1 = tn2
and same_tid (TypeExn _) (TypeExn _) = true
and same_tid _ _ = false

val same_ctor : conN * tid_or_exn -> conN * tid_or_exn -> bool
let rec same_ctor (cn1, TypeExn mn1) (cn2, TypeExn mn2) = cn1 = cn2 && mn1 = mn2
and same_ctor (cn1, _) (cn2, _) = cn1 = cn2

(* A big-step pattern matcher.  If the value matches the pattern, return an
 * environment with the pattern variables bound to the corresponding sub-terms
 * of the value; this environment extends the environment given as an argument.
 * No_match is returned when there is no match, but any constructors
 * encountered in determining the match failure are applied to the correct
 * number of arguments, and constructors in corresponding positions in the
 * pattern and value come from the same type.  Match_type_error is returned
 * when one of these conditions is violated *)
val pmatch : envC -> store v -> pat -> v -> envE -> match_result envE
let rec
pmatch envC s (Pvar x) v' env = Match (bind x v' env)
and
pmatch envC s (Plit l) (Litv l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error
and
pmatch envC s (Pcon (Just n) ps) (Conv (Just (n', t')) vs) env =
  match lookup n envC with
    | Just (l, t)->
        if same_tid t t' && List.length ps = l then
          if same_ctor (id_to_n n, t) (n',t') then
            pmatch_list envC s ps vs env
          else
            No_match
        else
          Match_type_error
    | _ -> Match_type_error
  end
and
pmatch envC s (Pcon Nothing ps) (Conv Nothing vs) env =
  if List.length ps = List.length vs then
    pmatch_list envC s ps vs env
  else
    Match_type_error
and
pmatch envC s (Pref p) (Loc lnum) env =
  match store_lookup lnum s with
    | Just v -> pmatch envC s p v env
    | Nothing -> Match_type_error
  end
and
pmatch envC _ _ _ env = Match_type_error
and
pmatch_list envC s [] [] env = Match env
and
pmatch_list envC s (p::ps) (v::vs) env =
  match pmatch envC s p v env with
    | No_match -> No_match
    | Match_type_error -> Match_type_error
    | Match env' -> pmatch_list envC s ps vs env'
  end
and
pmatch_list envC s _ _ env = Match_type_error

(* Bind each function of a mutually recursive set of functions to its closure *)
val build_rec_env : list (varN * varN * exp) -> all_env -> envE -> envE
let build_rec_env funs cl_env add_to_env =
  foldr 
    (fun (f,x,e) env' -> bind f (Recclosure cl_env funs f) env') 
    add_to_env 
    funs

(* Lookup in the list of mutually recursive functions *)
val find_recfun : forall 'a 'b. varN -> list (varN * 'a * 'b) -> maybe ('a * 'b)
let rec find_recfun n funs =
  match funs with
    | [] -> Nothing
    | (f,x,e) :: funs ->
        if f = n then
          Just (x,e)
        else
          find_recfun n funs
  end

declare termination_argument find_recfun = automatic

(* Check whether a value contains a closure, but don't indirect through the store *)
val contains_closure : v -> bool
let rec
contains_closure (Litv l) = false
and
contains_closure (Conv cn vs) = List.any contains_closure vs
and
contains_closure (Closure env n e) = true
and
contains_closure (Recclosure env funs n) = true
and
contains_closure (Loc n) = false

val do_uapp : store v -> uop -> v -> maybe (store v * v)
let do_uapp s uop v =
  match uop with
    | Opderef ->
        match v with
          | Loc n ->
              match store_lookup n s with
                | Just v -> Just (s,v)
                | Nothing -> Nothing
              end
          | _ -> Nothing
        end
    | Opref ->
        let (s',n) = store_alloc v s in
          Just (s', Loc n)
  end

type eq_result = 
  | Eq_val of bool
  | Eq_closure
  | Eq_type_error

val do_eq : v -> v -> eq_result
let rec 
do_eq (Litv l1) (Litv l2) = 
  Eq_val (l1 = l2)
and
do_eq (Loc l1) (Loc l2) = Eq_val (l1 = l2)
and
do_eq (Conv cn1 vs1) (Conv cn2 vs2) =
  if cn1 = cn2 && (List.length vs1 = List.length vs2) then
    do_eq_list vs1 vs2
  else
    Eq_val false
and
do_eq (Closure _ _ _) (Closure _ _ _) = Eq_closure
and
do_eq (Closure _ _ _) (Recclosure _ _ _) = Eq_closure
and
do_eq (Recclosure _ _ _) (Closure _ _ _) = Eq_closure
and
do_eq (Recclosure _ _ _) (Recclosure _ _ _) = Eq_closure
and
do_eq _ _ = Eq_type_error
and
do_eq_list [] [] = Eq_val true
and
do_eq_list (v1::vs1) (v2::vs2) = 
  match do_eq v1 v2 with
    | Eq_closure -> Eq_closure
    | Eq_type_error -> Eq_type_error
    | Eq_val r -> 
        if not r then
          Eq_val false
        else
          do_eq_list vs1 vs2
  end
and
do_eq_list _ _ = Eq_val false

val exn_env : all_env
let exn_env = (emp, List.map (fun cn -> (Short cn, (0, TypeExn Nothing))) ["Bind"; "Div"; "Eq"], emp)
                   
(* Do an application *)
val do_app : all_env -> store v -> op -> v -> v -> maybe (all_env * store v * exp)
let do_app env' s op v1 v2 =
  match (op, v1, v2) with
    | (Opapp, Closure (menv, cenv, env) n e, v) ->
        Just ((menv, cenv, bind n v env), s, e)
    | (Opapp, Recclosure (menv, cenv, env) funs n, v) ->
        match find_recfun n funs with
          | Just (n,e) -> Just ((menv, cenv, bind n v (build_rec_env funs (menv, cenv, env) env)), s, e)
          | Nothing -> Nothing
        end
    | (Opn op, Litv (IntLit n1), Litv (IntLit n2)) ->
        if (op = Divide || (op = Modulo)) && (n2 = 0) then
          Just (exn_env, s, Raise (Con (Just (Short "Div")) []))
        else
          Just (env', s, Lit (IntLit (opn_lookup op n1 n2)))
    | (Opb op, Litv (IntLit n1), Litv (IntLit n2)) ->
        Just (env', s, Lit (Bool (opb_lookup op n1 n2)))
    | (Equality, v1, v2) ->
        match do_eq v1 v2 with
          | Eq_type_error -> Nothing
          | Eq_closure -> Just (exn_env, s, Raise (Con (Just (Short "Eq")) []))
          | Eq_val b -> Just (env', s, Lit (Bool b))
        end
    | (Opassign, (Loc lnum), v) ->
        match store_assign lnum v s with
        | Just st -> Just (env', st, Lit Unit)
        | Nothing -> Nothing
        end
    | _ -> Nothing
  end

(* Do a logical operation *)
val do_log : lop -> v -> exp -> maybe exp
let do_log l v e =
  match (l, v) with
    | (And, Litv (Bool true)) -> Just e
    | (Or, Litv (Bool false)) -> Just e
    | (_, Litv (Bool b)) -> Just (Lit (Bool b))
    | _ -> Nothing
  end

(* Do an if-then-else *)
val do_if : v -> exp -> exp -> maybe exp
let do_if v e1 e2 =
  if v = Litv (Bool true) then
    Just e1
  else if v = Litv (Bool false) then
    Just e2
  else
    Nothing

(* Semantic helpers for definitions *)

(* Add the given type definition to the given constructor environment *)
val build_tdefs : maybe modN -> list (list tvarN * typeN * list (conN * list t)) -> envC
let build_tdefs mn tds =
  concat
    (List.map
      (fun (tvs, tn, condefs) ->
         List.map
           (fun (conN, ts) ->
              (Short conN, (List.length ts, TypeId (mk_id mn tn))))
           condefs)
      tds)

(* Checks that no constructor is defined twice in a type *)
val check_dup_ctors : list (list tvarN * typeN * list (conN * list t)) -> bool
let check_dup_ctors tds =
  all_distinct [ n | forall ((tvs, tn, condefs) MEM tds) ((n, ts) MEM condefs) | true ]

val combine_dec_result : forall 'a 'b 'c. env 'a 'b -> result (env 'a 'b) 'c -> result (env 'a 'b) 'c
let combine_dec_result env r =
  match r with
    | Rerr e -> Rerr e
    | Rval env' -> Rval (merge env' env)
  end

val combine_mod_result : forall 'a 'b 'c 'd 'e. env 'a 'b -> env 'c 'd -> result (env 'a 'b * env 'c 'd) 'e -> result (env 'a 'b * env 'c 'd) 'e
let combine_mod_result menv env r =
  match r with
    | Rerr e -> Rerr e
    | Rval (menv',env') -> Rval (merge menv' menv, merge env' env)
  end

val add_mod_prefix : forall 'a 'b. modN -> env (id 'a) 'b -> env (id 'a) 'b
let rec add_mod_prefix mn [] = []
and
add_mod_prefix mn ((Short x, v)::env) = (Long mn x, v) :: add_mod_prefix mn env
and
add_mod_prefix mn ((Long mn' x, v)::env) = (Long mn' x, v) :: add_mod_prefix mn env

declare termination_argument add_mod_prefix = automatic

(* Constructor environment implied by declarations *)

let rec
dec_to_cenv mn (Dtype tds) = build_tdefs mn tds
and
dec_to_cenv mn (Dexn cn ts) = bind (mk_id mn cn) (List.length ts,TypeExn mn) emp
and
dec_to_cenv mn _ = []

let rec
decs_to_cenv mn [] = []
and
decs_to_cenv mn (d::ds) = decs_to_cenv mn ds ++ dec_to_cenv mn d

declare termination_argument decs_to_cenv = automatic

let rec
top_to_cenv (Tdec d) = dec_to_cenv Nothing d
and
top_to_cenv (Tmod mn _ ds) = decs_to_cenv (Just mn) ds

(* conversions to strings *)

let rec
id_to_string (Short s) = s
and
id_to_string (Long x y) = x^"."^y

let int_to_string z =
  if z < 0 then "~"^(num_to_string (int_to_num (~ z)))
  else num_to_string (int_to_num z)
