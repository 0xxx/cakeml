(*Generated by Lem from funBigStep.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extraTheory libTheory astTheory ffiTheory semanticPrimitivesTheory;

val _ = numLib.prefer_num();



val _ = new_theory "funBigStep"

(*open import Pervasives_extra*)
(*open import Lib*)
(*open import Ast*)
(*open import SemanticPrimitives*)
(*open import Ffi*)

val _ = Hol_datatype `
 state =
  <| clock : num
   ; refs  : v store
   ; io    : io_trace
   |>`;


(* The semantics is defined here using check_clock so that HOL4 generates
 * provable termination conditions. However, after termination is proved, we
 * clean up the definition (in HOL4) to remove occurrences of check_clock. *)

val _ = Define `
 (check_clock s' s =  
(( s' with<| clock := if s'.clock <= s.clock
                     then s'.clock else s.clock |>)))`;


val _ = Define `
 (dec_clock s = (( s with<| clock := s.clock -  1 |>)))`;


(* list_result is equivalent to map_result (\v. [v]) I, where map_result is
 * defined in evalPropsTheory *)
 val _ = Define `

(list_result (Rval v) = (Rval [v]))
/\
(list_result (Rerr e) = (Rerr e))`;


(*val evaluate : list exp * all_env * state -> result (list v) v * state*)
(*val evaluate_match : list (pat * exp) * v * v * all_env * state -> result (list v) v * state*)
 val evaluate_defn = Hol_defn "evaluate" `

(evaluate ([],env,s) = (Rval [],s))
/\
(evaluate (e1::e2::es,env,s) =  
((case evaluate ([e1],env,s) of
    (Rval v1,s') =>
      (case evaluate ((e2::es),env,check_clock s' s) of
        (Rval vs,s) => (Rval (HD v1::vs),s)
      | res => res
      )
  | res => res
  )))
/\
(evaluate ([Lit l],env,s) = (Rval [Litv l],s))
/\
(evaluate ([Raise e],env,s) =  
((case evaluate ([e],env,s) of
    (Rval v,s) => (Rerr (Rraise (HD v)),s)
  | res => res
  )))
/\
(evaluate ([Handle e pes],env,s) =  
((case evaluate ([e],env,s) of
    (Rerr(Rraise v),s') => evaluate_match (pes,v,v,env,check_clock s' s)
  | res => res
  )))
/\
(evaluate ([Con cn es],env,s) =  
(if do_con_check (all_env_to_cenv env) cn (LENGTH es) then
    (case evaluate (REVERSE es,env,s) of
      (Rval vs,s) =>
        (case build_conv (all_env_to_cenv env) cn (REVERSE vs) of
          SOME v => (Rval [v],s)
        | NONE => (Rerr (Rabort Rtype_error),s)
        )
    | res => res
    )
  else (Rerr (Rabort Rtype_error),s)))
/\
(evaluate ([Var n],env,s) =  
((case lookup_var_id n env of
    SOME v => (Rval [v],s)
  | NONE => (Rerr (Rabort Rtype_error),s)
  )))
/\
(evaluate ([Fun x e],env,s) = (Rval [Closure env x e],s))
/\
(evaluate ([App op es],env,s) =  
((case evaluate (REVERSE es,env,s) of
    (Rval vs,s') =>
      if op = Opapp then
        (case do_opapp (REVERSE vs) of
          SOME (env,e) =>
            if (s'.clock = 0) \/ (s.clock = 0) then
              (Rerr (Rabort Rtimeout_error),s')
            else
              evaluate ([e],env,dec_clock (check_clock s' s))
        | NONE => (Rerr (Rabort Rtype_error),s')
        )
      else
        (case do_app (s'.refs,s'.io) op (REVERSE vs) of
          SOME ((refs,io),r) => (list_result r, ( s' with<| refs := refs; io := io |>))
        | NONE => (Rerr (Rabort Rtype_error),s')
        )
  | res => res
  )))
/\
(evaluate ([Log lop e1 e2],env,s) =  
((case evaluate ([e1],env,s) of
    (Rval v1,s') =>
      (case do_log lop (HD v1) e2 of
        SOME (Exp e) => evaluate ([e],env,check_clock s' s)
      | SOME (Val v) => (Rval [v],s')
      | NONE => (Rerr (Rabort Rtype_error),s')
      )
  | res => res
  )))
/\
(evaluate ([If e1 e2 e3],env,s) =  
((case evaluate ([e1],env,s) of
    (Rval v,s') =>
      (case do_if (HD v) e2 e3 of
        SOME e => evaluate ([e],env,check_clock s' s)
      | NONE => (Rerr (Rabort Rtype_error),s')
      )
  | res => res
  )))
/\
(evaluate ([Mat e pes],env,s) =  
((case evaluate ([e],env,s) of
    (Rval v,s') =>
      evaluate_match (pes,HD v,Bindv,env,check_clock s' s)
  | res => res
  )))
/\
(evaluate ([Let xo e1 e2],env,s) =  
((case evaluate ([e1],env,s) of
    (Rval v,s') => evaluate ([e2],all_env_with_env env (opt_bind xo (HD v) (all_env_to_env env)),check_clock s' s)
  | res => res
  )))
/\
(evaluate ([Letrec funs e],env,s) =  
(if ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs) then
    evaluate ([e],all_env_with_env env (build_rec_env funs env (all_env_to_env env)),s)
  else
    (Rerr (Rabort Rtype_error),s)))
/\
(evaluate_match ([],v,err_v,env,s) = (Rerr (Rraise err_v),s))
/\
(evaluate_match ((p,e)::pes,v,err_v,env,s) =  
(if ALL_DISTINCT (pat_bindings p []) then
    (case pmatch (all_env_to_cenv env) s.refs p v (all_env_to_env env) of
      Match env' => evaluate ([e],all_env_with_env env env',s)
    | No_match => evaluate_match (pes,v,err_v,env,s)
    | Match_type_error => (Rerr (Rabort Rtype_error),s)
    )
  else (Rerr (Rabort Rtype_error),s)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn evaluate_defn;

val _ = type_abbrev( "decs_state" , ``: state # tid_or_exn set``);

(*val evaluate_decs : (list dec * maybe modN * all_env * decs_state) -> result envE v * flat_envC * decs_state*)
 val evaluate_decs_defn = Hol_defn "evaluate_decs" `

(evaluate_decs ([],mn,env,s) = (Rval [],[],s))
/\
(evaluate_decs (d1::d2::ds,mn,env,s) =  
((case evaluate_decs ([d1],mn,env,s) of
    (Rval new_env,new_tds,s) =>
      (case
        evaluate_decs ((d2::ds),mn,
          (case env of (menv,cenv,env) =>
            (menv, merge_alist_mod_env ([],new_tds) cenv, (new_env++env))
          ),s)
      of (r,new_tds',s) =>
        (combine_dec_result new_env r, (new_tds'++new_tds), s)
      )
  | res => res
  )))
/\
(evaluate_decs ([Dlet p e],mn,env,(s,tdecs)) =  
(if ALL_DISTINCT (pat_bindings p []) then
    (case evaluate ([e],env,s) of
      (Rval v,s) =>
        ((case pmatch (all_env_to_cenv env) s.refs p (HD v) [] of
           Match env' => Rval env'
         | No_match => Rerr (Rraise Bindv)
         | Match_type_error => Rerr (Rabort Rtype_error)
         ),[],(s,tdecs))
    | (Rerr err,s) => (Rerr err,[],(s,tdecs))
    )
  else
    (Rerr (Rabort Rtype_error),[],(s,tdecs))))
/\
(evaluate_decs ([Dletrec funs],mn,env,s) =
  ((if ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs) then
     Rval (build_rec_env funs env [])
   else
     Rerr (Rabort Rtype_error))
  ,[],s))
/\
(evaluate_decs ([Dtype tds],mn,env,(s,tdecs)) =  
(let new_tdecs = (type_defs_to_new_tdecs mn tds) in
    if check_dup_ctors tds /\
       DISJOINT new_tdecs tdecs /\
       ALL_DISTINCT (MAP (\ (tvs,tn,ctors) .  tn) tds)
    then
      (Rval [],build_tdefs mn tds,(s,(new_tdecs UNION tdecs)))
    else
      (Rerr (Rabort Rtype_error),[],(s,tdecs))))
/\
(evaluate_decs ([Dtabbrev tvs tn t],mn,env,s) =
  (Rval [],[],s))
/\
(evaluate_decs ([Dexn cn ts],mn,env,(s,tdecs)) =  
(if TypeExn (mk_id mn cn) IN tdecs then
    (Rerr (Rabort Rtype_error),[],(s,tdecs))
  else
    (Rval [],[(cn, (LENGTH ts, TypeExn (mk_id mn cn)))],(s,({TypeExn (mk_id mn cn)} UNION tdecs)))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn evaluate_decs_defn;

val _ = type_abbrev( "prog_state" , ``: decs_state # modN set``);

(*val evaluate_tops : list top -> all_env -> prog_state -> result (envM * envE) v * envC * prog_state*)
 val evaluate_tops_defn = Hol_defn "evaluate_tops" `

(evaluate_tops [] env s = (Rval ([],[]), ([],[]), s))
/\
(evaluate_tops (top1::top2::tops) env s =  
((case evaluate_tops [top1] env s of
    (Rval (new_mods,new_env), new_tds, s) =>
      (case evaluate_tops (top2::tops)
              (case env of (menv,cenv,env) =>
                ((new_mods++menv),
                 merge_alist_mod_env new_tds cenv,                 
(new_env++env))
              ) s of
        (r,new_tds',s) => (combine_mod_result new_mods new_env r,
                           merge_alist_mod_env new_tds' new_tds,
                           s)
      )
  | res => res
  )))
/\
(evaluate_tops [Tdec d] env (s,mdecls) =  
((case evaluate_decs ([d],NONE,env,s) of
    (Rval new_env, new_tds, s) =>
      (Rval ([],new_env), ([],new_tds), (s,mdecls))
  | (Rerr err, new_tds, s) =>
      (Rerr err, ([],[]), (s,mdecls))
  )))
/\
(evaluate_tops [Tmod mn specs ds] env (s,mdecls) =  
(if ~ (mn IN mdecls) /\
     no_dup_types ds
  then
    (case evaluate_decs (ds,SOME mn,env,s) of
      (r, new_tds, s) =>
        ((case r of
           Rval new_env => Rval ([(mn,new_env)],[])
         | Rerr err => Rerr err
         ),
         ([(mn,new_tds)],[]),
         (s,({mn} UNION mdecls)))
    )
  else
    (Rerr (Rabort Rtype_error), ([],[]), (s,mdecls))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn evaluate_tops_defn;

val _ = Define `
 (convert_prog_state ((s,tdecls),mdecls) =
  ((s.clock,s.refs,s.io),tdecls,mdecls))`;


(*val evaluate_prog : prog -> all_env -> prog_state -> result (envM * envE) v * envC * prog_state*)
val _ = Define `

(evaluate_prog prog env s =  
(if no_dup_mods prog (convert_prog_state s) /\ no_dup_top_types prog (convert_prog_state s) then
    evaluate_tops prog env s
  else
    (Rerr (Rabort Rtype_error), ([],[]), s)))`;

val _ = export_theory()

