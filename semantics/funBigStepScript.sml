(*Generated by Lem from funBigStep.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extraTheory libTheory astTheory ffiTheory semanticPrimitivesTheory;

val _ = numLib.prefer_num();



val _ = new_theory "funBigStep"

(*open import Pervasives_extra*)
(*open import Lib*)
(*open import Ast*)
(*open import SemanticPrimitives*)
(*open import Ffi*)

val _ = Hol_datatype `
 state =
  <| clock : num
   ; refs  : v store
   ; io    : io_trace
   |>`;


(* The semantics is defined here using check_clock so that HOL4 generates
 * provable termination conditions. However, after termination is proved, we
 * clean up the definition (in HOL4) to remove occurrences of check_clock. *)

val _ = Define `
 (check_clock s' s =  
(( s' with<| clock := if s'.clock <= s.clock
                     then s'.clock else s.clock |>)))`;


val _ = Define `
 (dec_clock s = (( s with<| clock := s.clock -  1 |>)))`;


(* list_result is equivalent to map_result (\v. [v]) I, where map_result is
 * defined in evalPropsTheory *)
 val _ = Define `

(list_result (Rval v) = (Rval [v]))
/\
(list_result (Rerr e) = (Rerr e))`;


(*val evaluate : list exp * all_env * state -> result (list v) v * state*)
(*val evaluate_match : list (pat * exp) * v * v * all_env * state -> result (list v) v * state*)
 val evaluate_defn = Hol_defn "evaluate" `

(evaluate ([],env,s) = (Rval [],s))
/\
(evaluate (e1::e2::es,env,s) =  
((case evaluate ([e1],env,s) of
    (Rval v1,s') =>
      (case evaluate ((e2::es),env,check_clock s' s) of
        (Rval vs,s) => (Rval (HD v1::vs),s)
      | res => res
      )
  | res => res
  )))
/\
(evaluate ([Lit l],env,s) = (Rval [Litv l],s))
/\
(evaluate ([Raise e],env,s) =  
((case evaluate ([e],env,s) of
    (Rval v,s) => (Rerr (Rraise (HD v)),s)
  | res => res
  )))
/\
(evaluate ([Handle e pes],env,s) =  
((case evaluate ([e],env,s) of
    (Rerr(Rraise v),s') => evaluate_match (pes,v,v,env,check_clock s' s)
  | res => res
  )))
/\
(evaluate ([Con cn es],env,s) =  
(if do_con_check (all_env_to_cenv env) cn (LENGTH es) then
    (case evaluate (REVERSE es,env,s) of
      (Rval vs,s) =>
        (case build_conv (all_env_to_cenv env) cn (REVERSE vs) of
          SOME v => (Rval [v],s)
        | NONE => (Rerr (Rabort Rtype_error),s)
        )
    | res => res
    )
  else (Rerr (Rabort Rtype_error),s)))
/\
(evaluate ([Var n],env,s) =  
((case lookup_var_id n env of
    SOME v => (Rval [v],s)
  | NONE => (Rerr (Rabort Rtype_error),s)
  )))
/\
(evaluate ([Fun x e],env,s) = (Rval [Closure env x e],s))
/\
(evaluate ([App op es],env,s) =  
((case evaluate (REVERSE es,env,s) of
    (Rval vs,s') =>
      if op = Opapp then
        (case do_opapp (REVERSE vs) of
          SOME (env,e) =>
            if (s'.clock = 0) \/ (s.clock = 0) then
              (Rerr (Rabort Rtimeout_error),s')
            else
              evaluate ([e],env,dec_clock (check_clock s' s))
        | NONE => (Rerr (Rabort Rtype_error),s')
        )
      else
        (case do_app (s'.refs,s'.io) op (REVERSE vs) of
          SOME ((refs,io),r) => (list_result r, ( s with<| refs := refs; io := io |>))
        | NONE => (Rerr (Rabort Rtype_error),s)
        )
  | res => res
  )))
/\
(evaluate ([Log lop e1 e2],env,s) =  
((case evaluate ([e1],env,s) of
    (Rval v1,s') =>
      (case do_log lop (HD v1) e2 of
        SOME (Exp e) => evaluate ([e],env,check_clock s' s)
      | SOME (Val v) => (Rval [v],s')
      | NONE => (Rerr (Rabort Rtype_error),s')
      )
  | res => res
  )))
/\
(evaluate ([If e1 e2 e3],env,s) =  
((case evaluate ([e1],env,s) of
    (Rval v,s') =>
      (case do_if (HD v) e2 e3 of
        SOME e => evaluate ([e],env,check_clock s' s)
      | NONE => (Rerr (Rabort Rtype_error),s')
      )
  | res => res
  )))
/\
(evaluate ([Mat e pes],env,s) =  
((case evaluate ([e],env,s) of
    (Rval v,s') =>
      evaluate_match (pes,HD v,Conv(SOME("Bind",TypeExn(Short"Bind")))[],env,check_clock s' s)
  | res => res
  )))
/\
(evaluate ([Let xo e1 e2],env,s) =  
((case evaluate ([e1],env,s) of
    (Rval v,s') => evaluate ([e2],all_env_with_env env (opt_bind xo (HD v) (all_env_to_env env)),check_clock s' s)
  | res => res
  )))
/\
(evaluate ([Letrec funs e],env,s) =  
(if ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs) then
    evaluate ([e],all_env_with_env env (build_rec_env funs env (all_env_to_env env)),s)
  else
    (Rerr (Rabort Rtype_error),s)))
/\
(evaluate_match ([],v,err_v,env,s) = (Rerr (Rraise err_v),s))
/\
(evaluate_match ((p,e)::pes,v,err_v,env,s) =  
(if ALL_DISTINCT (pat_bindings p []) then
    (case pmatch (all_env_to_cenv env) s.refs p v (all_env_to_env env) of
      Match env' => evaluate ([e],all_env_with_env env env',s)
    | No_match => evaluate_match (pes,v,err_v,env,s)
    | Match_type_error => (Rerr (Rabort Rtype_error),s)
    )
  else (Rerr (Rabort Rtype_error),s)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn evaluate_defn;
val _ = export_theory()

