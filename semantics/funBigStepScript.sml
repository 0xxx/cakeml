(*Generated by Lem from funBigStep.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extraTheory libTheory astTheory ffiTheory semanticPrimitivesTheory;

val _ = numLib.prefer_num();



val _ = new_theory "funBigStep"

(*open import Pervasives_extra*)
(*open import Lib*)
(*open import Ast*)
(*open import SemanticPrimitives*)
(*open import Ffi*)

val _ = Hol_datatype `
 state =
  <| clock : num
   ; refs  : v store
   ; io    : io_trace
   |>`;


(* The semantics is defined here using check_clock so that HOL4 generates
 * provable termination conditions. However, after termination is proved, we
 * clean up the definition (in HOL4) to remove occurrences of check_clock. *)

val _ = Define `
 (check_clock s' s =  
(( s' with<| clock := if s'.clock <= s.clock
                     then s'.clock else s.clock |>)))`;


val _ = Define `
 (dec_clock s = (( s with<| clock := s.clock -  1 |>)))`;


(* list_result is equivalent to map_result (\v. [v]) I, where map_result is
 * defined in evalPropsTheory *)
 val _ = Define `

(list_result (Rval v) = (Rval [v]))
/\
(list_result (Rerr e) = (Rerr e))`;


(*val evaluate : list exp * all_env * state -> result (list v) v * state*)
(*val evaluate_match : list (pat * exp) * v * v * all_env * state -> result (list v) v * state*)
 val evaluate_defn = Hol_defn "evaluate" `

(evaluate ([],env,s) = (Rval [],s))
/\
(evaluate (e1::e2::es,env,s) =  
((case evaluate ([e1],env,s) of
    (Rval v1,s') =>
      (case evaluate ((e2::es),env,check_clock s' s) of
        (Rval vs,s) => (Rval (HD v1::vs),s)
      | res => res
      )
  | res => res
  )))
/\
(evaluate ([Lit l],env,s) = (Rval [Litv l],s))
/\
(evaluate ([Raise e],env,s) =  
((case evaluate ([e],env,s) of
    (Rval v,s) => (Rerr (Rraise (HD v)),s)
  | res => res
  )))
/\
(evaluate ([Handle e pes],env,s) =  
((case evaluate ([e],env,s) of
    (Rerr(Rraise v),s') => evaluate_match (pes,v,v,env,check_clock s' s)
  | res => res
  )))
/\
(evaluate ([Con cn es],env,s) =  
(if do_con_check (all_env_to_cenv env) cn (LENGTH es) then
    (case evaluate (REVERSE es,env,s) of
      (Rval vs,s) =>
        (case build_conv (all_env_to_cenv env) cn (REVERSE vs) of
          SOME v => (Rval [v],s)
        | NONE => (Rerr (Rabort Rtype_error),s)
        )
    | res => res
    )
  else (Rerr (Rabort Rtype_error),s)))
/\
(evaluate ([Var n],env,s) =  
((case lookup_var_id n env of
    SOME v => (Rval [v],s)
  | NONE => (Rerr (Rabort Rtype_error),s)
  )))
/\
(evaluate ([Fun x e],env,s) = (Rval [Closure env x e],s))
/\
(evaluate ([App op es],env,s) =  
((case evaluate (REVERSE es,env,s) of
    (Rval vs,s') =>
      if op = Opapp then
        (case do_opapp (REVERSE vs) of
          SOME (env,e) =>
            if (s'.clock = 0) \/ (s.clock = 0) then
              (Rerr (Rabort Rtimeout_error),s')
            else
              evaluate ([e],env,dec_clock (check_clock s' s))
        | NONE => (Rerr (Rabort Rtype_error),s')
        )
      else
        (case do_app (s'.refs,s'.io) op (REVERSE vs) of
          SOME ((refs,io),r) => (list_result r, ( s' with<| refs := refs; io := io |>))
        | NONE => (Rerr (Rabort Rtype_error),s')
        )
  | res => res
  )))
/\
(evaluate ([Log lop e1 e2],env,s) =  
((case evaluate ([e1],env,s) of
    (Rval v1,s') =>
      (case do_log lop (HD v1) e2 of
        SOME (Exp e) => evaluate ([e],env,check_clock s' s)
      | SOME (Val v) => (Rval [v],s')
      | NONE => (Rerr (Rabort Rtype_error),s')
      )
  | res => res
  )))
/\
(evaluate ([If e1 e2 e3],env,s) =  
((case evaluate ([e1],env,s) of
    (Rval v,s') =>
      (case do_if (HD v) e2 e3 of
        SOME e => evaluate ([e],env,check_clock s' s)
      | NONE => (Rerr (Rabort Rtype_error),s')
      )
  | res => res
  )))
/\
(evaluate ([Mat e pes],env,s) =  
((case evaluate ([e],env,s) of
    (Rval v,s') =>
      evaluate_match (pes,HD v,Bindv,env,check_clock s' s)
  | res => res
  )))
/\
(evaluate ([Let xo e1 e2],env,s) =  
((case evaluate ([e1],env,s) of
    (Rval v,s') => evaluate ([e2],all_env_with_env env (opt_bind xo (HD v) (all_env_to_env env)),check_clock s' s)
  | res => res
  )))
/\
(evaluate ([Letrec funs e],env,s) =  
(if ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs) then
    evaluate ([e],all_env_with_env env (build_rec_env funs env (all_env_to_env env)),s)
  else
    (Rerr (Rabort Rtype_error),s)))
/\
(evaluate_match ([],v,err_v,env,s) = (Rerr (Rraise err_v),s))
/\
(evaluate_match ((p,e)::pes,v,err_v,env,s) =  
(if ALL_DISTINCT (pat_bindings p []) then
    (case pmatch (all_env_to_cenv env) s.refs p v (all_env_to_env env) of
      Match env' => evaluate ([e],all_env_with_env env env',s)
    | No_match => evaluate_match (pes,v,err_v,env,s)
    | Match_type_error => (Rerr (Rabort Rtype_error),s)
    )
  else (Rerr (Rabort Rtype_error),s)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn evaluate_defn;

(*val evaluate_decs : (list dec * maybe modN * all_env * (state * set tid_or_exn)) -> result envE v * flat_envC * (state * set tid_or_exn)*)
 val evaluate_decs_defn = Hol_defn "evaluate_decs" `

(evaluate_decs ([],mn,env,s) = (Rval [],[],s))
/\
(evaluate_decs (d1::d2::ds,mn,env,s) =  
((case evaluate_decs ([d1],mn,env,s) of
    (Rval new_env,new_tds,s) =>
      (case
        evaluate_decs ((d2::ds),mn,
          (case env of (menv,cenv,env) =>
            (menv, merge_alist_mod_env ([],new_tds) cenv, (new_env++env))
          ),s)
      of (r,new_tds',s) =>
        (combine_dec_result new_env r, (new_tds'++new_tds), s)
      )
  | res => res
  )))
/\
(evaluate_decs ([Dlet p e],mn,env,(s,tdecs)) =  
(if ALL_DISTINCT (pat_bindings p []) then
    (case evaluate ([e],env,s) of
      (Rval v,s) =>
        ((case pmatch (all_env_to_cenv env) s.refs p (HD v) [] of
           Match env' => Rval env'
         | No_match => Rerr (Rraise Bindv)
         | Match_type_error => Rerr (Rabort Rtype_error)
         ),[],(s,tdecs))
    | (Rerr err,s) => (Rerr err,[],(s,tdecs))
    )
  else
    (Rerr (Rabort Rtype_error),[],(s,tdecs))))
/\
(evaluate_decs ([Dletrec funs],mn,env,s) =
  ((if ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs) then
     Rval (build_rec_env funs env [])
   else
     Rerr (Rabort Rtype_error))
  ,[],s))
/\
(evaluate_decs ([Dtype tds],mn,env,(s,tdecs)) =  
(let new_tdecs = (type_defs_to_new_tdecs mn tds) in
    if check_dup_ctors tds /\
       DISJOINT new_tdecs tdecs /\
       ALL_DISTINCT (MAP (\ (tvs,tn,ctors) .  tn) tds)
    then
      (Rval [],build_tdefs mn tds,(s,(new_tdecs UNION tdecs)))
    else
      (Rerr (Rabort Rtype_error),[],(s,tdecs))))
/\
(evaluate_decs ([Dtabbrev tvs tn t],mn,env,s) =
  (Rval [],[],s))
/\
(evaluate_decs ([Dexn cn ts],mn,env,(s,tdecs)) =  
(if TypeExn (mk_id mn cn) IN tdecs then
    (Rerr (Rabort Rtype_error),[],(s,tdecs))
  else
    (Rval [],[(cn, (LENGTH ts, TypeExn (mk_id mn cn)))],(s,({TypeExn (mk_id mn cn)} UNION tdecs)))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn evaluate_decs_defn;
val _ = export_theory()

