open import Transform
open Lib
open Ast

(* Only to get check_dup_ctors *)
open SemanticPrimitives 

(* Type substitution *)

(* Increment the deBruijn indices in a type by n levels, skipping all levels
 * less than skip. *)
val deBruijn_inc : num -> num -> t -> t
let rec
deBruijn_inc skip n (Tvar tv) = Tvar tv
and
deBruijn_inc skip n (Tvar_db m) =
  if m < skip then
    Tvar_db m
  else
    Tvar_db (m + n)
and
deBruijn_inc skip n (Tapp ts tn) = Tapp (List.map (deBruijn_inc skip n) ts) tn

(* skip the lowest given indices and replace the next (LENGTH ts) with the given types and reduce all the higher ones *)
val deBruijn_subst : num -> list t -> t -> t
let rec
deBruijn_subst skip ts (Tvar tv) = Tvar tv
and
deBruijn_subst skip ts (Tvar_db n) =
  if not (n < skip) && n < List.length ts + skip then
    List.nth ts (n - skip)
  else if not (n < skip) then
    Tvar_db (n - List.length ts)
  else
    Tvar_db n
and
deBruijn_subst skip ts (Tapp ts' tn) =
  Tapp (List.map (deBruijn_subst skip ts) ts') tn

(* constructor type environments: each constructor has a type
 * forall tyvars. t list -> (tyvars) typeN *)
type tenvC = env (id conN) (list tvarN * list t * tid_or_exn)

(* Type environments *)
type tenvE =
  | Empty
  (* Binds several de Bruijn type variables *)
  | Bind_tvar of num * tenvE
  (* The number is how many de Bruijn type variables the typescheme binds *)
  | Bind_name of varN * num * t * tenvE

type tenvM = env modN (env varN (num * t))

let bind_tvar tvs tenv = if tvs = 0 then tenv else Bind_tvar tvs tenv

val lookup_tenv : varN -> num -> tenvE -> option (num * t) 
let rec
lookup_tenv n inc Empty = None
and
lookup_tenv n inc (Bind_tvar tvs e) = lookup_tenv n (inc + tvs) e
and
lookup_tenv n inc (Bind_name n' tvs t e) =
  if n' = n then
    Some (tvs, deBruijn_inc tvs inc t)
  else
    lookup_tenv n inc e

val bind_tenv : varN -> num -> t -> tenvE -> tenvE
let bind_tenv n tvs t e = Bind_name n tvs t e

val t_lookup_var_id : id varN -> tenvM -> tenvE -> option (num * t)
let t_lookup_var_id id tenvM tenvE =
  match id with
    | Short x -> lookup_tenv x 0 tenvE
    | Long x y ->
        match lookup x tenvM with
          | None -> None
          | Some tenvE' -> lookup y tenvE'
        end
  end

val num_tvs : tenvE -> num
let rec 
num_tvs Empty = 0
and
num_tvs (Bind_tvar tvs e) = tvs + num_tvs e
and
num_tvs (Bind_name n tvs t e) = num_tvs e

(* A pattern matches values of a certain type and extends the type environment
 * with the pattern's binders. The number is the maximum deBruijn type variable
 * allowed. *)
val type_p : num -> tenvC -> pat -> t -> list (varN * t) -> bool

(* An expression has a type *)
val type_e : tenvM -> tenvC -> tenvE -> exp -> t -> bool

(* A list of expressions has a list of types *)
val type_es : tenvM -> tenvC -> tenvE -> list exp -> list t -> bool

(* Type a mutually recursive bundle of functions.  Unlike pattern typing, the
 * resulting environment does not extend the input environment, but just
 * represents the functions *)
val type_funs : tenvM -> tenvC -> tenvE -> list (varN * varN * exp) ->
                list (varN * t) -> bool

(* Check a declaration and update the top-level environments *)
val type_d : option modN -> tenvM -> tenvC -> tenvE -> dec -> tenvC -> env varN (num * t) -> bool

val type_ds : option modN -> tenvM -> tenvC -> tenvE -> list dec -> tenvC -> env varN (num * t) -> bool
val weakE : env varN (num * t) -> env varN (num * t) -> bool
val weakC : tenvC -> tenvC -> bool
val check_signature : option modN -> tenvC -> env varN (num * t) -> option specs -> tenvC -> env varN (num * t) -> bool
val type_specs : option modN -> tenvC -> env varN (num * t) -> specs -> tenvC -> env varN (num * t) -> bool
val type_prog : tenvM -> tenvC -> tenvE -> list top -> tenvM -> tenvC -> env varN (num * t) -> bool

(* Check that the operator can have type (t1 -> t2 -> t3) *)
val type_op : op -> t -> t -> t -> bool
let type_op op t1 t2 t3 =
  match (op,t1,t2) with
    | (Opapp, Tapp [t2'; t3'] TC_fn, _) -> (t2 = t2') && (t3 = t3')
    | (Opn _, Tapp [] TC_int, Tapp [] TC_int) -> (t3 = Tint)
    | (Opb _, Tapp [] TC_int, Tapp [] TC_int) -> (t3 = Tbool)
    | (Equality, t1, t2) -> (t1 = t2) && (t3 = Tbool)
    | (Opassign, Tapp [t1] TC_ref, t2) -> (t1 = t2) && (t3 = Tunit)
    | _ -> false
  end

(* Check that the operator can have type (t1 -> t2) *)
val type_uop : uop -> t -> t -> bool
let type_uop uop t1 t2 =
  match (uop,t1) with
    | (Opref, _) -> t2 = Tref t1
    | (Opderef, Tapp [t1'] TC_ref) -> t2 = t1'
    | _ -> false
  end

(* Check that the free type variables are in the given list.  Every deBruijn
 * variable must be smaller than the first argument.  So if it is 0, no deBruijn
 * indices are permitted. *)
val check_freevars : num -> list tvarN -> t -> bool
let rec
check_freevars dbmax tvs (Tvar tv) =
  List.mem tv tvs
and
check_freevars dbmax tvs (Tapp ts tn) =
  List.for_all (check_freevars dbmax tvs) ts
and
check_freevars dbmax tvs (Tvar_db n) = n < dbmax

(* Check that a type definition defines no already defined (or duplicate)
 * constructors or types, and that the free type variables of each constructor
 * argument type are included in the type's type parameters. *)
val check_ctor_tenv :
   option modN -> tenvC -> list (list tvarN * typeN * list (conN * list t)) -> bool
let check_ctor_tenv mn tenvC tds =
  check_dup_ctors mn tenvC tds &&
  List.for_all
    (fun (tvs,tn,ctors) ->
       all_distinct tvs &&
       List.for_all
         (fun (cn,ts) -> (List.for_all (check_freevars 0 tvs) ts))
         ctors)
    tds &&
  all_distinct (List.map (fun (_,tn,_) -> tn) tds) &&
  List.for_all
    (fun (tvs,tn,ctors) ->
       List.for_all (fun (_,(_,_,tn')) -> TypeId (mk_id mn tn) <> tn') tenvC)
    tds

val build_ctor_tenv : option modN -> list (list tvarN * typeN * list (conN * list t)) -> tenvC
let build_ctor_tenv mn tds =
  List.flatten
    (List.map
       (fun (tvs,tn,ctors) ->
          List.map (fun (cn,ts) -> (mk_id mn cn,(tvs,ts, TypeId (mk_id mn tn)))) ctors)
       tds)

(* Simultaneous substitution of types for type variables in a type *)
val type_subst : env tvarN t -> t -> t
let rec
type_subst s (Tvar tv) =
  match lookup tv s with
    | None -> Tvar tv
    | Some(t) -> t
  end
and
type_subst s (Tapp ts tn) =
  Tapp (List.map (type_subst s) ts) tn
and
type_subst s (Tvar_db n) = Tvar_db n

val bind_var_list : num -> list (varN * t) -> tenvE -> tenvE
let rec
bind_var_list tvs [] tenv = tenv
and
bind_var_list tvs ((n,t)::binds) tenv =
  bind_tenv n tvs t (bind_var_list tvs binds tenv)

val bind_var_list2 : env varN (num * t) -> tenvE -> tenvE
let rec
bind_var_list2 [] tenv = tenv
and
bind_var_list2 ((n,(tvs,t))::binds) tenv =
  bind_tenv n tvs t (bind_var_list2 binds tenv)


(* For the value restriction on let-based polymorphism *)
val is_value : exp -> bool
let rec 
is_value (Lit _) = true
and
is_value (Con _ es) = List.for_all is_value es
and
is_value (Var _) = true
and
is_value (Fun _ _) = true
and
is_value _ = false

val tid_exn_to_tc : tid_or_exn -> tc
let tid_exn_to_tc t =
  match t with
    | TypeId tid -> TC_name tid
    | TypeExn -> TC_exn
  end

indreln

forall tvs cenv n t.
check_freevars tvs [] t
==>
type_p tvs cenv (Pvar n) t [(n,t)]

and

forall tvs cenv b.
true
==>
type_p tvs cenv (Plit (Bool b)) Tbool []

and

forall tvs cenv n.
true
==>
type_p tvs cenv (Plit (IntLit n)) Tint []

and

forall tvs cenv.
true
==>
type_p tvs cenv (Plit Unit) Tunit []

and

forall tvs cenv cn ps ts tvs' tn ts' tenv.
List.for_all (check_freevars tvs []) ts' &&
List.length ts' = List.length tvs' &&
type_ps tvs cenv ps (List.map (type_subst (List.combine tvs' ts')) ts) tenv &&
lookup cn cenv = Some (tvs', ts, tn)
==>
type_p tvs cenv (Pcon (Some cn) ps) (Tapp ts' (tid_exn_to_tc tn)) tenv

and

forall tvs cenv ps ts tenv.
type_ps tvs cenv ps ts tenv
==>
type_p tvs cenv (Pcon None ps) (Tapp ts TC_tup) tenv

and

forall tvs cenv p t tenv.
type_p tvs cenv p t tenv
==>
type_p tvs cenv (Pref p) (Tref t) tenv

and

forall tvs cenv.
true
==>
type_ps tvs cenv [] [] []

and

forall tvs cenv p ps t ts tenv tenv'.
type_p tvs cenv p t tenv &&
type_ps tvs cenv ps ts tenv'
==>
type_ps tvs cenv (p::ps) (t::ts) (tenv'@tenv)

indreln

forall menv cenv tenv b.
true
==>
type_e menv cenv tenv (Lit (Bool b)) Tbool

and

forall menv cenv tenv n.
true
==>
type_e menv cenv tenv (Lit (IntLit n)) Tint

and

forall menv cenv tenv.
true
==>
type_e menv cenv tenv (Lit Unit) Tunit

and

forall menv cenv tenv e t.
check_freevars (num_tvs tenv) [] t &&
type_e menv cenv tenv e Texn 
==>
type_e menv cenv tenv (Raise e) t

and

forall menv cenv tenv e pes t.
type_e menv cenv tenv e t &&
(pes <> []) &&
(forall ((p,e) MEM pes). exists tenv'.
   all_distinct (pat_bindings p []) &&
   type_p (num_tvs tenv) cenv p Texn tenv' &&
   type_e menv cenv (bind_var_list 0 tenv' tenv) e t)
==>
type_e menv cenv tenv (Handle e pes) t

and

forall menv cenv tenv cn es tvs tn ts' ts.
List.for_all (check_freevars (num_tvs tenv) []) ts' &&
List.length tvs = List.length ts' &&
type_es menv cenv tenv es (List.map (type_subst (List.combine tvs ts')) ts) &&
lookup cn cenv = Some (tvs, ts, tn)
==>
type_e menv cenv tenv (Con (Some cn) es) (Tapp ts' (tid_exn_to_tc tn))

and

forall menv cenv tenv es ts.
type_es menv cenv tenv es ts
==>
type_e menv cenv tenv (Con None es) (Tapp ts TC_tup)

and

forall menv cenv tenv n t targs tvs.
(tvs = List.length targs) &&
List.for_all (check_freevars (num_tvs tenv) []) targs &&
(t_lookup_var_id n menv tenv = Some (tvs,t))
==>
type_e menv cenv tenv (Var n) (deBruijn_subst 0 targs t)

and

forall menv cenv tenv n e t1 t2.
check_freevars (num_tvs tenv) [] t1 &&
type_e menv cenv (bind_tenv n 0 t1 tenv) e t2
==>
type_e menv cenv tenv (Fun n e) (Tfn t1 t2)

and

forall menv cenv tenv uop e t1 t2.
type_e menv cenv tenv e t1 &&
type_uop uop t1 t2
==>
type_e menv cenv tenv (Uapp uop e) t2

and

forall menv cenv tenv op e1 e2 t1 t2 t3.
type_e menv cenv tenv e1 t1 &&
type_e menv cenv tenv e2 t2 &&
type_op op t1 t2 t3
==>
type_e menv cenv tenv (App op e1 e2) t3

and

forall menv cenv tenv l e1 e2.
type_e menv cenv tenv e1 Tbool &&
type_e menv cenv tenv e2 Tbool
==>
type_e menv cenv tenv (Log l e1 e2) Tbool

and

forall menv cenv tenv e1 e2 e3 t.
type_e menv cenv tenv e1 Tbool &&
type_e menv cenv tenv e2 t &&
type_e menv cenv tenv e3 t
==>
type_e menv cenv tenv (If e1 e2 e3) t

and

forall menv cenv tenv e pes t1 t2.
type_e menv cenv tenv e t1 &&
(pes <> []) &&
(forall ((p,e) MEM pes) . exists tenv'.
   all_distinct (pat_bindings p []) &&
   type_p (num_tvs tenv) cenv p t1 tenv' &&
   type_e menv cenv (bind_var_list 0 tenv' tenv) e t2)
==>
type_e menv cenv tenv (Mat e pes) t2

and

forall menv cenv tenv n e1 e2 t1 t2 tvs.
is_value e1 &&
type_e menv cenv (bind_tvar tvs tenv) e1 t1 &&
type_e menv cenv (bind_tenv n tvs t1 tenv) e2 t2
==>
type_e menv cenv tenv (Let n e1 e2) t2

and

forall menv cenv tenv n e1 e2 t1 t2.
type_e menv cenv tenv e1 t1 &&
type_e menv cenv (bind_tenv n 0 t1 tenv) e2 t2
==>
type_e menv cenv tenv (Let n e1 e2) t2

and

forall menv cenv tenv funs e t tenv' tvs.
type_funs menv cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv' &&
type_e menv cenv (bind_var_list tvs tenv' tenv) e t
==>
type_e menv cenv tenv (Letrec funs e) t

and

forall menv cenv tenv.
true
==>
type_es menv cenv tenv [] []

and

forall menv cenv tenv e es t ts.
type_e menv cenv tenv e t &&
type_es menv cenv tenv es ts
==>
type_es menv cenv tenv (e::es) (t::ts)

and

forall menv cenv env.
true
==>
type_funs menv cenv env [] []

and

forall menv cenv env fn n e funs env' t1 t2.
check_freevars (num_tvs env) [] (Tfn t1 t2) &&
type_e menv cenv (bind_tenv n 0 t1 env) e t2 &&
type_funs menv cenv env funs env' &&
lookup fn env' = None
==>
type_funs menv cenv env ((fn, n, e)::funs) ((fn, Tfn t1 t2)::env')

val tenv_add_tvs : num -> env varN t -> env varN (num * t)
let tenv_add_tvs tvs tenv =
  List.map (fun (n,t) -> (n,(tvs,t))) tenv

indreln

forall tvs mn menv cenv tenv p e t tenv'.
is_value e &&
all_distinct (pat_bindings p []) &&
type_p tvs cenv p t tenv' &&
type_e menv cenv (bind_tvar tvs tenv) e t
==>
type_d mn menv cenv tenv (Dlet p e) emp (tenv_add_tvs tvs tenv')

and

forall mn menv cenv tenv p e t tenv'.
all_distinct (pat_bindings p []) &&
type_p 0 cenv p t tenv' &&
type_e menv cenv tenv e t
==>
type_d mn menv cenv tenv (Dlet p e) emp (tenv_add_tvs 0 tenv')

and

forall mn menv cenv tenv funs tenv' tvs.
type_funs menv cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv'
==>
type_d mn menv cenv tenv (Dletrec funs) emp (tenv_add_tvs tvs tenv')

and

forall mn menv cenv tenv tdecs.
check_ctor_tenv mn cenv tdecs
==>
type_d mn menv cenv tenv (Dtype tdecs) (build_ctor_tenv mn tdecs) emp

and

forall mn menv cenv tenv cn ts.
(lookup (mk_id mn cn) cenv = None) &&
List.for_all (check_freevars 0 []) ts
==>
type_d mn menv cenv tenv (Dexn cn ts) (bind (mk_id mn cn) ([], ts, TypeExn) emp) emp

indreln

forall mn menv cenv tenv.
true
==>
type_ds mn menv cenv tenv [] emp emp

and

forall mn menv cenv tenv d ds cenv' tenv' cenv'' tenv''.
type_d mn menv cenv tenv d cenv' tenv' &&
type_ds mn menv (merge cenv' cenv) (bind_var_list2 tenv' tenv) ds cenv'' tenv''
==>
type_ds mn menv cenv tenv (d::ds) (merge cenv'' cenv') (merge tenv'' tenv')

indreln

forall cenv tenv mn.
true
==>
type_specs mn cenv tenv [] cenv tenv

and

forall mn cenv tenv x t specs cenv' tenv' fvs.
check_freevars 0 fvs t &&
type_specs mn cenv (bind x (List.length fvs, type_subst (List.combine fvs (List.map Tvar_db (count_list (List.length fvs)))) t) tenv) specs cenv' tenv'
==>
type_specs mn cenv tenv (Sval x t :: specs) cenv' tenv' 

and

forall mn cenv tenv td specs cenv' tenv'.
check_ctor_tenv mn cenv td &&
type_specs mn (merge (build_ctor_tenv mn td) cenv) tenv specs cenv' tenv'
==>
type_specs mn cenv tenv (Stype td :: specs) cenv' tenv'

and

forall mn cenv tenv cn ts specs cenv' tenv'.
(lookup (mk_id mn cn) cenv = None) &&
List.for_all (check_freevars 0 []) ts &&
type_specs mn (bind (mk_id mn cn) ([], ts, TypeExn) cenv) tenv specs cenv' tenv'
==>
type_specs mn cenv tenv (Sexn cn ts :: specs) cenv' tenv'

and

forall mn cenv tenv tn specs cenv' tenv' tvs.
all_distinct tvs &&
List.for_all (fun (_,(_,_,tn')) -> TypeId (mk_id mn tn) <> tn') cenv &&
type_specs mn cenv tenv specs cenv' tenv'
==>
type_specs mn cenv tenv (Stype_opq tvs tn :: specs) cenv' tenv'

let weakE tenv_impl tenv_spec =
  forall x.
    match lookup x tenv_spec with
      | Some (tvs_spec, t_spec) ->
          match lookup x tenv_impl with
            | None -> false
            | Some (tvs_impl, t_impl) ->
                exists subst. 
                  List.length subst = tvs_impl &&
                  check_freevars tvs_impl [] t_impl &&
                  List.for_all (check_freevars tvs_spec []) subst &&
                  deBruijn_subst 0 subst t_impl = t_spec
          end
        | None -> true
    end

let weakC cenv_impl cenv_spec =
  forall cn.
    match lookup cn cenv_spec with
      | Some (tvs_spec,ts_spec,tn_spec) ->
          match lookup cn cenv_impl with
            | None -> false
            | Some (tvs_impl, ts_impl, tn_impl) ->
                tn_spec = tn_impl &&
                (* For simplicity, we reject matches that differ only by renaming of bound type variables *)
                tvs_spec = tvs_impl &&
                ts_spec = ts_impl 
          end
      | None -> true
    end

indreln

forall mn cenv tenv.
true
==>
check_signature mn cenv tenv None cenv tenv

and

forall mn cenv tenv specs tenv' cenv'.
weakE tenv tenv' &&
weakC cenv cenv' &&
type_specs mn emp emp specs cenv' tenv'
==>
check_signature mn cenv tenv (Some specs) cenv' tenv'

indreln

forall menv cenv tenv d cenv' tenv'.
type_d None menv cenv tenv d cenv' tenv'
==>
type_top menv cenv tenv (Tdec d) emp cenv' tenv'

and

forall menv cenv tenv mn spec ds cenv' tenv' cenv'' tenv''.
not (List.mem mn (List.map fst menv)) &&
type_ds (Some mn) menv cenv tenv ds cenv' tenv' &&
check_signature (Some mn) cenv' tenv' spec cenv'' tenv''
==>
type_top menv cenv tenv (Tmod mn spec ds) [(mn,tenv'')] cenv'' emp

indreln

forall menv cenv tenv.
true
==>
type_prog menv cenv tenv [] emp emp emp

and

forall menv cenv tenv top tops menv' cenv' tenv' menv'' cenv'' tenv''.
type_top menv cenv tenv top menv' cenv' tenv' &&
type_prog (merge menv' menv) (merge cenv' cenv) (bind_var_list2 tenv' tenv) tops menv'' cenv'' tenv''
==>
type_prog menv cenv tenv (top :: tops) (merge menv'' menv') (merge cenv'' cenv') (merge tenv'' tenv')
