(* By Scott Owens, University of Cambridge, Copyright 2011, 2012
 *                 University of Kent 2012, 2013
 *
 * MiniML is a simple ML-like language. It has no type abbreviations, or
 * records, and only simple top-level modules.  It has mutually recursive
 * datatypes (at the top-level and module top-level only) and functions, as
 * well as higher-order functions.  It also supports pattern matching for
 * nested patterns (which can fail due to non-exhaustive patterns).  Only
 * booleans and integer types are built-in.  Syntactic sugar is generally
 * omitted.
 *
 * In some ways it makes more sense to write these kind of semantics in Ott (to
 * get a presentation that looks like ML concrete-syntax-wise, and that has the
 * usual syntax for type systems and operational semantics, i.e., with |- and
 * horizontal lines).  Here in Lem, everything looks like abstract syntax;
 * however, unlike Ott, we get good support for functions, and not just
 * relations.
 *
 * The small-step operational semantics is based on the CEK machine.  The type
 * system is typical.  The big step semantics is also typical.  The small-step
 * and big-step semantics agree even on untyped programs. *)

val i : num -> Int.int
let inline {hol} i = Hol.(&)

val all_distinct : forall 'a. list 'a -> bool
let inline {hol} all_distinct = Hol.ALL_DISTINCT

val rtc : forall 'a. ('a -> 'a -> bool) -> ('a -> 'a -> bool)
let inline {hol} rtc = Hol.RTC

val count_list : num -> list num
let inline {hol} count_list = Hol.COUNT_LIST

val option_map : forall 'a 'b. ('a -> 'b) -> option 'a -> option 'b
let option_map f x = 
  match x with
    | None -> None
    | Some y -> Some (f y)
  end

(* Change the nth element in the list to 'a *)
val LUPDATE : forall 'a. 'a -> num -> list 'a -> list 'a
let inline {hol} LUPDATE = Hol.LUPDATE

(* Environments *)
type env 'a 'b = list ('a*'b)

val emp : forall 'a 'b. env 'a 'b
let emp = []

val lookup : forall 'a 'b. 'a -> env 'a 'b -> option 'b
let rec
lookup n [] = None
and
lookup n ((n',v)::e) =
  if n' = n then
    Some v
  else
    lookup n e

val bind : forall 'a 'b. 'a -> 'b -> env 'a 'b -> env 'a 'b
let bind n v e = (n,v)::e

val merge : forall 'a 'b. env 'a 'b -> env 'a 'b -> env 'a 'b
let merge e1 e2 = e1 @ e2

(* ------------------------------------------------------------------------ *) 
(*   The Abstract Syntax                                                    *)
(* ------------------------------------------------------------------------ *) 

(* Literal constants *)
type lit =
  | IntLit of int
  | Bool of bool
  | Unit

(* Built-in binary operations (including function application) *)

type opn = Plus | Minus | Times | Divide | Modulo
type opb = Lt | Gt | Leq | Geq

let opn_lookup n = match n with
  | Plus -> Int.(+)
  | Minus -> Int.(-)
  | Times -> Int.( * )
  | Divide -> Int.(/)
  | Modulo -> Int.(%)
end

let opb_lookup n : int -> int -> bool = match n with
  | Lt -> Int.(<)
  | Gt -> Int.(>)
  | Leq -> Int.(<=)
  | Geq -> Int.(>=)
end

(* Opapp is function application *)
type op =
  | Opn of opn
  | Opb of opb
  | Equality
  | Opapp
  | Opassign

type uop =
  | Opref
  | Opderef

(* Built-in logical operations *)
type log =
  | And
  | Or

(* Module names *)
type modN = string
(* Identifiers *)
type id 'a =
  | Short of 'a
  | Long of modN * 'a
(* Variable names *)
type varN = string
(* Constructor names (from datatype definitions) *)
type conN = string
(* Type names *)
type typeN = string
(* Type variable names *)
type tvarN = string

val mk_id : forall 'a. option modN -> 'a -> id 'a
let mk_id mn_opt n =
  match mn_opt with
    | None -> Short n
    | Some mn -> Long mn n
  end

(* Types
 * 0-ary type applications represent unparameterised types (e.g., num or string)
 *)
type tc = 
  | TC_name of id typeN
  | TC_int
  | TC_bool
  | TC_unit
  | TC_ref
  | TC_fn

type t =
  | Tvar of tvarN
  (* DeBruin indexed type variables. *)
  | Tvar_db of num
  | Tapp of list t * tc

let Tint = Tapp [] TC_int
let Tunit = Tapp [] TC_unit
let Tbool = Tapp [] TC_bool
let Tref t = Tapp [t] TC_ref
let Tfn t1 t2 = Tapp [t1;t2] TC_fn

(* Patterns *)
type pat =
  | Pvar of varN
  | Plit of lit
  (* Constructor applications. *)
  | Pcon of id conN * list pat
  | Pref of pat

(* Runtime errors.  Temporary: later on we want to move to SML-style declared
 * exception constructors *)
type error =
  | Bind_error
  | Div_error
  | Int_error of int

(* Expressions *)
type exp =
  (* Temporary: later on we want Raise of exp *)
  | Raise of error
  (* Temporary: later on we want Handle of exp * list (pat * exp) *)
  | Handle of exp * varN * exp
  | Lit of lit
  (* Constructor application. *)
  | Con of id conN * list exp
  | Var of id varN
  | Fun of varN * exp
  (* Application of a unary operator *)
  | Uapp of uop * exp
  (* Application of an operator (including function application) *)
  | App of op * exp * exp
  (* Logical operations (and, or) *)
  | Log of log * exp * exp
  | If of exp * exp * exp
  (* Pattern matching *)
  | Mat of exp * list (pat * exp)
  (* The number is how many type variables are bound. *)
  | Let of varN * exp * exp
  (* Local definition of (potentially) mutually recursive functions
   * The first varN is the function's name, and the second varN is its
   * parameter. *)
  | Letrec of list (varN * varN * exp) * exp

type type_def = list (list tvarN * typeN * list (conN * list t))

(* Declarations *)
type dec =
  (* Top-level bindings
   * The number is how many type variables are bound.
   * The pattern allows several names to be bound at once *)
  | Dlet of pat * exp
  (* Mutually recursive function definition *)
  | Dletrec of list (varN * varN * exp)
  (* Type definition
     Defines several types, each of which has several named variants, which can
     in turn have several arguments *)
  | Dtype of type_def

type decs = list dec 

type spec =
  | Sval of varN * t
  | Stype of type_def
  | Stype_opq of typeN

type specs = list spec

type top =
  | Tmod of modN * option specs * decs
  | Tdec of dec

type prog = list top


(* ------------------------------------------------------------------------ *) 
(*   The Semantics                                                          *)
(* ------------------------------------------------------------------------ *) 

(* Value forms *)
type v =
  | Litv of lit
  (* Constructor application. *)
  | Conv of id conN * list v 
  (* Function closures
     The environment is used for the free variables in the function *)
  | Closure of env varN v * varN * exp
  (* Function closure for recursive functions
   * See Closure and Letrec above
   * The last variable name indicates which function from the mutually
   * recursive bundle this closure value represents *)
  | Recclosure of env varN v * list (varN * varN * exp) * varN
  | Loc of num


(* Type substitution *)

(* Increment the deBruijn indices in a type by n levels, skipping all levels
 * less than skip. *)
val deBruijn_inc : num -> num -> t -> t
let rec
deBruijn_inc skip n (Tvar tv) = Tvar tv
and
deBruijn_inc skip n (Tvar_db m) =
  if m < skip then
    Tvar_db m
  else
    Tvar_db (m + n)
and
deBruijn_inc skip n (Tapp ts tn) = Tapp (List.map (deBruijn_inc skip n) ts) tn

(* skip the lowest given indices and replace the next (LENGTH ts) with the given types and reduce all the higher ones *)
val deBruijn_subst : num -> list t -> t -> t
let rec
deBruijn_subst skip ts (Tvar tv) = Tvar tv
and
deBruijn_subst skip ts (Tvar_db n) =
  if not (n < skip) && n < List.length ts + skip then
    List.nth ts (n - skip)
  else if not (n < skip) then
    Tvar_db (n - List.length ts)
  else
    Tvar_db n
and
deBruijn_subst skip ts (Tapp ts' tn) =
  Tapp (List.map (deBruijn_subst skip ts) ts') tn

(* Environments *)

(* Maps each constructor to its arity and which type it is from *)
type envC = env (id conN) (num * id typeN)

type envE = env varN v

(* The bindings of a module *)
type envM = env modN envE

val lookup_var_id : id varN -> envM -> envE -> option v
let lookup_var_id id menv envE =
  match id with
    | Short x -> lookup x envE
    | Long x y ->
        match lookup x menv with
          | None -> None
          | Some env -> lookup y env
        end
  end

(* Stores *)
(* The nth item in the list is the value at location n *)
type store = list v

val empty_store : store
let empty_store = []

val store_lookup : num -> store -> option v
let store_lookup l st =
  if l < List.length st then
    Some (List.nth st l)
  else
    None

val store_alloc : v -> store -> store * num
let store_alloc v st =
  (st @ [v], List.length st)

val store_assign : num -> v -> store -> option store
let store_assign n v st =
  if n < List.length st then
    Some (LUPDATE v n st)
  else
    None


(* Evaluation contexts
 * The hole is denoted by the unit type
 * The env argument contains bindings for the free variables of expressions in
     the context *)
type ctxt_frame =
  | Chandle of unit * varN * exp
  | Capp1 of op * unit * exp
  | Capp2 of op * v * unit
  | Clog of log * unit * exp
  | Cif of unit * exp * exp
  | Cmat of unit * list (pat * exp)
  | Clet of varN * unit * exp
  (* Evaluating a constructor's arguments
   * The v list should be in reverse order. *)
  | Ccon of id conN * list v * unit * list exp
  | Cuapp of uop * unit
type ctxt = ctxt_frame * envE

val lit_same_type : lit -> lit -> bool
let lit_same_type l1 l2 =
  match (l1,l2) with
    | (IntLit _, IntLit _) -> true
    | (Bool _, Bool _) -> true
    | (Unit, Unit) -> true
    | _ -> false
  end

type match_result =
  | No_match
  | Match_type_error
  | Match of envE

(* A big-step pattern matcher.  If the value matches the pattern, return an
 * environment with the pattern variables bound to the corresponding sub-terms
 * of the value; this environment extends the environment given as an argument.
 * No_match is returned when there is no match, but any constructors
 * encountered in determining the match failure are applied to the correct
 * number of arguments, and constructors in corresponding positions in the
 * pattern and value come from the same type.  Match_type_error is returned
 * when one of these conditions is violated *)
val pmatch : envC -> store -> pat -> v -> envE -> match_result
let rec
pmatch envC s (Pvar x) v' env = Match (bind x v' env)
and
pmatch envC s (Plit l) (Litv l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error
and
pmatch envC s (Pcon n ps) (Conv n' vs) env =
  match (lookup n envC, lookup n' envC) with
    | (Some (l, t), Some (l', t')) ->
        if t = t' && (List.length ps = l) && (List.length vs = l') then
          if n = n' then
            pmatch_list envC s ps vs env
          else
            No_match
        else
          Match_type_error
    | (_, _) -> Match_type_error
  end
and
pmatch envC s (Pref p) (Loc lnum) env =
  match store_lookup lnum s with
    | Some v -> pmatch envC s p v env
    | None -> Match_type_error
  end
and
pmatch envC _ _ _ env = Match_type_error
and
pmatch_list envC s [] [] env = Match env
and
pmatch_list envC s (p::ps) (v::vs) env =
  match pmatch envC s p v env with
    | No_match -> No_match
    | Match_type_error -> Match_type_error
    | Match env' -> pmatch_list envC s ps vs env'
  end
and
pmatch_list envC s _ _ env = Match_type_error

(* Accumulates the bindings of a patterns *)
val pat_bindings : pat -> list varN -> list varN
let rec
pat_bindings (Pvar n) already_bound =
  n::already_bound
and
pat_bindings (Plit l) already_bound =
  already_bound
and
pat_bindings (Pcon _ ps) already_bound =
  pats_bindings ps already_bound
and
pat_bindings (Pref p) already_bound =
  pat_bindings p already_bound
and
pats_bindings [] already_bound =
  already_bound
and
pats_bindings (p::ps) already_bound =
  pats_bindings ps (pat_bindings p already_bound)

(* State for CEK-style expression evaluation
 * - constructor data
 * - the store
 * - the environment for the free variables of the current expression
 * - the current expression to evaluate, or a value if finished
 * - the context stack (continuation) of what to do once the current expression
 *   is finished.  Each entry has an environment for it's free variables *)
type exp_or_val =
  | Exp of exp
  | Val of v

type state = envM * envC * store * envE * exp_or_val * list ctxt

type e_step_result =
  | Estep of state
  | Etype_error
  | Estuck

(* The semantics are deterministic, and presented functionally instead of
 * relationally for proof rather that readability; the steps are very small: we
 * push individual frames onto the context stack instead of finding a redex in a
 * single step *)

val push : envM -> envC -> store -> envE -> exp -> ctxt_frame -> list ctxt -> e_step_result
let push envM envC s env e c' cs = Estep (envM, envC, s, env, Exp e, (c',env)::cs)

val return : envM -> envC -> store -> envE -> v -> list ctxt -> e_step_result
let return envM envC s env v c = Estep (envM, envC, s, env, Val v, c)

(* Bind each function of a mutually recursive set of functions to its closure *)
val build_rec_env : list (varN * varN * exp) -> envE -> envE -> envE
let build_rec_env funs cl_env add_to_env =
  List.fold_right
    (fun (f,x,e) env' -> bind f (Recclosure cl_env funs f) env')
    funs
    add_to_env

(* Lookup in the list of mutually recursive functions *)
val find_recfun : varN -> list (varN * varN * exp) -> option (varN * exp)
let rec find_recfun n funs =
  match funs with
    | [] -> None
    | (f,x,e) :: funs ->
        if f = n then
          Some (x,e)
        else
          find_recfun n funs
  end

(* Do an application *)
val do_app : store -> envE -> op -> v -> v -> option (store * envE * exp)
let do_app s env' op v1 v2 =
  match (op, v1, v2) with
    | (Opapp, Closure env n e, v) ->
        Some (s, bind n v env, e)
    | (Opapp, Recclosure env funs n, v) ->
        match find_recfun n funs with
          | Some (n,e) -> Some (s, bind n v (build_rec_env funs env env), e)
          | None -> None
        end
    | (Opn op, Litv (IntLit n1), Litv (IntLit n2)) ->
        if (op = Divide || op = Modulo) && n2 = i 0 then
          Some (s, env', Raise Div_error)
        else
          Some (s, env',Lit (IntLit (opn_lookup op n1 n2)))
    | (Opb op, Litv (IntLit n1), Litv (IntLit n2)) ->
        Some (s, env', Lit (Bool (opb_lookup op n1 n2)))
    | (Equality, v1, v2) ->
        (* TODO: Check for closures in v1 and v2, and possibly check that they
         * have the same type *)
        Some (s, env', Lit (Bool (v1 = v2)))
    | (Opassign, (Loc lnum), v) ->
        match store_assign lnum v s with
        | Some st -> Some (st, env', Lit Unit)
        | None -> None
        end
    | _ -> None
  end

(* Do a logical operation *)
val do_log : log -> v -> exp -> option exp
let do_log l v e =
  match (l, v) with
    | (And, Litv (Bool true)) -> Some e
    | (Or, Litv (Bool false)) -> Some e
    | (_, Litv (Bool b)) -> Some (Lit (Bool b))
    | _ -> None
  end

(* Do an if-then-else *)
val do_if : v -> exp -> exp -> option exp
let do_if v e1 e2 =
  if v = Litv (Bool true) then
    Some e1
  else if v = Litv (Bool false) then
    Some e2
  else
    None

(* Check that a constructor is properly applied *)
val do_con_check : envC -> id conN -> num -> bool
let do_con_check cenv n l =
  match lookup n cenv with
    | None -> false
    | Some (l',ns) -> l = l'
  end

val do_uapp : store -> uop -> v -> option (store * v)
let do_uapp s uop v =
  match uop with
    | Opderef ->
        match v with
          | Loc n ->
              match store_lookup n s with
                | Some v -> Some (s,v)
                | None -> None
              end
          | _ -> None
        end
    | Opref ->
        let (s',n) = store_alloc v s in
          Some (s', Loc n)
  end

(* apply a context to a value *)
val continue : envM -> envC -> store -> v -> list ctxt -> e_step_result
let continue envM envC s v cs =
  match cs with
    | [] -> Estuck
    | (Chandle () n e, env) :: c ->
        return envM envC s env v c
    | (Capp1 op () e, env) :: c ->
        push envM envC s env e (Capp2 op v ()) c
    | (Capp2 op v' (), env) :: c ->
        match do_app s env op v' v with
          | Some (s',env,e) -> Estep (envM, envC, s', env, Exp e, c)
          | None -> Etype_error
        end
    | (Clog l () e, env) :: c ->
        match do_log l v e with
          | Some e -> Estep (envM, envC, s, env, Exp e, c)
          | None -> Etype_error
        end
    | (Cif () e1 e2, env) :: c ->
        match do_if v e1 e2 with
          | Some e -> Estep (envM, envC, s, env, Exp e, c)
          | None -> Etype_error
        end
    | (Cmat () [], env) :: c ->
        Estep (envM, envC, s, env, Exp (Raise Bind_error), c)
    | (Cmat () ((p,e)::pes), env) :: c ->
        if all_distinct (pat_bindings p []) then
          match pmatch envC s p v env with
            | Match_type_error -> Etype_error
            | No_match -> Estep (envM, envC, s, env, Val v, (Cmat () pes,env)::c)
            | Match env' -> Estep (envM, envC, s, env', Exp e, c)
          end
        else
          Etype_error
    | (Clet n () e, env) :: c ->
        Estep (envM, envC, s, bind n v env, Exp e, c)
    | (Ccon n vs () [], env) :: c ->
        if do_con_check envC n (List.length vs + 1) then
          return envM envC s env (Conv n (List.rev (v::vs))) c
        else
          Etype_error
    | (Ccon n vs () (e::es), env) :: c ->
        if do_con_check envC n (List.length vs + 1 + 1 + List.length es) then
          push envM envC s env e (Ccon n (v::vs) () es) c
        else
          Etype_error
    | (Cuapp uop (), env) :: c ->
       match do_uapp s uop v with
         | Some (s',v') -> return envM envC s' env v' c
         | None -> Etype_error
       end
  end

(* The single step expression evaluator.  Returns None if there is nothing to
 * do, but no type error.  Returns Type_error on encountering free variables,
 * mis-applied (or non-existent) constructors, and when the wrong kind of value
 * if given to a primitive.  Returns Bind_error when no pattern in a match
 * matches the value.  Otherwise it returns the next state *)

val e_step : state -> e_step_result
let e_step (envM, envC, s, env, ev, c) =
  match ev with
    | Val v  ->
	continue envM envC s v c
    | Exp e ->
        match e with
          | Lit l -> return envM envC s env (Litv l) c
          | Raise e ->
              match c with
                | [] -> Estuck
                | ((Chandle () n e',env') :: c) ->
                     match e with
                        | Int_error i ->
                           Estep (envM,envC,s,(bind n (Litv (IntLit i)) env'),Exp e',c)
                        | _ -> Estep (envM,envC,s,env,Exp (Raise e),c)
                     end
                | _::c -> Estep (envM,envC,s,env,Exp (Raise e),c)
              end
          | Handle e n e' ->
              push envM envC s env e (Chandle () n e') c
          | Con n es ->
              if do_con_check envC n (List.length es) then
                match es with
                  | [] -> return envM envC s env (Conv n []) c
                  | e::es ->
                      push envM envC s env e (Ccon n [] () es) c
                end
              else
                Etype_error
          | Var n ->
              match lookup_var_id n envM env with
                | None -> Etype_error
                | Some v -> 
                    return envM envC s env v c
              end
          | Fun n e -> return envM envC s env (Closure env n e) c
          | App op e1 e2 -> push envM envC s env e1 (Capp1 op () e2) c
          | Log l e1 e2 -> push envM envC s env e1 (Clog l () e2) c
          | If e1 e2 e3 -> push envM envC s env e1 (Cif () e2 e3) c
          | Mat e pes -> push envM envC s env e (Cmat () pes) c
          | Let n e1 e2 -> push envM envC s env e1 (Clet n () e2) c
          | Letrec funs e ->
              if not (all_distinct (List.map (fun (x,y,z) -> x) funs)) then
                Etype_error
              else
                Estep (envM,envC, s, build_rec_env funs env env, Exp e, c)
          | Uapp uop e ->
              push envM envC s env e (Cuapp uop ()) c
        end
  end

(* Define a semantic function using the steps *)

type error_result =
  | Rtype_error
  | Rraise of error

type result 'a =
  | Rval of 'a
  | Rerr of error_result

val e_step_reln : state -> state -> bool
val small_eval : envM -> envC -> store -> envE -> exp -> list ctxt -> store * result v -> bool

let e_step_reln st1 st2 =
  (e_step st1 = Estep st2)

let rec
small_eval menv cenv s env e c (s', Rval v) =
  exists env'. (rtc e_step_reln) (menv,cenv,s,env,Exp e,c) (menv,cenv,s',env',Val v,[])
and
small_eval menv cenv s env e c (s', Rerr (Rraise err)) =
  exists env'. (rtc e_step_reln) (menv,cenv,s,env,Exp e,c) (menv,cenv,s',env',Exp (Raise err),[])
and
small_eval menv cenv s env e c (s', Rerr Rtype_error) =
  exists env' e' c'.
    (rtc e_step_reln) (menv,cenv,s,env,Exp e,c) (menv,cenv,s',env',e',c') &&
    (e_step (menv,cenv,s',env',e',c') = Etype_error)

val e_diverges : envM -> envC -> store -> envE -> exp -> bool
let e_diverges menv cenv s env e =
  forall menv' cenv' s' env' e' c'.
    (rtc e_step_reln) (menv,cenv,s,env,Exp e,[]) (menv',cenv',s',env', e',c')
    -->
    exists menv'' cenv'' s'' env'' e'' c''.
      e_step_reln (menv',cenv',s',env', e',c') (menv'',cenv'',s'',env'',e'',c'')

(* ------------------------ Big step semantics -------------------------- *)
val evaluate : envM -> envC -> store -> envE -> exp -> store * result v -> bool
val evaluate_list : envM -> envC -> store -> envE -> list exp -> store * result (list v) -> bool
val evaluate_match : envM -> envC -> store -> envE -> v -> list (pat * exp) -> store * result v -> bool
val evaluate_dec : option modN -> envM -> envC -> store -> envE -> dec -> store * result (envC * envE) -> bool
val evaluate_decs : option modN -> envM -> envC -> store -> envE -> list dec -> store * result (envC * envE) -> bool
val evaluate_prog : envM -> envC -> store -> envE -> prog -> store * result (envM * envC * envE) -> bool

indreln

forall menv cenv env l s.
true
==>
evaluate menv cenv s env (Lit l) (s, Rval (Litv l))

and

forall menv cenv env err s.
true
==>
evaluate menv cenv s env (Raise err) (s, Rerr (Rraise err))

and

forall menv cenv s1 s2 env e1 e2 v var.
evaluate menv cenv s1 env e1 (s2, Rval v)
==>
evaluate menv cenv s1 env (Handle e1 var e2) (s2, Rval v)

and

forall menv cenv s1 s2 env e1 e2 n var bv.
evaluate menv cenv s1 env e1 (s2, Rerr (Rraise (Int_error n))) &&
evaluate menv cenv s2 (bind var (Litv (IntLit n)) env) e2 bv
==>
evaluate menv cenv s1 env (Handle e1 var e2) bv

and

forall menv cenv s1 s2 env e1 e2 var err.
evaluate menv cenv s1 env e1 (s2, Rerr err) &&
(err = Rtype_error || err = Rraise Bind_error || err = Rraise Div_error)
==>
evaluate menv cenv s1 env (Handle e1 var e2) (s2, Rerr err)

and

forall menv cenv env cn es vs s s'.
do_con_check cenv cn (List.length es) &&
evaluate_list menv cenv s env es (s', Rval vs)
==>
evaluate menv cenv s env (Con cn es) (s', Rval (Conv cn vs))

and

forall menv cenv env cn es s.
not (do_con_check cenv cn (List.length es))
==>
evaluate menv cenv s env (Con cn es) (s, Rerr Rtype_error)

and

forall menv cenv env cn es err s s'.
do_con_check cenv cn (List.length es) &&
evaluate_list menv cenv s env es (s', Rerr err)
==>
evaluate menv cenv s env (Con cn es) (s', Rerr err)

and

forall menv cenv env n v s.
(lookup_var_id n menv env = Some v)
==>
evaluate menv cenv s env (Var n) (s, Rval v)

and

forall menv cenv env n s.
(lookup_var_id n menv env = None)
==>
evaluate menv cenv s env (Var n) (s, Rerr Rtype_error)

and

forall menv cenv env n e s.
true
==>
evaluate menv cenv s env (Fun n e) (s, Rval (Closure env n e))

and

forall menv cenv env uop e v v' s1 s2 s3.
evaluate menv cenv s1 env e (s2, Rval v) &&
do_uapp s2 uop v = Some (s3,v')
==>
evaluate menv cenv s1 env (Uapp uop e) (s3, Rval v')

and

forall menv cenv env uop e v s1 s2.
evaluate menv cenv s1 env e (s2, Rval v) &&
do_uapp s2 uop v = None
==>
evaluate menv cenv s1 env (Uapp uop e) (s2, Rerr Rtype_error)

and

forall menv cenv env uop e err s s'.
evaluate menv cenv s env e (s', Rerr err)
==>
evaluate menv cenv s env (Uapp uop e) (s', Rerr err)

and

forall menv cenv env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 s4.
evaluate menv cenv s1 env e1 (s2, Rval v1) &&
evaluate menv cenv s2 env e2 (s3, Rval v2) &&
do_app s3 env op v1 v2 = Some (s4, env', e3) &&
evaluate menv cenv s4 env' e3 bv
==>
evaluate menv cenv s1 env (App op e1 e2) bv

and

forall menv cenv env op e1 e2 v1 v2 s1 s2 s3.
evaluate menv cenv s1 env e1 (s2, Rval v1) &&
evaluate menv cenv s2 env e2 (s3, Rval v2) &&
do_app s3 env op v1 v2 = None
==>
evaluate menv cenv s1 env (App op e1 e2) (s3, Rerr Rtype_error)

and

forall menv cenv env op e1 e2 v1 err s1 s2 s3.
evaluate menv cenv s1 env e1 (s2, Rval v1) &&
evaluate menv cenv s2 env e2 (s3, Rerr err)
==>
evaluate menv cenv s1 env (App op e1 e2) (s3, Rerr err)

and

forall menv cenv env op e1 e2 err s s'.
evaluate menv cenv s env e1 (s', Rerr err)
==>
evaluate menv cenv s env (App op e1 e2) (s', Rerr err)

and

forall menv cenv env op e1 e2 v e' bv s1 s2.
evaluate menv cenv s1 env e1 (s2, Rval v) &&
do_log op v e2 = Some e' &&
evaluate menv cenv s2 env e' bv
==>
evaluate menv cenv s1 env (Log op e1 e2) bv

and

forall menv cenv env op e1 e2 v s1 s2.
evaluate menv cenv s1 env e1 (s2, Rval v) &&
do_log op v e2 = None
==>
evaluate menv cenv s1 env (Log op e1 e2) (s2, Rerr Rtype_error)

and

forall menv cenv env op e1 e2 err s s'.
evaluate menv cenv s env e1 (s', Rerr err)
==>
evaluate menv cenv s env (Log op e1 e2) (s', Rerr err)

and

forall menv cenv env e1 e2 e3 v e' bv s1 s2.
evaluate menv cenv s1 env e1 (s2, Rval v) &&
do_if v e2 e3 = Some e' &&
evaluate menv cenv s2 env e' bv
==>
evaluate menv cenv s1 env (If e1 e2 e3) bv

and

forall menv cenv env e1 e2 e3 v s1 s2.
evaluate menv cenv s1 env e1 (s2, Rval v) &&
do_if v e2 e3 = None
==>
evaluate menv cenv s1 env (If e1 e2 e3) (s2, Rerr Rtype_error)

and

forall menv cenv env e1 e2 e3 err s s'.
evaluate menv cenv s env e1 (s', Rerr err)
==>
evaluate menv cenv s env (If e1 e2 e3) (s', Rerr err)

and

forall menv cenv env e pes v bv s1 s2.
evaluate menv cenv s1 env e (s2, Rval v) &&
evaluate_match menv cenv s2 env v pes bv
==>
evaluate menv cenv s1 env (Mat e pes) bv

and

forall menv cenv env e pes err s s'.
evaluate menv cenv s env e (s', Rerr err)
==>
evaluate menv cenv s env (Mat e pes) (s', Rerr err)

and

forall menv cenv env n e1 e2 v bv s1 s2.
evaluate menv cenv s1 env e1 (s2, Rval v) &&
evaluate menv cenv s2 (bind n v env) e2 bv
==>
evaluate menv cenv s1 env (Let n e1 e2) bv

and

forall menv cenv env n e1 e2 err s s'.
evaluate menv cenv s env e1 (s', Rerr err)
==>
evaluate menv cenv s env (Let n e1 e2) (s', Rerr err)

and

forall menv cenv env funs e bv s.
all_distinct (List.map (fun (x,y,z) -> x) funs) &&
evaluate menv cenv s (build_rec_env funs env env) e bv
==>
evaluate menv cenv s env (Letrec funs e) bv

and

forall menv cenv env funs e s.
not (all_distinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate menv cenv s env (Letrec funs e) (s, Rerr Rtype_error)

and

forall menv cenv env s.
true
==>
evaluate_list menv cenv s env [] (s, Rval [])

and

forall menv cenv env e es v vs s1 s2 s3.
evaluate menv cenv s1 env e (s2, Rval v) &&
evaluate_list menv cenv s2 env es (s3, Rval vs)
==>
evaluate_list menv cenv s1 env (e::es) (s3, Rval (v::vs))

and

forall menv cenv env e es err s s'.
evaluate menv cenv s env e (s', Rerr err)
==>
evaluate_list menv cenv s env (e::es) (s', Rerr err)

and

forall menv cenv env e es v err s1 s2 s3.
evaluate menv cenv s1 env e (s2, Rval v) &&
evaluate_list menv cenv s2 env es (s3, Rerr err)
==>
evaluate_list menv cenv s1 env (e::es) (s3, Rerr err)

and

forall menv cenv env v s.
true
==>
evaluate_match menv cenv s env v [] (s, Rerr (Rraise Bind_error))

and

forall menv cenv env v p e pes env' bv s.
all_distinct (pat_bindings p []) &&
(pmatch cenv s p v env = Match env') &&
evaluate menv cenv s env' e bv
==>
evaluate_match menv cenv s env v ((p,e)::pes) bv

and

forall menv cenv env v p e pes bv s.
all_distinct (pat_bindings p []) &&
(pmatch cenv s p v env = No_match) &&
evaluate_match menv cenv s env v pes bv
==>
evaluate_match menv cenv s env v ((p,e)::pes) bv

and

forall menv cenv env v p e pes s.
(pmatch cenv s p v env = Match_type_error)
==>
evaluate_match menv cenv s env v ((p,e)::pes) (s, Rerr Rtype_error)

and

forall menv cenv env v p e pes s.
not (all_distinct (pat_bindings p []))
==>
evaluate_match menv cenv s env v ((p,e)::pes) (s, Rerr Rtype_error)

(* Semantic helpers for definitions *)

(* Add the given type definition to the given constructor environment *)
val build_tdefs : option modN -> list (list tvarN * typeN * list (conN * list t)) -> envC
let build_tdefs mn tds =
  List.flatten
    (List.map
      (fun (tvs, tn, condefs) ->
         List.map
           (fun (conN, ts) ->
              (mk_id mn conN, (List.length ts, mk_id mn tn)))
           condefs)
      tds)

(* Checks that no constructor is defined twice *)
val check_dup_ctors :
    forall 'a. option modN -> env (id conN) 'a -> list (list tvarN * typeN * list (conN * list t)) -> bool
let check_dup_ctors mn_opt cenv tds =
  (forall ((tvs, tn, condefs) MEM tds) ((n, ts) MEM condefs).
     lookup (mk_id mn_opt n) cenv = None)
  &&
  all_distinct [ n | forall ((tvs, tn, condefs) MEM tds) ((n, ts) MEM condefs) | true ]

indreln

forall mn menv cenv env p e v env' s1 s2.
evaluate menv cenv s1 env e (s2, Rval v) &&
all_distinct (pat_bindings p []) &&
(pmatch cenv s2 p v emp = Match env')
==>
evaluate_dec mn menv cenv s1 env (Dlet p e) (s2, Rval (emp, env'))

and

forall mn menv cenv env p e v s1 s2.
evaluate menv cenv s1 env e (s2, Rval v) &&
all_distinct (pat_bindings p []) &&
(pmatch cenv s2 p v emp = No_match)
==>
evaluate_dec mn menv cenv s1 env (Dlet p e) (s2, Rerr (Rraise Bind_error))

and

forall mn menv cenv env p e v s1 s2.
evaluate menv cenv s1 env e (s2, Rval v) &&
(pmatch cenv s2 p v emp = Match_type_error)
==>
evaluate_dec mn menv cenv s1 env (Dlet p e) (s2, Rerr Rtype_error)

and

forall mn menv cenv env p e v s1 s2.
evaluate menv cenv s1 env e (s2, Rval v) &&
not (all_distinct (pat_bindings p []))
==>
evaluate_dec mn menv cenv s1 env (Dlet p e) (s2, Rerr Rtype_error)

and

forall mn menv cenv env p e err s s'.
evaluate menv cenv s env e (s', Rerr err)
==>
evaluate_dec mn menv cenv s env (Dlet p e) (s', Rerr err)

and

forall mn menv cenv env funs s.
all_distinct (List.map (fun (x,y,z) -> x) funs)
==>
evaluate_dec mn menv cenv s env (Dletrec funs) (s, Rval (emp, build_rec_env funs env emp))

and

forall mn menv cenv env funs s.
not (all_distinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate_dec mn menv cenv s env (Dletrec funs) (s, Rerr Rtype_error)

and

forall mn menv cenv env tds s.
check_dup_ctors mn cenv tds
==>
evaluate_dec mn menv cenv s env (Dtype tds) (s, Rval (build_tdefs mn tds, emp))

and

forall mn menv cenv env tds s.
not (check_dup_ctors mn cenv tds)
==>
evaluate_dec mn menv cenv s env (Dtype tds) (s, Rerr Rtype_error)

val combine_dec_result : forall 'a 'b 'c 'd. env 'a 'b -> env 'c 'd -> result (env 'a 'b * env 'c 'd) -> result (env 'a 'b * env 'c 'd)
let combine_dec_result cenv env r =
  match r with
    | Rerr e -> Rerr e
    | Rval (cenv',env') -> Rval (merge cenv' cenv, merge env' env)
  end

indreln

forall mn menv cenv s env.
true
==>
evaluate_decs mn menv cenv s env [] (s, Rval (emp, emp))

and

forall mn menv cenv s1 s2 env d ds e.
evaluate_dec mn menv cenv s1 env d (s2, Rerr e)
==>
evaluate_decs mn menv cenv s1 env (d::ds) (s2, Rerr e)

and

forall mn menv cenv s1 s2 s3 env d ds new_tds new_env r.
evaluate_dec mn menv cenv s1 env d (s2, Rval (new_tds,new_env)) &&
evaluate_decs mn menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, r)
==>
evaluate_decs mn menv cenv s1 env (d::ds) (s3, combine_dec_result new_tds new_env r)

val combine_mod_result : forall 'a 'b 'c 'd 'e 'f. env 'a 'b -> env 'c 'd -> env 'e 'f -> result (env 'a 'b * env 'c 'd * env 'e 'f) -> result (env 'a 'b * env 'c 'd * env 'e 'f)
let combine_mod_result menv cenv env r =
  match r with
    | Rerr e -> Rerr e
    | Rval (menv',cenv',env') -> Rval (merge menv' menv, merge cenv' cenv, merge env' env)
  end

indreln

forall menv cenv s env.
true
==>
evaluate_prog menv cenv s env [] (s, Rval (emp, emp, emp))

and

forall menv cenv s1 s2 s3 env d ds new_tds new_env r.
evaluate_dec None menv cenv s1 env d (s2, Rval (new_tds,new_env)) &&
evaluate_prog menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, r)
==>
evaluate_prog menv cenv s1 env (Tdec d::ds) (s3, combine_mod_result emp new_tds new_env r)

and

forall menv cenv s1 s2 env d ds e.
evaluate_dec None menv cenv s1 env d (s2, Rerr e)
==>
evaluate_prog menv cenv s1 env (Tdec d::ds) (s2, Rerr e)

and

forall menv cenv s1 s2 s3 env ds1 ds2 mn specs new_tds new_env r.
not (List.mem mn (List.map fst menv)) &&
evaluate_decs (Some mn) menv cenv s1 env ds1 (s2, Rval (new_tds,new_env)) &&
evaluate_prog (bind mn new_env menv) (merge new_tds cenv) s2 env ds2 (s3, r)
==>
evaluate_prog menv cenv s1 env (Tmod mn specs ds1::ds2) (s3, combine_mod_result [(mn,new_env)] new_tds emp r)

and

forall menv cenv s1 s2 env mn specs ds1 ds2 e.
not (List.mem mn (List.map fst menv)) &&
evaluate_decs (Some mn) menv cenv s1 env ds1 (s2, Rerr e)
==>
evaluate_prog menv cenv s1 env (Tmod mn specs ds1::ds2) (s2, Rerr e)

and

forall menv cenv s env mn specs ds1 ds2.
List.mem mn (List.map fst menv)
==>
evaluate_prog menv cenv s env (Tmod mn specs ds1::ds2) (s, Rerr Rtype_error)


val dec_diverges : envM -> envC -> store -> envE -> dec -> bool
val decs_diverges : option modN -> envM -> envC -> store -> envE -> decs -> bool
val prog_diverges : envM -> envC -> store -> envE -> prog -> bool

let dec_diverges menv cenv st env d =
  match d with
    | Dlet p e -> e_diverges menv cenv st env e
    | Dletrec funs -> false
    | Dtype tds -> false
  end

indreln

forall mn menv cenv st env d ds.
dec_diverges menv cenv st env d
==>
decs_diverges mn menv cenv st env (d::ds) 

and

forall mn menv cenv s1 s2 env d ds new_tds new_env.
evaluate_dec mn menv cenv s1 env d (s2, Rval (new_tds, new_env)) &&
decs_diverges mn menv (merge new_tds cenv) s2 (merge new_env env) ds
==>
decs_diverges mn menv cenv s1 env (d::ds)

indreln

forall menv cenv st env d ds.
dec_diverges menv cenv st env d
==>
prog_diverges menv cenv st env (Tdec d::ds)

and

forall menv cenv s1 s2 env d ds new_tds new_env.
evaluate_dec None menv cenv s1 env d (s2, Rval (new_tds, new_env)) &&
prog_diverges menv (merge new_tds cenv) s2 (merge new_env env) ds
==>
prog_diverges menv cenv s1 env (Tdec d::ds) 

and

forall menv cenv s1 env ds1 ds2 mn specs.
not (List.mem mn (List.map fst menv)) &&
decs_diverges (Some mn) menv cenv s1 env ds1
==>
prog_diverges menv cenv s1 env (Tmod mn specs ds1::ds2)

and

forall menv cenv s1 s2 env ds1 ds2 mn specs new_tds new_env.
not (List.mem mn (List.map fst menv)) &&
evaluate_decs (Some mn) menv cenv s1 env ds1 (s2, Rval (new_tds,new_env)) &&
prog_diverges (bind mn new_env menv) (merge new_tds cenv) s2 env ds2
==>
prog_diverges menv cenv s1 env (Tmod mn specs ds1::ds2)


(* ------------------------------------------------------------------------ *) 
(*   The Type System                                                        *)
(* ------------------------------------------------------------------------ *) 


(* constructor type environments: each constructor has a type
 * forall tyvars. t list -> (tyvars) typeN *)
type tenvC = env (id conN) (list tvarN * list t * id typeN)

(* Type environments *)
type tenvE =
  | Empty
  (* Binds several de Bruijn type variables *)
  | Bind_tvar of num * tenvE
  (* The number is how many de Bruijn type variables the typescheme binds *)
  | Bind_name of varN * num * t * tenvE

type tenvM = env modN (env varN (num * t))

let bind_tvar tvs tenv = if tvs = 0 then tenv else Bind_tvar tvs tenv

val lookup_tenv : varN -> num -> tenvE -> option (num * t) 
let rec
lookup_tenv n inc Empty = None
and
lookup_tenv n inc (Bind_tvar tvs e) = lookup_tenv n (inc + tvs) e
and
lookup_tenv n inc (Bind_name n' tvs t e) =
  if n' = n then
    Some (tvs, deBruijn_inc tvs inc t)
  else
    lookup_tenv n inc e

val bind_tenv : varN -> num -> t -> tenvE -> tenvE
let bind_tenv n tvs t e = Bind_name n tvs t e

val t_lookup_var_id : id varN -> tenvM -> tenvE -> option (num * t)
let t_lookup_var_id id tenvM tenvE =
  match id with
    | Short x -> lookup_tenv x 0 tenvE
    | Long x y ->
        match lookup x tenvM with
          | None -> None
          | Some tenvE' -> lookup y tenvE'
        end
  end

val num_tvs : tenvE -> num
let rec 
num_tvs Empty = 0
and
num_tvs (Bind_tvar tvs e) = tvs + num_tvs e
and
num_tvs (Bind_name n tvs t e) = num_tvs e

(* A pattern matches values of a certain type and extends the type environment
 * with the pattern's binders. The number is the maximum deBruijn type variable
 * allowed. *)
val type_p : num -> tenvC -> pat -> t -> list (varN * t) -> bool

(* An expression has a type *)
val type_e : tenvM -> tenvC -> tenvE -> exp -> t -> bool

(* A list of expressions has a list of types *)
val type_es : tenvM -> tenvC -> tenvE -> list exp -> list t -> bool

(* Type a mutually recursive bundle of functions.  Unlike pattern typing, the
 * resulting environment does not extend the input environment, but just
 * represents the functions *)
val type_funs : tenvM -> tenvC -> tenvE -> list (varN * varN * exp) ->
                list (varN * t) -> bool

(* Check a declaration and update the top-level environments *)
val type_d : option modN -> tenvM -> tenvC -> tenvE -> dec -> tenvC -> env varN (num * t) -> bool

val type_ds : option modN -> tenvM -> tenvC -> tenvE -> list dec -> tenvC -> env varN (num * t) -> bool
val weakE : env varN (num * t) -> env varN (num * t) -> bool
val weakC : tenvC -> tenvC -> bool
val check_signature : option modN -> tenvC -> env varN (num * t) -> option specs -> tenvC -> env varN (num * t) -> bool
val type_specs : option modN -> tenvC -> env varN (num * t) -> specs -> tenvC -> env varN (num * t) -> bool
val type_prog : tenvM -> tenvC -> tenvE -> list top -> tenvM -> tenvC -> env varN (num * t) -> bool

(* Check that the operator can have type (t1 -> t2 -> t3) *)
val type_op : op -> t -> t -> t -> bool
let type_op op t1 t2 t3 =
  match (op,t1,t2) with
    | (Opapp, Tapp [t2'; t3'] TC_fn, _) -> (t2 = t2') && (t3 = t3')
    | (Opn _, Tapp [] TC_int, Tapp [] TC_int) -> (t3 = Tint)
    | (Opb _, Tapp [] TC_int, Tapp [] TC_int) -> (t3 = Tbool)
    | (Equality, t1, t2) -> (t1 = t2) && (t3 = Tbool)
    | (Opassign, Tapp [t1] TC_ref, t2) -> (t1 = t2) && (t3 = Tunit)
    | _ -> false
  end

(* Check that the operator can have type (t1 -> t2) *)
val type_uop : uop -> t -> t -> bool
let type_uop uop t1 t2 =
  match (uop,t1) with
    | (Opref, _) -> t2 = Tref t1
    | (Opderef, Tapp [t1'] TC_ref) -> t2 = t1'
    | _ -> false
  end

(* Check that the free type variables are in the given list.  Every deBruijn
 * variable must be smaller than the first argument.  So if it is 0, no deBruijn
 * indices are permitted. *)
val check_freevars : num -> list tvarN -> t -> bool
let rec
check_freevars dbmax tvs (Tvar tv) =
  List.mem tv tvs
and
check_freevars dbmax tvs (Tapp ts tn) =
  List.for_all (check_freevars dbmax tvs) ts
and
check_freevars dbmax tvs (Tvar_db n) = n < dbmax

(* Check that a type definition defines no already defined (or duplicate)
 * constructors or types, and that the free type variables of each constructor
 * argument type are included in the type's type parameters. *)
val check_ctor_tenv :
   option modN -> tenvC -> list (list tvarN * typeN * list (conN * list t)) -> bool
let check_ctor_tenv mn tenvC tds =
  check_dup_ctors mn tenvC tds &&
  List.for_all
    (fun (tvs,tn,ctors) ->
       all_distinct tvs &&
       List.for_all
         (fun (cn,ts) -> (List.for_all (check_freevars 0 tvs) ts))
         ctors)
    tds &&
  all_distinct (List.map (fun (_,tn,_) -> tn) tds) &&
  List.for_all
    (fun (tvs,tn,ctors) ->
       List.for_all (fun (_,(_,_,tn')) -> mk_id mn tn <> tn') tenvC)
    tds

val build_ctor_tenv : option modN -> list (list tvarN * typeN * list (conN * list t)) -> tenvC
let build_ctor_tenv mn tds =
  List.flatten
    (List.map
       (fun (tvs,tn,ctors) ->
          List.map (fun (cn,ts) -> (mk_id mn cn,(tvs,ts, mk_id mn tn))) ctors)
       tds)

(* Simultaneous substitution of types for type variables in a type *)
val type_subst : env tvarN t -> t -> t
let rec
type_subst s (Tvar tv) =
  match lookup tv s with
    | None -> Tvar tv
    | Some(t) -> t
  end
and
type_subst s (Tapp ts tn) =
  Tapp (List.map (type_subst s) ts) tn
and
type_subst s (Tvar_db n) = Tvar_db n

val bind_var_list : num -> list (varN * t) -> tenvE -> tenvE
let rec
bind_var_list tvs [] tenv = tenv
and
bind_var_list tvs ((n,t)::binds) tenv =
  bind_tenv n tvs t (bind_var_list tvs binds tenv)

val bind_var_list2 : env varN (num * t) -> tenvE -> tenvE
let rec
bind_var_list2 [] tenv = tenv
and
bind_var_list2 ((n,(tvs,t))::binds) tenv =
  bind_tenv n tvs t (bind_var_list2 binds tenv)


(* For the value restriction on let-based polymorphism *)
val is_value : exp -> bool
let rec 
is_value (Lit _) = true
and
is_value (Con _ es) = List.for_all is_value es
and
is_value (Var _) = true
and
is_value (Fun _ _) = true
and
is_value _ = false

indreln

forall tvs cenv n t.
check_freevars tvs [] t
==>
type_p tvs cenv (Pvar n) t [(n,t)]

and

forall tvs cenv b.
true
==>
type_p tvs cenv (Plit (Bool b)) Tbool []

and

forall tvs cenv n.
true
==>
type_p tvs cenv (Plit (IntLit n)) Tint []

and

forall tvs cenv.
true
==>
type_p tvs cenv (Plit Unit) Tunit []

and

forall tvs cenv cn ps ts tvs' tn ts' tenv.
List.for_all (check_freevars tvs []) ts' &&
List.length ts' = List.length tvs' &&
type_ps tvs cenv ps (List.map (type_subst (List.combine tvs' ts')) ts) tenv &&
lookup cn cenv = Some (tvs', ts, tn)
==>
type_p tvs cenv (Pcon cn ps) (Tapp ts' (TC_name tn)) tenv

and

forall tvs cenv p t tenv.
type_p tvs cenv p t tenv
==>
type_p tvs cenv (Pref p) (Tref t) tenv

and

forall tvs cenv.
true
==>
type_ps tvs cenv [] [] []

and

forall tvs cenv p ps t ts tenv tenv'.
type_p tvs cenv p t tenv &&
type_ps tvs cenv ps ts tenv'
==>
type_ps tvs cenv (p::ps) (t::ts) (tenv'@tenv)

indreln

forall menv cenv tenv b.
true
==>
type_e menv cenv tenv (Lit (Bool b)) Tbool

and

forall menv cenv tenv n.
true
==>
type_e menv cenv tenv (Lit (IntLit n)) Tint

and

forall menv cenv tenv.
true
==>
type_e menv cenv tenv (Lit Unit) Tunit

and

forall menv cenv tenv err t.
check_freevars (num_tvs tenv) [] t
==>
type_e menv cenv tenv (Raise err) t

and

forall menv cenv tenv e1 var e2 t.
type_e menv cenv tenv e1 t &&
type_e menv cenv (bind_tenv var 0 Tint tenv) e2 t
==>
type_e menv cenv tenv (Handle e1 var e2) t

and

forall menv cenv tenv cn es tvs tn ts' ts.
List.for_all (check_freevars (num_tvs tenv) []) ts' &&
List.length tvs = List.length ts' &&
type_es menv cenv tenv es (List.map (type_subst (List.combine tvs ts')) ts) &&
lookup cn cenv = Some (tvs, ts, tn)
==>
type_e menv cenv tenv (Con cn es) (Tapp ts' (TC_name tn))

and

forall menv cenv tenv n t targs tvs.
(tvs = List.length targs) &&
List.for_all (check_freevars (num_tvs tenv) []) targs &&
(t_lookup_var_id n menv tenv = Some (tvs,t))
==>
type_e menv cenv tenv (Var n) (deBruijn_subst 0 targs t)

and

forall menv cenv tenv n e t1 t2.
check_freevars (num_tvs tenv) [] t1 &&
type_e menv cenv (bind_tenv n 0 t1 tenv) e t2
==>
type_e menv cenv tenv (Fun n e) (Tfn t1 t2)

and

forall menv cenv tenv uop e t1 t2.
type_e menv cenv tenv e t1 &&
type_uop uop t1 t2
==>
type_e menv cenv tenv (Uapp uop e) t2

and

forall menv cenv tenv op e1 e2 t1 t2 t3.
type_e menv cenv tenv e1 t1 &&
type_e menv cenv tenv e2 t2 &&
type_op op t1 t2 t3
==>
type_e menv cenv tenv (App op e1 e2) t3

and

forall menv cenv tenv l e1 e2.
type_e menv cenv tenv e1 Tbool &&
type_e menv cenv tenv e2 Tbool
==>
type_e menv cenv tenv (Log l e1 e2) Tbool

and

forall menv cenv tenv e1 e2 e3 t.
type_e menv cenv tenv e1 Tbool &&
type_e menv cenv tenv e2 t &&
type_e menv cenv tenv e3 t
==>
type_e menv cenv tenv (If e1 e2 e3) t

and

forall menv cenv tenv e pes t1 t2.
type_e menv cenv tenv e t1 &&
(pes <> []) &&
(forall ((p,e) MEM pes) . exists tenv'.
   all_distinct (pat_bindings p []) &&
   type_p (num_tvs tenv) cenv p t1 tenv' &&
   type_e menv cenv (bind_var_list 0 tenv' tenv) e t2)
==>
type_e menv cenv tenv (Mat e pes) t2

and

forall menv cenv tenv n e1 e2 t1 t2 tvs.
is_value e1 &&
type_e menv cenv (bind_tvar tvs tenv) e1 t1 &&
type_e menv cenv (bind_tenv n tvs t1 tenv) e2 t2
==>
type_e menv cenv tenv (Let n e1 e2) t2

and

forall menv cenv tenv n e1 e2 t1 t2.
type_e menv cenv tenv e1 t1 &&
type_e menv cenv (bind_tenv n 0 t1 tenv) e2 t2
==>
type_e menv cenv tenv (Let n e1 e2) t2

and

forall menv cenv tenv funs e t tenv' tvs.
type_funs menv cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv' &&
type_e menv cenv (bind_var_list tvs tenv' tenv) e t
==>
type_e menv cenv tenv (Letrec funs e) t

and

forall menv cenv tenv.
true
==>
type_es menv cenv tenv [] []

and

forall menv cenv tenv e es t ts.
type_e menv cenv tenv e t &&
type_es menv cenv tenv es ts
==>
type_es menv cenv tenv (e::es) (t::ts)

and

forall menv cenv env.
true
==>
type_funs menv cenv env [] []

and

forall menv cenv env fn n e funs env' t1 t2.
check_freevars (num_tvs env) [] (Tfn t1 t2) &&
type_e menv cenv (bind_tenv n 0 t1 env) e t2 &&
type_funs menv cenv env funs env' &&
lookup fn env' = None
==>
type_funs menv cenv env ((fn, n, e)::funs) ((fn, Tfn t1 t2)::env')

val tenv_add_tvs : num -> env varN t -> env varN (num * t)
let tenv_add_tvs tvs tenv =
  List.map (fun (n,t) -> (n,(tvs,t))) tenv

indreln

forall tvs mn menv cenv tenv p e t tenv'.
is_value e &&
all_distinct (pat_bindings p []) &&
type_p tvs cenv p t tenv' &&
type_e menv cenv (bind_tvar tvs tenv) e t
==>
type_d mn menv cenv tenv (Dlet p e) emp (tenv_add_tvs tvs tenv')

and

forall mn menv cenv tenv p e t tenv'.
all_distinct (pat_bindings p []) &&
type_p 0 cenv p t tenv' &&
type_e menv cenv tenv e t
==>
type_d mn menv cenv tenv (Dlet p e) emp (tenv_add_tvs 0 tenv')

and

forall mn menv cenv tenv funs tenv' tvs.
type_funs menv cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv'
==>
type_d mn menv cenv tenv (Dletrec funs) emp (tenv_add_tvs tvs tenv')

and

forall mn menv cenv tenv tdecs.
check_ctor_tenv mn cenv tdecs
==>
type_d mn menv cenv tenv (Dtype tdecs) (build_ctor_tenv mn tdecs) emp

indreln

forall mn menv cenv tenv.
true
==>
type_ds mn menv cenv tenv [] emp emp

and

forall mn menv cenv tenv d ds cenv' tenv' cenv'' tenv''.
type_d mn menv cenv tenv d cenv' tenv' &&
type_ds mn menv (merge cenv' cenv) (bind_var_list2 tenv' tenv) ds cenv'' tenv''
==>
type_ds mn menv cenv tenv (d::ds) (merge cenv'' cenv') (merge tenv'' tenv')

indreln

forall cenv tenv mn.
true
==>
type_specs mn cenv tenv [] cenv tenv

and

forall mn cenv tenv x t specs cenv' tenv' fvs.
check_freevars 0 fvs t &&
type_specs mn cenv (bind x (List.length fvs, type_subst (List.combine fvs (List.map Tvar_db (count_list (List.length fvs)))) t) tenv) specs cenv' tenv'
==>
type_specs mn cenv tenv (Sval x t :: specs) cenv' tenv' 

and

forall mn cenv tenv td specs cenv' tenv'.
check_ctor_tenv mn cenv td &&
type_specs mn (merge (build_ctor_tenv mn td) cenv) tenv specs cenv' tenv'
==>
type_specs mn cenv tenv (Stype td :: specs) cenv' tenv'

and

forall mn cenv tenv tn specs cenv' tenv'.
List.for_all (fun (_,(_,_,tn')) -> mk_id mn tn <> tn') cenv &&
type_specs mn cenv tenv specs cenv' tenv'
==>
type_specs mn cenv tenv (Stype_opq tn :: specs) cenv' tenv'

let weakE tenv_impl tenv_spec =
  forall x.
    match lookup x tenv_spec with
      | Some (tvs_spec, t_spec) ->
          match lookup x tenv_impl with
            | None -> false
            | Some (tvs_impl, t_impl) ->
                exists subst. 
                  List.length subst = tvs_impl &&
                  check_freevars tvs_impl [] t_impl &&
                  List.for_all (check_freevars tvs_spec []) subst &&
                  deBruijn_subst 0 subst t_impl = t_spec
          end
        | None -> true
    end

let weakC cenv_impl cenv_spec =
  forall cn.
    match lookup cn cenv_spec with
      | Some (tvs_spec,ts_spec,tn_spec) ->
          match lookup cn cenv_impl with
            | None -> false
            | Some (tvs_impl, ts_impl, tn_impl) ->
                tn_spec = tn_impl &&
                (* For simplicity, we reject matches that differ only by renaming of bound type variables *)
                tvs_spec = tvs_impl &&
                ts_spec = ts_impl 
          end
      | None -> true
    end

indreln

forall mn cenv tenv.
true
==>
check_signature mn cenv tenv None cenv tenv

and

forall mn cenv tenv specs tenv' cenv'.
weakE tenv tenv' &&
weakC cenv cenv' &&
type_specs mn emp emp specs cenv' tenv'
==>
check_signature mn cenv tenv (Some specs) cenv' tenv'

indreln

forall menv cenv tenv.
true
==>
type_prog menv cenv tenv [] emp emp emp

and

forall menv cenv tenv d ds cenv' tenv' menv'' cenv'' tenv''.
type_d None menv cenv tenv d cenv' tenv' &&
type_prog menv (merge cenv' cenv) (bind_var_list2 tenv' tenv) ds menv'' cenv'' tenv''
==>
type_prog menv cenv tenv (Tdec d :: ds) menv'' (merge cenv'' cenv') (merge tenv'' tenv')

and

forall menv cenv tenv mn spec ds1 ds2 cenv' menv'' tenv' cenv'' tenv'' cenv''' tenv'''.
not (List.mem mn (List.map fst menv)) &&
type_ds (Some mn) menv cenv tenv ds1 cenv' tenv' &&
check_signature (Some mn) cenv' tenv' spec cenv'' tenv'' &&
type_prog (bind mn tenv'' menv) (merge cenv'' cenv) tenv ds2 menv'' cenv''' tenv'''
==>
type_prog menv cenv tenv (Tmod mn spec ds1 :: ds2) (merge menv'' [(mn,tenv'')]) (merge cenv''' cenv'') tenv'''

(* ------------------------------------------------------------------------ *) 
(*   Auxiliary definitions used in the proofs                               *)
(* ------------------------------------------------------------------------ *) 

(* Store typing *)
type tenvS = env num t

(* A value has a type *)
(* The number is how many deBruijn type variables are bound in the context. *)
val type_v : num -> tenvM -> tenvC -> tenvS -> v -> t -> bool

(* A value environment has a corresponding type environment.  Since all of the
 * entries in the environment are values, and values have no free variables,
 * each entry in the environment can be typed in the empty environment (if at
 * all) *)
val type_env : tenvM -> tenvC -> tenvS -> envE -> tenvE -> bool

(* The type of the store *)
val type_s : tenvM -> tenvC -> tenvS -> store -> bool

(* An evaluation context has the second type when its hole is filled with a
 * value of the first type. *)
(* The number is how many deBruijn type variables are bound in the context.
 * This is only used for constructor contexts, because the value restriction 
 * ensures that no other contexts can be created under a let binding. *)
val type_ctxt : num -> tenvM -> tenvC -> tenvS -> tenvE -> ctxt_frame -> t -> t -> bool
val type_ctxts : num -> tenvM -> tenvC -> tenvS -> list ctxt -> t -> t -> bool
val type_state : num -> tenvM -> tenvC -> tenvS -> state -> t -> bool
val context_invariant : num -> list ctxt -> num -> bool

(* Type programs without imposing signatures.  This is needed for the type
 * soundness proof *)
val type_prog_ignore_sig : tenvM -> tenvC -> tenvE -> list top -> tenvM -> tenvC -> env varN (num * t) -> bool


indreln

forall menv cenv tenv.
true
==>
type_prog_ignore_sig menv cenv tenv [] emp emp emp

and

forall menv cenv tenv d ds cenv' tenv' menv'' cenv'' tenv''.
type_d None menv cenv tenv d cenv' tenv' &&
type_prog_ignore_sig menv (merge cenv' cenv) (bind_var_list2 tenv' tenv) ds menv'' cenv'' tenv''
==>
type_prog_ignore_sig menv cenv tenv (Tdec d :: ds) menv'' (merge cenv'' cenv') (merge tenv'' tenv')

and

forall menv cenv tenv mn spec ds1 ds2 cenv' menv'' tenv' cenv'' tenv''.
not (List.mem mn (List.map fst menv)) &&
type_ds (Some mn) menv cenv tenv ds1 cenv' tenv' &&
type_prog_ignore_sig (bind mn tenv' menv) (merge cenv' cenv) tenv ds2 menv'' cenv'' tenv''
==>
type_prog_ignore_sig menv cenv tenv (Tmod mn spec ds1 :: ds2) (merge menv'' [(mn,tenv')]) (merge cenv'' cenv') tenv''


indreln

forall tvs menv cenv senv b.
true
==>
type_v tvs menv cenv senv (Litv (Bool b)) Tbool

and

forall tvs menv cenv senv n.
true
==>
type_v tvs menv cenv senv (Litv (IntLit n)) Tint

and

forall tvs menv cenv senv.
true
==>
type_v tvs menv cenv senv (Litv Unit) Tunit

and

forall tvs menv cenv senv cn vs tvs' tn ts' ts.
List.for_all (check_freevars tvs []) ts' &&
List.length tvs' = List.length ts' &&
type_vs tvs menv cenv senv vs (List.map (type_subst (List.combine tvs' ts')) ts) &&
lookup cn cenv = Some (tvs', ts, tn)
==>
type_v tvs menv cenv senv (Conv cn vs) (Tapp ts' (TC_name tn))

and

forall tvs menv cenv senv env tenv n e t1 t2.
type_env menv cenv senv env tenv &&
check_freevars tvs [] t1 &&
type_e menv cenv (bind_tenv n 0 t1 (bind_tvar tvs tenv)) e t2
==>
type_v tvs menv cenv senv (Closure env n e) (Tfn t1 t2)

and

forall tvs menv cenv senv env funs n t tenv tenv'.
type_env menv cenv senv env tenv &&
type_funs menv cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv' &&
lookup n tenv' = Some t
==>
type_v tvs menv cenv senv (Recclosure env funs n) t

and

forall tvs menv cenv senv n t.
check_freevars 0 [] t &&
(lookup n senv = Some t)
==>
type_v tvs menv cenv senv (Loc n) (Tref t)

and

forall tvs menv cenv senv.
true
==>
type_vs tvs menv cenv senv [] []

and

forall tvs menv cenv senv v vs t ts.
type_v tvs menv cenv senv v t &&
type_vs tvs menv cenv senv vs ts
==>
type_vs tvs menv cenv senv (v::vs) (t::ts)

and

forall menv cenv senv.
true
==>
type_env menv cenv senv emp Empty

and

forall menv cenv senv n v env t tenv tvs.
type_v tvs menv cenv senv v t &&
type_env menv cenv senv env tenv
==>
type_env menv cenv senv (bind n v env) (bind_tenv n tvs t tenv)

let type_s menv cenv senv s =
  forall l. 
    ((exists t. lookup l senv = Some t) = (exists v. store_lookup l s = Some v)) &&
    forall t v. ((lookup l senv = Some t) && (store_lookup l s = Some v)) --> type_v 0 menv cenv senv v t

indreln 

forall n.
true
==>
context_invariant n [] n

and

forall dec_tvs c x e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Chandle () x e,env) :: c) 0

and

forall dec_tvs c op e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Capp1 op () e,env) :: c) 0

and

forall dec_tvs c op v env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Capp2 op v (),env) :: c) 0

and

forall dec_tvs c l e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Clog l () e,env) :: c) 0

and

forall dec_tvs c e1 e2 env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cif () e1 e2,env) :: c) 0

and

forall dec_tvs c pes env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cmat () pes,env) :: c) 0

and

forall dec_tvs c tvs x e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Clet x () e,env) :: c) tvs

and

forall dec_tvs c cn vs es tvs env.
context_invariant dec_tvs c tvs &&
(tvs <> 0 --> List.for_all is_value es)
==>
context_invariant dec_tvs ((Ccon cn vs () es,env) :: c) tvs

and

forall dec_tvs c op env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cuapp op (),env) :: c) 0

indreln

forall tvs menv cenv senv tenv x e t.
type_e menv cenv (bind_tenv x 0 Tint tenv) e t
==>
type_ctxt tvs menv cenv senv tenv (Chandle () x e) t t

and

forall tvs menv cenv senv tenv uop t1 t2.
check_freevars tvs [] t1 &&
check_freevars tvs [] t2 &&
type_uop uop t1 t2
==>
type_ctxt tvs menv cenv senv tenv (Cuapp uop ()) t1 t2

and

forall tvs menv cenv senv tenv e op t1 t2 t3.
check_freevars tvs [] t1 &&
check_freevars tvs [] t3 &&
type_e menv cenv tenv e t2 &&
type_op op t1 t2 t3
==>
type_ctxt tvs menv cenv senv tenv (Capp1 op () e) t1 t3

and

forall tvs menv cenv senv tenv op v t1 t2 t3.
check_freevars tvs [] t2 &&
check_freevars tvs [] t3 &&
type_v 0 menv cenv senv v t1 &&
type_op op t1 t2 t3
==>
type_ctxt tvs menv cenv senv tenv (Capp2 op v ()) t2 t3

and

forall tvs menv cenv senv tenv op e.
type_e menv cenv tenv e Tbool
==>
type_ctxt tvs menv cenv senv tenv (Clog op () e) Tbool Tbool

and

forall tvs menv cenv senv tenv e1 e2 t.
type_e menv cenv tenv e1 t &&
type_e menv cenv tenv e2 t
==>
type_ctxt tvs menv cenv senv tenv (Cif () e1 e2) Tbool t

and

forall tvs menv cenv senv tenv t1 t2 pes.
((pes = []) --> (check_freevars tvs [] t1 && check_freevars 0 [] t2)) &&
(forall ((p,e) MEM pes) . exists tenv'.
   all_distinct (pat_bindings p []) &&
   type_p tvs cenv p t1 tenv' &&
   type_e menv cenv (bind_var_list 0 tenv' tenv) e t2)
==>
type_ctxt tvs menv cenv senv tenv (Cmat () pes) t1 t2

and

forall tvs menv cenv senv tenv e t1 t2 n tvs'.
check_freevars tvs [] t1 &&
type_e menv cenv (bind_tenv n tvs' t1 tenv) e t2
==>
type_ctxt tvs menv cenv senv tenv (Clet n () e) t1 t2

and

forall tvs menv cenv senv tenv cn vs es ts1 ts2 t tn ts' tvs'.
List.for_all (check_freevars tvs []) ts' &&
List.length tvs' = List.length ts' &&
type_vs tvs menv cenv senv (List.rev vs)
        (List.map (type_subst (List.combine tvs' ts')) ts1) &&
type_es menv cenv (bind_tvar tvs tenv) es (List.map (type_subst (List.combine tvs' ts')) ts2) &&
lookup cn cenv = Some (tvs', ts1@[t]@ts2, tn)
==>
type_ctxt tvs menv cenv senv tenv (Ccon cn vs () es) (type_subst (List.combine tvs' ts') t)
          (Tapp ts' (TC_name tn))

indreln

forall dec_tvs tenvM tenvC senv t.
check_freevars dec_tvs [] t
==>
type_ctxts dec_tvs tenvM tenvC senv [] t t

and

forall dec_tvs tenvM tenvC senv c env cs tenv t1 t2 t3 tvs.
type_env tenvM tenvC senv env tenv &&
context_invariant dec_tvs ((c,env)::cs) tvs &&
type_ctxt tvs tenvM tenvC senv tenv c t1 t2 &&
type_ctxts dec_tvs tenvM tenvC senv cs t2 t3
==>
type_ctxts dec_tvs tenvM tenvC senv ((c,env)::cs) t1 t3

indreln

forall dec_tvs tenvM tenvC senv envM envC s env e c t1 t2 tenv tvs.
type_ctxts dec_tvs tenvM tenvC senv c t1 t2 &&
type_env tenvM tenvC senv env tenv &&
type_s tenvM tenvC senv s &&
context_invariant dec_tvs c tvs &&
type_e tenvM tenvC (bind_tvar tvs tenv) e t1 &&
((tvs <> 0) --> is_value e)
==>
type_state dec_tvs tenvM tenvC senv (envM,envC, s, env, Exp e, c) t2

and

forall dec_tvs tenvM tenvC senv envM envC s env v c t1 t2 tenv tvs.
type_ctxts dec_tvs tenvM tenvC senv c t1 t2 &&
type_env tenvM tenvC senv env tenv &&
type_s tenvM tenvC senv s &&
context_invariant dec_tvs c tvs &&
type_v tvs tenvM tenvC senv v t1
==>
type_state dec_tvs tenvM tenvC senv (envM, envC, s, env, Val v, c) t2

(* ------ Auxiliary relations for proving big/small step equivalence ------ *)

val evaluate_ctxt : envM -> envC -> store -> envE -> ctxt_frame -> v -> store * result v -> bool
val evaluate_ctxts : envM -> envC -> store -> list ctxt -> result v -> store * result v -> bool
val evaluate_state : state -> store * result v -> bool

indreln

forall menv cenv s env v1 e2 var.
true
==>
evaluate_ctxt menv cenv s env (Chandle () var e2) v1 (s, Rval v1)

and

forall menv cenv env op e2 v1 v2 env' e3 bv s1 s2 s3.
evaluate menv cenv s1 env e2 (s2, Rval v2) &&
do_app s2 env op v1 v2 = Some (s3,env', e3) &&
evaluate menv cenv s3 env' e3 bv
==>
evaluate_ctxt menv cenv s1 env (Capp1 op () e2) v1 bv

and

forall menv cenv env op e2 v1 v2 s1 s2.
evaluate menv cenv s1 env e2 (s2, Rval v2) &&
do_app s2 env op v1 v2 = None
==>
evaluate_ctxt menv cenv s1 env (Capp1 op () e2) v1 (s2, Rerr Rtype_error)

and

forall menv cenv env op e2 v1 err s s'.
evaluate menv cenv s env e2 (s', Rerr err)
==>
evaluate_ctxt menv cenv s env (Capp1 op () e2) v1 (s', Rerr err)

and

forall menv cenv env op v1 v2 env' e3 bv s1 s2.
do_app s1 env op v1 v2 = Some (s2, env', e3) &&
evaluate menv cenv s2 env' e3 bv
==>
evaluate_ctxt menv cenv s1 env (Capp2 op v1 ()) v2 bv

and

forall menv cenv env op v1 v2 s.
(do_app s env op v1 v2 = None)
==>
evaluate_ctxt menv cenv s env (Capp2 op v1 ()) v2 (s, Rerr Rtype_error)

and

forall menv cenv env uop v v' s1 s2.
(do_uapp s1 uop v = Some (s2,v'))
==>
evaluate_ctxt menv cenv s1 env (Cuapp uop ()) v (s2, Rval v')

and

forall menv cenv env uop v s.
(do_uapp s uop v = None)
==>
evaluate_ctxt menv cenv s env (Cuapp uop ()) v (s, Rerr Rtype_error)

and

forall menv cenv env op e2 v e' bv s.
do_log op v e2 = Some e' &&
evaluate menv cenv s env e' bv
==>
evaluate_ctxt menv cenv s env (Clog op () e2) v bv

and

forall menv cenv env op e2 v s.
(do_log op v e2 = None)
==>
evaluate_ctxt menv cenv s env (Clog op () e2) v (s, Rerr Rtype_error)

and
forall menv cenv env e2 e3 v e' bv s.
do_if v e2 e3 = Some e' &&
evaluate menv cenv s env e' bv
==>
evaluate_ctxt menv cenv s env (Cif () e2 e3) v bv

and

forall menv cenv env e2 e3 v s.
(do_if v e2 e3 = None)
==>
evaluate_ctxt menv cenv s env (Cif () e2 e3) v (s, Rerr Rtype_error)

and

forall menv cenv env pes v bv s.
evaluate_match menv cenv s env v pes bv
==>
evaluate_ctxt menv cenv s env (Cmat () pes) v bv

and

forall menv cenv env n e2 v bv s.
evaluate menv cenv s (bind n v env) e2 bv
==>
evaluate_ctxt menv cenv s env (Clet n () e2) v bv

and

forall menv cenv env cn es vs v vs' s1 s2.
do_con_check cenv cn (List.length vs + List.length es + 1) &&
evaluate_list menv cenv s1 env es (s2, Rval vs')
==>
evaluate_ctxt menv cenv s1 env (Ccon cn vs () es) v (s2, Rval (Conv cn (List.rev vs @ [v] @ vs')))

and

forall menv cenv env cn es vs v s.
not (do_con_check cenv cn (List.length vs + List.length es + 1))
==>
evaluate_ctxt menv cenv s env (Ccon cn vs () es) v (s, Rerr Rtype_error)

and

forall menv cenv env cn es vs v err s s'.
do_con_check cenv cn (List.length vs + List.length es + 1) &&
evaluate_list menv cenv s env es (s', Rerr err)
==>
evaluate_ctxt menv cenv s env (Ccon cn vs () es) v (s', Rerr err)

indreln

forall menv cenv res s.
true
==>
evaluate_ctxts menv cenv s [] res (s, res)

and

forall menv cenv c cs env v res bv s1 s2.
evaluate_ctxt menv cenv s1 env c v (s2, res) &&
evaluate_ctxts menv cenv s2 cs res bv
==>
evaluate_ctxts menv cenv s1 ((c,env)::cs) (Rval v) bv

and

forall menv cenv c cs env err s bv.
evaluate_ctxts menv cenv s cs (Rerr err) bv &&
((forall i e'. c <> Chandle () i e') ||
 (forall i. err <> Rraise (Int_error i)))
==>
evaluate_ctxts menv cenv s ((c,env)::cs) (Rerr err) bv

and

forall menv cenv cs env s s' var res1 res2 i e'.
evaluate menv cenv s (bind var (Litv (IntLit i)) env) e' (s', res1) &&
evaluate_ctxts menv cenv s' cs res1 res2
==>
evaluate_ctxts menv cenv s ((Chandle () var e',env)::cs) (Rerr (Rraise (Int_error i))) res2

indreln

forall menv cenv env e c res bv s1 s2.
evaluate menv cenv s1 env e (s2, res) &&
evaluate_ctxts menv cenv s2 c res bv
==>
evaluate_state (menv, cenv, s1, env, Exp e, c) bv

and

forall menv cenv s env v c bv.
evaluate_ctxts menv cenv s c (Rval v) bv
==>
evaluate_state (menv, cenv, s, env, Val v, c) bv


(* ------------------------------------------------------------------------ *) 
(*   Alternate big-step semantics                                           *)
(* ------------------------------------------------------------------------ *) 

(* A version of the big-step expression semantics that doesn't use the
 * constructor environment to know if a value is ok or not.  It also has no
 * module environment. Is equivalent to the normal one for well-typed programs
 * that don't contain module references. *)

val pmatch' : store -> pat -> v -> envE -> match_result
let rec
pmatch' s (Pvar n) v' env = Match (bind n v' env)
and
pmatch' s (Plit l) (Litv l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error
and
pmatch' s (Pcon cn ps) (Conv cn' vs) env =
  if List.length ps = List.length vs && cn = cn' then
    pmatch_list' s ps vs env
  else
    No_match
and
pmatch' s (Pref p) (Loc lnum) env =
  match store_lookup lnum s with
    | Some v -> pmatch' s p v env
    | None -> Match_type_error
  end
and
pmatch' _ _ _ env = Match_type_error
and
pmatch_list' s [] [] env = Match env
and
pmatch_list' s (p::ps) (v::vs) env =
  match pmatch' s p v env with
    | No_match -> No_match
    | Match_type_error -> Match_type_error
    | Match env' -> pmatch_list' s ps vs env'
  end
and
pmatch_list' _ _ _ env = Match_type_error


indreln

forall env l s.
true
==>
evaluate' s env (Lit l) (s, Rval (Litv l))

and

forall env err s.
true
==>
evaluate' s env (Raise err) (s, Rerr (Rraise err))

and

forall s1 s2 env e1 e2 v var.
evaluate' s1 env e1 (s2, Rval v)
==>
evaluate' s1 env (Handle e1 var e2) (s2, Rval v)

and

forall s1 s2 env e1 e2 n var bv.
evaluate' s1 env e1 (s2, Rerr (Rraise (Int_error n))) &&
evaluate' s2 (bind var (Litv (IntLit n)) env) e2 bv
==>
evaluate' s1 env (Handle e1 var e2) bv

and

forall s1 s2 env e1 e2 var err.
evaluate' s1 env e1 (s2, Rerr err) &&
(err = Rtype_error || err = Rraise Bind_error || err = Rraise Div_error)
==>
evaluate' s1 env (Handle e1 var e2) (s2, Rerr err)

and

forall env cn es vs s1 s2.
evaluate_list' s1 env es (s2, Rval vs)
==>
evaluate' s1 env (Con cn es) (s2, Rval (Conv cn vs))

and

forall env cn es err s s'.
evaluate_list' s env es (s', Rerr err)
==>
evaluate' s env (Con cn es) (s', Rerr err)

and

forall env n v s.
(lookup n env = Some v)
==>
evaluate' s env (Var (Short n)) (s, Rval v)

and

forall env n s.
(lookup n env = None)
==>
evaluate' s env (Var (Short n)) (s, Rerr Rtype_error)

and

forall env n e s.
true
==>
evaluate' s env (Fun n e) (s, Rval (Closure env n e))

and

forall env uop e v v' s1 s2 s3.
evaluate' s1 env e (s2, Rval v) &&
do_uapp s2 uop v = Some (s3,v')
==>
evaluate' s1 env (Uapp uop e) (s3, Rval v')

and

forall env uop e v s1 s2.
evaluate' s1 env e (s2, Rval v) &&
do_uapp s2 uop v = None
==>
evaluate' s1 env (Uapp uop e) (s2, Rerr Rtype_error)

and

forall env uop e err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate' s env (Uapp uop e) (s', Rerr err)

and

forall env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 s4.
evaluate' s1 env e1 (s2, Rval v1) &&
evaluate' s2 env e2 (s3, Rval v2) &&
do_app s3 env op v1 v2 = Some (s4, env', e3) &&
evaluate' s4 env' e3 bv
==>
evaluate' s1 env (App op e1 e2) bv

and

forall env op e1 e2 v1 v2 s1 s2 s3.
evaluate' s1 env e1 (s2, Rval v1) &&
evaluate' s2 env e2 (s3, Rval v2) &&
do_app s3 env op v1 v2 = None
==>
evaluate' s1 env (App op e1 e2) (s3, Rerr Rtype_error)

and

forall env op e1 e2 v1 err s1 s2 s3.
evaluate' s1 env e1 (s2, Rval v1) &&
evaluate' s2 env e2 (s3, Rerr err)
==>
evaluate' s1 env (App op e1 e2) (s3, Rerr err)

and

forall env op e1 e2 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (App op e1 e2) (s', Rerr err)

and

forall env op e1 e2 v e' bv s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
do_log op v e2 = Some e' &&
evaluate' s2 env e' bv
==>
evaluate' s1 env (Log op e1 e2) bv

and

forall env op e1 e2 v s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
do_log op v e2 = None
==>
evaluate' s1 env (Log op e1 e2) (s2, Rerr Rtype_error)

and

forall env op e1 e2 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (Log op e1 e2) (s', Rerr err)

and

forall env e1 e2 e3 v e' bv s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
do_if v e2 e3 = Some e' &&
evaluate' s2 env e' bv
==>
evaluate' s1 env (If e1 e2 e3) bv

and

forall env e1 e2 e3 v s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
do_if v e2 e3 = None
==>
evaluate' s1 env (If e1 e2 e3) (s2, Rerr Rtype_error)

and


forall env e1 e2 e3 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (If e1 e2 e3) (s', Rerr err)

and

forall env e pes v bv s1 s2.
evaluate' s1 env e (s2, Rval v) &&
evaluate_match' s2 env v pes bv
==>
evaluate' s1 env (Mat e pes) bv

and

forall env e pes err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate' s env (Mat e pes) (s', Rerr err)

and

forall env n e1 e2 v bv s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
evaluate' s2 (bind n v env) e2 bv
==>
evaluate' s1 env (Let n e1 e2) bv

and

forall env n e1 e2 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (Let n e1 e2) (s', Rerr err)

and

forall env funs e bv s.
all_distinct (List.map (fun (x,y,z) -> x) funs) &&
evaluate' s (build_rec_env funs env env) e bv
==>
evaluate' s env (Letrec funs e) bv

and

forall env funs e s.
not (all_distinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate' s env (Letrec funs e) (s, Rerr Rtype_error)

and

forall env s.
true
==>
evaluate_list' s env [] (s, Rval [])

and

forall env e es v vs s1 s2 s3.
evaluate' s1 env e (s2, Rval v) &&
evaluate_list' s2 env es (s3, Rval vs)
==>
evaluate_list' s1 env (e::es) (s3, Rval (v::vs))

and

forall env e es err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate_list' s env (e::es) (s', Rerr err)

and

forall env e es v err s1 s2 s3.
evaluate' s1 env e (s2, Rval v) &&
evaluate_list' s2 env es (s3, Rerr err)
==>
evaluate_list' s1 env (e::es) (s3, Rerr err)

and

forall env v s.
true
==>
evaluate_match' s env v [] (s, Rerr (Rraise Bind_error))

and

forall env v p e pes env' bv s.
all_distinct (pat_bindings p []) &&
(pmatch' s p v env = Match env') &&
evaluate' s env' e bv
==>
evaluate_match' s env v ((p,e)::pes) bv

and

forall env v p e pes bv s.
all_distinct (pat_bindings p []) &&
(pmatch' s p v env = No_match) &&
evaluate_match' s env v pes bv
==>
evaluate_match' s env v ((p,e)::pes) bv

and

forall env v p e pes s.
(pmatch' s p v env = Match_type_error)
==>
evaluate_match' s env v ((p,e)::pes) (s, Rerr Rtype_error)

and

forall env v p e pes s.
not (all_distinct (pat_bindings p []))
==>
evaluate_match' s env v ((p,e)::pes) (s, Rerr Rtype_error)

indreln

forall mn menv cenv env p e v env' s1 s2.
evaluate' s1 env e (s2, Rval v) &&
all_distinct (pat_bindings p []) &&
(pmatch' s2 p v emp = Match env')
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rval (emp, env'))

and

forall mn menv cenv env p e v s1 s2.
evaluate' s1 env e (s2, Rval v) &&
all_distinct (pat_bindings p []) &&
(pmatch' s2 p v emp = No_match)
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rerr (Rraise Bind_error))

and

forall mn menv cenv env p e v s1 s2.
evaluate' s1 env e (s2, Rval v) &&
(pmatch' s2 p v emp = Match_type_error)
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rerr Rtype_error)

and

forall mn menv cenv env p e v s1 s2.
evaluate' s1 env e (s2, Rval v) &&
not (all_distinct (pat_bindings p []))
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rerr Rtype_error)

and

forall mn menv cenv env p e err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate_dec' mn menv cenv s env (Dlet p e) (s', Rerr err)

and

forall mn menv cenv env funs s.
all_distinct (List.map (fun (x,y,z) -> x) funs)
==>
evaluate_dec' mn menv cenv s env (Dletrec funs) (s, Rval (emp, build_rec_env funs env emp))

and

forall mn menv cenv env funs s.
not (all_distinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate_dec' mn menv cenv s env (Dletrec funs) (s, Rerr Rtype_error)

and

forall mn menv cenv env tds s.
check_dup_ctors mn cenv tds
==>
evaluate_dec' mn menv cenv s env (Dtype tds) (s, Rval (build_tdefs mn tds, emp))

and

forall mn menv cenv env tds s.
not (check_dup_ctors mn cenv tds)
==>
evaluate_dec' mn menv cenv s env (Dtype tds) (s, Rerr Rtype_error)

indreln

forall mn menv cenv s env.
true
==>
evaluate_decs' mn menv cenv s env [] (s, Rval (emp, emp))

and

forall mn menv cenv s1 s2 env d ds e.
evaluate_dec' mn menv cenv s1 env d (s2, Rerr e)
==>
evaluate_decs' mn menv cenv s1 env (d::ds) (s2, Rerr e)

and

forall mn menv cenv s1 s2 s3 env d ds new_tds new_env r.
evaluate_dec' mn menv cenv s1 env d (s2, Rval (new_tds,new_env)) &&
evaluate_decs' mn menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, r)
==>
evaluate_decs' mn menv cenv s1 env (d::ds) (s3, combine_dec_result new_tds new_env r)

indreln

forall menv cenv s env.
true
==>
evaluate_prog' menv cenv s env [] (s, Rval (emp, emp, emp))

and

forall menv cenv s1 s2 s3 env d ds new_tds new_env r.
evaluate_dec' None menv cenv s1 env d (s2, Rval (new_tds,new_env)) &&
evaluate_prog' menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, r)
==>
evaluate_prog' menv cenv s1 env (Tdec d::ds) (s3, combine_mod_result emp new_tds new_env r)

and

forall menv cenv s1 s2 env d ds e.
evaluate_dec' None menv cenv s1 env d (s2, Rerr e)
==>
evaluate_prog' menv cenv s1 env (Tdec d::ds) (s2, Rerr e)

and

forall menv cenv s1 s2 s3 env ds1 ds2 mn specs new_tds new_env r.
not (List.mem mn (List.map fst menv)) &&
evaluate_decs' (Some mn) menv cenv s1 env ds1 (s2, Rval (new_tds,new_env)) &&
evaluate_prog' (bind mn new_env menv) (merge new_tds cenv) s2 env ds2 (s3, r)
==>
evaluate_prog' menv cenv s1 env (Tmod mn specs ds1::ds2) (s3, combine_mod_result [(mn,new_env)] new_tds emp r)

and

forall menv cenv s1 s2 env mn specs ds1 ds2 e.
not (List.mem mn (List.map fst menv)) &&
evaluate_decs' (Some mn) menv cenv s1 env ds1 (s2, Rerr e)
==>
evaluate_prog' menv cenv s1 env (Tmod mn specs ds1::ds2) (s2, Rerr e)

and

forall menv cenv s env mn specs ds1 ds2.
List.mem mn (List.map fst menv)
==>
evaluate_prog' menv cenv s env (Tmod mn specs ds1::ds2) (s, Rerr Rtype_error)

