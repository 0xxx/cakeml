(* By Scott Owens, University of Cambridge, Copyright 2011, 2012
 *                 University of Kent 2012
 *
 * MiniML is a simple ML-like language. It has no type abbreviations, or
 * records, and only simple top-level modules.  It has mutually recursive
 * datatypes (at the top-level and module top-level only) and functions, as
 * well as higher-order functions.  It also supports pattern matching for
 * nested patterns (which can fail due to non-exhaustive patterns).  Only
 * booleans and integer types are built-in.  Syntactic sugar is generally
 * omitted.
 *
 * In some ways it makes more sense to write these kind of semantics in Ott (to
 * get a presentation that looks like ML concrete-syntax-wise, and that has the
 * usual syntax for type systems and operational semantics, i.e., with |- and
 * horizontal lines).  Here in Lem, everything looks like abstract syntax;
 * however, unlike Ott, we get good support for functions, and not just
 * relations.
 *
 * The small-step operational semantics is based on the CEK machine.  The type
 * system is typical.  The big step semantics is also typical.  The small-step
 * and big-step semantics agree even on untyped programs. *)

val i : num -> Int.int
let inline {hol} i = Hol.(&)

val all_distinct : forall 'a. list 'a -> bool
let inline {hol} all_distinct = Hol.ALL_DISTINCT

val rtc : forall 'a. ('a -> 'a -> bool) -> ('a -> 'a -> bool)
let inline {hol} rtc = Hol.RTC

val option_map : forall 'a 'b. ('a -> 'b) -> option 'a -> option 'b
let option_map f x = 
  match x with
    | None -> None
    | Some y -> Some (f y)
  end

(* Change the nth element in the list to 'a *)
val LUPDATE : forall 'a. 'a -> num -> list 'a -> list 'a
let inline {hol} LUPDATE = Hol.LUPDATE

(* Environments *)
type env 'a 'b = list ('a*'b)

val emp : forall 'a 'b. env 'a 'b
let emp = []

val lookup : forall 'a 'b. 'a -> env 'a 'b -> option 'b
let rec
lookup n [] = None
and
lookup n ((n',v)::e) =
  if n' = n then
    Some v
  else
    lookup n e

val bind : forall 'a 'b. 'a -> 'b -> env 'a 'b -> env 'a 'b
let bind n v e = (n,v)::e

val merge : forall 'a 'b. env 'a 'b -> env 'a 'b -> env 'a 'b
let merge e1 e2 = e1 @ e2

(* ------------------------------------------------------------------------ *) 
(*   The Abstract Syntax                                                    *)
(* ------------------------------------------------------------------------ *) 

(* Literal constants *)
type lit =
  | IntLit of int
  | Bool of bool
  | Unit

(* Built-in binary operations (including function application) *)

type opn = Plus | Minus | Times | Divide | Modulo
type opb = Lt | Gt | Leq | Geq

let opn_lookup n = match n with
  | Plus -> Int.(+)
  | Minus -> Int.(-)
  | Times -> Int.( * )
  | Divide -> Int.(/)
  | Modulo -> Int.(%)
end

let opb_lookup n : int -> int -> bool = match n with
  | Lt -> Int.(<)
  | Gt -> Int.(>)
  | Leq -> Int.(<=)
  | Geq -> Int.(>=)
end

(* Opapp is function application *)
type op =
  | Opn of opn
  | Opb of opb
  | Equality
  | Opapp
  | Opassign

type uop =
  | Opref
  | Opderef

(* Built-in logical operations *)
type log =
  | And
  | Or

(* Variable names *)
type varN = string
(* Constructor names (from datatype definitions) *)
type conN = string
(* Type names *)
type typeN = string
(* Type variable names *)
type tvarN = string
(* Module names *)
type mvarN = string

(* Types
 * 0-ary type applications represent unparameterised types (e.g., num or string)
 *)
type t =
  | Tvar of tvarN
  (* DeBruin indexed type variables. *)
  | Tvar_db of num
  | Tapp of list t * typeN
  | Tfn of t * t
  | Tint
  | Tbool
  | Tref of t
  | Tunit

(* Patterns *)
type pat =
  (* We optionally type annotate all binders *)
  | Pvar of varN * option t
  | Plit of lit
  (* Constructor applications. *)
  | Pcon of conN * list pat
  | Pref of pat

(* Runtime errors.  Temporary: later on we want to move to SML-style declared
 * exception constructors *)
type error =
  | Bind_error
  | Div_error
  | Int_error of int

(* Expressions *)
(* We optionally type annotate all binders *)
type exp =
  (* Temporary: later on we want Raise of exp *)
  | Raise of error
  (* Temporary: later on we want Handle of exp * list (pat * exp) *)
  (* We don't type annotate this binder because it must be an int *)
  | Handle of exp * varN * exp
  | Lit of lit
  (* Constructor application. *)
  | Con of conN * list exp
  (* The optional type list is the type application in the case that the
   * variable references a polymorphic binding. *)
  | Var of varN * option (list t)
  | Fun of varN * option t * exp
  (* Application of a unary operator *)
  | Uapp of uop * exp
  (* Application of an operator (including function application) *)
  | App of op * exp * exp
  (* Logical operations (and, or) *)
  | Log of log * exp * exp
  | If of exp * exp * exp
  (* Pattern matching *)
  | Mat of exp * list (pat * exp)
  (* The number is how many type variables are bound. *)
  | Let of option num * varN * option t * exp * exp
  (* Local definition of (potentially) mutually recursive functions
   * The first varN is the function's name, and the second varN is its
   * parameter.
   * The number is how many type variables are bound. *)
  | Letrec of option num * list (varN * option t * varN * option t * exp) * exp

type type_def = list (list tvarN * typeN * list (conN * list t))

(* Declarations *)
type dec =
  (* Top-level bindings
   * The number is how many type variables are bound.
   * The pattern allows several names to be bound at once *)
  | Dlet of option num * pat * exp
  (* Mutually recursive function definition
   * The number is how many type variables are bound. *)
  | Dletrec of option num * list (varN * option t * varN * option t * exp)
  (* Type definition
     Defines several types, each of which has several named variants, which can
     in turn have several arguments *)
  | Dtype of type_def

type decs = list dec

type spec =
  | Sval of t
  | Stype of type_def
  | Stype_opq of typeN

type specs = list spec

type top =
  | Tmodule of mvarN * specs * decs
  | Tdec of dec

type prog = list top

(* ------------------------------------------------------------------------ *) 
(*   The Semantics                                                          *)
(* ------------------------------------------------------------------------ *) 

(* Value forms *)
type v =
  | Litv of lit
  (* Constructor application. *)
  | Conv of conN * list v
  (* Function closures
     The environment is used for the free variables in the function *)
  | Closure of env varN (v * option (num * t)) * varN * option t * exp
  (* Function closure for recursive functions
   * See Closure and Letrec above
   * The last variable name indicates which function from the mutually
   * recursive bundle this closure value represents *)
  | Recclosure of env varN (v * option (num * t)) * list (varN * option t * varN * option t * exp) * varN
  | Loc of num


(* Type substitution *)

(* Increment the deBruijn indices in a type by n levels, skipping all levels
 * less than skip. *)
val deBruijn_inc : num -> num -> t -> t
let rec
deBruijn_inc skip n (Tvar tv) = Tvar tv
and
deBruijn_inc skip n (Tvar_db m) =
  if m < skip then
    Tvar_db m
  else
    Tvar_db (m + n)
and
deBruijn_inc skip n (Tapp ts tn) = Tapp (List.map (deBruijn_inc skip n) ts) tn
and
deBruijn_inc skip n (Tfn t1 t2) =
  Tfn (deBruijn_inc skip n t1) (deBruijn_inc skip n t2)
and
deBruijn_inc skip n Tint = Tint
and
deBruijn_inc skip n Tbool = Tbool
and
deBruijn_inc skip n (Tref t) = Tref (deBruijn_inc skip n t)
and
deBruijn_inc skip n Tunit = Tunit

(* skip the lowest given indices and replace the next (LENGTH ts) with the given types and reduce all the higher ones *)
val deBruijn_subst : num -> list t -> t -> t
let rec
deBruijn_subst skip ts (Tvar tv) = Tvar tv
and
deBruijn_subst skip ts (Tvar_db n) =
  if not (n < skip) && n < List.length ts + skip then
    List.nth ts (n - skip)
  else if not (n < skip) then
    Tvar_db (n - List.length ts)
  else
    Tvar_db n
and
deBruijn_subst skip ts (Tapp ts' tn) =
  Tapp (List.map (deBruijn_subst skip ts) ts') tn
and
deBruijn_subst skip ts (Tfn t1 t2) =
  Tfn (deBruijn_subst skip ts t1) (deBruijn_subst skip ts t2)
and
deBruijn_subst skip ts Tint = Tint
and
deBruijn_subst skip ts Tbool = Tbool
and
deBruijn_subst skip ts Tunit = Tunit
and
deBruijn_subst skip ts (Tref t) = Tref (deBruijn_subst skip ts t)

val deBruijn_subst_p : num -> list t -> pat -> pat
let rec
deBruijn_subst_p skip ts (Pvar x topt) =
  Pvar x (option_map (deBruijn_subst skip ts) topt)
and
deBruijn_subst_p skip ts (Plit l) = Plit l
and
deBruijn_subst_p skip ts (Pcon cn ps) = 
  Pcon cn (List.map (deBruijn_subst_p skip ts) ps)
and
deBruijn_subst_p skip ts (Pref p) =
  Pref (deBruijn_subst_p skip ts p)

val deBruijn_subst_e : num -> list t -> exp -> exp
let rec
deBruijn_subst_e skip ts (Raise err) = Raise err
and
deBruijn_subst_e skip ts (Handle e1 n e2) = 
  Handle (deBruijn_subst_e skip ts e1) n (deBruijn_subst_e skip ts e2)
and
deBruijn_subst_e skip ts (Lit l) = Lit l
and
deBruijn_subst_e skip ts (Con cn es) =
  Con cn (List.map (deBruijn_subst_e skip ts) es)
and
deBruijn_subst_e skip ts (Var x targs_opt) =
  Var x (option_map (List.map (deBruijn_subst skip ts)) targs_opt)
and
deBruijn_subst_e skip ts (Fun x topt e) =
  Fun x (option_map (deBruijn_subst skip ts) topt) (deBruijn_subst_e skip ts e)
and
deBruijn_subst_e skip ts (Uapp uop e) =
  Uapp uop (deBruijn_subst_e skip ts e)
and
deBruijn_subst_e skip ts (App bop e1 e2) =
  App bop (deBruijn_subst_e skip ts e1) (deBruijn_subst_e skip ts e2)
and
deBruijn_subst_e skip ts (Log lop e1 e2) =
  Log lop (deBruijn_subst_e skip ts e1) (deBruijn_subst_e skip ts e2)
and
deBruijn_subst_e skip ts (If e1 e2 e3) =
  If (deBruijn_subst_e skip ts e1) (deBruijn_subst_e skip ts e2) (deBruijn_subst_e skip ts e3)
and
deBruijn_subst_e skip ts (Mat e pes) =
  Mat (deBruijn_subst_e skip ts e) 
      (List.map (fun (p,e) -> (deBruijn_subst_p skip ts p, deBruijn_subst_e skip ts e)) pes)
and
deBruijn_subst_e skip ts (Let tvs x topt e1 e2) =
  let skip' = match tvs with | None -> skip | Some x -> x + skip end in
  let ts' = match tvs with | None -> ts | Some tvs -> List.map (deBruijn_inc 0 tvs) ts end in
    Let tvs x 
      (option_map (deBruijn_subst skip' ts') topt)
      (deBruijn_subst_e skip' ts' e1)
      (deBruijn_subst_e skip ts e2)
and
deBruijn_subst_e skip ts (Letrec tvs funs e) =
  let skip' = match tvs with | None -> skip | Some x -> x + skip end in
  let ts' = match tvs with | None -> ts | Some tvs -> List.map (deBruijn_inc 0 tvs) ts end in
    Letrec tvs 
      (List.map (fun (f,topt1,x,topt2,e) -> 
                   (f,
                    option_map (deBruijn_subst skip' ts') topt1,
                    x,
                    option_map (deBruijn_subst skip' ts') topt2,
                    (deBruijn_subst_e skip' ts' e)))
         funs) 
      (deBruijn_subst_e skip ts e)

val deBruijn_subst_v : list t -> v -> v
let rec
deBruijn_subst_v ts (Litv lit) = Litv lit
and
deBruijn_subst_v ts (Conv cn vs) =
  Conv cn (List.map (deBruijn_subst_v ts) vs)
and
deBruijn_subst_v ts (Closure env x topt e) =
  Closure env x (option_map (deBruijn_subst 0 ts) topt) (deBruijn_subst_e 0 ts e)
and
deBruijn_subst_v ts (Recclosure env funs f) =
  Recclosure env
      (List.map (fun (f,topt1,x,topt2,e) -> 
                   (f,
                    option_map (deBruijn_subst 0 ts) topt1,
                    x,
                    option_map (deBruijn_subst 0 ts) topt2,
                    (deBruijn_subst_e 0 ts e)))
         funs) 
    f
and
deBruijn_subst_v ts (Loc l) = Loc l

(* Environments *)
(* The optional type scheme annotation's type variable binding scopes over the
 * value too *)
type envE = env varN (v * option (num * t))

val add_tvs : option num -> option t -> option (num * t)
let add_tvs tvsopt topt =
  match topt with
    | None -> None
    | Some t -> 
        match tvsopt with
          | None -> None
          | Some tvs -> Some (tvs, t)
        end
  end

(* Stores *)
(* The nth item in the list is the value at location n *)
type store = list v

val empty_store : store
let empty_store = []

val store_lookup : num -> store -> option v
let store_lookup l st =
  if l < List.length st then
    Some (List.nth st l)
  else
    None

val store_alloc : v -> store -> store * num
let store_alloc v st =
  (st @ [v], List.length st)

val store_assign : num -> v -> store -> option store
let store_assign n v st =
  if n < List.length st then
    Some (LUPDATE v n st)
  else
    None

(* Maps each constructor to its arity and the set of all constructors of that
 * type *)
type envC = env conN (num * set conN)

(* Evaluation contexts
 * The hole is denoted by the unit type
 * The env argument contains bindings for the free variables of expressions in
     the context *)
type ctxt_frame =
  | Chandle of unit * varN * exp
  | Capp1 of op * unit * exp
  | Capp2 of op * v * unit
  | Clog of log * unit * exp
  | Cif of unit * exp * exp
  | Cmat of unit * list (pat * exp)
  | Clet of option num * varN * option t * unit * exp
  (* Evaluating a constructor's arguments
   * The v list should be in reverse order. *)
  | Ccon of conN * list v * unit * list exp
  | Cuapp of uop * unit
type ctxt = ctxt_frame * envE

val lit_same_type : lit -> lit -> bool
let lit_same_type l1 l2 =
  match (l1,l2) with
    | (IntLit _, IntLit _) -> true
    | (Bool _, Bool _) -> true
    | (Unit, Unit) -> true
    | _ -> false
  end

type match_result =
  | No_match
  | Match_type_error
  | Match of envE

(* A big-step pattern matcher.  If the value matches the pattern, return an
 * environment with the pattern variables bound to the corresponding sub-terms
 * of the value; this environment extends the environment given as an argument.
 * No_match is returned when there is no match, but any constructors
 * encountered in determining the match failure are applied to the correct
 * number of arguments, and constructors in corresponding positions in the
 * pattern and value come from the same type.  Match_type_error is returned
 * when one of these conditions is violated *)
val pmatch : option num -> envC -> store -> pat -> v -> envE -> match_result
let rec
pmatch tvs envC s (Pvar n topt) v' env = Match (bind n (v', add_tvs tvs topt) env)
and
pmatch tvs envC s (Plit l) (Litv l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error
and
pmatch tvs envC s (Pcon n ps) (Conv n' vs) env =
  match (lookup n envC, lookup n' envC) with
    | (Some (l, ns), Some (l', ns')) ->
        if n IN ns' && n' IN ns && (List.length ps = l) && (List.length vs = l')
        then
          if n = n' then
            pmatch_list tvs envC s ps vs env
          else
            No_match
        else
          Match_type_error
    | (_, _) -> Match_type_error
  end
and
pmatch tvs envC s (Pref p) (Loc lnum) env =
  match store_lookup lnum s with
    | Some v -> pmatch tvs envC s p v env
    | None -> Match_type_error
  end
and
pmatch tvs envC _ _ _ env = Match_type_error
and
pmatch_list tvs envC s [] [] env = Match env
and
pmatch_list tvs envC s (p::ps) (v::vs) env =
  match pmatch tvs envC s p v env with
    | No_match -> No_match
    | Match_type_error -> Match_type_error
    | Match env' -> pmatch_list tvs envC s ps vs env'
  end
and
pmatch_list tvs envC s _ _ env = Match_type_error

(* Accumulates the bindings of a patterns *)
val pat_bindings : pat -> list varN -> list varN
let rec
pat_bindings (Pvar n topt) already_bound =
  n::already_bound
and
pat_bindings (Plit l) already_bound =
  already_bound
and
pat_bindings (Pcon _ ps) already_bound =
  pats_bindings ps already_bound
and
pat_bindings (Pref p) already_bound =
  pat_bindings p already_bound
and
pats_bindings [] already_bound =
  already_bound
and
pats_bindings (p::ps) already_bound =
  pats_bindings ps (pat_bindings p already_bound)

(* State for CEK-style expression evaluation
 * - constructor data
 * - the store
 * - the environment for the free variables of the current expression
 * - the current expression to evaluate, or a value if finished
 * - the context stack (continuation) of what to do once the current expression
 *   is finished.  Each entry has an environment for it's free variables *)
type exp_or_val =
  | Exp of exp
  | Val of v

type state = envC * store * envE * exp_or_val * list ctxt

type e_step_result =
  | Estep of state
  | Etype_error
  | Estuck

(* The semantics are deterministic, and presented functionally instead of
 * relationally for proof rather that readability; the steps are very small: we
 * push individual frames onto the context stack instead of finding a redex in a
 * single step *)

val push : envC -> store -> envE -> exp -> ctxt_frame -> list ctxt -> e_step_result
let push envC s env e c' cs = Estep (envC, s, env, Exp e, (c',env)::cs)

val return : envC -> store -> envE -> v -> list ctxt -> e_step_result
let return envC s env v c = Estep (envC, s, env, Val v, c)

(* Bind each function of a mutually recursive set of functions to its closure *)
val build_rec_env : option num -> list (varN * option t * varN * option t * exp) -> envE -> envE
let build_rec_env tvs funs env =
  List.fold_right
    (fun (f,topt,x,topt',e) env' -> bind f (Recclosure env funs f, add_tvs tvs topt) env')
    funs
    env

(* Lookup in the list of mutually recursive functions *)
val find_recfun : varN -> list (varN * option t * varN * option t * exp) -> option (varN * option t * exp)
let rec find_recfun n funs =
  match funs with
    | [] -> None
    | (f,_,x,topt,e) :: funs ->
        if f = n then
          Some (x,topt,e)
        else
          find_recfun n funs
  end

(* Do an application *)
val do_app : store -> envE -> op -> v -> v -> option (store * envE * exp)
let do_app s env' op v1 v2 =
  match (op, v1, v2) with
    | (Opapp, Closure env n topt e, v) ->
        Some (s, bind n (v, add_tvs (Some 0) topt) env, e)
    | (Opapp, Recclosure env funs n, v) ->
        match find_recfun n funs with
          | Some (n,topt,e) -> Some (s, bind n (v, add_tvs (Some 0) topt) (build_rec_env (Some 0) funs env), e)
          | None -> None
        end
    | (Opn op, Litv (IntLit n1), Litv (IntLit n2)) ->
        if (op = Divide || op = Modulo) && n2 = i 0 then
          Some (s, env', Raise Div_error)
        else
          Some (s, env',Lit (IntLit (opn_lookup op n1 n2)))
    | (Opb op, Litv (IntLit n1), Litv (IntLit n2)) ->
        Some (s, env', Lit (Bool (opb_lookup op n1 n2)))
    | (Equality, v1, v2) ->
        (* TODO: Check for closures in v1 and v2, and possibly check that they
         * have the same type *)
        Some (s, env', Lit (Bool (v1 = v2)))
    | (Opassign, (Loc lnum), v) ->
        match store_assign lnum v s with
        | Some st -> Some (st, env', Lit Unit)
        | None -> None
        end
    | _ -> None
  end

(* Do a logical operation *)
val do_log : log -> v -> exp -> option exp
let do_log l v e =
  match (l, v) with
    | (And, Litv (Bool true)) -> Some e
    | (Or, Litv (Bool false)) -> Some e
    | (_, Litv (Bool b)) -> Some (Lit (Bool b))
    | _ -> None
  end

(* Do an if-then-else *)
val do_if : v -> exp -> exp -> option exp
let do_if v e1 e2 =
  if v = Litv (Bool true) then
    Some e1
  else if v = Litv (Bool false) then
    Some e2
  else
    None

(* Check that a constructor is properly applied *)
val do_con_check : envC -> conN -> num -> bool
let do_con_check envC n l =
  match lookup n envC with
    | None -> false
    | Some (l',ns) -> l = l'
  end

val do_uapp : store -> uop -> v -> option (store * v)
let do_uapp s uop v =
  match uop with
    | Opderef ->
        match v with
          | Loc n ->
              match store_lookup n s with
                | Some v -> Some (s,v)
                | None -> None
              end
          | _ -> None
        end
    | Opref ->
        let (s',n) = store_alloc v s in
          Some (s', Loc n)
  end

(* apply a context to a value *)
val continue : envC -> store -> v -> list ctxt -> e_step_result
let continue envC s v cs =
  match cs with
    | [] -> Estuck
    | (Chandle () n e, env) :: c ->
        return envC s env v c
    | (Capp1 op () e, env) :: c ->
        push envC s env e (Capp2 op v ()) c
    | (Capp2 op v' (), env) :: c ->
        match do_app s env op v' v with
          | Some (s',env,e) -> Estep (envC, s', env, Exp e, c)
          | None -> Etype_error
        end
    | (Clog l () e, env) :: c ->
        match do_log l v e with
          | Some e -> Estep (envC, s, env, Exp e, c)
          | None -> Etype_error
        end
    | (Cif () e1 e2, env) :: c ->
        match do_if v e1 e2 with
          | Some e -> Estep (envC, s, env, Exp e, c)
          | None -> Etype_error
        end
    | (Cmat () [], env) :: c ->
        Estep (envC, s, env, Exp (Raise Bind_error), c)
    | (Cmat () ((p,e)::pes), env) :: c ->
        if all_distinct (pat_bindings p []) then
          match pmatch (Some 0) envC s p v env with
            | Match_type_error -> Etype_error
            | No_match -> Estep (envC, s, env, Val v, (Cmat () pes,env)::c)
            | Match env' -> Estep (envC, s, env', Exp e, c)
          end
        else
          Etype_error
    | (Clet tvs n topt () e, env) :: c ->
        Estep (envC, s, bind n (v, add_tvs tvs topt) env, Exp e, c)
    | (Ccon n vs () [], env) :: c ->
        if do_con_check envC n (List.length vs + 1) then
          return envC s env (Conv n (List.rev (v::vs))) c
        else
          Etype_error
    | (Ccon n vs () (e::es), env) :: c ->
        if do_con_check envC n (List.length vs + 1 + 1 + List.length es) then
          push envC s env e (Ccon n (v::vs) () es) c
        else
          Etype_error
    | (Cuapp uop (), env) :: c ->
       match do_uapp s uop v with
         | Some (s',v') -> return envC s' env v' c
         | None -> Etype_error
       end
  end

val do_tapp : option (num * t) -> option (list t) -> v -> v
let do_tapp tscheme_opt targs_opt v =
  match (tscheme_opt, targs_opt) with
    | (Some (tvs, tscheme), Some targs) ->
        if tvs = List.length targs then
          deBruijn_subst_v targs v
        else
          v
    | _ -> v
  end

(* The single step expression evaluator.  Returns None if there is nothing to
 * do, but no type error.  Returns Type_error on encountering free variables,
 * mis-applied (or non-existent) constructors, and when the wrong kind of value
 * if given to a primitive.  Returns Bind_error when no pattern in a match
 * matches the value.  Otherwise it returns the next state *)

val e_step : state -> e_step_result
let e_step (envC, s, env, ev, c) =
  match ev with
    | Val v  ->
	continue envC s v c
    | Exp e ->
        match e with
          | Lit l -> return envC s env (Litv l) c
          | Raise e ->
              match c with
                | [] -> Estuck
                | ((Chandle () n e',env') :: c) ->
                     match e with
                        | Int_error i ->
                           Estep (envC,s,(bind n (Litv (IntLit i), Some (0,Tint)) env'),Exp e',c)
                        | _ -> Estep (envC,s,env,Exp (Raise e),c)
                     end
                | _::c -> Estep (envC,s,env,Exp (Raise e),c)
              end
          | Handle e n e' ->
              push envC s env e (Chandle () n e') c
          | Con n es ->
              if do_con_check envC n (List.length es) then
                match es with
                  | [] -> return envC s env (Conv n []) c
                  | e::es ->
                      push envC s env e (Ccon n [] () es) c
                end
              else
                Etype_error
          | Var n targs_opt ->
              match lookup n env with
                | None -> Etype_error
                | Some (v,type_scheme_opt) -> 
                    return envC s env (do_tapp type_scheme_opt targs_opt v) c
              end
          | Fun n topt e -> return envC s env (Closure env n topt e) c
          | App op e1 e2 -> push envC s env e1 (Capp1 op () e2) c
          | Log l e1 e2 -> push envC s env e1 (Clog l () e2) c
          | If e1 e2 e3 -> push envC s env e1 (Cif () e2 e3) c
          | Mat e pes -> push envC s env e (Cmat () pes) c
          | Let tvs n topt e1 e2 -> push envC s env e1 (Clet tvs n topt () e2) c
          | Letrec tvs funs e ->
              if not (all_distinct (List.map (fun (x,a,y,b,z) -> x) funs)) then
                Etype_error
              else
                Estep (envC, s, build_rec_env tvs funs env, Exp e, c)
          | Uapp uop e ->
              push envC s env e (Cuapp uop ()) c
        end
  end

(* Add the given type definition to the given constructor environment *)
val build_tdefs : list (list tvarN * typeN * list (conN * list t)) -> envC
let build_tdefs tds =
  List.rev (List.flatten
    (List.map
      (fun (tvs, tn, condefs) ->
         List.map
           (fun (conN, ts) ->
              (conN, (List.length ts,
                         {cn | forall ((cn,ts) MEM condefs) | true})))
           condefs)
      tds))

(* Checks that no constructor is defined twice *)
val check_dup_ctors :
    forall 'a. list (list tvarN * typeN * list (conN * list t)) -> env conN 'a -> bool
let check_dup_ctors tds envC =
  (forall ((tvs, tn, condefs) MEM tds) ((n, ts) MEM condefs).
   lookup n envC = None) &&
  all_distinct
    [ n | forall ((tvs, tn, condefs) MEM tds) ((n, ts) MEM condefs) | true ]

(* Whole program state
 * - constructor data
 * - values bound be previous definitions
 * - remaining definitions
 * - current state for evaluating the current definition *)
type d_state = envC * store * envE * decs * option (option num * pat * state)

type d_step_result =
  | Dstep of d_state
  | Draise of error
  | Dtype_error
  | Dstuck

val d_step : d_state -> d_step_result
let d_step (envC, s, env, ds, st) =
  match st with
    | Some (tvs, p, (envC', s', env', Val v, [])) ->
        if all_distinct (pat_bindings p []) then
          match pmatch tvs envC s' p v env with
            | Match env' -> Dstep (envC, s', env', ds, None)
            | No_match -> Draise Bind_error
            | Match_type_error -> Dtype_error
          end
        else
          Dtype_error
    | Some (tvs, p, (envC, s', env', Exp (Raise err), [])) ->
        Draise err
    | Some (tvs, p, (envC', s', env', e, c)) ->
        match e_step (envC', s', env', e, c) with
          | Estep st -> Dstep (envC, empty_store, env, ds, Some (tvs, p, st))
          | Etype_error -> Dtype_error
          | Estuck -> Dstuck
        end
    | None ->
        match ds with
          | [] -> Dstuck
          | (Dlet tvs p e) :: ds ->
              Dstep (envC, empty_store, env, ds, Some (tvs, p, (envC, s, env, Exp e, [])))
          | (Dletrec tvs funs) :: ds ->
              if not (all_distinct (List.map (fun (x,a,y,b,z) -> x) funs)) then
                Dtype_error
              else
                Dstep (envC, s, build_rec_env tvs funs env, ds, None)
          | (Dtype tds) :: ds ->
              if check_dup_ctors tds envC then
                Dstep (merge (build_tdefs tds) envC, s, env, ds, None)
              else
                Dtype_error
      end
  end

(* Define a semantic function using the steps *)

type error_result =
  | Rtype_error
  | Rraise of error

type result 'a =
  | Rval of 'a
  | Rerr of error_result

val e_step_reln : state -> state -> bool
val small_eval : envC -> store -> envE -> exp -> list ctxt -> store * result v -> bool
val d_step_reln : d_state -> d_state -> bool
val d_small_eval : envC -> store -> envE -> list dec -> option (option num * pat * state) -> store * result (envC * envE) -> bool

let e_step_reln st1 st2 =
  (e_step st1 = Estep st2)

let rec
small_eval cenv s env e c (s', Rval v) =
  exists env'. (rtc e_step_reln) (cenv,s,env,Exp e,c) (cenv,s',env',Val v,[])
and
small_eval cenv s env e c (s', Rerr (Rraise err)) =
  exists env'. (rtc e_step_reln) (cenv,s,env,Exp e,c) (cenv,s',env',Exp (Raise err),[])
and
small_eval cenv s env e c (s', Rerr Rtype_error) =
  exists env' e' c'.
    (rtc e_step_reln) (cenv,s,env,Exp e,c) (cenv,s',env',e',c') &&
    (e_step (cenv,s',env',e',c') = Etype_error)

val e_diverges : envC -> store -> envE -> exp -> bool
let e_diverges cenv s env e =
  forall cenv' s' env' e' c'.
    (rtc e_step_reln) (cenv,s,env,Exp e,[]) (cenv',s',env', e',c')
    -->
    exists cenv'' s'' env'' e'' c''.
      e_step_reln (cenv',s',env', e',c') (cenv'',s'',env'',e'',c'')

val d_state_to_store : store -> option (option num * pat * state) -> store
let d_state_to_store s c =
  match c with
    | None -> s
    | Some (_, _, (_,s',_,_,_)) -> s'
  end

let d_step_reln st st' =
  (d_step st = Dstep st')

let rec
d_small_eval cenv s env ds c (s', Rval (cenv',env')) =
  (rtc d_step_reln) (cenv,s,env,ds,c) (cenv',s',env',[],None)
and
d_small_eval cenv s env ds c (s', Rerr Rtype_error) =
  exists cenv' s'' env' ds' c'.
    (s' = d_state_to_store s'' c') &&
    (rtc d_step_reln) (cenv,s,env,ds,c) (cenv',s'',env',ds',c') &&
    (d_step (cenv',s'',env',ds',c') = Dtype_error)
and
d_small_eval cenv s env ds c (s', Rerr (Rraise err)) =
  exists cenv' s'' env' ds' c'.
    (s' = d_state_to_store s'' c') &&
    (rtc d_step_reln) (cenv,s,env,ds,c) (cenv',s'',env',ds',c') &&
    (d_step (cenv',s'',env',ds',c') = Draise err)

val diverges : envC -> store -> envE -> list dec -> bool
let diverges cenv s env ds =
  forall cenv' s' env' ds' c'.
    (rtc d_step_reln) (cenv,s,env,ds,None) (cenv',s',env',ds',c')
    -->
    exists cenv'' s'' env'' ds'' c''.
      d_step_reln (cenv',s',env',ds',c') (cenv'',s'',env'',ds'',c'')

(* ------------------------ Big step semantics -------------------------- *)
val evaluate : envC -> store -> envE -> exp -> store * result v -> bool
val evaluate_list : envC -> store -> envE -> list exp -> store * result (list v) -> bool
val evaluate_match : envC -> store -> envE -> v -> list (pat * exp) -> store * result v -> bool
val evaluate_decs : envC -> store -> envE -> list dec -> store * result (envC * envE) -> bool

indreln

forall cenv env l s.
true
==>
evaluate cenv s env (Lit l) (s, Rval (Litv l))

and

forall cenv env err s.
true
==>
evaluate cenv s env (Raise err) (s, Rerr (Rraise err))

and

forall cenv s1 s2 env e1 e2 v var.
evaluate cenv s1 env e1 (s2, Rval v)
==>
evaluate cenv s1 env (Handle e1 var e2) (s2, Rval v)

and

forall cenv s1 s2 env e1 e2 n var bv.
evaluate cenv s1 env e1 (s2, Rerr (Rraise (Int_error n))) &&
evaluate cenv s2 (bind var (Litv (IntLit n), Some (0, Tint)) env) e2 bv
==>
evaluate cenv s1 env (Handle e1 var e2) bv

and

forall cenv s1 s2 env e1 e2 var err.
evaluate cenv s1 env e1 (s2, Rerr err) &&
(err = Rtype_error || err = Rraise Bind_error || err = Rraise Div_error)
==>
evaluate cenv s1 env (Handle e1 var e2) (s2, Rerr err)

and

forall cenv env cn es vs s s'.
do_con_check cenv cn (List.length es) &&
evaluate_list cenv s env es (s', Rval vs)
==>
evaluate cenv s env (Con cn es) (s', Rval (Conv cn vs))

and

forall cenv env cn es s.
not (do_con_check cenv cn (List.length es))
==>
evaluate cenv s env (Con cn es) (s, Rerr Rtype_error)

and

forall cenv env cn es err s s'.
do_con_check cenv cn (List.length es) &&
evaluate_list cenv s env es (s', Rerr err)
==>
evaluate cenv s env (Con cn es) (s', Rerr err)

and

forall cenv env n v s targs_opt type_scheme_opt.
(lookup n env = Some (v,type_scheme_opt))
==>
evaluate cenv s env (Var n targs_opt) (s, Rval (do_tapp type_scheme_opt targs_opt v))

and

forall cenv env n s tparams_opt.
(lookup n env = None)
==>
evaluate cenv s env (Var n tparams_opt) (s, Rerr Rtype_error)

and

forall cenv env n e s topt.
true
==>
evaluate cenv s env (Fun n topt e) (s, Rval (Closure env n topt e))

and

forall cenv env uop e v v' s1 s2 s3.
evaluate cenv s1 env e (s2, Rval v) &&
do_uapp s2 uop v = Some (s3,v')
==>
evaluate cenv s1 env (Uapp uop e) (s3, Rval v')

and

forall cenv env uop e v s1 s2.
evaluate cenv s1 env e (s2, Rval v) &&
do_uapp s2 uop v = None
==>
evaluate cenv s1 env (Uapp uop e) (s2, Rerr Rtype_error)

and

forall cenv env uop e err s s'.
evaluate cenv s env e (s', Rerr err)
==>
evaluate cenv s env (Uapp uop e) (s', Rerr err)

and

forall cenv env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 s4.
evaluate cenv s1 env e1 (s2, Rval v1) &&
evaluate cenv s2 env e2 (s3, Rval v2) &&
do_app s3 env op v1 v2 = Some (s4, env', e3) &&
evaluate cenv s4 env' e3 bv
==>
evaluate cenv s1 env (App op e1 e2) bv

and

forall cenv env op e1 e2 v1 v2 s1 s2 s3.
evaluate cenv s1 env e1 (s2, Rval v1) &&
evaluate cenv s2 env e2 (s3, Rval v2) &&
do_app s3 env op v1 v2 = None
==>
evaluate cenv s1 env (App op e1 e2) (s3, Rerr Rtype_error)

and

forall cenv env op e1 e2 v1 err s1 s2 s3.
evaluate cenv s1 env e1 (s2, Rval v1) &&
evaluate cenv s2 env e2 (s3, Rerr err)
==>
evaluate cenv s1 env (App op e1 e2) (s3, Rerr err)

and

forall cenv env op e1 e2 err s s'.
evaluate cenv s env e1 (s', Rerr err)
==>
evaluate cenv s env (App op e1 e2) (s', Rerr err)

and

forall cenv env op e1 e2 v e' bv s1 s2.
evaluate cenv s1 env e1 (s2, Rval v) &&
do_log op v e2 = Some e' &&
evaluate cenv s2 env e' bv
==>
evaluate cenv s1 env (Log op e1 e2) bv

and

forall cenv env op e1 e2 v s1 s2.
evaluate cenv s1 env e1 (s2, Rval v) &&
do_log op v e2 = None
==>
evaluate cenv s1 env (Log op e1 e2) (s2, Rerr Rtype_error)

and

forall cenv env op e1 e2 err s s'.
evaluate cenv s env e1 (s', Rerr err)
==>
evaluate cenv s env (Log op e1 e2) (s', Rerr err)

and

forall cenv env e1 e2 e3 v e' bv s1 s2.
evaluate cenv s1 env e1 (s2, Rval v) &&
do_if v e2 e3 = Some e' &&
evaluate cenv s2 env e' bv
==>
evaluate cenv s1 env (If e1 e2 e3) bv

and

forall cenv env e1 e2 e3 v s1 s2.
evaluate cenv s1 env e1 (s2, Rval v) &&
do_if v e2 e3 = None
==>
evaluate cenv s1 env (If e1 e2 e3) (s2, Rerr Rtype_error)

and

forall cenv env e1 e2 e3 err s s'.
evaluate cenv s env e1 (s', Rerr err)
==>
evaluate cenv s env (If e1 e2 e3) (s', Rerr err)

and

forall cenv env e pes v bv s1 s2.
evaluate cenv s1 env e (s2, Rval v) &&
evaluate_match cenv s2 env v pes bv
==>
evaluate cenv s1 env (Mat e pes) bv

and

forall cenv env e pes err s s'.
evaluate cenv s env e (s', Rerr err)
==>
evaluate cenv s env (Mat e pes) (s', Rerr err)

and

forall cenv env n e1 e2 v bv s1 s2 topt tvs.
evaluate cenv s1 env e1 (s2, Rval v) &&
evaluate cenv s2 (bind n (v, add_tvs tvs topt) env) e2 bv
==>
evaluate cenv s1 env (Let tvs n topt e1 e2) bv

and

forall cenv env n e1 e2 err s s' topt tvs.
evaluate cenv s env e1 (s', Rerr err)
==>
evaluate cenv s env (Let tvs n topt e1 e2) (s', Rerr err)

and

forall cenv env funs e bv s tvs.
all_distinct (List.map (fun (x,a,y,b,z) -> x) funs) &&
evaluate cenv s (build_rec_env tvs funs env) e bv
==>
evaluate cenv s env (Letrec tvs funs e) bv

and

forall cenv env funs e s tvs.
not (all_distinct (List.map (fun (x,a,y,b,z) -> x) funs))
==>
evaluate cenv s env (Letrec tvs funs e) (s, Rerr Rtype_error)

and

forall cenv env s.
true
==>
evaluate_list cenv s env [] (s, Rval [])

and

forall cenv env e es v vs s1 s2 s3.
evaluate cenv s1 env e (s2, Rval v) &&
evaluate_list cenv s2 env es (s3, Rval vs)
==>
evaluate_list cenv s1 env (e::es) (s3, Rval (v::vs))

and

forall cenv env e es err s s'.
evaluate cenv s env e (s', Rerr err)
==>
evaluate_list cenv s env (e::es) (s', Rerr err)

and

forall cenv env e es v err s1 s2 s3.
evaluate cenv s1 env e (s2, Rval v) &&
evaluate_list cenv s2 env es (s3, Rerr err)
==>
evaluate_list cenv s1 env (e::es) (s3, Rerr err)

and

forall cenv env v s.
true
==>
evaluate_match cenv s env v [] (s, Rerr (Rraise Bind_error))

and

forall cenv env v p e pes env' bv s.
all_distinct (pat_bindings p []) &&
(pmatch (Some 0) cenv s p v env = Match env') &&
evaluate cenv s env' e bv
==>
evaluate_match cenv s env v ((p,e)::pes) bv

and

forall cenv env v p e pes bv s.
all_distinct (pat_bindings p []) &&
(pmatch (Some 0) cenv s p v env = No_match) &&
evaluate_match cenv s env v pes bv
==>
evaluate_match cenv s env v ((p,e)::pes) bv

and

forall cenv env v p e pes s.
(pmatch (Some 0) cenv s p v env = Match_type_error)
==>
evaluate_match cenv s env v ((p,e)::pes) (s, Rerr Rtype_error)

and

forall cenv env v p e pes s.
not (all_distinct (pat_bindings p []))
==>
evaluate_match cenv s env v ((p,e)::pes) (s, Rerr Rtype_error)

indreln

forall cenv env s.
true
==>
evaluate_decs cenv s env [] (s, Rval (cenv,env))

and

forall cenv env p e ds v env' r s1 s2 tvs.
evaluate cenv s1 env e (s2, Rval v) &&
all_distinct (pat_bindings p []) &&
(pmatch tvs cenv s2 p v env = Match env') &&
evaluate_decs cenv s2 env' ds r
==>
evaluate_decs cenv s1 env (Dlet tvs p e :: ds) r

and

forall cenv env p e ds v s1 s2 tvs.
evaluate cenv s1 env e (s2, Rval v) &&
all_distinct (pat_bindings p []) &&
(pmatch tvs cenv s2 p v env = No_match)
==>
evaluate_decs cenv s1 env (Dlet tvs p e :: ds) (s2, Rerr (Rraise Bind_error))

and

forall cenv env p e ds v s1 s2 tvs.
evaluate cenv s1 env e (s2, Rval v) &&
(pmatch tvs cenv s2 p v env = Match_type_error)
==>
evaluate_decs cenv s1 env (Dlet tvs p e :: ds) (s2, Rerr Rtype_error)

and

forall cenv env p e ds v s1 s2 tvs.
evaluate cenv s1 env e (s2, Rval v) &&
not (all_distinct (pat_bindings p []))
==>
evaluate_decs cenv s1 env (Dlet tvs p e :: ds) (s2, Rerr Rtype_error)

and

forall cenv env p e ds err s s' tvs.
evaluate cenv s env e (s', Rerr err)
==>
evaluate_decs cenv s env (Dlet tvs p e :: ds) (s', Rerr err)

and

forall cenv env funs ds r s tvs.
all_distinct (List.map (fun (x,topt1,y,topt2,z) -> x) funs) &&
evaluate_decs cenv s (build_rec_env tvs funs env) ds r
==>
evaluate_decs cenv s env (Dletrec tvs funs :: ds) r

and

forall cenv env funs ds s tvs.
not (all_distinct (List.map (fun (x,topt1,y,topt2,z) -> x) funs))
==>
evaluate_decs cenv s env (Dletrec tvs funs :: ds) (s, Rerr Rtype_error)

and

forall cenv env tds ds r s.
check_dup_ctors tds cenv &&
evaluate_decs (merge (build_tdefs tds) cenv) s env ds r
==>
evaluate_decs cenv s env (Dtype tds :: ds) r

and

forall cenv env tds ds s.
not (check_dup_ctors tds cenv)
==>
evaluate_decs cenv s env (Dtype tds :: ds) (s, Rerr Rtype_error)

(* ------------------------------------------------------------------------ *) 
(*   The Type System                                                        *)
(* ------------------------------------------------------------------------ *) 


(* constructor type environments: each constructor has a type
 * forall tyvars. t list -> (tyvars) typeN *)
type tenvC = env conN (list tvarN * list t * typeN)

(* Type environments *)
type tenvE =
  | Empty
  (* Binds several de Bruijn type variables *)
  | Bind_tvar of num * tenvE
  (* The number is how many de Bruijn type variables the typescheme binds *)
  | Bind_name of varN * num * t * tenvE

let bind_tvar tvs tenv = if tvs = 0 then tenv else Bind_tvar tvs tenv

val lookup_tenv : varN -> num -> tenvE -> option (num * t) 
let rec
lookup_tenv n inc Empty = None
and
lookup_tenv n inc (Bind_tvar tvs e) = lookup_tenv n (inc + tvs) e
and
lookup_tenv n inc (Bind_name n' tvs t e) =
  if n' = n then
    Some (tvs, deBruijn_inc tvs inc t)
  else
    lookup_tenv n inc e

val bind_tenv : varN -> num -> t -> tenvE -> tenvE
let bind_tenv n tvs t e = Bind_name n tvs t e

val num_tvs : tenvE -> num
let rec 
num_tvs Empty = 0
and
num_tvs (Bind_tvar tvs e) = tvs + num_tvs e
and
num_tvs (Bind_name n tvs t e) = num_tvs e

(* A pattern matches values of a certain type and extends the type environment
 * with the pattern's binders. The number is the maximum deBruijn type variable
 * allowed. *)
val type_p : num -> tenvC -> pat -> t -> list (varN * t) -> bool

(* An expression has a type *)
val type_e : tenvC -> tenvE -> exp -> t -> bool

(* A list of expressions has a list of types *)
val type_es : tenvC -> tenvE -> list exp -> list t -> bool

(* Type a mutually recursive bundle of functions.  Unlike pattern typing, the
 * resulting environment does not extend the input environment, but just
 * represents the functions *)
val type_funs : tenvC -> tenvE -> list (varN * option t * varN * option t * exp) ->
                list (varN * t) -> bool

(* Check a declaration and update the top-level environments *)
val type_d : tenvC -> tenvE -> dec -> tenvC -> tenvE -> bool

val type_ds : tenvC -> tenvE -> list dec -> tenvC -> tenvE -> bool

(* Check that the operator can have type (t1 -> t2 -> t3) *)
val type_op : op -> t -> t -> t -> bool
let type_op op t1 t2 t3 =
  match (op,t1,t2) with
    | (Opapp, Tfn t2' t3', _) -> (t2 = t2') && (t3 = t3')
    | (Opn _, Tint, Tint) -> (t3 = Tint)
    | (Opb _, Tint, Tint) -> (t3 = Tbool)
    | (Equality, t1, t2) -> (t1 = t2) && (t3 = Tbool)
    | (Opassign, Tref t1, t2) -> (t1 = t2) && (t3 = Tunit)
    | _ -> false
  end

(* Check that the operator can have type (t1 -> t2) *)
val type_uop : uop -> t -> t -> bool
let type_uop uop t1 t2 =
  match (uop,t1) with
    | (Opref, _) -> t2 = Tref t1
    | (Opderef, Tref t1') -> t2 = t1'
    | _ -> false
  end

(* Check that the free type variables are in the given list.  Every deBruijn
 * variable must be smaller than the first argument.  So if it is 0, no deBruijn
 * indices are permitted. *)
val check_freevars : num -> list tvarN -> t -> bool
let rec
check_freevars dbmax tvs (Tvar tv) =
  List.mem tv tvs
and
check_freevars dbmax tvs (Tapp ts tn) =
  List.for_all (check_freevars dbmax tvs) ts
and
check_freevars dbmax tvs (Tfn t1 t2) =
  check_freevars dbmax tvs t1 && check_freevars dbmax tvs t2
and
check_freevars dbmax tvs Tint = true
and
check_freevars dbmax tvs Tbool = true
and
check_freevars dbmax tvs Tunit = true
and
check_freevars dbmax tvs (Tref t) = check_freevars dbmax tvs t
and
check_freevars dbmax tvs (Tvar_db n) = n < dbmax

(* Check that a type definition defines no already defined (or duplicate)
 * constructors or types, and that the free type variables of each constructor
 * argument type are included in the type's type parameters. *)
val check_ctor_tenv :
  tenvC -> list (list tvarN * typeN * list (conN * list t)) -> bool
let check_ctor_tenv tenvC tds =
  check_dup_ctors tds tenvC &&
  List.for_all
    (fun (tvs,tn,ctors) ->
       all_distinct tvs &&
       List.for_all
         (fun (cn,ts) -> (List.for_all (check_freevars 0 tvs) ts))
         ctors)
    tds &&
  all_distinct (List.map (fun (_,tn,_) -> tn) tds) &&
  List.for_all
    (fun (tvs,tn,ctors) ->
       List.for_all (fun (_,(_,_,tn')) -> tn <> tn') tenvC)
    tds

val build_ctor_tenv : list (list tvarN * typeN * list (conN * list t)) -> tenvC
let build_ctor_tenv tds =
  List.flatten
    (List.map
       (fun (tvs,tn,ctors) ->
          List.map (fun (cn,ts) -> (cn,(tvs,ts,tn))) ctors)
       tds)

(* Simultaneous substitution of types for type variables in a type *)
val type_subst : env tvarN t -> t -> t
let rec
type_subst s (Tvar tv) =
  match lookup tv s with
    | None -> Tvar tv
    | Some(t) -> t
  end
and
type_subst s (Tapp ts tn) =
  Tapp (List.map (type_subst s) ts) tn
and
type_subst s (Tfn t1 t2) =
  Tfn (type_subst s t1) (type_subst s t2)
and
type_subst s Tint = Tint
and
type_subst s Tbool = Tbool
and
type_subst s Tunit = Tunit
and
type_subst s (Tref t) = Tref (type_subst s t)
and
type_subst s (Tvar_db n) = Tvar_db n

val bind_var_list : num -> list (varN * t) -> tenvE -> tenvE
let rec
bind_var_list tvs [] tenv = tenv
and
bind_var_list tvs ((n,t)::binds) tenv =
  bind_tenv n tvs t (bind_var_list tvs binds tenv)

(* For the value restriction on let-based polymorphism *)
val is_value : exp -> bool
let rec 
is_value (Lit _) = true
and
is_value (Con _ es) = List.for_all is_value es
and
is_value (Var _ _) = true
and
is_value (Fun _ _ _) = true
and
is_value _ = false

indreln

forall tvs cenv n t.
check_freevars tvs [] t
==>
type_p tvs cenv (Pvar n (Some t)) t [(n,t)]

and

forall tvs cenv b.
true
==>
type_p tvs cenv (Plit (Bool b)) Tbool []

and

forall tvs cenv n.
true
==>
type_p tvs cenv (Plit (IntLit n)) Tint []

and

forall tvs cenv.
true
==>
type_p tvs cenv (Plit Unit) Tunit []

and

forall tvs cenv cn ps ts tvs' tn ts' tenv.
List.for_all (check_freevars tvs []) ts' &&
List.length ts' = List.length tvs' &&
type_ps tvs cenv ps (List.map (type_subst (List.combine tvs' ts')) ts) tenv &&
lookup cn cenv = Some (tvs', ts, tn)
==>
type_p tvs cenv (Pcon cn ps) (Tapp ts' tn) tenv

and

forall tvs cenv p t tenv.
type_p tvs cenv p t tenv
==>
type_p tvs cenv (Pref p) (Tref t) tenv

and

forall tvs cenv.
true
==>
type_ps tvs cenv [] [] []

and

forall tvs cenv p ps t ts tenv tenv'.
type_p tvs cenv p t tenv &&
type_ps tvs cenv ps ts tenv'
==>
type_ps tvs cenv (p::ps) (t::ts) (tenv'@tenv)

indreln

forall cenv tenv b.
true
==>
type_e cenv tenv (Lit (Bool b)) Tbool

and

forall cenv tenv n.
true
==>
type_e cenv tenv (Lit (IntLit n)) Tint

and

forall cenv tenv.
true
==>
type_e cenv tenv (Lit Unit) Tunit

and

forall cenv tenv err t.
check_freevars (num_tvs tenv) [] t
==>
type_e cenv tenv (Raise err) t

and

forall cenv tenv e1 var e2 t.
type_e cenv tenv e1 t &&
type_e cenv (bind_tenv var 0 Tint tenv) e2 t
==>
type_e cenv tenv (Handle e1 var e2) t

and

forall cenv tenv cn es tvs tn ts' ts.
List.for_all (check_freevars (num_tvs tenv) []) ts' &&
List.length tvs = List.length ts' &&
type_es cenv tenv es (List.map (type_subst (List.combine tvs ts')) ts) &&
lookup cn cenv = Some (tvs, ts, tn)
==>
type_e cenv tenv (Con cn es) (Tapp ts' tn)

and

forall cenv tenv n t targs tvs.
(tvs = List.length targs) &&
List.for_all (check_freevars (num_tvs tenv) []) targs &&
(lookup_tenv n 0 tenv = Some (tvs,t))
==>
type_e cenv tenv (Var n (Some targs)) (deBruijn_subst 0 targs t)

and

forall cenv tenv n e t1 t2.
check_freevars (num_tvs tenv) [] t1 &&
type_e cenv (bind_tenv n 0 t1 tenv) e t2
==>
type_e cenv tenv (Fun n (Some t1) e) (Tfn t1 t2)

and

forall cenv tenv uop e t1 t2.
type_e cenv tenv e t1 &&
type_uop uop t1 t2
==>
type_e cenv tenv (Uapp uop e) t2

and

forall cenv tenv op e1 e2 t1 t2 t3.
type_e cenv tenv e1 t1 &&
type_e cenv tenv e2 t2 &&
type_op op t1 t2 t3
==>
type_e cenv tenv (App op e1 e2) t3

and

forall cenv tenv l e1 e2.
type_e cenv tenv e1 Tbool &&
type_e cenv tenv e2 Tbool
==>
type_e cenv tenv (Log l e1 e2) Tbool

and

forall cenv tenv e1 e2 e3 t.
type_e cenv tenv e1 Tbool &&
type_e cenv tenv e2 t &&
type_e cenv tenv e3 t
==>
type_e cenv tenv (If e1 e2 e3) t

and

forall cenv tenv e pes t1 t2.
type_e cenv tenv e t1 &&
(pes <> []) &&
(forall ((p,e) MEM pes) . exists tenv'.
   all_distinct (pat_bindings p []) &&
   type_p (num_tvs tenv) cenv p t1 tenv' &&
   type_e cenv (bind_var_list 0 tenv' tenv) e t2)
==>
type_e cenv tenv (Mat e pes) t2

and

forall cenv tenv n e1 e2 t1 t2 tvs.
is_value e1 &&
type_e cenv (bind_tvar tvs tenv) e1 t1 &&
type_e cenv (bind_tenv n tvs t1 tenv) e2 t2
==>
type_e cenv tenv (Let (Some tvs) n (Some t1) e1 e2) t2

and

forall cenv tenv n e1 e2 t1 t2.
type_e cenv tenv e1 t1 &&
type_e cenv (bind_tenv n 0 t1 tenv) e2 t2
==>
type_e cenv tenv (Let (Some 0) n (Some t1) e1 e2) t2

and

forall cenv tenv funs e t tenv' tvs.
type_funs cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv' &&
type_e cenv (bind_var_list tvs tenv' tenv) e t
==>
type_e cenv tenv (Letrec (Some tvs) funs e) t

and

forall cenv tenv.
true
==>
type_es cenv tenv [] []

and

forall cenv tenv e es t ts.
type_e cenv tenv e t &&
type_es cenv tenv es ts
==>
type_es cenv tenv (e::es) (t::ts)

and

forall cenv env.
true
==>
type_funs cenv env [] []

and

forall cenv env fn n e funs env' t1 t2.
check_freevars (num_tvs env) [] (Tfn t1 t2) &&
type_e cenv (bind_tenv n 0 t1 env) e t2 &&
type_funs cenv env funs env' &&
lookup fn env' = None
==>
type_funs cenv env ((fn, Some (Tfn t1 t2), n, Some t1, e)::funs) ((fn, Tfn t1 t2)::env')

indreln

forall tvs cenv tenv p e t tenv'.
is_value e &&
all_distinct (pat_bindings p []) &&
type_p tvs cenv p t tenv' &&
type_e cenv (bind_tvar tvs tenv) e t
==>
type_d cenv tenv (Dlet (Some tvs) p e) emp (bind_var_list tvs tenv' tenv)

and

forall cenv tenv p e t tenv'.
all_distinct (pat_bindings p []) &&
type_p 0 cenv p t tenv' &&
type_e cenv tenv e t
==>
type_d cenv tenv (Dlet (Some 0) p e) emp (bind_var_list 0 tenv' tenv)

and

forall cenv tenv funs tenv' tvs.
type_funs cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv'
==>
type_d cenv tenv (Dletrec (Some tvs) funs) emp (bind_var_list tvs tenv' tenv)

and

forall cenv tenv tdecs.
check_ctor_tenv cenv tdecs
==>
type_d cenv tenv (Dtype tdecs) (build_ctor_tenv tdecs) tenv

indreln

forall cenv tenv.
true
==>
type_ds cenv tenv [] emp tenv

and

forall cenv tenv d ds cenv' tenv' cenv'' tenv''.
type_d cenv tenv d cenv' tenv' &&
type_ds (merge (List.rev cenv') cenv) tenv' ds cenv'' tenv''
==>
type_ds cenv tenv (d::ds) (merge cenv' cenv'') tenv''

(* ------------------------------------------------------------------------ *) 
(*   Auxiliary definitions used in the proofs                               *)
(* ------------------------------------------------------------------------ *) 

(* Store typing *)
type tenvS = env num t

(* A value has a type *)
(* The number is how many deBruijn type variables are bound in the context. *)
val type_v : num -> tenvC -> tenvS -> v -> t -> bool

(* A value environment has a corresponding type environment.  Since all of the
 * entries in the environment are values, and values have no free variables,
 * each entry in the environment can be typed in the empty environment (if at
 * all) *)
val type_env : tenvC -> tenvS -> envE -> tenvE -> bool

(* The type of the store *)
val type_s : tenvC -> tenvS -> store -> bool

(* An evaluation context has the second type when its hole is filled with a
 * value of the first type. *)
(* The number is how many deBruijn type variables are bound in the context.
 * This is only used for constructor contexts, because the value restriction 
 * ensures that no other contexts can be created under a let binding. *)
val type_ctxt : num -> tenvC -> tenvS -> tenvE -> ctxt_frame -> t -> t -> bool
val type_ctxts : num -> tenvC -> tenvS -> list ctxt -> t -> t -> bool
val type_state : num -> tenvC -> tenvS -> state -> t -> bool
val context_invariant : num -> list ctxt -> num -> bool

indreln

forall tvs cenv senv b.
true
==>
type_v tvs cenv senv (Litv (Bool b)) Tbool

and

forall tvs cenv senv n.
true
==>
type_v tvs cenv senv (Litv (IntLit n)) Tint

and

forall tvs cenv senv.
true
==>
type_v tvs cenv senv (Litv Unit) Tunit

and

forall tvs cenv senv cn vs tvs' tn ts' ts.
List.for_all (check_freevars tvs []) ts' &&
List.length tvs' = List.length ts' &&
type_vs tvs cenv senv vs (List.map (type_subst (List.combine tvs' ts')) ts) &&
lookup cn cenv = Some (tvs', ts, tn)
==>
type_v tvs cenv senv (Conv cn vs) (Tapp ts' tn)

and

forall tvs cenv senv env tenv n e t1 t2.
type_env cenv senv env tenv &&
check_freevars tvs [] t1 &&
type_e cenv (bind_tenv n 0 t1 (bind_tvar tvs tenv)) e t2
==>
type_v tvs cenv senv (Closure env n (Some t1) e) (Tfn t1 t2)

and

forall tvs cenv senv env funs n t tenv tenv'.
type_env cenv senv env tenv &&
type_funs cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv' &&
lookup n tenv' = Some t
==>
type_v tvs cenv senv (Recclosure env funs n) t

and

forall tvs cenv senv n t.
check_freevars 0 [] t &&
(lookup n senv = Some t)
==>
type_v tvs cenv senv (Loc n) (Tref t)

and

forall tvs cenv senv.
true
==>
type_vs tvs cenv senv [] []

and

forall tvs cenv senv v vs t ts.
type_v tvs cenv senv v t &&
type_vs tvs cenv senv vs ts
==>
type_vs tvs cenv senv (v::vs) (t::ts)

and

forall cenv senv.
true
==>
type_env cenv senv emp Empty

and

forall cenv senv n v env t tenv tvs.
type_v tvs cenv senv v t &&
type_env cenv senv env tenv
==>
type_env cenv senv (bind n (v,Some (tvs,t)) env) (bind_tenv n tvs t tenv)

let type_s cenv senv s =
  forall l. 
    ((exists t. lookup l senv = Some t) = (exists v. store_lookup l s = Some v)) &&
    forall t v. ((lookup l senv = Some t) && (store_lookup l s = Some v)) --> type_v 0 cenv senv v t

indreln 

forall n.
true
==>
context_invariant n [] n

and

forall dec_tvs c x e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Chandle () x e,env) :: c) 0

and

forall dec_tvs c op e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Capp1 op () e,env) :: c) 0

and

forall dec_tvs c op v env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Capp2 op v (),env) :: c) 0

and

forall dec_tvs c l e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Clog l () e,env) :: c) 0

and

forall dec_tvs c e1 e2 env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cif () e1 e2,env) :: c) 0

and

forall dec_tvs c pes env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cmat () pes,env) :: c) 0

and

forall dec_tvs c tvs x topt e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Clet (Some tvs) x topt () e,env) :: c) tvs

and

forall dec_tvs c cn vs es tvs env.
context_invariant dec_tvs c tvs &&
(tvs <> 0 --> List.for_all is_value es)
==>
context_invariant dec_tvs ((Ccon cn vs () es,env) :: c) tvs

and

forall dec_tvs c op env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cuapp op (),env) :: c) 0

indreln

forall tvs cenv senv tenv x e t.
type_e cenv (bind_tenv x 0 Tint tenv) e t
==>
type_ctxt tvs cenv senv tenv (Chandle () x e) t t

and

forall tvs cenv senv tenv uop t1 t2.
check_freevars tvs [] t1 &&
check_freevars tvs [] t2 &&
type_uop uop t1 t2
==>
type_ctxt tvs cenv senv tenv (Cuapp uop ()) t1 t2

and

forall tvs cenv senv tenv e op t1 t2 t3.
check_freevars tvs [] t1 &&
check_freevars tvs [] t3 &&
type_e cenv tenv e t2 &&
type_op op t1 t2 t3
==>
type_ctxt tvs cenv senv tenv (Capp1 op () e) t1 t3

and

forall tvs cenv senv tenv op v t1 t2 t3.
check_freevars tvs [] t2 &&
check_freevars tvs [] t3 &&
type_v 0 cenv senv v t1 &&
type_op op t1 t2 t3
==>
type_ctxt tvs cenv senv tenv (Capp2 op v ()) t2 t3

and

forall tvs cenv senv tenv op e.
type_e cenv tenv e Tbool
==>
type_ctxt tvs cenv senv tenv (Clog op () e) Tbool Tbool

and

forall tvs cenv senv tenv e1 e2 t.
type_e cenv tenv e1 t &&
type_e cenv tenv e2 t
==>
type_ctxt tvs cenv senv tenv (Cif () e1 e2) Tbool t

and

forall tvs cenv senv tenv t1 t2 pes.
((pes = []) --> (check_freevars tvs [] t1 && check_freevars 0 [] t2)) &&
(forall ((p,e) MEM pes) . exists tenv'.
   all_distinct (pat_bindings p []) &&
   type_p tvs cenv p t1 tenv' &&
   type_e cenv (bind_var_list 0 tenv' tenv) e t2)
==>
type_ctxt tvs cenv senv tenv (Cmat () pes) t1 t2

and

forall tvs cenv senv tenv e t1 t2 n tvs'.
check_freevars tvs [] t1 &&
type_e cenv (bind_tenv n tvs' t1 tenv) e t2
==>
type_ctxt tvs cenv senv tenv (Clet (Some tvs') n (Some t1) () e) t1 t2

and

forall tvs cenv senv tenv cn vs es ts1 ts2 t tn ts' tvs'.
List.for_all (check_freevars tvs []) ts' &&
List.length tvs' = List.length ts' &&
type_vs tvs cenv senv (List.rev vs)
        (List.map (type_subst (List.combine tvs' ts')) ts1) &&
type_es cenv (bind_tvar tvs tenv) es (List.map (type_subst (List.combine tvs' ts')) ts2) &&
lookup cn cenv = Some (tvs', ts1@[t]@ts2, tn)
==>
type_ctxt tvs cenv senv tenv (Ccon cn vs () es) (type_subst (List.combine tvs' ts') t)
          (Tapp ts' tn)

indreln

forall dec_tvs tenvC senv t.
check_freevars dec_tvs [] t
==>
type_ctxts dec_tvs tenvC senv [] t t

and

forall dec_tvs tenvC senv c env cs tenv t1 t2 t3 tvs.
type_env tenvC senv env tenv &&
context_invariant dec_tvs ((c,env)::cs) tvs &&
type_ctxt tvs tenvC senv tenv c t1 t2 &&
type_ctxts dec_tvs tenvC senv cs t2 t3
==>
type_ctxts dec_tvs tenvC senv ((c,env)::cs) t1 t3

indreln

forall dec_tvs tenvC senv envC s env e c t1 t2 tenv tvs.
type_ctxts dec_tvs tenvC senv c t1 t2 &&
type_env tenvC senv env tenv &&
type_s tenvC senv s &&
context_invariant dec_tvs c tvs &&
type_e tenvC (bind_tvar tvs tenv) e t1 &&
((tvs <> 0) --> is_value e)
==>
type_state dec_tvs tenvC senv (envC, s, env, Exp e, c) t2

and

forall dec_tvs tenvC senv envC s env v c t1 t2 tenv tvs.
type_ctxts dec_tvs tenvC senv c t1 t2 &&
type_env tenvC senv env tenv &&
type_s tenvC senv s &&
context_invariant dec_tvs c tvs &&
type_v tvs tenvC senv v t1
==>
type_state dec_tvs tenvC senv (envC, s, env, Val v, c) t2

indreln

forall tenvC senv envC s env ds tenvC' tenv tenv'.
type_env tenvC senv env tenv &&
type_s tenvC senv s &&
type_ds tenvC tenv ds tenvC' tenv'
==>
type_d_state tenvC (envC, s, env, ds, None) tenvC' tenv'

and

forall tenvC senv envC s env ds tenvC' tenv tenv' p s' env' e c t tenv'' tvs.
type_env tenvC senv env tenv &&
type_state tvs tenvC senv (envC,s',env',e,c) t &&
all_distinct (pat_bindings p []) &&
type_p tvs tenvC p t tenv' &&
type_s tenvC senv s' &&
type_ds tenvC (bind_var_list tvs tenv' tenv) ds tenvC' tenv''
==>
type_d_state tenvC (envC, s, env, ds, Some (Some tvs, p, (envC,s',env',e,c))) tenvC' tenv''

(* ------ Auxiliary relations for proving big/small step equivalence ------ *)

val evaluate_ctxt : envC -> store -> envE -> ctxt_frame -> v -> store * result v -> bool
val evaluate_ctxts : envC -> store -> list ctxt -> result v -> store * result v -> bool
val evaluate_state : state -> store * result v -> bool

indreln

forall cenv s env v1 e2 var.
true
==>
evaluate_ctxt cenv s env (Chandle () var e2) v1 (s, Rval v1)

and

forall cenv env op e2 v1 v2 env' e3 bv s1 s2 s3.
evaluate cenv s1 env e2 (s2, Rval v2) &&
do_app s2 env op v1 v2 = Some (s3,env', e3) &&
evaluate cenv s3 env' e3 bv
==>
evaluate_ctxt cenv s1 env (Capp1 op () e2) v1 bv

and

forall cenv env op e2 v1 v2 s1 s2.
evaluate cenv s1 env e2 (s2, Rval v2) &&
do_app s2 env op v1 v2 = None
==>
evaluate_ctxt cenv s1 env (Capp1 op () e2) v1 (s2, Rerr Rtype_error)

and

forall cenv env op e2 v1 err s s'.
evaluate cenv s env e2 (s', Rerr err)
==>
evaluate_ctxt cenv s env (Capp1 op () e2) v1 (s', Rerr err)

and

forall cenv env op v1 v2 env' e3 bv s1 s2.
do_app s1 env op v1 v2 = Some (s2, env', e3) &&
evaluate cenv s2 env' e3 bv
==>
evaluate_ctxt cenv s1 env (Capp2 op v1 ()) v2 bv

and

forall cenv env op v1 v2 s.
(do_app s env op v1 v2 = None)
==>
evaluate_ctxt cenv s env (Capp2 op v1 ()) v2 (s, Rerr Rtype_error)

and

forall cenv env uop v v' s1 s2.
(do_uapp s1 uop v = Some (s2,v'))
==>
evaluate_ctxt cenv s1 env (Cuapp uop ()) v (s2, Rval v')

and

forall cenv env uop v s.
(do_uapp s uop v = None)
==>
evaluate_ctxt cenv s env (Cuapp uop ()) v (s, Rerr Rtype_error)

and

forall cenv env op e2 v e' bv s.
do_log op v e2 = Some e' &&
evaluate cenv s env e' bv
==>
evaluate_ctxt cenv s env (Clog op () e2) v bv

and

forall cenv env op e2 v s.
(do_log op v e2 = None)
==>
evaluate_ctxt cenv s env (Clog op () e2) v (s, Rerr Rtype_error)

and
forall cenv env e2 e3 v e' bv s.
do_if v e2 e3 = Some e' &&
evaluate cenv s env e' bv
==>
evaluate_ctxt cenv s env (Cif () e2 e3) v bv

and

forall cenv env e2 e3 v s.
(do_if v e2 e3 = None)
==>
evaluate_ctxt cenv s env (Cif () e2 e3) v (s, Rerr Rtype_error)

and

forall cenv env pes v bv s.
evaluate_match cenv s env v pes bv
==>
evaluate_ctxt cenv s env (Cmat () pes) v bv

and

forall cenv env n e2 v bv s topt tvs.
evaluate cenv s (bind n (v,add_tvs tvs topt) env) e2 bv
==>
evaluate_ctxt cenv s env (Clet tvs n topt () e2) v bv

and

forall cenv env cn es vs v vs' s1 s2.
do_con_check cenv cn (List.length vs + List.length es + 1) &&
evaluate_list cenv s1 env es (s2, Rval vs')
==>
evaluate_ctxt cenv s1 env (Ccon cn vs () es) v (s2, Rval (Conv cn (List.rev vs @ [v] @ vs')))

and

forall cenv env cn es vs v s.
not (do_con_check cenv cn (List.length vs + List.length es + 1))
==>
evaluate_ctxt cenv s env (Ccon cn vs () es) v (s, Rerr Rtype_error)

and

forall cenv env cn es vs v err s s'.
do_con_check cenv cn (List.length vs + List.length es + 1) &&
evaluate_list cenv s env es (s', Rerr err)
==>
evaluate_ctxt cenv s env (Ccon cn vs () es) v (s', Rerr err)

indreln

forall cenv res s.
true
==>
evaluate_ctxts cenv s [] res (s, res)

and

forall cenv c cs env v res bv s1 s2.
evaluate_ctxt cenv s1 env c v (s2, res) &&
evaluate_ctxts cenv s2 cs res bv
==>
evaluate_ctxts cenv s1 ((c,env)::cs) (Rval v) bv

and

forall cenv c cs env err s bv.
evaluate_ctxts cenv s cs (Rerr err) bv &&
((forall i e'. c <> Chandle () i e') ||
 (forall i. err <> Rraise (Int_error i)))
==>
evaluate_ctxts cenv s ((c,env)::cs) (Rerr err) bv

and

forall cenv cs env s s' var res1 res2 i e'.
evaluate cenv s (bind var (Litv (IntLit i), Some (0,Tint)) env) e' (s', res1) &&
evaluate_ctxts cenv s' cs res1 res2
==>
evaluate_ctxts cenv s ((Chandle () var e',env)::cs) (Rerr (Rraise (Int_error i))) res2

indreln

forall cenv env e c res bv s1 s2.
evaluate cenv s1 env e (s2, res) &&
evaluate_ctxts cenv s2 c res bv
==>
evaluate_state (cenv, s1, env, Exp e, c) bv

and

forall cenv s env v c bv.
evaluate_ctxts cenv s c (Rval v) bv
==>
evaluate_state (cenv, s, env, Val v, c) bv


(* ------------------------------------------------------------------------ *) 
(*   Alternate big-step semantics                                           *)
(* ------------------------------------------------------------------------ *) 

(* A version of the big-step expression semantics that doesn't use the
 * constructor environment to know if a value is ok or not.  Is equivalent to
 * the normal one for well-typed programs. *)

val pmatch' : option num -> store -> pat -> v -> envE -> match_result
let rec
pmatch' tvs s (Pvar n topt) v' env = Match (bind n (v', add_tvs tvs topt) env)
and
pmatch' tvs s (Plit l) (Litv l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error
and
pmatch' tvs s (Pcon n ps) (Conv n' vs) env =
  if List.length ps = List.length vs && n = n' then
    pmatch_list' tvs s ps vs env
  else
    No_match
and
pmatch' tvs s (Pref p) (Loc lnum) env =
  match store_lookup lnum s with
    | Some v -> pmatch' tvs s p v env
    | None -> Match_type_error
  end
and
pmatch' tvs _ _ _ env = Match_type_error
and
pmatch_list' tvs s [] [] env = Match env
and
pmatch_list' tvs s (p::ps) (v::vs) env =
  match pmatch' tvs s p v env with
    | No_match -> No_match
    | Match_type_error -> Match_type_error
    | Match env' -> pmatch_list' tvs s ps vs env'
  end
and
pmatch_list' tvs _ _ _ env = Match_type_error


indreln

forall env l s.
true
==>
evaluate' s env (Lit l) (s, Rval (Litv l))

and

forall env err s.
true
==>
evaluate' s env (Raise err) (s, Rerr (Rraise err))

and

forall s1 s2 env e1 e2 v var.
evaluate' s1 env e1 (s2, Rval v)
==>
evaluate' s1 env (Handle e1 var e2) (s2, Rval v)

and

forall s1 s2 env e1 e2 n var bv.
evaluate' s1 env e1 (s2, Rerr (Rraise (Int_error n))) &&
evaluate' s2 (bind var (Litv (IntLit n), Some (0,Tint)) env) e2 bv
==>
evaluate' s1 env (Handle e1 var e2) bv

and

forall s1 s2 env e1 e2 var err.
evaluate' s1 env e1 (s2, Rerr err) &&
(err = Rtype_error || err = Rraise Bind_error || err = Rraise Div_error)
==>
evaluate' s1 env (Handle e1 var e2) (s2, Rerr err)

and

forall env cn es vs s1 s2.
evaluate_list' s1 env es (s2, Rval vs)
==>
evaluate' s1 env (Con cn es) (s2, Rval (Conv cn vs))

and

forall env cn es err s s'.
evaluate_list' s env es (s', Rerr err)
==>
evaluate' s env (Con cn es) (s', Rerr err)

and

forall env n v s targs_opt type_scheme_opt.
(lookup n env = Some (v,type_scheme_opt))
==>
evaluate' s env (Var n targs_opt) (s, Rval (do_tapp type_scheme_opt targs_opt v))

and

forall env n s targs_opt.
(lookup n env = None)
==>
evaluate' s env (Var n targs_opt) (s, Rerr Rtype_error)

and

forall env n e s topt.
true
==>
evaluate' s env (Fun n topt e) (s, Rval (Closure env n topt e))

and

forall env uop e v v' s1 s2 s3.
evaluate' s1 env e (s2, Rval v) &&
do_uapp s2 uop v = Some (s3,v')
==>
evaluate' s1 env (Uapp uop e) (s3, Rval v')

and

forall env uop e v s1 s2.
evaluate' s1 env e (s2, Rval v) &&
do_uapp s2 uop v = None
==>
evaluate' s1 env (Uapp uop e) (s2, Rerr Rtype_error)

and

forall env uop e err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate' s env (Uapp uop e) (s', Rerr err)

and

forall env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 s4.
evaluate' s1 env e1 (s2, Rval v1) &&
evaluate' s2 env e2 (s3, Rval v2) &&
do_app s3 env op v1 v2 = Some (s4, env', e3) &&
evaluate' s4 env' e3 bv
==>
evaluate' s1 env (App op e1 e2) bv

and

forall env op e1 e2 v1 v2 s1 s2 s3.
evaluate' s1 env e1 (s2, Rval v1) &&
evaluate' s2 env e2 (s3, Rval v2) &&
do_app s3 env op v1 v2 = None
==>
evaluate' s1 env (App op e1 e2) (s3, Rerr Rtype_error)

and

forall env op e1 e2 v1 err s1 s2 s3.
evaluate' s1 env e1 (s2, Rval v1) &&
evaluate' s2 env e2 (s3, Rerr err)
==>
evaluate' s1 env (App op e1 e2) (s3, Rerr err)

and

forall env op e1 e2 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (App op e1 e2) (s', Rerr err)

and

forall env op e1 e2 v e' bv s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
do_log op v e2 = Some e' &&
evaluate' s2 env e' bv
==>
evaluate' s1 env (Log op e1 e2) bv

and

forall env op e1 e2 v s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
do_log op v e2 = None
==>
evaluate' s1 env (Log op e1 e2) (s2, Rerr Rtype_error)

and

forall env op e1 e2 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (Log op e1 e2) (s', Rerr err)

and

forall env e1 e2 e3 v e' bv s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
do_if v e2 e3 = Some e' &&
evaluate' s2 env e' bv
==>
evaluate' s1 env (If e1 e2 e3) bv

and

forall env e1 e2 e3 v s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
do_if v e2 e3 = None
==>
evaluate' s1 env (If e1 e2 e3) (s2, Rerr Rtype_error)

and


forall env e1 e2 e3 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (If e1 e2 e3) (s', Rerr err)

and

forall env e pes v bv s1 s2.
evaluate' s1 env e (s2, Rval v) &&
evaluate_match' s2 env v pes bv
==>
evaluate' s1 env (Mat e pes) bv

and

forall env e pes err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate' s env (Mat e pes) (s', Rerr err)

and

forall env n e1 e2 v bv s1 s2 topt tvs.
evaluate' s1 env e1 (s2, Rval v) &&
evaluate' s2 (bind n (v,add_tvs tvs topt) env) e2 bv
==>
evaluate' s1 env (Let tvs n topt e1 e2) bv

and

forall env n e1 e2 err s s' topt tvs.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (Let tvs n topt e1 e2) (s', Rerr err)

and

forall env funs e bv s tvs.
all_distinct (List.map (fun (x,topt1,y,topt2,z) -> x) funs) &&
evaluate' s (build_rec_env tvs funs env) e bv
==>
evaluate' s env (Letrec tvs funs e) bv

and

forall env funs e s tvs.
not (all_distinct (List.map (fun (x,topt1,y,topt2,z) -> x) funs))
==>
evaluate' s env (Letrec tvs funs e) (s, Rerr Rtype_error)

and

forall env s.
true
==>
evaluate_list' s env [] (s, Rval [])

and

forall env e es v vs s1 s2 s3.
evaluate' s1 env e (s2, Rval v) &&
evaluate_list' s2 env es (s3, Rval vs)
==>
evaluate_list' s1 env (e::es) (s3, Rval (v::vs))

and

forall env e es err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate_list' s env (e::es) (s', Rerr err)

and

forall env e es v err s1 s2 s3.
evaluate' s1 env e (s2, Rval v) &&
evaluate_list' s2 env es (s3, Rerr err)
==>
evaluate_list' s1 env (e::es) (s3, Rerr err)

and

forall env v s.
true
==>
evaluate_match' s env v [] (s, Rerr (Rraise Bind_error))

and

forall env v p e pes env' bv s.
all_distinct (pat_bindings p []) &&
(pmatch' (Some 0) s p v env = Match env') &&
evaluate' s env' e bv
==>
evaluate_match' s env v ((p,e)::pes) bv

and

forall env v p e pes bv s.
all_distinct (pat_bindings p []) &&
(pmatch' (Some 0) s p v env = No_match) &&
evaluate_match' s env v pes bv
==>
evaluate_match' s env v ((p,e)::pes) bv

and

forall env v p e pes s.
(pmatch' (Some 0) s p v env = Match_type_error)
==>
evaluate_match' s env v ((p,e)::pes) (s, Rerr Rtype_error)

and

forall env v p e pes s.
not (all_distinct (pat_bindings p []))
==>
evaluate_match' s env v ((p,e)::pes) (s, Rerr Rtype_error)


indreln

forall cenv env s.
true
==>
evaluate_decs' cenv s env [] (s, Rval (cenv,env))

and

forall cenv env p e ds v env' r s1 s2 tvs.
evaluate' s1 env e (s2, Rval v) &&
all_distinct (pat_bindings p []) &&
(* TODO: Should be pmatch' ? *)
(pmatch tvs cenv s2 p v env = Match env') &&
evaluate_decs' cenv s2 env' ds r
==>
evaluate_decs' cenv s1 env (Dlet tvs p e :: ds) r

and

forall cenv env p e ds v s1 s2 tvs.
evaluate' s1 env e (s2, Rval v) &&
all_distinct (pat_bindings p []) &&
(pmatch tvs cenv s2 p v env = No_match)
==>
evaluate_decs' cenv s1 env (Dlet tvs p e :: ds) (s2, Rerr (Rraise Bind_error))

and

forall cenv env p e ds v s1 s2 tvs.
evaluate' s1 env e (s2, Rval v) &&
(pmatch tvs cenv s2 p v env = Match_type_error)
==>
evaluate_decs' cenv s1 env (Dlet tvs p e :: ds) (s2, Rerr (Rtype_error))

and

forall cenv env p e ds v s1 s2 tvs.
evaluate' s1 env e (s2, Rval v) &&
not (all_distinct (pat_bindings p []))
==>
evaluate_decs' cenv s1 env (Dlet tvs p e :: ds) (s2, Rerr (Rtype_error))

and

forall cenv env p e ds err s s' tvs.
evaluate' s env e (s', Rerr err)
==>
evaluate_decs' cenv s env (Dlet tvs p e :: ds) (s', Rerr err)

and

forall cenv env funs ds r s tvs.
all_distinct (List.map (fun (x,topt1,y,topt2,z) -> x) funs) &&
evaluate_decs' cenv s (build_rec_env tvs funs env) ds r
==>
evaluate_decs' cenv s env (Dletrec tvs funs :: ds) r

and

forall cenv env funs ds s tvs.
not (all_distinct (List.map (fun (x,topt1,y,topt2,z) -> x) funs))
==>
evaluate_decs' cenv s env (Dletrec tvs funs :: ds) (s, Rerr Rtype_error)

and

forall cenv env tds ds r s.
check_dup_ctors tds cenv &&
evaluate_decs' (merge (build_tdefs tds) cenv) s env ds r
==>
evaluate_decs' cenv s env (Dtype tds :: ds) r

and

forall cenv env tds ds s.
not (check_dup_ctors tds cenv)
==>
evaluate_decs' cenv s env (Dtype tds :: ds) (s, Rerr Rtype_error)
