open import Pervasives_extra
open import Lib
open import Ast 
open import SemanticPrimitives

(* A version of the big-step expression semantics that doesn't use the
 * constructor environment to know if a value is ok or not.  It also has no
 * module environment. Is equivalent to the normal one for well-typed programs
 * that don't contain module references. *)

val pmatch' : store -> pat -> v -> envE -> match_result
let rec
pmatch' s (Pvar n) v' env = Match (bind n v' env)
and
pmatch' s (Plit l) (Litv l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error
and
pmatch' s (Pcon cn ps) (Conv cn' vs) env =
  if List.length ps = List.length vs && (cn = cn') then
    pmatch_list' s ps vs env
  else
    No_match
and
pmatch' s (Pref p) (Loc lnum) env =
  match store_lookup lnum s with
    | Just v -> pmatch' s p v env
    | Nothing -> Match_type_error
  end
and
pmatch' _ _ _ env = Match_type_error
and
pmatch_list' s [] [] env = Match env
and
pmatch_list' s (p::ps) (v::vs) env =
  match pmatch' s p v env with
    | No_match -> No_match
    | Match_type_error -> Match_type_error
    | Match env' -> pmatch_list' s ps vs env'
  end
and
pmatch_list' _ _ _ env = Match_type_error


indreln [evaluate' : store -> envE -> exp -> store * result v -> bool] 
and [evaluate_list' : store -> envE -> list exp -> store * result (list v) -> bool]
and [evaluate_match' : store -> envE -> v -> list (pat * exp) -> v -> store * result v -> bool]

lit : forall env l s.
true
==>
evaluate' s env (Lit l) (s, Rval (Litv l))

and

raise1 : forall env e s1 s2 v.
evaluate' s1 env e (s2, Rval v)
==>
evaluate' s1 env (Raise e) (s2, Rerr (Rraise v))

and

raise2 : forall env e s1 s2 err.
evaluate' s1 env e (s2, Rerr err)
==>
evaluate' s1 env (Raise e) (s2, Rerr err)

and

handle1 : forall s1 s2 env e v pes.
evaluate' s1 env e (s2, Rval v)
==>
evaluate' s1 env (Handle e pes) (s2, Rval v)

and

handle2 : forall s1 s2 env e pes v bv.
evaluate' s1 env e (s2, Rerr (Rraise v)) &&
evaluate_match' s2 env v pes v bv
==>
evaluate' s1 env (Handle e pes) bv

and

handle3 : forall s1 s2 env e pes err.
evaluate' s1 env e (s2, Rerr err) &&
(err = Rtimeout_error || (err = Rtype_error))
==>
evaluate' s1 env (Handle e pes) (s2, Rerr err)

and

con1 : forall env cn es vs s1 s2.
evaluate_list' s1 env es (s2, Rval vs)
==>
evaluate' s1 env (Con cn es) (s2, Rval (Conv cn vs))

and

con2 : forall env cn es err s s'.
evaluate_list' s env es (s', Rerr err)
==>
evaluate' s env (Con cn es) (s', Rerr err)

and

var1 : forall env n v s.
(lookup n env = Just v)
==>
evaluate' s env (Var (Short n)) (s, Rval v)

and

var2 : forall env n s.
(lookup n env = Nothing)
==>
evaluate' s env (Var (Short n)) (s, Rerr Rtype_error)

and

fn : forall env n e s.
true
==>
evaluate' s env (Fun n e) (s, Rval (Closure env n e))

and

uapp1 : forall env uop e v v' s1 s2 s3.
evaluate' s1 env e (s2, Rval v) &&
(do_uapp s2 uop v = Just (s3,v'))
==>
evaluate' s1 env (Uapp uop e) (s3, Rval v')

and

uapp2 : forall env uop e v s1 s2.
evaluate' s1 env e (s2, Rval v) &&
(do_uapp s2 uop v = Nothing)
==>
evaluate' s1 env (Uapp uop e) (s2, Rerr Rtype_error)

and

uapp3 : forall env uop e err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate' s env (Uapp uop e) (s', Rerr err)

and

app1 : forall env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 s4.
evaluate' s1 env e1 (s2, Rval v1) &&
(evaluate' s2 env e2 (s3, Rval v2) &&
(do_app s3 env op v1 v2 = Just (s4, env', e3) &&
evaluate' s4 env' e3 bv))
==>
evaluate' s1 env (App op e1 e2) bv

and

app2 : forall env op e1 e2 v1 v2 s1 s2 s3.
evaluate' s1 env e1 (s2, Rval v1) &&
(evaluate' s2 env e2 (s3, Rval v2) &&
(do_app s3 env op v1 v2 = Nothing))
==>
evaluate' s1 env (App op e1 e2) (s3, Rerr Rtype_error)

and

app3 : forall env op e1 e2 v1 err s1 s2 s3.
evaluate' s1 env e1 (s2, Rval v1) &&
evaluate' s2 env e2 (s3, Rerr err)
==>
evaluate' s1 env (App op e1 e2) (s3, Rerr err)

and

app4 : forall env op e1 e2 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (App op e1 e2) (s', Rerr err)

and

log1 : forall env op e1 e2 v e' bv s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
(do_log op v e2 = Just e' &&
evaluate' s2 env e' bv)
==>
evaluate' s1 env (Log op e1 e2) bv

and

log2 : forall env op e1 e2 v s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
(do_log op v e2 = Nothing)
==>
evaluate' s1 env (Log op e1 e2) (s2, Rerr Rtype_error)

and

log3 : forall env op e1 e2 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (Log op e1 e2) (s', Rerr err)

and

if1 : forall env e1 e2 e3 v e' bv s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
(do_if v e2 e3 = Just e' &&
evaluate' s2 env e' bv)
==>
evaluate' s1 env (If e1 e2 e3) bv

and

if2 : forall env e1 e2 e3 v s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
(do_if v e2 e3 = Nothing)
==>
evaluate' s1 env (If e1 e2 e3) (s2, Rerr Rtype_error)

and


if3 : forall env e1 e2 e3 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (If e1 e2 e3) (s', Rerr err)

and

mat1 : forall env e pes v bv s1 s2.
evaluate' s1 env e (s2, Rval v) &&
evaluate_match' s2 env v pes (Conv (Just (Short "Bind")) []) bv
==>
evaluate' s1 env (Mat e pes) bv

and

mat2 : forall env e pes err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate' s env (Mat e pes) (s', Rerr err)

and

let1 : forall env n e1 e2 v bv s1 s2.
evaluate' s1 env e1 (s2, Rval v) &&
evaluate' s2 (bind n v env) e2 bv
==>
evaluate' s1 env (Let n e1 e2) bv

and

let2 : forall env n e1 e2 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (Let n e1 e2) (s', Rerr err)

and

letrec1 : forall env funs e bv s.
all_distinct (List.map (fun (x,y,z) -> x) funs) &&
evaluate' s (build_rec_env funs env env) e bv
==>
evaluate' s env (Letrec funs e) bv

and

letrec2 : forall env funs e s.
not (all_distinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate' s env (Letrec funs e) (s, Rerr Rtype_error)

and

empty : forall env s.
true
==>
evaluate_list' s env [] (s, Rval [])

and

cons1 : forall env e es v vs s1 s2 s3.
evaluate' s1 env e (s2, Rval v) &&
evaluate_list' s2 env es (s3, Rval vs)
==>
evaluate_list' s1 env (e::es) (s3, Rval (v::vs))

and

cons2 : forall env e es err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate_list' s env (e::es) (s', Rerr err)

and

cons3 : forall env e es v err s1 s2 s3.
evaluate' s1 env e (s2, Rval v) &&
evaluate_list' s2 env es (s3, Rerr err)
==>
evaluate_list' s1 env (e::es) (s3, Rerr err)

and

mat_empty : forall env v s err_v.
true
==>
evaluate_match' s env v [] err_v (s, Rerr (Rraise err_v))

and

mat_cons1 : forall env v p e pes env' bv s err_v.
all_distinct (pat_bindings p []) &&
((pmatch' s p v env = Match env') &&
evaluate' s env' e bv)
==>
evaluate_match' s env v ((p,e)::pes) err_v bv

and

mat_cons2 : forall env v p e pes bv s err_v.
all_distinct (pat_bindings p []) &&
((pmatch' s p v env = No_match) &&
evaluate_match' s env v pes err_v bv)
==>
evaluate_match' s env v ((p,e)::pes) err_v bv

and

mat_cons3 : forall env v p e pes s err_v.
(pmatch' s p v env = Match_type_error)
==>
evaluate_match' s env v ((p,e)::pes) err_v (s, Rerr Rtype_error)

and

mat_cons4 : forall env v p e pes s err_v.
not (all_distinct (pat_bindings p []))
==>
evaluate_match' s env v ((p,e)::pes) err_v (s, Rerr Rtype_error)

indreln [evaluate_dec' : maybe modN -> envM -> envC -> store -> envE -> dec -> store * result (envC * envE) -> bool]


dlet1 : forall mn menv cenv env p e v env' s1 s2.
evaluate' s1 env e (s2, Rval v) &&
(all_distinct (pat_bindings p []) &&
(pmatch' s2 p v emp = Match env'))
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rval (emp, env'))

and

dlet2 : forall mn menv cenv env p e v s1 s2.
evaluate' s1 env e (s2, Rval v) &&
(all_distinct (pat_bindings p []) &&
(pmatch' s2 p v emp = No_match))
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rerr (Rraise (Conv (Just (Short "Bind")) [])))

and

dlet3 : forall mn menv cenv env p e v s1 s2.
evaluate' s1 env e (s2, Rval v) &&
(all_distinct (pat_bindings p []) &&
(pmatch' s2 p v emp = Match_type_error))
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rerr Rtype_error)

and

dlet4 : forall mn menv cenv env p e s.
not (all_distinct (pat_bindings p []))
==>
evaluate_dec' mn (menv:envM) (cenv:envC) s env (Dlet p e) (s, Rerr Rtype_error)

and

dlet5 : forall mn menv cenv env p e err s s'.
evaluate' s env e (s', Rerr err) &&
all_distinct (pat_bindings p [])
==>
evaluate_dec' mn menv cenv s env (Dlet p e) (s', Rerr err)

and

dletrec1 : forall mn menv cenv env funs s.
all_distinct (List.map (fun (x,y,z) -> x) funs)
==>
evaluate_dec' mn menv cenv s env (Dletrec funs) (s, Rval (emp, build_rec_env funs env emp))

and

dletrec2 : forall mn menv cenv env funs s.
not (all_distinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate_dec' mn menv cenv s env (Dletrec funs) (s, Rerr Rtype_error)

and

dtype1 : forall mn menv cenv env tds s.
check_dup_ctors mn cenv tds
==>
evaluate_dec' mn menv cenv s env (Dtype tds) (s, Rval (build_tdefs mn tds, emp))

and

dtype2 : forall mn menv cenv env tds s.
not (check_dup_ctors mn cenv tds)
==>
evaluate_dec' mn menv cenv s env (Dtype tds) (s, Rerr Rtype_error)

and

dexn1 : forall mn menv cenv env cn ts s.
(lookup (mk_id mn cn) cenv = Nothing)
==>
evaluate_dec' mn menv cenv s env (Dexn cn ts) (s, Rval (bind (mk_id mn cn) (List.length ts, TypeExn) emp, emp))

and

dexn2 : forall mn menv cenv env cn ts s.
(lookup (mk_id mn cn) cenv <> Nothing)
==>
evaluate_dec' mn menv cenv s env (Dexn cn ts) (s, Rerr Rtype_error)


indreln [evaluate_decs' : maybe modN -> envM -> envC -> store -> envE -> list dec -> store * envC * result envE -> bool]

empty : forall mn menv cenv s env.
true
==>
evaluate_decs' mn menv cenv s env [] (s, emp, Rval emp)

and

cons1 : forall mn menv cenv s1 s2 env d ds e.
evaluate_dec' mn menv cenv s1 env d (s2, Rerr e)
==>
evaluate_decs' mn menv cenv s1 env (d::ds) (s2, emp, Rerr e)

and

cons2 : forall mn menv cenv s1 s2 s3 env d ds new_tds' new_tds new_env r.
evaluate_dec' mn menv cenv s1 env d (s2, Rval (new_tds,new_env)) &&
evaluate_decs' mn menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, new_tds', r)
==>
evaluate_decs' mn menv cenv s1 env (d::ds) (s3, merge new_tds' new_tds, combine_dec_result new_env r)

indreln [evaluate_top' : envM -> envC -> store -> envE -> top -> store * envC * result (envM * envE) -> bool]

tdec1 : forall menv cenv s1 s2 env d new_tds new_env.
evaluate_dec' Nothing menv cenv s1 env d (s2, Rval (new_tds, new_env))
==>
evaluate_top' menv cenv s1 env (Tdec d) (s2, new_tds, Rval (emp, new_env))

and

tdec2 : forall menv cenv s1 s2 env d err.
evaluate_dec' Nothing menv cenv s1 env d (s2, Rerr err)
==>
evaluate_top' menv cenv s1 env (Tdec d) (s2, emp, Rerr err)

and

mod1 : forall menv cenv s1 s2 env ds mn specs new_tds new_env. 
not (elem mn (List.map fst menv)) &&
evaluate_decs' (Just mn) menv cenv s1 env ds (s2, new_tds, Rval new_env)
==>
evaluate_top' menv cenv s1 env (Tmod mn specs ds) (s2, new_tds, Rval ([(mn,new_env)], emp))

and

mod2 : forall menv cenv s1 s2 env ds mn specs new_tds err. 
not (elem mn (List.map fst menv)) &&
evaluate_decs' (Just mn) menv cenv s1 env ds (s2, new_tds, Rerr err)
==>
evaluate_top' menv cenv s1 env (Tmod mn specs ds) (s2, new_tds, Rerr err)

and

mod3 : forall menv cenv s env mn specs ds.
elem mn (List.map fst menv)
==>
evaluate_top' menv cenv s env (Tmod mn specs ds) (s, emp, Rerr Rtype_error)

indreln [evaluate_prog' : envM -> envC -> store -> envE -> prog -> store * envC * result (envM * envE) -> bool]

empty : forall menv cenv s env.
true
==>
evaluate_prog' menv cenv s env [] (s, emp, Rval (emp, emp))

and

cons1 : forall menv cenv s1 s2 s3 env top tops new_mods new_tds new_tds' new_env r.
evaluate_top' menv cenv s1 env top (s2, new_tds, Rval (new_mods,new_env)) &&
evaluate_prog' (merge new_mods menv) (merge new_tds cenv) s2 (merge new_env env) tops (s3, new_tds', r)
==>
evaluate_prog' menv cenv s1 env (top::tops) (s3, merge new_tds' new_tds, combine_mod_result new_mods new_env r)

and

cons2 : forall menv cenv s1 s2 env top tops err new_tds.
evaluate_top' menv cenv s1 env top (s2, new_tds, Rerr err)
==>
evaluate_prog' menv cenv s1 env (top::tops) (s2, new_tds, Rerr err)


