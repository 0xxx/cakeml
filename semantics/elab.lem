open import Pervasives_extra
open import Lib
open import Ast

type ast_t =
    (* 'a *)
  | Ast_Tvar of tvarN
    (* t *)
    (* num t *)
    (* (num,bool) t *)
  | Ast_Tapp of list ast_t * maybe (id typeN)
    (* t -> t *)
  | Ast_Tfn of ast_t * ast_t

(* type t = C of t1 * t2 | D of t2  * t3
 * and 'a u = E of 'a
 * and ('a,'b) v = F of 'b u | G of 'a u *)
type ast_type_def = list (list tvarN * typeN * list (conN * list ast_t))

type ast_dec =
    (* val (C(x,y)) = C(1,2) *) 
  | Ast_Dlet of pat * exp
    (* fun f x = e and g y = f *) 
  | Ast_Dletrec of list (varN * varN * exp)
    (* see above *)
  | Ast_Dtype of ast_type_def
  | Ast_Dexn of conN * list ast_t

type ast_decs = list ast_dec

type ast_spec =
  | Ast_Sval of varN * ast_t
  | Ast_Stype of ast_type_def
  | Ast_Stype_opq of list tvarN * typeN
  | Ast_Sexn of conN * list ast_t

type ast_specs = list ast_spec

type ast_top =
  | Ast_Tmod of modN * maybe ast_specs * ast_decs
  | Ast_Tdec of ast_dec

type ast_prog = list ast_top

type tdef_env = env typeN Ast.tc

val elab_t : tdef_env -> ast_t -> t
val elab_dec : maybe modN -> tdef_env -> ast_dec -> tdef_env * dec
val elab_decs : maybe modN -> tdef_env -> list ast_dec -> tdef_env * list dec
val elab_spec : maybe modN -> tdef_env -> list ast_spec -> list spec
val elab_top : tdef_env -> ast_top -> tdef_env * top
val elab_prog : tdef_env -> list ast_top -> tdef_env * prog

let rec
elab_t type_bound (Ast_Tvar n) = Tvar n
and
elab_t type_bound (Ast_Tfn t1 t2) =
  Tfn (elab_t type_bound t1) (elab_t type_bound t2)
and
elab_t type_bound (Ast_Tapp ts Nothing) =
  let ts' = List.map (elab_t type_bound) ts in
    Tapp ts' TC_tup
and
elab_t type_bound (Ast_Tapp ts (Just (Long m tn))) =
  let ts' = List.map (elab_t type_bound) ts in
    Tapp ts' (TC_name (Long m tn))
and
elab_t type_bound (Ast_Tapp ts (Just (Short tn))) =
  let ts' = List.map (elab_t type_bound) ts in
    match lookup tn type_bound with
      | Nothing -> Tapp ts' (TC_name (Short tn))
      | Just tc -> Tapp ts' tc
    end

let elab_td type_bound (tvs,tn,ctors) =
  (tvs, tn, List.map (fun (cn,t) -> (cn, List.map (elab_t type_bound) t)) ctors)

let rec
elab_dec mn type_bound (Ast_Dlet p e) =
  ([], Dlet p e)
and
elab_dec mn type_bound (Ast_Dletrec funs) =
  ([], Dletrec funs)
and
elab_dec mn type_bound (Ast_Dtype t) = 
  let type_bound' = List.map (fun (tvs,tn,ctors) -> (tn, TC_name (mk_id mn tn))) t in
  (type_bound',
   Dtype (List.map (elab_td (merge type_bound' type_bound)) t))
and
elab_dec mn type_bound (Ast_Dexn cn ts) =
  (emp,
   Dexn cn (List.map (elab_t type_bound) ts))

let rec
elab_decs mn type_bound [] = ([],[])
and
elab_decs mn type_bound (d::ds) = 
  let (type_bound', d') = elab_dec mn type_bound d in
  let (type_bound'',ds') = 
    elab_decs mn (merge type_bound' type_bound) ds 
  in
    (merge type_bound'' type_bound', (d'::ds'))

declare termination_argument elab_decs = automatic

let rec
elab_spec mn type_bound [] = []
and
elab_spec mn type_bound (Ast_Sval x t::spec) =
  Sval x (elab_t type_bound t) :: elab_spec mn type_bound spec
and
elab_spec mn type_bound (Ast_Stype td :: spec) =
  let type_bound' = List.map (fun (tvs,tn,ctors) -> (tn, TC_name (mk_id mn tn))) td in
    Stype (List.map (elab_td (merge type_bound' type_bound)) td) :: elab_spec mn (merge type_bound' type_bound) spec
and
elab_spec mn type_bound (Ast_Stype_opq tvs tn::spec) =
  Stype_opq tvs tn :: elab_spec mn ((tn, TC_name (mk_id mn tn))::type_bound) spec
and
elab_spec mn type_bound (Ast_Sexn cn ts::spec) =
  Sexn cn (List.map (elab_t type_bound) ts) :: elab_spec mn type_bound spec

declare termination_argument elab_spec = automatic

let rec
elab_top type_bound (Ast_Tdec d) =
  let (type_bound', d') = elab_dec Nothing type_bound d in
      (type_bound', Tdec d')
and
elab_top type_bound (Ast_Tmod mn spec ds) =
  let (type_bound',ds') = elab_decs (Just mn) type_bound ds in
      (type_bound,Tmod mn (Maybe.map (elab_spec (Just mn) type_bound) spec) ds')

let rec
elab_prog type_bound [] = ([],[])
and
elab_prog type_bound (top::prog) =
  let (type_bound',top') = elab_top type_bound top in
  let (type_bound'',prog') = 
    elab_prog (merge type_bound' type_bound) prog
  in
    (merge type_bound'' type_bound', (top'::prog'))

declare termination_argument elab_prog = automatic
      
