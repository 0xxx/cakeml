(* An AST that can be the result of parsing, and then elaborated into the main
 * CakeML AST in ast.lem.  We are assuming that constructors start with capital
 * letters, and non-constructors start with lower case (as in OCaml) so that
 * the parser can determine what is a constructor application.  Example syntax
 * in comments before each node.
 * 
 * Also, an elaboration from this syntax to the AST in ast.lem.  The
 * elaboration spots types that are bound to ML primitives.  It also prefixes
 * datatype constructors and types with their paths, so
 *
 * structure S = struct datatype t = C val x = C end
 *
 * becomes
 *
 * structure S = struct datatype t = C val x = S.C end
 * 
 *)

open Lib
open Ast

type ast_pat =
    (* x *)
  | Ast_Pvar of varN
    (* 1 *)
    (* true *)
    (* () *)
  | Ast_Plit of lit
    (* C(x,y) *)
    (* D *)
    (* E x *)
  | Ast_Pcon of option (id conN) * list ast_pat
    (* ref x *)
  | Ast_Pref of ast_pat

type ast_exp =
    (* raise (E 4) *)
  | Ast_Raise of ast_exp
    (* e handle E x => x | F => 1 *)
  | Ast_Handle of ast_exp * list (ast_pat * ast_exp)
    (* 1 *)
    (* true *)
    (* () *)
  | Ast_Lit of lit
    (* x *)
  | Ast_Var of id varN
    (* C(x,y) *)
    (* D *)
    (* E x *)
  | Ast_Con of option (id conN) * list ast_exp
    (* fn x => e *)
  | Ast_Fun of varN * ast_exp
    (* e e *)
  | Ast_App of ast_exp * ast_exp
    (* e andalso e *)
    (* e orelse e *)
  | Ast_Log of lop * ast_exp * ast_exp
    (* if e then e else e *)
  | Ast_If of ast_exp * ast_exp * ast_exp
    (* case e of C(x,y) => x | D y => y *)
  | Ast_Mat of ast_exp * list (ast_pat * ast_exp)
    (* let val x = e in e end *)
  | Ast_Let of varN * ast_exp * ast_exp
    (* let fun f x = e and g y = e in e end *) 
  | Ast_Letrec of list (varN * varN * ast_exp) * ast_exp

type ast_t =
    (* 'a *)
  | Ast_Tvar of tvarN
    (* t *)
    (* num t *)
    (* (num,bool) t *)
  | Ast_Tapp of list ast_t * option (id typeN)
    (* t -> t *)
  | Ast_Tfn of ast_t * ast_t

(* type t = C of t1 * t2 | D of t2  * t3
 * and 'a u = E of 'a
 * and ('a,'b) v = F of 'b u | G of 'a u *)
type ast_type_def = list (list tvarN * typeN * list (conN * list ast_t))

type ast_dec =
    (* val (C(x,y)) = C(1,2) *) 
  | Ast_Dlet of ast_pat * ast_exp
    (* fun f x = e and g y = f *) 
  | Ast_Dletrec of list (varN * varN * ast_exp)
    (* see above *)
  | Ast_Dtype of ast_type_def
  | Ast_Dexn of conN * list ast_t

type ast_decs = list ast_dec

type ast_spec =
  | Ast_Sval of varN * ast_t
  | Ast_Stype of ast_type_def
  | Ast_Stype_opq of list tvarN * typeN

type ast_specs = list ast_spec

type ast_top =
  | Ast_Tmod of modN * option ast_specs * ast_decs
  | Ast_Tdec of ast_dec

type ast_prog = list ast_top

type ctor_env = env conN (id conN)

val elab_p : ctor_env -> ast_pat -> pat
let rec
elab_p ctors (Ast_Pvar n) = Pvar n
and
elab_p ctors (Ast_Plit l) = Plit l
and
elab_p ctors (Ast_Pcon (Some (Short cn)) ps) =
  match lookup cn ctors with
    | Some cid ->
        Pcon (Some cid) (elab_ps ctors ps)
    | None ->
        Pcon (Some (Short cn)) (elab_ps ctors ps)
  end
and
elab_p ctors (Ast_Pcon cn ps) =
  Pcon cn (elab_ps ctors ps)
and
elab_p ctors (Ast_Pref p) = Pref (elab_p ctors p)
and
elab_ps ctors [] = []
and
elab_ps ctors (p::ps) = elab_p ctors p :: elab_ps ctors ps

type tdef_env = env typeN Ast.tc

val elab_t : tdef_env -> ast_t -> t
val elab_e : ctor_env -> ast_exp -> exp
val elab_funs : ctor_env -> list (varN * varN * ast_exp) -> 
                list (varN * varN * exp)
val elab_dec : option modN -> tdef_env -> ctor_env -> ast_dec -> tdef_env * ctor_env * dec
val elab_decs : option modN -> tdef_env -> ctor_env -> list ast_dec -> tdef_env * ctor_env * list dec
val elab_spec : option modN -> tdef_env -> list ast_spec -> list spec
val elab_top : tdef_env -> ctor_env -> ast_top -> tdef_env * ctor_env * top
val elab_prog : tdef_env -> ctor_env -> list ast_top -> tdef_env * ctor_env * prog

let rec
elab_e ctors (Ast_Raise e) =
  Raise (elab_e ctors e)
and
elab_e ctors (Ast_Handle e pes) =
  Handle (elab_e ctors e) 
         (List.map (fun (p,e) -> (elab_p ctors p, elab_e ctors e)) pes)
and
elab_e ctors (Ast_Lit l) =
  Lit l
and 
elab_e ctors (Ast_Var id) =
  Var id
and
elab_e ctors (Ast_Con (Some (Short cn)) es) =
  match lookup cn ctors with
    | Some cid ->
        Con (Some cid) (List.map (elab_e ctors) es)
    | None ->
        Con (Some (Short cn)) (List.map (elab_e ctors) es)
  end
and
elab_e ctors (Ast_Con cn es) =
  Con cn (List.map (elab_e ctors) es)
and
elab_e ctors (Ast_Fun n e) =
  Fun n (elab_e ctors e)
and
elab_e ctors (Ast_App e1 e2) =
  App Opapp (elab_e ctors e1) (elab_e ctors e2)
and
elab_e ctors (Ast_Log lop e1 e2) =
  Log lop (elab_e ctors e1) (elab_e ctors e2)
and
elab_e ctors (Ast_If e1 e2 e3) =
  If (elab_e ctors e1) (elab_e ctors e2) (elab_e ctors e3)
and
elab_e ctors (Ast_Mat e pes) =
  Mat (elab_e ctors e) 
      (List.map (fun (p,e) -> (elab_p ctors p, elab_e ctors e)) pes)
and
elab_e ctors (Ast_Let x e1 e2) =
  Let x (elab_e ctors e1) (elab_e ctors e2)
and
elab_e ctors (Ast_Letrec funs e) =
  Letrec (elab_funs ctors funs) 
         (elab_e ctors e)
and
elab_funs ctors [] =
  []
and
elab_funs ctors ((n1,n2,e)::funs) =
  (n1,n2,elab_e ctors e) :: elab_funs ctors funs

let rec
elab_t type_bound (Ast_Tvar n) = Tvar n
and
elab_t type_bound (Ast_Tfn t1 t2) =
  Tfn (elab_t type_bound t1) (elab_t type_bound t2)
    and
elab_t type_bound (Ast_Tapp ts None) =
  let ts' = List.map (elab_t type_bound) ts in
    Tapp ts' TC_tup
and
elab_t type_bound (Ast_Tapp ts (Some (Long m tn))) =
  let ts' = List.map (elab_t type_bound) ts in
    Tapp ts' (TC_name (Long m tn))
and
elab_t type_bound (Ast_Tapp ts (Some (Short tn))) =
  let ts' = List.map (elab_t type_bound) ts in
    match lookup tn type_bound with
      | None -> Tapp ts' (TC_name (Short tn))
      | Some tc -> Tapp ts' tc
    end

let get_ctors_bindings mn t =
  List.flatten
    (List.map (fun (tvs,tn,ctors) -> List.map (fun (cn,t) -> (cn, mk_id mn cn)) ctors) t)
   
let elab_td type_bound (tvs,tn,ctors) =
  (tvs, tn, List.map (fun (cn,t) -> (cn, List.map (elab_t type_bound) t)) ctors)

let rec
elab_dec mn type_bound ctors (Ast_Dlet p e) =
  let p' = elab_p ctors p in
    ([], emp, Dlet p' (elab_e ctors e))
and
elab_dec mn type_bound ctors (Ast_Dletrec funs) =
  ([], emp, Dletrec (elab_funs ctors funs))
and
elab_dec mn type_bound ctors (Ast_Dtype t) = 
  let type_bound' = List.map (fun (tvs,tn,ctors) -> (tn, TC_name (mk_id mn tn))) t in
  (type_bound',
   get_ctors_bindings mn t,
   Dtype (List.map (elab_td (merge type_bound' type_bound)) t))
and
elab_dec mn type_bound ctors (Ast_Dexn cn ts) =
  (emp,
   bind cn (mk_id mn cn) emp,
   Dexn cn (List.map (elab_t type_bound) ts))

let rec
elab_decs mn type_bound ctors [] = ([],emp,[])
and
elab_decs mn type_bound ctors (d::ds) = 
  let (type_bound', ctors', d') = elab_dec mn type_bound ctors d in
  let (type_bound'',ctors'',ds') = 
    elab_decs mn (merge type_bound' type_bound) (merge ctors' ctors) ds 
  in
    (merge type_bound'' type_bound', merge ctors'' ctors', d'::ds')

let rec 
elab_spec mn type_bound [] = []
and
elab_spec mn type_bound (Ast_Sval x t::spec) =
  Sval x (elab_t type_bound t) :: elab_spec mn type_bound spec
and
elab_spec mn type_bound (Ast_Stype td :: spec) =
  let type_bound' = List.map (fun (tvs,tn,ctors) -> (tn, TC_name (mk_id mn tn))) td in
    Stype (List.map (elab_td (merge type_bound' type_bound)) td) :: elab_spec mn (merge type_bound' type_bound) spec
and
elab_spec mn type_bound (Ast_Stype_opq tvs tn::spec) =
  Stype_opq tvs tn :: elab_spec mn ((tn, TC_name (mk_id mn tn))::type_bound) spec

let rec
elab_top type_bound ctors (Ast_Tdec d) =
  let (type_bound', ctors', d') = elab_dec None type_bound ctors d in
      (type_bound', ctors', Tdec d')
and
elab_top type_bound ctors (Ast_Tmod mn spec ds) =
  let (type_bound',ctors',ds') = elab_decs (Some mn) type_bound ctors ds in
      (type_bound,ctors,Tmod mn (option_map (elab_spec (Some mn) type_bound) spec) ds')

let rec
elab_prog type_bound ctors [] = ([],emp,[])
and
elab_prog type_bound ctors (top::prog) =
  let (type_bound',ctors',top') = elab_top type_bound ctors top in
  let (type_bound'',ctors'',prog') = 
    elab_prog (merge type_bound' type_bound) (merge ctors' ctors) prog
  in
    (merge type_bound'' type_bound', merge ctors'' ctors', top'::prog')
