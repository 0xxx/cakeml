open import Pervasives
open import Ast
open import SemanticPrimitives
open import BigStep
open import Lib

val mk_binop : string -> op -> dec
let mk_binop name prim =
  Dlet (Pvar name) (Fun "x" (Fun "y" (App prim [Var (Short "x"); Var (Short "y")])))

val mk_unop : string -> op -> dec
let mk_unop name prim =
  Dlet (Pvar name) (Fun "x" (App prim [Var (Short "x")]))

val mk_ffi : nat -> dec
let mk_ffi n =
  Dlet (Pvar ("ffi" ^ show n)) (Fun "x" (App (FFI n) [Var (Short "x")]))

val prim_types_program : prog
let prim_types_program =
  [Tdec (Dexn "Bind" []);
   Tdec (Dexn "Chr" []);
   Tdec (Dexn "Div" []);
   Tdec (Dexn "Eq" []);
   Tdec (Dexn "Subscript" []);
   Tdec (Dtype [([], "bool", [("true", []); ("false", [])])]);
   Tdec (Dtype [(["'a"], "list", [("nil", []); ("::", [Tvar "'a"; Tapp [Tvar "'a"] (TC_name (Short "list"))]);])]);
   Tdec (Dtype [(["'a"], "option", [("NONE", []);("SOME", [Tvar "'a"]);])]);]

val basis_program : prog
let basis_program =
  [Tdec (Dtabbrev [] "int" (Tapp [] TC_int));
   Tdec (Dtabbrev [] "string" (Tapp [] TC_string));
   Tdec (Dtabbrev [] "unit" (Tapp [] TC_tup));
   Tdec (Dtabbrev ["'a"] "ref" (Tapp [Tvar "'a"] TC_ref));
   Tdec (Dtabbrev [] "exn" (Tapp [] TC_exn));
   Tdec (mk_binop "+" (Opn Plus));
   Tdec (mk_binop "-" (Opn Minus));
   Tdec (mk_binop "*" (Opn Times));
   Tdec (mk_binop "div" (Opn Divide));
   Tdec (mk_binop "mod" (Opn Modulo));
   Tdec (mk_binop "<" (Opb Lt));
   Tdec (mk_binop ">" (Opb Gt));
   Tdec (mk_binop "<=" (Opb Leq));
   Tdec (mk_binop ">=" (Opb Geq));
   Tdec (mk_binop "=" Equality);
   Tdec (mk_binop ":=" Opassign);
   Tdec (Dlet (Pvar "~") (Fun "x" (App (Opn Minus) [Lit (IntLit 0); Var(Short"x")])));
   Tdec (mk_unop "!" Opderef);
   Tdec (mk_unop "ref" Opref);
   Tdec (Dtabbrev [] "word" (Tapp [] TC_word8));
   Tdec (Dtabbrev ["'a"] "vector" (Tapp [Tvar "'a"] TC_vector));
   Tdec (Dtabbrev ["'a"] "array" (Tapp [Tvar "'a"] TC_array));
   Tdec (Dtabbrev [] "char" (Tapp [] TC_char));
   Tmod "Word8" Nothing
     [Dtabbrev [] "word" (Tapp [] TC_word8)];
   Tmod "Word8Array" Nothing
     [Dtabbrev [] "array" (Tapp [] TC_word8array);
      Dtabbrev [] "elem" (Tapp [] TC_word8);
      mk_binop "array" Aw8alloc;
      mk_binop "sub" Aw8sub;
      mk_unop "length" Aw8length;
      Dlet (Pvar "update") (Fun "x" (Fun "y" (Fun "z" (App Aw8update [Var (Short "x"); Var (Short "y"); Var (Short "z")])))) ];
   Tmod "Vector" Nothing
     [Dtabbrev ["'a"] "vector" (Tapp [Tvar "'a"] TC_vector);
      mk_unop "fromList" VfromList;
      mk_unop "length" Vlength;
      mk_binop "sub" Vsub];
   Tmod "Array" Nothing
     [Dtabbrev ["'a"] "array" (Tapp [Tvar "'a"] TC_array);
      mk_binop "array" Aalloc;
      mk_binop "sub" Asub;
      mk_unop "length" Alength;
      Dlet (Pvar "update") (Fun "x" (Fun "y" (Fun "z" (App Aupdate [Var (Short "x"); Var (Short "y"); Var (Short "z")])))) ];
   Tmod "Char" Nothing
     [Dtabbrev [] "char" (Tapp [] TC_char);
      mk_unop "ord" Ord;
      mk_unop "chr" Chr;
      mk_binop "<" (Chopb Lt);
      mk_binop "<=" (Chopb Leq);
      mk_binop ">" (Chopb Gt);
      mk_binop ">=" (Chopb Geq)];
   Tmod "String" Nothing
     [Dtabbrev [] "string" (Tapp [] TC_string);
      mk_unop "explode" Explode;
      mk_unop "implode" Implode;
      mk_unop "size" Strlen];
   Tmod "Ffi" Nothing
     [mk_ffi 0;
      mk_ffi 1;
      mk_ffi 2;
      mk_ffi 3;
      mk_ffi 4;
      mk_ffi 5;
      mk_ffi 6;
      mk_ffi 7;
      mk_ffi 8;
      mk_ffi 9] ]


val add_to_sem_env : (state * environment v) -> prog -> maybe (state * environment v)
let add_to_sem_env (st, env) prog =
  let res = { res | evaluate_whole_prog false env st prog res } in
    if res = {} then
      Nothing
    else
      match Set_extra.choose res with
        | (s,envC,Rval (envM,envE)) ->
           Just (s, <| env with m = envM ++ env.m;
                                c = merge_alist_mod_env envC env.c;
                                v = envE ++ env.v |>)
        | _ -> Nothing
      end

val prim_sem_env : maybe (state * environment v)
let prim_sem_env =
  add_to_sem_env (<| clock = 0; io = Just lnil; refs = []; defined_mods = {}; defined_types = {} |>,
                  <| m = []; c= ([],[]); v = [] |>)
        prim_types_program

val basis_sem_env : maybe (state * environment v)
let basis_sem_env =
  add_to_sem_env (Maybe_extra.fromJust prim_sem_env) basis_program

open import TypeSystem
type top_state =
         <| (* Type system state *)
            tdecs : decls; tenvT : tenvT; tenvM : tenvM; tenvC : tenvC; tenv : tenvE;
            (* Semantics state *)
            sem_st : state;
            sem_env : environment v |>
