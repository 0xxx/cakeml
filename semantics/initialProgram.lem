open import Pervasives
open import Ast
open import SemanticPrimitives
open import BigStep

val mk_binop : string -> op -> dec
let mk_binop name prim =
  Dlet (Pvar name) (Fun "x" (Fun "y" (App prim [Var (Short "x"); Var (Short "y")])))

val mk_unop : string -> op -> dec
let mk_unop name prim =
  Dlet (Pvar name) (Fun "x" (App prim [Var (Short "x")]))

val prim_types_program : prog
let prim_types_program =
  [Tdec (Dexn "Bind" []);
   Tdec (Dexn "Div" []);
   Tdec (Dexn "Eq" []);
   Tdec (Dexn "Subscript" []);
   Tdec (Dtype [(["'a"], "list", [("nil", []); ("::", [Tvar "'a"; Tapp [Tvar "'a"] (TC_name (Short "list"))]);])]);
   Tdec (Dtype [(["'a"], "option", [("NONE", []);("SOME", [Tvar "'a"]);])]);]

val basis_program : prog
let basis_program =
  [Tdec (mk_binop "+" (Opn Plus));
   Tdec (mk_binop "-" (Opn Minus));
   Tdec (mk_binop "*" (Opn Times));
   Tdec (mk_binop "div" (Opn Divide));
   Tdec (mk_binop "mod" (Opn Modulo));
   Tdec (mk_binop "<" (Opb Lt));
   Tdec (mk_binop ">" (Opb Gt));
   Tdec (mk_binop "<=" (Opb Leq));
   Tdec (mk_binop ">=" (Opb Geq));
   Tdec (mk_binop "=" Equality);
   Tdec (mk_binop ":=" Opassign);
   Tdec (Dlet (Pvar "~") (Fun "x" (App (Opn Minus) [Lit (IntLit 0); Var(Short"x")])));
   Tdec (mk_unop "!" Opderef);
   Tdec (mk_unop "ref" Opref);
   Tmod "Word8" Nothing [];
   Tmod "Word8Array" Nothing 
     [mk_binop "array" Aalloc;
      mk_binop "sub" Asub;
      mk_unop "length" Alength;
      Dlet (Pvar "update") (Fun "x" (Fun "y" (Fun "z" (App Aupdate [Var (Short "x"); Var (Short "y"); Var (Short "z")])))) ] ]

(* The initial mapping of type names to primitive type constructors, for the elaborator *)
let init_type_bindings =
  [("int", TC_int);
   ("bool", TC_bool);
   ("ref", TC_ref);
   ("exn", TC_exn);
   ("unit", TC_unit);
   ("list", TC_name (Short "list"));
   ("option", TC_name (Short "option"))]

type sem_environment = <| sem_envM : envM;
                          sem_envC : envC;
                          sem_envE : envE;
                          sem_store : count_store v * set tid_or_exn * set modN |>

val add_to_sem_env : sem_environment -> prog -> maybe sem_environment
let add_to_sem_env se prog =
  let res = { res | evaluate_whole_prog false (se.sem_envM,se.sem_envC,se.sem_envE) se.sem_store prog res } in
    if res = {} then
      Nothing
    else 
      match Set_extra.choose res with
        | (s,envC,Rval (envM,envE)) ->
           Just <| sem_envM = envM ++ se.sem_envM;
                   sem_envC = merge_envC envC se.sem_envC;
                   sem_envE = envE ++ se.sem_envE;
                   sem_store = s |>
        | _ -> Nothing
      end

val prim_sem_env : maybe sem_environment
let prim_sem_env =
  add_to_sem_env <| sem_envM = []; sem_envC = ([],[]); sem_envE = []; sem_store = ((0,[]),{},{}) |> prim_types_program

val basis_sem_env : maybe sem_environment
let basis_sem_env =
  add_to_sem_env (Maybe_extra.fromJust prim_sem_env) basis_program
