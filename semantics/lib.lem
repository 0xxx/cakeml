open import Pervasives
import List_extra
import String

(* TODO: look for these in the built-in library *)

val rtc : forall 'a. ('a -> 'a -> bool) -> ('a -> 'a -> bool)
declare hol    target_rep function rtc = `RTC`

val disjoint : forall 'a. set 'a -> set 'a -> bool
declare hol    target_rep function disjoint = `DISJOINT`

(* TODO: proper support for words... *)
open import {hol} `wordsTheory`
type word8
declare hol target_rep type word8 = `word8`
val natFromWord8 : word8 -> nat
declare hol target_rep function natFromWord8 = `w2n`
val word_to_hex_string : word8 -> string
declare hol target_rep function word_to_hex_string = `word_to_hex_string`

(* The builtin List.zip maps to list_combine in HOL, but I want to map to ZIP *)
val ZIP : forall 'a 'b. list 'a -> list 'b -> list ('a * 'b)
let inline ZIP = List_extra.zipSameLength

(* Environments *)
type env 'a 'b = list ('a*'b)

val emp : forall 'a 'b. env 'a 'b
let emp = []

val lookup : forall 'a 'b. Eq 'a => 'a -> env 'a 'b -> maybe 'b
let rec
lookup n [] = Nothing
and
lookup n ((n',v)::e) =
  if n' = n then
    Just v
  else
    lookup n e
declare termination_argument lookup = automatic

val bind : forall 'a 'b. 'a -> 'b -> env 'a 'b -> env 'a 'b
let bind n v e = (n,v)::e

val opt_bind : forall 'a 'b. maybe 'a -> 'b -> env 'a 'b -> env 'a 'b
let opt_bind n v e = 
  match n with 
    | Nothing -> e
    | Just n' -> (n',v)::e
  end

val merge : forall 'a 'b. env 'a 'b -> env 'a 'b -> env 'a 'b
let merge e1 e2 = e1 ++ e2

