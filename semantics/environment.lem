open import Pervasives
open import Ast

type alist 'k 'v = list ('k * 'v)

type environment 'n 'v =
  Bind of alist 'n 'v * alist modN (environment 'n 'v)

val eLookup : forall 'v 'n. Eq 'n => environment 'n 'v -> id 'n -> maybe 'v
let rec eLookup (Bind v m) (Short n) = List.lookup n v
    and eLookup (Bind v m) (Long mn id) =
      match List.lookup mn m with
      | Nothing -> Nothing
      | Just env -> eLookup env id
      end
declare termination_argument eLookup = automatic

val eEmpty : forall 'v 'n. environment 'n 'v
let eEmpty = Bind [] []

val eMerge : forall 'v 'n. environment 'n 'v -> environment 'n 'v -> environment 'n 'v
let eMerge (Bind v1 m1) (Bind v2 m2) = Bind (v1 ++ v2) (m1 ++ m2)

val eLift : forall 'v 'n. modN -> environment 'n 'v -> environment 'n 'v
let eLift mn env = Bind [] [(mn, env)]

val alist_to_env : forall 'v 'n. alist 'n 'v -> environment 'n 'v
let alist_to_env a = Bind a []

val eBind : forall 'v 'n. 'n -> 'v -> environment 'n 'v -> environment 'n 'v
let eBind k x (Bind v m) = Bind ((k,x)::v) m

val eOptBind : forall 'v 'n. maybe 'n -> 'v -> environment 'n 'v -> environment 'n 'v
let eOptBind n x env =
  match n with
  | Nothing -> env
  | Just n' -> eBind n' x env
  end

val eSing : forall 'v 'n. 'n -> 'v -> environment 'n 'v
let eSing n x = Bind ([(n,x)]) []

val eSubEnv : forall 'v1 'v2 'n. Eq 'n, Eq 'v1, Eq 'v2 =>
  (id 'n -> 'v1 -> 'v2 -> bool) -> environment 'n 'v1 -> environment 'n 'v2 -> bool
let eSubEnv r env1 env2 =
  forall id v1.
    eLookup env1 id = Just v1
    -->
    exists v2. eLookup env2 id = Just v2 && r id v1 v2

val eAll : forall 'v 'n. ('v -> bool) -> environment 'n 'v -> bool
let rec eAll f (Bind v m) =
  List.all (fun x -> f (snd x)) v &&
  List.all (fun x -> eAll f (snd x)) m

val eAll2 : forall 'v1 'v2 'n. Eq 'n, Eq 'v1, Eq 'v2 =>
   (id 'n -> 'v1 -> 'v2 -> bool) -> environment 'n 'v1 -> environment 'n 'v2 -> bool
let eAll2 r env1 env2 =
  eSubEnv r env1 env2 &&
  (forall n.
    eLookup env1 n = Nothing
    -->
    eLookup env1 n = Nothing)

val eDom : forall 'v 'n. Eq 'n, Eq 'v => environment 'n 'v -> set (id 'n)
let eDom env = { n | forall v n | eLookup env n = Just v }

val eMap : forall 'v 'w 'n. ('v -> 'w) -> environment 'n 'v -> environment 'n 'w
let rec eMap f (Bind v m) =
  Bind (List.map (fun (n,x) -> (n, f x)) v)
       (List.map (fun (mn,e) -> (mn, eMap f e)) m)
