open import Pervasives
open import Ast

type alist 'k 'v = list ('k * 'v)

(* Identifiers *)
type id 'a =
  | Short of 'a
  | Long of modN * id 'a

val mk_id : forall 'a. list modN -> 'a -> id 'a
let rec mk_id [] n = Short n
    and mk_id (mn::mns) n = Long mn (mk_id mns n)

val id_to_n : forall 'a. id 'a -> 'a
let rec id_to_n (Short n) = n
    and id_to_n (Long _ id) = id_to_n id

val id_to_mods : forall 'a. id 'a -> list modN
let rec id_to_mods (Short _) = []
    and id_to_mods (Long mn id) = mn :: id_to_mods id

type environment 'n 'v =
  Bind of alist 'n 'v * alist modN (environment 'n 'v)

val eLookup : forall 'v 'n. Eq 'n => environment 'n 'v -> id 'n -> maybe 'v
let rec eLookup (Bind v m) (Short n) = List.lookup n v
    and eLookup (Bind v m) (Long mn id) =
      match List.lookup mn m with
      | Nothing -> Nothing
      | Just env -> eLookup env id
      end
declare termination_argument eLookup = automatic

val eLookupMod : forall 'n 'v. Eq 'n => environment 'n 'v -> list modN -> maybe (environment 'n 'v)
let rec eLookupMod e [] = Just e
    and eLookupMod (Bind v m) (mn::path) =
      match List.lookup mn m with
      | Nothing -> Nothing
      | Just env -> eLookupMod env path
      end
declare termination_argument eLookupMod = automatic

val eEmpty : forall 'v 'n. environment 'n 'v
let eEmpty = Bind [] []

val eAppend : forall 'v 'n. environment 'n 'v -> environment 'n 'v -> environment 'n 'v
let eAppend (Bind v1 m1) (Bind v2 m2) = Bind (v1 ++ v2) (m1 ++ m2)

val eLift : forall 'v 'n. modN -> environment 'n 'v -> environment 'n 'v
let eLift mn env = Bind [] [(mn, env)]

val alist_to_env : forall 'v 'n. alist 'n 'v -> environment 'n 'v
let alist_to_env a = Bind a []

val eBind : forall 'v 'n. 'n -> 'v -> environment 'n 'v -> environment 'n 'v
let eBind k x (Bind v m) = Bind ((k,x)::v) m

val eBindList : forall 'v 'n. list ('n * 'v) -> environment 'n 'v -> environment 'n 'v
let eBindList l e = List.foldr (fun (x,v) e -> eBind x v e) e l

val eOptBind : forall 'v 'n. maybe 'n -> 'v -> environment 'n 'v -> environment 'n 'v
let eOptBind n x env =
  match n with
  | Nothing -> env
  | Just n' -> eBind n' x env
  end

val eSing : forall 'v 'n. 'n -> 'v -> environment 'n 'v
let eSing n x = Bind ([(n,x)]) []

val eSubEnv : forall 'v1 'v2 'n. Eq 'n, Eq 'v1, Eq 'v2 =>
  (id 'n -> 'v1 -> 'v2 -> bool) -> environment 'n 'v1 -> environment 'n 'v2 -> bool
let eSubEnv r env1 env2 =
  (forall id v1.
    eLookup env1 id = Just v1
    -->
    exists v2. eLookup env2 id = Just v2 && r id v1 v2)
  &&
  (forall path.
    eLookupMod env2 path = Nothing --> eLookupMod env1 path = Nothing)

val eAll : forall 'v 'n. Eq 'n, Eq 'v => (id 'n -> 'v -> bool) -> environment 'n 'v -> bool
let rec eAll f env =
  (forall id v.
     eLookup env id = Just v
     -->
     f id v)

val eAll2 : forall 'v1 'v2 'n. Eq 'n, Eq 'v1, Eq 'v2 =>
   (id 'n -> 'v1 -> 'v2 -> bool) -> environment 'n 'v1 -> environment 'n 'v2 -> bool
let eAll2 r env1 env2 =
  eSubEnv r env1 env2 &&
  eSubEnv (fun x y z -> r x z y) env2 env1

val eDom : forall 'v 'n. Eq 'n, Eq 'v => environment 'n 'v -> set (id 'n)
let eDom env = { n | forall v n | eLookup env n = Just v }

val eMap : forall 'v 'w 'n. ('v -> 'w) -> environment 'n 'v -> environment 'n 'w
let rec eMap f (Bind v m) =
  Bind (List.map (fun (n,x) -> (n, f x)) v)
       (List.map (fun (mn,e) -> (mn, eMap f e)) m)
