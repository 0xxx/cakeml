(*Generated by Lem from simpleIO.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory lem_pervasives_extraTheory libTheory ffiTheory;

val _ = numLib.prefer_num();



val _ = new_theory "simpleIO"

(*open import Pervasives*)
(*open import Pervasives_extra*)
(*open import Lib*)
(*open import Ffi*)

val _ = Hol_datatype `
 simpleIO = <| input :  word8 llist; output :  word8 llist ; has_exited : bool |>`;


(*val isEof : oracle_function simpleIO*)
val _ = Define `
 (isEof st input =  
((case input of
    [] => NONE
  | x::xs => SOME (st,((if st.input = LNIL then n2w ( 1) else n2w ( 0))::xs))
  )))`;


(*val getChar : oracle_function simpleIO*)
val _ = Define `
 (getChar st input =  
((case input of
    [] => NONE
  | x::xs =>
      (case LHD st.input of
        SOME y => SOME (( st with<| input := THE (LTL st.input) |>), (y::xs))
      | _ => NONE
      )
  )))`;


(*val putChar : oracle_function simpleIO*)
val _ = Define `
 (putChar st input =  
((case input of
    [] => NONE
  | x::_ => SOME (( st with<| output := LCONS x st.output |>), input)
  )))`;


(*val exit : oracle_function simpleIO*)
val _ = Define `
 (exit st input =  
(if st.has_exited then
    NONE
  else
    SOME (( st with<| has_exited := T |>), input)))`;


(*val simpleIO_oracle : oracle simpleIO*)
val _ = Define `
 (simpleIO_oracle n st input =  
(if st.has_exited then
    NONE
  else if n = 0 then
    isEof st input
  else if n = 1 then
    getChar st input
  else if n = 2 then
    putChar st input
  else if n = 3 then
    exit st input
  else
    NONE))`;

val _ = export_theory()

