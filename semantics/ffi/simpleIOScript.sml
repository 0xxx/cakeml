(*Generated by Lem from simpleIO.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory lem_pervasives_extraTheory libTheory ffiTheory;

val _ = numLib.prefer_num();



val _ = new_theory "simpleIO"

(*open import Pervasives*)
(*open import Pervasives_extra*)
(*open import Lib*)
(*open import Ffi*)

val _ = Hol_datatype `
 simpleIO = <| input :  word8 llist; output :  word8 llist |>`;


(*val isEof : oracle_function simpleIO*)
val _ = Define `
 (isEof st input =  
((case input of
    [] => Oracle_fail
  | x::xs => Oracle_return st ((if st.input = LNIL then n2w ( 1) else n2w ( 0))::xs)
  )))`;


(*val getChar : oracle_function simpleIO*)
val _ = Define `
 (getChar st input =  
((case input of
    [] => Oracle_fail
  | x::xs =>
      (case LHD st.input of
        SOME y => Oracle_return (( st with<| input := THE (LTL st.input) |>)) (y::xs)
      | _ => Oracle_fail
      )
  )))`;


(*val putChar : oracle_function simpleIO*)
val _ = Define `
 (putChar st input =  
((case input of
    [] => Oracle_fail
  | x::_ => Oracle_return (( st with<| output := LCONS x st.output |>)) input
  )))`;


(*val exit : oracle_function simpleIO*)
val _ = Define `
 (exit st input = Oracle_diverge)`;


(*val simpleIO_oracle : oracle simpleIO*)
val _ = Define `
 (simpleIO_oracle n st input =  
(if n = 0 then
    isEof st input
  else if n = 1 then
    getChar st input
  else if n = 2 then
    putChar st input
  else if n = 3 then
    exit st input
  else
    Oracle_fail))`;

val _ = export_theory()

