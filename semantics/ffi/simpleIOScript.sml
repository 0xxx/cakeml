(*Generated by Lem from simpleIO.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory lem_pervasives_extraTheory libTheory ffiTheory;

val _ = numLib.prefer_num();



val _ = new_theory "simpleIO"

(*open import Pervasives*)
(*open import Pervasives_extra*)
(*open import Lib*)
(*open import Ffi*)

val _ = Hol_datatype `
 simpleIO = <| input :  word8 llist; output :  word8 llist ; has_exited : bool |>`;


(*val isEof : simpleIO -> list (word8 * word8) -> bool*)
val _ = Define `
 (isEof st io =  
((case io of
    [] => F
  | (x,y)::io =>
      EVERY (\ (x,y) .  x = y) io /\
      (((st.input = LNIL) /\ (y =n2w ( 1))) \/
       ((st.input <> LNIL) /\ (y =n2w ( 0))))
  )))`;


(*val getChar : simpleIO -> list (word8 * word8) -> maybe simpleIO*)
val _ = Define `
 (getChar st io =  
((case io of
    [] => NONE
  | (x,y)::io =>
      if EVERY (\ (x,y) .  x = y) io /\ (SOME y = LHD st.input) then
        SOME ( st with<| input := THE (LTL st.input) |>)
      else
        NONE
  )))`;


(*val putChar : simpleIO -> list (word8 * word8) -> maybe simpleIO*)
val _ = Define `
 (putChar st io =  
((case io of
    [] => NONE
  | (x,y)::io =>
      if (x = y) /\ EVERY (\ (x,y) .  x = y) io then
        SOME ( st with<| output := LCONS x st.output |>)
      else
        NONE
  )))`;


(*val exit : simpleIO -> maybe simpleIO*)
val _ = Define `
 (exit st =  
(if st.has_exited then
    NONE
  else
    SOME ( st with<| has_exited := T |>)))`;


(*val simpleIO_oracle : oracle simpleIO*)
val _ = Define `
 (simpleIO_oracle st (IO_event n xs) =  
(if st.has_exited then
    NONE
  else if (n = 0) /\ isEof st xs then
    SOME st
  else if n = 1 then
    getChar st xs
  else if n = 2 then
    putChar st xs
  else if n = 3 then
    exit st
  else
    NONE))`;

val _ = export_theory()

