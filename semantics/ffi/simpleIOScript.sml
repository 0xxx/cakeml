(*Generated by Lem from simpleIO.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory lem_pervasives_extraTheory libTheory ffiTheory;

val _ = numLib.prefer_num();



val _ = new_theory "simpleIO"

(*open import Pervasives*)
(*open import Pervasives_extra*)
(*open import Lib*)
(*open import Ffi*)

val _ = Hol_datatype `
 io_state = <| input :  word8 llist; output :  word8 llist ; has_exited : bool |>`;


(*val isEof : io_state -> list (word8 * word8) -> bool*)
val _ = Define `
 (isEof st io =  
((case io of
    [] => F
  | (x,y)::io =>
      EVERY (\ (x,y) .  x = y) io /\
      (((st.input = LNIL) /\ (y =n2w ( 1))) \/
       ((st.input <> LNIL) /\ (y =n2w ( 0))))
  )))`;


(*val getChar : io_state -> list (word8 * word8) -> maybe io_state*)
val _ = Define `
 (getChar st io =  
((case io of
    [] => NONE
  | (x,y)::io =>
      if EVERY (\ (x,y) .  x = y) io /\ (SOME y = LHD st.input) then
        SOME ( st with<| input := THE (LTL st.input) |>)
      else
        NONE
  )))`;


(*val putChar : io_state -> list (word8 * word8) -> maybe io_state*)
val _ = Define `
 (putChar st io =  
((case io of
    [] => NONE
  | (x,y)::io =>
      if (x = y) /\ EVERY (\ (x,y) .  x = y) io then
        SOME ( st with<| output := LCONS x st.output |>)
      else
        NONE
  )))`;


(*val exit : io_state -> maybe io_state*)
val _ = Define `
 (exit st =  
(if st.has_exited then
    NONE
  else
    SOME ( st with<| has_exited := T |>)))`;


(*val system_step : io_state -> io_event -> io_state -> bool*)
val _ = Define `
 (system_step st1 (IO_event n xs) st2 =  
(if st1.has_exited then
    F
  else if (n = 0) /\ isEof st1 xs then
    st1 = st2
  else if n = 1 then
    (case getChar st1 xs of
      SOME st' => st' = st2
    | NONE => F
    )
  else if n = 2 then
    (case putChar st1 xs of
      SOME st' => st' = st2
    | NONE => F
    )
  else if n = 3 then
    (case exit st1 of
      SOME st' => st' = st2
    | NONE => F
    )
  else
    F))`;

val _ = export_theory()

