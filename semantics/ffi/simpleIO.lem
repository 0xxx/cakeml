open import Pervasives
open import Pervasives_extra
open import Lib
open import Ffi

type simpleIO = <| input : llist word8; output : llist word8 ; has_exited : bool |>

val isEof : simpleIO -> list (word8 * word8) -> bool
let isEof st io =
  match io with
  | [] -> false
  | (x,y)::io ->
      List.all (fun (x,y) -> x = y) io &&
      ((st.input = lnil && y = 1) ||
       (st.input <> lnil && y = 0))
  end

val getChar : simpleIO -> list (word8 * word8) -> maybe simpleIO
let getChar st io =
  match io with
  | [] -> Nothing
  | (x,y)::io ->
      if List.all (fun (x,y) -> x = y) io && Just y = lhd st.input then
        Just <| st with input = fromJust (ltl st.input) |>
      else
        Nothing
  end

val putChar : simpleIO -> list (word8 * word8) -> maybe simpleIO
let putChar st io =
  match io with
  | [] -> Nothing
  | (x,y)::io ->
      if x = y && List.all (fun (x,y) -> x = y) io then
        Just <| st with output = lcons x st.output |>
      else
        Nothing
  end

val exit : simpleIO -> maybe simpleIO
let exit st =
  if st.has_exited then
    Nothing
  else
    Just <| st with has_exited = true |>

val simpleIO_oracle : oracle simpleIO
let simpleIO_oracle st (IO_event n xs) =
  if st.has_exited then
    Nothing
  else if n = 0 && isEof st xs then
    Just st
  else if n = 1 then
    getChar st xs
  else if n = 2 then
    putChar st xs
  else if n = 3 then
    exit st
  else
    Nothing
