open import Pervasives
open import Pervasives_extra
open import Lib

(* An oracle says how to perform an ffi call based on its internal state,
 * represented by the type variable 'ffi. *)

type oracle_function 'ffi = 'ffi -> list word8 -> maybe ('ffi * (list word8))
type oracle 'ffi = nat -> oracle_function 'ffi

(* call_FFI lifts the oracle into the option monad, allowing the CakeML
 * semantics to continue past failed FFI. It also checks the length of the output. *)
val call_FFI : forall 'ffi. oracle 'ffi -> nat -> maybe 'ffi -> list word8 -> maybe 'ffi * list word8
let call_FFI oracle n st bytes =
  match st with
  | Just ffi ->
      match oracle n ffi bytes with
      | Just (ffi', bytes') ->
          if length bytes' = length bytes then
            (Just ffi', bytes')
          else (Nothing, bytes)
      | _ -> (Nothing, bytes)
      end
  | _ -> (Nothing, bytes)
  end

(* I/O events *)

(* An I/O event, IO_event n bytes2, represents the call of FFI function n with
 * input map fst bytes2 in the passed array, returning map snd bytes2 in the
 * array. *)

type io_event = IO_event of nat * (list (word8 * word8))

(* Any oracle can be extended as an oracle that tracks the io_events it has
 * encountered *)

val add_trace : forall 'ffi. oracle 'ffi -> oracle ('ffi * list io_event)
let add_trace oracle n (ffi,events) bytes =
  match oracle n ffi bytes with
  | Just (ffi',bytes') -> Just ((ffi', (IO_event n (zipSameLength bytes bytes'))::events),bytes')
  | _ -> Nothing
  end

(* A program can Diverge, Terminate, or Fail. We prove that Fail is
   avoided. For Diverge and Terminate, we keep track of what I/O
   events are valid I/O events for this behaviour. *)
type  behaviour =
    (* There cannot be any non-returning FFI calls in a diverging
       exeuction. The list of I/O events can be finite or infinite,
       hence the llist (lazy list) type. *)
    Diverge of llist io_event
    (* Terminating executions can only perform a finite number of
       FFI calls. The execution can be terminated by a non-returning
       FFI call. *)
  | Terminate of list io_event
    (* Failure is a behaviour which we prove cannot occur for any
       well-typed program. *)
  | Fail

(* trace-based semantics can be recovered as an instance of oracle-based
 * semantics as follows. *)

val trace_oracle : oracle (llist io_event)
let trace_oracle n io_trace input =
  match lhd io_trace with
  | Just (IO_event n' bytes2) ->
      if (n = n') && (map fst bytes2 = input) then
        Just (fromJust (ltl io_trace), map snd bytes2)
      else Nothing
  | _ -> Nothing
  end
