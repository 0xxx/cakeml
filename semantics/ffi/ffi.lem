open import Pervasives
open import Pervasives_extra
open import Lib

(* I/O events *)

(* An I/O event, IO_event n bytes2, calls FFI function n with input
   map fst bytes2 in the passed array, and the call returns with map snd bytes2
   in the array. *)
type io_event = IO_event of nat * (list (word8 * word8))

(* An I/O oracle accepts or rejects the next event in an io_trace according to
 * its oracle state, represented by the type variable 'ffi. *)

type oracle 'ffi = 'ffi -> io_event -> maybe 'ffi

type oracle_state_and_trace 'ffi =
  <| oracle_state: 'ffi
   ; io_trace: llist io_event
   |>

type io_state 'ffi = maybe (oracle_state_and_trace 'ffi)

(* A program can Diverge, Terminate, or Fail. We prove that Fail is
   avoided. For Diverge and Terminate, we keep track of what I/O
   events are valid I/O events for this behaviour. *)
type  behaviour =
    (* There cannot be any non-returning FFI calls in a diverging
       exeuction. The list of I/O events can be finite or infinite,
       hence the llist (lazy list) type. *)
    Diverge of llist io_event
    (* Terminating executions can only perform a finite number of
       FFI calls. The execution can be terminated by a non-returning
       FFI call. *)
  | Terminate of list io_event
    (* Failure is a behaviour which we prove cannot occur for any
       well-typed program. *)
  | Fail

val call_FFI : forall 'ffi. oracle 'ffi -> nat -> list word8 -> io_state 'ffi -> list word8 * io_state 'ffi
let call_FFI oracle n bytes io_state =
  match io_state with
  | Just s ->
     match lhd s.io_trace with
     | Just (IO_event n' xs) ->
         if (n = n') && (map fst xs = bytes) then
           match oracle s.oracle_state (IO_event n xs) with
           | Just ffi' -> (map snd xs,
                           Just <| oracle_state = ffi'
                                 ; io_trace = fromJust (ltl s.io_trace) |>)
           | Nothing -> (bytes, Nothing)
           end
         else (bytes, Nothing)
     | _ -> (bytes, Nothing)
     end
  | _ -> (bytes, Nothing)
  end

(* trace-based semantics can be recovered as an instance of oracle-based
 * semantics by using a trivial oracle_state that simply corresponds
 * exactly to the io_trace. *)

val trace_oracle : oracle (llist io_event)
let trace_oracle io_trace event =
  match lhd io_trace with
  | Just event' -> if event = event' then ltl io_trace else Nothing
  | _ -> Nothing
  end
