(*Generated by Lem from ffi.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory lem_pervasives_extraTheory libTheory;

val _ = numLib.prefer_num();



val _ = new_theory "ffi"

(*open import Pervasives*)
(*open import Pervasives_extra*)
(*open import Lib*)

(* I/O events *)

(* An I/O event, IO_event n bytes2, calls FFI function n with input
   map fst bytes2 in the passed array, and the call returns with map snd bytes2
   in the array. *)
val _ = Hol_datatype `
 io_event = IO_event of num => ( (word8 # word8)list)`;


(* An I/O oracle accepts or rejects the next event in an io_trace according to
 * its oracle state, represented by the type variable 'ffi. *)

val _ = type_abbrev((*  'ffi *) "oracle" , ``: 'ffi -> io_event ->  'ffi option``);

val _ = Hol_datatype `
(*  'ffi *) oracle_state_and_trace =
  <| oracle_state: 'ffi
   ; io_trace:  io_event llist
   |>`;


val _ = type_abbrev((*  'ffi *) "io_state" , ``:  ( 'ffi oracle_state_and_trace)option``);

(* A program can Diverge, Terminate, or Fail. We prove that Fail is
   avoided. For Diverge and Terminate, we keep track of what I/O
   events are valid I/O events for this behaviour. *)
val _ = Hol_datatype `
  behaviour =
    (* There cannot be any non-returning FFI calls in a diverging
       exeuction. The list of I/O events can be finite or infinite,
       hence the llist (lazy list) type. *)
    Diverge of  io_event llist
    (* Terminating executions can only perform a finite number of
       FFI calls. The execution can be terminated by a non-returning
       FFI call. *)
  | Terminate of io_event list
    (* Failure is a behaviour which we prove cannot occur for any
       well-typed program. *)
  | Fail`;


(*val call_FFI : forall 'ffi. oracle 'ffi -> nat -> list word8 -> io_state 'ffi -> list word8 * io_state 'ffi*)
val _ = Define `
 (call_FFI oracle n bytes io_state =  
((case io_state of
    SOME s =>
     (case LHD s.io_trace of
       SOME (IO_event n' xs) =>
         if (n = n') /\ (MAP FST xs = bytes) then
           (case oracle s.oracle_state (IO_event n xs) of
             SOME ffi' => (MAP SND xs,
                           SOME <| oracle_state := ffi'
                                 ; io_trace := (THE (LTL s.io_trace)) |>)
           | NONE => (bytes, NONE)
           )
         else (bytes, NONE)
     | _ => (bytes, NONE)
     )
  | _ => (bytes, NONE)
  )))`;


(* trace-based semantics can be recovered as an instance of oracle-based
 * semantics by using a trivial oracle_state that simply corresponds
 * exactly to the io_trace. *)

(*val trace_oracle : oracle (llist io_event)*)
val _ = Define `
 (trace_oracle io_trace event =  
((case LHD io_trace of
    SOME event' => if event = event' then LTL io_trace else NONE
  | _ => NONE
  )))`;

val _ = export_theory()

