(*Generated by Lem from ffi.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory lem_pervasives_extraTheory libTheory;

val _ = numLib.prefer_num();



val _ = new_theory "ffi"

(*open import Pervasives*)
(*open import Pervasives_extra*)
(*open import Lib*)

(* An oracle says how to perform an ffi call based on its internal state,
 * represented by the type variable 'ffi. *)

val _ = type_abbrev((*  'ffi *) "oracle_function" , ``: 'ffi -> word8 list ->  ('ffi # ( word8 list))option``);
val _ = type_abbrev((*  'ffi *) "oracle" , ``: num -> 'ffi oracle_function``);

(* call_FFI lifts the oracle into the option monad, allowing the CakeML
 * semantics to continue past failed FFI. It also checks the length of the output. *)
(*val call_FFI : forall 'ffi. oracle 'ffi -> nat -> list word8 -> maybe 'ffi -> maybe 'ffi * list word8*)
val _ = Define `
 (call_FFI oracle n bytes st =  
((case st of
    SOME ffi =>
      (case oracle n ffi bytes of
        SOME (ffi', bytes') =>
          if LENGTH bytes' = LENGTH bytes then
            (SOME ffi', bytes')
          else (NONE, bytes)
      | _ => (NONE, bytes)
      )
  | _ => (NONE, bytes)
  )))`;


(* I/O events for trace-based semantics *)

(* An I/O event, IO_event n bytes2, represents the call of FFI function n with
 * input map fst bytes2 in the passed array, returning map snd bytes2 in the
 * array. *)

val _ = Hol_datatype `
 io_event = IO_event of num => ( (word8 # word8)list)`;


(* A program can Diverge, Terminate, or Fail. We prove that Fail is
   avoided. For Diverge and Terminate, we keep track of what I/O
   events are valid I/O events for this behaviour. *)
val _ = Hol_datatype `
  behaviour =
    (* There cannot be any non-returning FFI calls in a diverging
       exeuction. The list of I/O events can be finite or infinite,
       hence the llist (lazy list) type. *)
    Diverge of  io_event llist
    (* Terminating executions can only perform a finite number of
       FFI calls. The execution can be terminated by a non-returning
       FFI call. *)
  | Terminate of io_event list
    (* Failure is a behaviour which we prove cannot occur for any
       well-typed program. *)
  | Fail`;


(* trace-based semantics can be recovered as an instance of oracle-based
 * semantics as follows. *)

(*val trace_oracle : oracle (llist io_event)*)
val _ = Define `
 (trace_oracle n io_trace input =  
((case LHD io_trace of
    SOME (IO_event n' bytes2) =>
      if (n = n') /\ (MAP FST bytes2 = input) then
        SOME (THE (LTL io_trace), MAP SND bytes2)
      else NONE
  | _ => NONE
  )))`;

val _ = export_theory()

