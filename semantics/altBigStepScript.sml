(*Generated by Lem from altBigStep.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extraTheory libTheory astTheory semanticPrimitivesTheory bigStepTheory;

val _ = numLib.prefer_num();



val _ = new_theory "altBigStep"

(*open import Pervasives_extra*)
(*open import Lib*)
(*open import Ast*) 
(*open import SemanticPrimitives*)
(*import BigStep*)

(* A version of the big-step expression semantics that stores the constructor
and module environments in constructors.  It is equivalent to the normal one
for well-typed programs.  *)

val _ = Hol_datatype `
 v' =
    Litv' of lit
  | Conv' of  ( conN id)option => v list 
  | Closure' of envM => envC => (varN, v) env => varN => exp
  | Recclosure' of envM => envC => (varN, v) env => (varN # varN # exp) list => varN
  | Loc' of num`;


(*val do_app' : store -> envE -> op -> v -> v -> maybe (store * envE * exp)*)
val _ = Define `
 (do_app' s env' op v1 v2 =  
((case (op, v1, v2) of
      (Opapp, Closure env n e, v) =>
        SOME (s, bind n v env, e)
    | (Opapp, Recclosure env funs n, v) =>
        (case find_recfun n funs of
            SOME (n,e) => SOME (s, bind n v (build_rec_env funs env env), e)
          | NONE => NONE
        )
    | (Opn op, Litv (IntLit n1), Litv (IntLit n2)) =>
        if ((op = Divide) \/ (op = Modulo)) /\ (n2 =( 0 : int)) then
          SOME (s, env', Raise (Con (SOME (Short "Div")) []))
        else
          SOME (s, env',Lit (IntLit (opn_lookup op n1 n2)))
    | (Opb op, Litv (IntLit n1), Litv (IntLit n2)) =>
        SOME (s, env', Lit (Bool (opb_lookup op n1 n2)))
    | (Equality, v1, v2) =>
        (case do_eq v1 v2 of
            Eq_type_error => NONE
          | Eq_closure => SOME (s, env', Raise (Con (SOME (Short "Eq")) []))
          | Eq_val b => SOME (s, env', Lit (Bool b))
        )
    | (Opassign, (Loc lnum), v) =>
        (case store_assign lnum v s of
          SOME st => SOME (st, env', Lit Unit)
        | NONE => NONE
        )
    | _ => NONE
  )))`;


val _ = Hol_reln ` (! ck menv cenv env l s.
T
==>
evaluate' ck menv cenv s env (Lit l) (s, Rval (Litv l)))

/\ (! ck menv cenv env e s1 s2 v.
(evaluate' ck menv cenv s1 env e (s2, Rval v))
==>
evaluate' ck menv cenv s1 env (Raise e) (s2, Rerr (Rraise v)))

/\ (! ck menv cenv env e s1 s2 err.
(evaluate' ck menv cenv s1 env e (s2, Rerr err))
==>
evaluate' ck menv cenv s1 env (Raise e) (s2, Rerr err))

/\ (! ck menv cenv s1 s2 env e v pes.
(evaluate' ck menv cenv s1 env e (s2, Rval v))
==>
evaluate' ck menv cenv s1 env (Handle e pes) (s2, Rval v))

/\ (! ck menv cenv s1 s2 env e pes v bv.
(evaluate' ck menv cenv s1 env e (s2, Rerr (Rraise v)) /\
evaluate_match' ck menv cenv s2 env v pes v bv)
==>
evaluate' ck menv cenv s1 env (Handle e pes) bv)

/\ (! ck menv cenv s1 s2 env e pes err.
(evaluate' ck menv cenv s1 env e (s2, Rerr err) /\
((err = Rtimeout_error) \/ (err = Rtype_error)))
==>
evaluate' ck menv cenv s1 env (Handle e pes) (s2, Rerr err))

/\ (! ck menv cenv env cn es vs s s'.
(do_con_check cenv cn (LENGTH es) /\
evaluate_list' ck menv cenv s env es (s', Rval vs))
==>
evaluate' ck menv cenv s env (Con cn es) (s', Rval (Conv cn vs)))

/\ (! ck menv cenv env cn es s.
(~ (do_con_check cenv cn (LENGTH es)))
==>
evaluate' ck menv cenv s env (Con cn es) (s, Rerr Rtype_error))

/\ (! ck menv cenv env cn es err s s'.
(do_con_check cenv cn (LENGTH es) /\
evaluate_list' ck menv cenv s env es (s', Rerr err))
==>
evaluate' ck menv cenv s env (Con cn es) (s', Rerr err))

/\ (! ck menv cenv env n v s.
(lookup_var_id n menv env = SOME v)
==>
evaluate' ck menv cenv s env (Var n) (s, Rval v))

/\ (! ck menv cenv env n s.
(lookup_var_id n menv env = NONE)
==>
evaluate' ck menv cenv s env (Var n) (s, Rerr Rtype_error))

/\ (! ck menv cenv env n e s.
T
==>
evaluate' ck menv cenv s env (Fun n e) (s, Rval (Closure env n e)))

/\ (! ck menv cenv env uop e v v' s1 s2 count s3.
(evaluate' ck menv cenv s1 env e ((count,s2), Rval v) /\
(do_uapp s2 uop v = SOME (s3,v')))
==>
evaluate' ck menv cenv s1 env (Uapp uop e) ((count,s3), Rval v'))

/\ (! ck menv cenv env uop e v s1 s2 count.
(evaluate' ck menv cenv s1 env e ((count,s2), Rval v) /\
(do_uapp s2 uop v = NONE))
==>
evaluate' ck menv cenv s1 env (Uapp uop e) ((count,s2), Rerr Rtype_error))

/\ (! ck menv cenv env uop e err s s'.
(evaluate' ck menv cenv s env e (s', Rerr err))
==>
evaluate' ck menv cenv s env (Uapp uop e) (s', Rerr err))

/\ (! ck menv cenv env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 count s4.
(evaluate' ck menv cenv s1 env e1 (s2, Rval v1) /\
(evaluate' ck menv cenv s2 env e2 ((count,s3), Rval v2) /\
((do_app' s3 env op v1 v2 = SOME (s4, env', e3)) /\
(((ck /\ (op = Opapp)) ==> ~ (count =( 0))) /\
evaluate' ck menv cenv ((if ck then bigStep$dec_count op count else count),s4) env' e3 bv))))
==>
evaluate' ck menv cenv s1 env (App op e1 e2) bv)

/\ (! ck menv cenv env op e1 e2 v1 v2 env' e3 s1 s2 s3 count s4.
(evaluate' ck menv cenv s1 env e1 (s2, Rval v1) /\
(evaluate' ck menv cenv s2 env e2 ((count,s3), Rval v2) /\
((do_app' s3 env op v1 v2 = SOME (s4, env', e3)) /\
((count = 0) /\
((op = Opapp) /\
ck)))))
==>
evaluate' ck menv cenv s1 env (App op e1 e2) (( 0,s4), Rerr Rtimeout_error))

/\ (! ck menv cenv env op e1 e2 v1 v2 s1 s2 s3 count.
(evaluate' ck menv cenv s1 env e1 (s2, Rval v1) /\
(evaluate' ck menv cenv s2 env e2 ((count,s3), Rval v2) /\
(do_app' s3 env op v1 v2 = NONE)))
==>
evaluate' ck menv cenv s1 env (App op e1 e2) ((count,s3), Rerr Rtype_error))

/\ (! ck menv cenv env op e1 e2 v1 err s1 s2 s3.
(evaluate' ck menv cenv s1 env e1 (s2, Rval v1) /\
evaluate' ck menv cenv s2 env e2 (s3, Rerr err))
==>
evaluate' ck menv cenv s1 env (App op e1 e2) (s3, Rerr err))

/\ (! ck menv cenv env op e1 e2 err s s'.
(evaluate' ck menv cenv s env e1 (s', Rerr err))
==>
evaluate' ck menv cenv s env (App op e1 e2) (s', Rerr err))

/\ (! ck menv cenv env op e1 e2 v e' bv s1 s2.
(evaluate' ck menv cenv s1 env e1 (s2, Rval v) /\
((do_log op v e2 = SOME e') /\
evaluate' ck menv cenv s2 env e' bv))
==>
evaluate' ck menv cenv s1 env (Log op e1 e2) bv)

/\ (! ck menv cenv env op e1 e2 v s1 s2.
(evaluate' ck menv cenv s1 env e1 (s2, Rval v) /\
(do_log op v e2 = NONE))
==>
evaluate' ck menv cenv s1 env (Log op e1 e2) (s2, Rerr Rtype_error))

/\ (! ck menv cenv env op e1 e2 err s s'.
(evaluate' ck menv cenv s env e1 (s', Rerr err))
==>
evaluate' ck menv cenv s env (Log op e1 e2) (s', Rerr err))

/\ (! ck menv cenv env e1 e2 e3 v e' bv s1 s2.
(evaluate' ck menv cenv s1 env e1 (s2, Rval v) /\
((do_if v e2 e3 = SOME e') /\
evaluate' ck menv cenv s2 env e' bv))
==>
evaluate' ck menv cenv s1 env (If e1 e2 e3) bv)

/\ (! ck menv cenv env e1 e2 e3 v s1 s2.
(evaluate' ck menv cenv s1 env e1 (s2, Rval v) /\
(do_if v e2 e3 = NONE))
==>
evaluate' ck menv cenv s1 env (If e1 e2 e3) (s2, Rerr Rtype_error))

/\ (! ck menv cenv env e1 e2 e3 err s s'.
(evaluate' ck menv cenv s env e1 (s', Rerr err))
==>
evaluate' ck menv cenv s env (If e1 e2 e3) (s', Rerr err))

/\ (! ck menv cenv env e pes v bv s1 s2.
(evaluate' ck menv cenv s1 env e (s2, Rval v) /\
evaluate_match' ck menv cenv s2 env v pes (Conv (SOME (Short "Bind")) []) bv)
==>
evaluate' ck menv cenv s1 env (Mat e pes) bv)

/\ (! ck menv cenv env e pes err s s'.
(evaluate' ck menv cenv s env e (s', Rerr err))
==>
evaluate' ck menv cenv s env (Mat e pes) (s', Rerr err))

/\ (! ck menv cenv env n e1 e2 v bv s1 s2.
(evaluate' ck menv cenv s1 env e1 (s2, Rval v) /\
evaluate' ck menv cenv s2 (bind n v env) e2 bv)
==>
evaluate' ck menv cenv s1 env (Let n e1 e2) bv)

/\ (! ck menv cenv env n e1 e2 err s s'.
(evaluate' ck menv cenv s env e1 (s', Rerr err))
==>
evaluate' ck menv cenv s env (Let n e1 e2) (s', Rerr err))

/\ (! ck menv cenv env funs e bv s.
(ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs) /\
evaluate' ck menv cenv s (build_rec_env funs env env) e bv)
==>
evaluate' ck menv cenv s env (Letrec funs e) bv)

/\ (! ck menv cenv env funs e s.
(~ (ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs)))
==>
evaluate' ck menv cenv s env (Letrec funs e) (s, Rerr Rtype_error))

/\ (! ck menv cenv env s.
T
==>
evaluate_list' ck menv cenv s env [] (s, Rval []))

/\ (! ck menv cenv env e es v vs s1 s2 s3.
(evaluate' ck menv cenv s1 env e (s2, Rval v) /\
evaluate_list' ck menv cenv s2 env es (s3, Rval vs))
==>
evaluate_list' ck menv cenv s1 env (e::es) (s3, Rval (v::vs)))

/\ (! ck menv cenv env e es err s s'.
(evaluate' ck menv cenv s env e (s', Rerr err))
==>
evaluate_list' ck menv cenv s env (e::es) (s', Rerr err))

/\ (! ck menv cenv env e es v err s1 s2 s3.
(evaluate' ck menv cenv s1 env e (s2, Rval v) /\
evaluate_list' ck menv cenv s2 env es (s3, Rerr err))
==>
evaluate_list' ck menv cenv s1 env (e::es) (s3, Rerr err))

/\ (! ck menv cenv env v err_v s.
T
==>
evaluate_match' ck menv cenv s env v [] err_v (s, Rerr (Rraise err_v)))

/\ (! ck menv cenv env v p e pes env' bv err_v s count.
(ALL_DISTINCT (pat_bindings p []) /\
((pmatch cenv s p v env = Match env') /\
evaluate' ck menv cenv (count,s) env' e bv))
==>
evaluate_match' ck menv cenv (count,s) env v ((p,e)::pes) err_v bv)

/\ (! ck menv cenv env v p e pes bv s count err_v.
(ALL_DISTINCT (pat_bindings p []) /\
((pmatch cenv s p v env = No_match) /\
evaluate_match' ck menv cenv (count,s) env v pes err_v bv))
==>
evaluate_match' ck menv cenv (count,s) env v ((p,e)::pes) err_v bv)

/\ (! ck menv cenv env v p e pes s count err_v.
(pmatch cenv s p v env = Match_type_error)
==>
evaluate_match' ck menv cenv (count,s) env v ((p,e)::pes) err_v ((count,s), Rerr Rtype_error))

/\ (! ck menv cenv env v p e pes s err_v.
(~ (ALL_DISTINCT (pat_bindings p [])))
==>
evaluate_match' ck menv cenv s env v ((p,e)::pes) err_v (s, Rerr Rtype_error))`;


val _ = Hol_reln ` (! mn menv cenv env p e v env' s1 s2 count.
(evaluate' F menv cenv ( 0,s1) env e ((count,s2), Rval v) /\
(ALL_DISTINCT (pat_bindings p []) /\
(pmatch cenv s2 p v emp = Match env')))
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rval (emp, env')))

/\ (! mn menv cenv env p e v s1 s2 count.
(evaluate' F menv cenv ( 0,s1) env e ((count,s2), Rval v) /\
(ALL_DISTINCT (pat_bindings p []) /\
(pmatch cenv s2 p v emp = No_match)))
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rerr (Rraise (Conv (SOME (Short "Bind")) []))))

/\ (! mn menv cenv env p e v s1 s2 count.
(evaluate' F menv cenv ( 0,s1) env e ((count,s2), Rval v) /\
(ALL_DISTINCT (pat_bindings p []) /\
(pmatch cenv s2 p v emp = Match_type_error)))
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rerr Rtype_error))

/\ (! mn menv cenv env p e s.
(~ (ALL_DISTINCT (pat_bindings p [])))
==>
evaluate_dec' mn menv cenv s env (Dlet p e) (s, Rerr Rtype_error))

/\ (! mn menv cenv env p e err s count s'.
(evaluate' F menv cenv ( 0,s) env e ((count,s'), Rerr err) /\
ALL_DISTINCT (pat_bindings p []))
==>
evaluate_dec' mn menv cenv s env (Dlet p e) (s', Rerr err))

/\ (! mn menv cenv env funs s.
(ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs))
==>
evaluate_dec' mn menv cenv s env (Dletrec funs) (s, Rval (emp, build_rec_env funs env emp)))

/\ (! mn menv cenv env funs s.
(~ (ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs)))
==>
evaluate_dec' mn menv cenv s env (Dletrec funs) (s, Rerr Rtype_error))

/\ (! mn menv cenv env tds s.
(check_dup_ctors mn cenv tds)
==>
evaluate_dec' mn menv cenv s env (Dtype tds) (s, Rval (build_tdefs mn tds, emp)))

/\ (! mn menv cenv env tds s.
(~ (check_dup_ctors mn cenv tds))
==>
evaluate_dec' mn menv cenv s env (Dtype tds) (s, Rerr Rtype_error))

/\ (! mn menv cenv env cn ts s.
(lookup (mk_id mn cn) cenv = NONE)
==>
evaluate_dec' mn menv cenv s env (Dexn cn ts) (s, Rval (bind (mk_id mn cn) (LENGTH ts, TypeExn) emp, emp)))

/\ (! mn menv cenv env cn ts s.
( ~ ((lookup (mk_id mn cn) cenv) = NONE))
==>
evaluate_dec' mn menv cenv s env (Dexn cn ts) (s, Rerr Rtype_error))`;

val _ = Hol_reln ` (! mn menv cenv s env.
T
==>
evaluate_decs' mn menv cenv s env [] (s, emp, Rval emp))

/\ (! mn menv cenv s1 s2 env d ds e.
(evaluate_dec' mn menv cenv s1 env d (s2, Rerr e))
==>
evaluate_decs' mn menv cenv s1 env (d::ds) (s2, emp, Rerr e))

/\ (! mn menv cenv s1 s2 s3 env d ds new_tds' new_tds new_env r.
(evaluate_dec' mn menv cenv s1 env d (s2, Rval (new_tds,new_env)) /\
evaluate_decs' mn menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, new_tds', r))
==>
evaluate_decs' mn menv cenv s1 env (d::ds) (s3, merge new_tds' new_tds, combine_dec_result new_env r))`;

val _ = Hol_reln ` (! menv cenv s1 s2 env d new_tds new_env.
(evaluate_dec' NONE menv cenv s1 env d (s2, Rval (new_tds, new_env)))
==>
evaluate_top' menv cenv s1 env (Tdec d) (s2, new_tds, Rval (emp, new_env)))

/\ (! menv cenv s1 s2 env d err.
(evaluate_dec' NONE menv cenv s1 env d (s2, Rerr err))
==>
evaluate_top' menv cenv s1 env (Tdec d) (s2, emp, Rerr err))

/\ (! menv cenv s1 s2 env ds mn specs new_tds new_env.
 (~ (MEM mn (MAP FST menv)) /\
evaluate_decs' (SOME mn) menv cenv s1 env ds (s2, new_tds, Rval new_env))
==>
evaluate_top' menv cenv s1 env (Tmod mn specs ds) (s2, new_tds, Rval ([(mn,new_env)], emp)))

/\ (! menv cenv s1 s2 env ds mn specs new_tds err.
 (~ (MEM mn (MAP FST menv)) /\
evaluate_decs' (SOME mn) menv cenv s1 env ds (s2, new_tds, Rerr err))
==>
evaluate_top' menv cenv s1 env (Tmod mn specs ds) (s2, new_tds, Rerr err))

/\ (! menv cenv s env mn specs ds.
(MEM mn (MAP FST menv))
==>
evaluate_top' menv cenv s env (Tmod mn specs ds) (s, emp, Rerr Rtype_error))`;

val _ = Hol_reln ` (! menv cenv s env.
T
==>
evaluate_prog' menv cenv s env [] (s, emp, Rval (emp, emp)))

/\ (! menv cenv s1 s2 s3 env top tops new_mods new_tds new_tds' new_env r.
(evaluate_top' menv cenv s1 env top (s2, new_tds, Rval (new_mods,new_env)) /\
evaluate_prog' (merge new_mods menv) (merge new_tds cenv) s2 (merge new_env env) tops (s3, new_tds', r))
==>
evaluate_prog' menv cenv s1 env (top::tops) (s3, merge new_tds' new_tds, combine_mod_result new_mods new_env r))

/\ (! menv cenv s1 s2 env top tops err new_tds.
(evaluate_top' menv cenv s1 env top (s2, new_tds, Rerr err))
==>
evaluate_prog' menv cenv s1 env (top::tops) (s2, new_tds, Rerr err))`;
val _ = export_theory()

