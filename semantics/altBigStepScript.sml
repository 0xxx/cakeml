(*Generated by Lem from altBigStep.lem.*)
open HolKernel Parse boolLib bossLib;
open pervasives_extraTheory libTheory astTheory semanticPrimitivesTheory;

val _ = numLib.prefer_num();



val _ = new_theory "altBigStep"

(*open import Pervasives_extra*)
(*open import Lib*)
(*open import Ast*) 
(*open import SemanticPrimitives*)

(* A version of the big-step expression semantics that doesn't use the
 * constructor environment to know if a value is ok or not.  It also has no
 * module environment. Is equivalent to the normal one for well-typed programs
 * that don't contain module references. *)

(*val pmatch' : store -> pat -> v -> envE -> match_result*)
 val pmatch'_defn = Hol_defn "pmatch'" `

(pmatch' s (Pvar n) v' env = (Match (bind n v' env)))
/\
(pmatch' s (Plit l) (Litv l') env =  
(if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error))
/\
(pmatch' s (Pcon cn ps) (Conv cn' vs) env =  
(if ((LENGTH ps) = (LENGTH vs)) /\ (cn = cn') then
    pmatch_list' s ps vs env
  else
    No_match))
/\
(pmatch' s (Pref p) (Loc lnum) env =  
((case store_lookup lnum s of
      (SOME v) => pmatch' s p v env
    | (NONE) => Match_type_error
  )))
/\
(pmatch' _ _ _ env = Match_type_error)
/\
(pmatch_list' s [] [] env = (Match env))
/\
(pmatch_list' s (p::ps) (v::vs) env =  
((case pmatch' s p v env of
      No_match => No_match
    | Match_type_error => Match_type_error
    | Match env' => pmatch_list' s ps vs env'
  )))
/\
(pmatch_list' _ _ _ env = Match_type_error)`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn pmatch'_defn;


val _ = Hol_reln ` evaluate' : envM -> store -> envE -> exp -> store # v result -> bool 
/\ evaluate_list' : envM -> store -> envE -> exp list -> store # ( v list) result -> bool
/\ evaluate_match' : envM -> store -> envE -> v -> (pat # exp) list -> v -> store # v result -> bool (! env l s.
T
==>
evaluate' s env (Lit l) (s, Rval (Litv l)))

/\ (! env e s1 s2 v.
(evaluate' s1 env e (s2, Rval v))
==>
evaluate' s1 env (Raise e) (s2, Rerr (Rraise v)))

/\ (! env e s1 s2 err.
(evaluate' s1 env e (s2, Rerr err))
==>
evaluate' s1 env (Raise e) (s2, Rerr err))

/\ (! s1 s2 env e v pes.
(evaluate' s1 env e (s2, Rval v))
==>
evaluate' s1 env (Handle e pes) (s2, Rval v))

/\ (! s1 s2 env e pes v bv.
(evaluate' s1 env e (s2, Rerr (Rraise v)) /\
evaluate_match' s2 env v pes v bv)
==>
evaluate' s1 env (Handle e pes) bv)

/\ (! s1 s2 env e pes err.
(evaluate' s1 env e (s2, Rerr err) /\
((err = Rtimeout_error) \/ (err = Rtype_error)))
==>
evaluate' s1 env (Handle e pes) (s2, Rerr err))

/\ (! env cn es vs s1 s2.
(evaluate_list' s1 env es (s2, Rval vs))
==>
evaluate' s1 env (Con cn es) (s2, Rval (Conv cn vs)))

/\ (! env cn es err s s'.
(evaluate_list' s env es (s', Rerr err))
==>
evaluate' s env (Con cn es) (s', Rerr err))

/\ (! env n v s.
(lookup instance_Basic_classes_Eq_var_dict n env = (SOME v))
==>
evaluate' s env (Var (Short n)) (s, Rval v))

/\ (! env n s.
(lookup instance_Basic_classes_Eq_var_dict n env = (NONE))
==>
evaluate' s env (Var (Short n)) (s, Rerr Rtype_error))

/\ (! env n e s.
T
==>
evaluate' s env (Fun n e) (s, Rval (Closure env n e)))

/\ (! env uop e v v' s1 s2 s3.
(evaluate' s1 env e (s2, Rval v) /\
(do_uapp s2 uop v = (SOME (s3,v'))))
==>
evaluate' s1 env (Uapp uop e) (s3, Rval v'))

/\ (! env uop e v s1 s2.
(evaluate' s1 env e (s2, Rval v) /\
(do_uapp s2 uop v = (NONE)))
==>
evaluate' s1 env (Uapp uop e) (s2, Rerr Rtype_error))

/\ (! env uop e err s s'.
(evaluate' s env e (s', Rerr err))
==>
evaluate' s env (Uapp uop e) (s', Rerr err))

/\ (! env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 s4.
(evaluate' s1 env e1 (s2, Rval v1) /\
(evaluate' s2 env e2 (s3, Rval v2) /\
((do_app s3 env op v1 v2 = (SOME (s4, env', e3))) /\
evaluate' s4 env' e3 bv)))
==>
evaluate' s1 env (App op e1 e2) bv)

/\ (! env op e1 e2 v1 v2 s1 s2 s3.
(evaluate' s1 env e1 (s2, Rval v1) /\
(evaluate' s2 env e2 (s3, Rval v2) /\
(do_app s3 env op v1 v2 = (NONE))))
==>
evaluate' s1 env (App op e1 e2) (s3, Rerr Rtype_error))

/\ (! env op e1 e2 v1 err s1 s2 s3.
(evaluate' s1 env e1 (s2, Rval v1) /\
evaluate' s2 env e2 (s3, Rerr err))
==>
evaluate' s1 env (App op e1 e2) (s3, Rerr err))

/\ (! env op e1 e2 err s s'.
(evaluate' s env e1 (s', Rerr err))
==>
evaluate' s env (App op e1 e2) (s', Rerr err))

/\ (! env op e1 e2 v e' bv s1 s2.
(evaluate' s1 env e1 (s2, Rval v) /\
((do_log op v e2 = (SOME e')) /\
evaluate' s2 env e' bv))
==>
evaluate' s1 env (Log op e1 e2) bv)

/\ (! env op e1 e2 v s1 s2.
(evaluate' s1 env e1 (s2, Rval v) /\
(do_log op v e2 = (NONE)))
==>
evaluate' s1 env (Log op e1 e2) (s2, Rerr Rtype_error))

/\ (! env op e1 e2 err s s'.
(evaluate' s env e1 (s', Rerr err))
==>
evaluate' s env (Log op e1 e2) (s', Rerr err))

/\ (! env e1 e2 e3 v e' bv s1 s2.
(evaluate' s1 env e1 (s2, Rval v) /\
((do_if v e2 e3 = (SOME e')) /\
evaluate' s2 env e' bv))
==>
evaluate' s1 env (If e1 e2 e3) bv)

/\ (! env e1 e2 e3 v s1 s2.
(evaluate' s1 env e1 (s2, Rval v) /\
(do_if v e2 e3 = (NONE)))
==>
evaluate' s1 env (If e1 e2 e3) (s2, Rerr Rtype_error))

/\ (! env e1 e2 e3 err s s'.
(evaluate' s env e1 (s', Rerr err))
==>
evaluate' s env (If e1 e2 e3) (s', Rerr err))

/\ (! env e pes v bv s1 s2.
(evaluate' s1 env e (s2, Rval v) /\
evaluate_match' s2 env v pes (Conv ((SOME (Short "Bind"))) []) bv)
==>
evaluate' s1 env (Mat e pes) bv)

/\ (! env e pes err s s'.
(evaluate' s env e (s', Rerr err))
==>
evaluate' s env (Mat e pes) (s', Rerr err))

/\ (! env n e1 e2 v bv s1 s2.
(evaluate' s1 env e1 (s2, Rval v) /\
evaluate' s2 (bind n v env) e2 bv)
==>
evaluate' s1 env (Let n e1 e2) bv)

/\ (! env n e1 e2 err s s'.
(evaluate' s env e1 (s', Rerr err))
==>
evaluate' s env (Let n e1 e2) (s', Rerr err))

/\ (! env funs e bv s.
((ALL_DISTINCT ((MAP (\ (x,y,z) . x) funs))) /\
evaluate' s (build_rec_env funs env env) e bv)
==>
evaluate' s env (Letrec funs e) bv)

/\ (! env funs e s.
((~ ((ALL_DISTINCT ((MAP (\ (x,y,z) . x) funs))))))
==>
evaluate' s env (Letrec funs e) (s, Rerr Rtype_error))

/\ (! env s.
T
==>
evaluate_list' s env [] (s, Rval []))

/\ (! env e es v vs s1 s2 s3.
(evaluate' s1 env e (s2, Rval v) /\
evaluate_list' s2 env es (s3, Rval vs))
==>
evaluate_list' s1 env (e::es) (s3, Rval (v::vs)))

/\ (! env e es err s s'.
(evaluate' s env e (s', Rerr err))
==>
evaluate_list' s env (e::es) (s', Rerr err))

/\ (! env e es v err s1 s2 s3.
(evaluate' s1 env e (s2, Rval v) /\
evaluate_list' s2 env es (s3, Rerr err))
==>
evaluate_list' s1 env (e::es) (s3, Rerr err))

/\ (! env v s err_v.
T
==>
evaluate_match' s env v [] err_v (s, Rerr (Rraise err_v)))

/\ (! env v p e pes env' bv s err_v.
((ALL_DISTINCT (pat_bindings p [])) /\
((pmatch' s p v env = Match env') /\
evaluate' s env' e bv))
==>
evaluate_match' s env v ((p,e)::pes) err_v bv)

/\ (! env v p e pes bv s err_v.
((ALL_DISTINCT (pat_bindings p [])) /\
((pmatch' s p v env = No_match) /\
evaluate_match' s env v pes err_v bv))
==>
evaluate_match' s env v ((p,e)::pes) err_v bv)

/\ (! env v p e pes s err_v.
(pmatch' s p v env = Match_type_error)
==>
evaluate_match' s env v ((p,e)::pes) err_v (s, Rerr Rtype_error))

/\ (! env v p e pes s err_v.
((~ ((ALL_DISTINCT (pat_bindings p [])))))
==>
evaluate_match' s env v ((p,e)::pes) err_v (s, Rerr Rtype_error))`;

val _ = Hol_reln ` evaluate_dec' :  modN option -> envM -> envC -> store -> envE -> dec -> store # (envC # envE) result -> bool (! mn menv cenv env p e v env' s1 s2.
(evaluate' s1 env e (s2, Rval v) /\
((ALL_DISTINCT (pat_bindings p [])) /\
(pmatch' s2 p v emp = Match env')))
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rval (emp, env')))

/\ (! mn menv cenv env p e v s1 s2.
(evaluate' s1 env e (s2, Rval v) /\
((ALL_DISTINCT (pat_bindings p [])) /\
(pmatch' s2 p v emp = No_match)))
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rerr (Rraise (Conv ((SOME (Short "Bind"))) []))))

/\ (! mn menv cenv env p e v s1 s2.
(evaluate' s1 env e (s2, Rval v) /\
((ALL_DISTINCT (pat_bindings p [])) /\
(pmatch' s2 p v emp = Match_type_error)))
==>
evaluate_dec' mn menv cenv s1 env (Dlet p e) (s2, Rerr Rtype_error))

/\ (! mn menv cenv env p e s.
((~ ((ALL_DISTINCT (pat_bindings p [])))))
==>
evaluate_dec' mn (menv:envM) (cenv:envC) s env (Dlet p e) (s, Rerr Rtype_error))

/\ (! mn menv cenv env p e err s s'.
(evaluate' s env e (s', Rerr err) /\
(ALL_DISTINCT (pat_bindings p [])))
==>
evaluate_dec' mn menv cenv s env (Dlet p e) (s', Rerr err))

/\ (! mn menv cenv env funs s.
((ALL_DISTINCT ((MAP (\ (x,y,z) . x) funs))))
==>
evaluate_dec' mn menv cenv s env (Dletrec funs) (s, Rval (emp, build_rec_env funs env emp)))

/\ (! mn menv cenv env funs s.
((~ ((ALL_DISTINCT ((MAP (\ (x,y,z) . x) funs))))))
==>
evaluate_dec' mn menv cenv s env (Dletrec funs) (s, Rerr Rtype_error))

/\ (! mn menv cenv env tds s.
(check_dup_ctors (instance_Basic_classes_Eq_tup_dict instance_Basic_classes_Eq_nat_dict
   instance_Basic_classes_Eq_var_dict) mn cenv tds)
==>
evaluate_dec' mn menv cenv s env (Dtype tds) (s, Rval (build_tdefs mn tds, emp)))

/\ (! mn menv cenv env tds s.
((~ (check_dup_ctors (instance_Basic_classes_Eq_tup_dict instance_Basic_classes_Eq_nat_dict
   instance_Basic_classes_Eq_var_dict) mn cenv tds)))
==>
evaluate_dec' mn menv cenv s env (Dtype tds) (s, Rerr Rtype_error))

/\ (! mn menv cenv env cn ts s.
(lookup instance_Basic_classes_Eq_var_dict (mk_id mn cn) cenv = (NONE))
==>
evaluate_dec' mn menv cenv s env (Dexn cn ts) (s, Rval (bind (mk_id mn cn) ((LENGTH ts), TypeExn) emp, emp)))

/\ (! mn menv cenv env cn ts s.
( (~ (lookup instance_Basic_classes_Eq_var_dict (mk_id mn cn) cenv =  (NONE))))
==>
evaluate_dec' mn menv cenv s env (Dexn cn ts) (s, Rerr Rtype_error))`;


val _ = Hol_reln ` evaluate_decs' :  modN option -> envM -> envC -> store -> envE -> dec list -> store # envC # envE result -> bool (! mn menv cenv s env.
T
==>
evaluate_decs' mn menv cenv s env [] (s, emp, Rval emp))

/\ (! mn menv cenv s1 s2 env d ds e.
(evaluate_dec' mn menv cenv s1 env d (s2, Rerr e))
==>
evaluate_decs' mn menv cenv s1 env (d::ds) (s2, emp, Rerr e))

/\ (! mn menv cenv s1 s2 s3 env d ds new_tds' new_tds new_env r.
(evaluate_dec' mn menv cenv s1 env d (s2, Rval (new_tds,new_env)) /\
evaluate_decs' mn menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, new_tds', r))
==>
evaluate_decs' mn menv cenv s1 env (d::ds) (s3, merge new_tds' new_tds, combine_dec_result new_env r))`;

val _ = Hol_reln ` evaluate_top' : envM -> envC -> store -> envE -> top -> store # envC # (envM # envE) result -> bool (! menv cenv s1 s2 env d new_tds new_env.
(evaluate_dec' (NONE) menv cenv s1 env d (s2, Rval (new_tds, new_env)))
==>
evaluate_top' menv cenv s1 env (Tdec d) (s2, new_tds, Rval (emp, new_env)))

/\ (! menv cenv s1 s2 env d err.
(evaluate_dec' (NONE) menv cenv s1 env d (s2, Rerr err))
==>
evaluate_top' menv cenv s1 env (Tdec d) (s2, emp, Rerr err))

/\ (! menv cenv s1 s2 env ds mn specs new_tds new_env.
 ((~ ((MEM mn ((MAP (FST) menv))))) /\
evaluate_decs' ((SOME mn)) menv cenv s1 env ds (s2, new_tds, Rval new_env))
==>
evaluate_top' menv cenv s1 env (Tmod mn specs ds) (s2, new_tds, Rval ([(mn,new_env)], emp)))

/\ (! menv cenv s1 s2 env ds mn specs new_tds err.
 ((~ ((MEM mn ((MAP (FST) menv))))) /\
evaluate_decs' ((SOME mn)) menv cenv s1 env ds (s2, new_tds, Rerr err))
==>
evaluate_top' menv cenv s1 env (Tmod mn specs ds) (s2, new_tds, Rerr err))

/\ (! menv cenv s env mn specs ds.
((MEM mn ((MAP (FST) menv))))
==>
evaluate_top' menv cenv s env (Tmod mn specs ds) (s, emp, Rerr Rtype_error))`;

val _ = Hol_reln ` evaluate_prog' : envM -> envC -> store -> envE -> prog -> store # envC # (envM # envE) result -> bool (! menv cenv s env.
T
==>
evaluate_prog' menv cenv s env [] (s, emp, Rval (emp, emp)))

/\ (! menv cenv s1 s2 s3 env top tops new_mods new_tds new_tds' new_env r.
(evaluate_top' menv cenv s1 env top (s2, new_tds, Rval (new_mods,new_env)) /\
evaluate_prog' (merge new_mods menv) (merge new_tds cenv) s2 (merge new_env env) tops (s3, new_tds', r))
==>
evaluate_prog' menv cenv s1 env (top::tops) (s3, merge new_tds' new_tds, combine_mod_result new_mods new_env r))

/\ (! menv cenv s1 s2 env top tops err new_tds.
(evaluate_top' menv cenv s1 env top (s2, new_tds, Rerr err))
==>
evaluate_prog' menv cenv s1 env (top::tops) (s2, new_tds, Rerr err))`;


val _ = export_theory()

