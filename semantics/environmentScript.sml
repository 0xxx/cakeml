(*Generated by Lem from environment.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory astTheory;

val _ = numLib.prefer_num();



val _ = new_theory "environment"

(*open import Pervasives*)
(*open import Ast*)

val _ = type_abbrev((* ( 'k, 'v) *) "alist" , ``: ('k # 'v) list``);

val _ = Hol_datatype `
 environment =
  Bind of ('n, 'v) alist => (modN, (environment)) alist`;


(*val elookup : forall 'v 'n. Eq 'n => environment 'n 'v -> id 'n -> maybe 'v*)
 val elookup_defn = Hol_defn "elookup" `
 (elookup (Bind v m) (Short n) = (ALOOKUP v n))
    /\ (elookup (Bind v m) (Long mn id) =      
((case ALOOKUP m mn of
        NONE => NONE
      | SOME env => elookup env id
      )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn elookup_defn;

(*val eempty : forall 'v 'n. environment 'n 'v*)
val _ = Define `
 (eempty = (Bind [] []))`;


(*val emerge : forall 'v 'n. environment 'n 'v -> environment 'n 'v -> environment 'n 'v*)
val _ = Define `
 (emerge (Bind v1 m1) (Bind v2 m2) = (Bind (v1 ++ v2) (m1 ++ m2)))`;


(*val elift : forall 'v 'n. modN -> environment 'n 'v -> environment 'n 'v*)
val _ = Define `
 (elift mn env = (Bind [] [(mn, env)]))`;


(*val alist_to_env : forall 'v 'n. alist 'n 'v -> environment 'n 'v*)
val _ = Define `
 (alist_to_env a = (Bind a []))`;


(*val ebind : forall 'v 'n. 'n -> 'v -> environment 'n 'v -> environment 'n 'v*)
val _ = Define `
 (ebind k x (Bind v m) = (Bind ((k,x)::v) m))`;


(*val eoptbind : forall 'v 'n. maybe 'n -> 'v -> environment 'n 'v -> environment 'n 'v*)
val _ = Define `
 (eoptbind n x env =  
((case n of
    NONE => env
  | SOME n' => ebind n' x env
  )))`;

val _ = export_theory()

