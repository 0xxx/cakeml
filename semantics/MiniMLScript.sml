(*Generated by Lem from semantics/miniML.lem.*)
open bossLib Theory Parse res_quanTheory
open finite_mapTheory listTheory pairTheory pred_setTheory integerTheory
open set_relationTheory sortingTheory stringTheory wordsTheory

val _ = new_theory "MiniML"

open TokensTheory

(* By Scott Owens, University of Cambridge, Copyright 2011, 2012
 *                 University of Kent 2012
 *
 * MiniML is my idea of a simple ML-like language that is convenient to program
 * in.  It has no handled exceptions, no modules, no type abbreviations, or
 * records.  It does have mutually recursive datatypes (at the top-level only)
 * and functions, as well as higher-order functions.  It also supports pattern
 * matching for nested patterns (which can fail due to non-exhaustive patterns).
 * Polymorphism is limited to top-level definitions.  Only booleans and number
 * types are built-in.  Syntactic sugar is generally omitted.
 *
 * In some ways it makes more sense to write these kind of semantics in Ott (to
 * get a presentation that looks like ML concrete-syntax-wise, and that has the
 * usual syntax for type systems and operational semantics, i.e., with |- and
 * horizontal lines).  Here in Lem, everything looks like abstract syntax;
 * however, unlike Ott, we get good support for functions, and not just
 * relations.
 *
 * The small-step operational semantics is based on the CEK machine.  The type
 * system is typical.  The big step semantics is also typical.  The small-step
 * and big-step semantics agree even on untyped programs. *)

(*val i : num -> Int.int*)

(*val all_distinct : forall 'a. list 'a -> bool*)

(*val rtc : forall 'a. ('a -> 'a -> bool) -> ('a -> 'a -> bool)*)

(*val LUPDATE : forall 'a. num -> 'a -> list 'a -> list 'a*)

(* Environments *)
val _ = type_abbrev((* ( 'a, 'b) *) "env" , ``: ('a#'b) list``);

(*val emp : forall 'a 'b. env 'a 'b*)
val _ = Define `
 emp = []`;


(*val lookup : forall 'a 'b. 'a -> env 'a 'b -> option 'b*)
 val lookup_defn = Hol_defn "lookup" `

(lookup n [] = NONE)
/\
(lookup n ((n',v)::e) =
  if n' = n then(
    SOME v)
  else((
    lookup n) e))`;

val _ = Defn.save_defn lookup_defn;

(*val bind : forall 'a 'b. 'a -> 'b -> env 'a 'b -> env 'a 'b*)
val _ = Define `
 (bind n v e = (n,v)::e)`;


(*val merge : forall 'a 'b. env 'a 'b -> env 'a 'b -> env 'a 'b*)
val _ = Define `
 (merge e1 e2 = e1 ++ e2)`;


(* Literal constants *)
val _ = Hol_datatype `
 lit =
    IntLit of int
  | Bool of bool
  | Unit`;


(* Built-in binary operations (including function application) *)

val _ = Hol_datatype `
 opn = Plus | Minus | Times | Divide | Modulo`;

val _ = Hol_datatype `
 opb = Lt | Gt | Leq | Geq`;


val _ = Define `
 (opn_lookup n = (case n of
    Plus => int_add
  | Minus => (int_sub)
  | Times => int_mul
  | Divide => int_div
  | Modulo => int_mod
))`;


val _ = Define `
 (opb_lookup n : int -> int -> bool = (case n of
    Lt => int_lt
  | Gt => int_gt
  | Leq => int_le
  | Geq => int_ge
))`;


val _ = Hol_datatype `
 op =
    Opn of opn
  | Opb of opb
  | Equality
  | Opapp
  | Opassign`;


val _ = Hol_datatype `
 uop =
    Ref
  | Deref`;


(* Built-in logical operations *)
val _ = Hol_datatype `
 log =
    And
  | Or`;


(* Variable names *)
val _ = type_abbrev( "varN" , ``: string``);
(* Constructor names (from datatype definitions) *)
val _ = type_abbrev( "conN" , ``: string``);
(* Type names *)
val _ = type_abbrev( "typeN" , ``: string``);
(* Type variable names *)
val _ = type_abbrev( "tvarN" , ``: string``);

(* Types
 * 0-ary type applications represent unparameterised types (e.g., num or string)
 *)
val _ = Hol_datatype `
 t =
    Tvar of tvarN
  (* DeBruin indexed type variables. *)
  | Tvar_db of num
  | Tapp of t list => typeN
  | Tfn of t => t
  | Tnum
  | Tbool
  | Tref of t
  | Tunit`;


(* Patterns *)
val _ = Hol_datatype `
 pat =
    Pvar of varN
  | Plit of lit
  (* Constructor applications. *)
  | Pcon of conN => pat list
  | Pref of pat`;


(* Runtime errors *)
val _ = Hol_datatype `
 error =
    Bind_error
  | Div_error`;


(* Expressions *)
val _ = Hol_datatype `
 exp =
    Raise of error
  | Lit of lit
  (* Constructor application. *)
  | Con of conN => exp list
  | Var of varN
  | Fun of varN => exp
  (* Application of a unary operator *)
  | Uapp of uop => exp
  (* Application of an operator (including function application) *)
  | App of op => exp => exp
  (* Logical operations (and, or) *)
  | Log of log => exp => exp
  | If of exp => exp => exp
  (* Pattern matching *)
  | Mat of exp => (pat # exp) list
  | Let of varN => exp => exp
  (* Local definition of (potentially) mutually recursive functions
   * The first varN is the function's name, and the second varN is its
   * parameter *)
  | Letrec of (varN # varN # exp) list => exp`;


(* Value forms *)
val _ = Hol_datatype `
 v =
    Litv of lit
  (* Constructor application. *) 
  | Conv of conN => v list
  (* Function closures
     The environment is used for the free variables in the function *)
  | Closure of (varN, v) env => varN => exp
  (* Function closure for recursive functions
   * See Closure and Letrec above
   * The last variable name indicates which function from the mutually
   * recursive bundle this closure value represents *)
  | Recclosure of (varN, v) env => (varN # varN # exp) list => varN
  | Loc of num`;


(* Environments *)
val _ = type_abbrev( "envE" , ``: (varN, v) env``);

(* Stores *)
(* Keep the next number to allocate, so that we can be deterministic *)
val _ = type_abbrev( "store" , ``: v list``);

(*val empty_store : store*)
val _ = Define `
 empty_store = []`;


(*val store_lookup : num -> store -> option v*)
val _ = Define `
 (store_lookup l st =
  if l <( LENGTH st) then(
    SOME (((EL  l)  st)))
  else
    NONE)`;


(*val store_alloc : v -> store -> store * num*)
val _ = Define `
 (store_alloc v st =
  (st ++ [v],( LENGTH st)))`;


(*val store_assign : num -> v -> store -> store*)
 val store_assign_defn = Hol_defn "store_assign" `
 (store_assign n v st =(((
  LUPDATE n) v) st))`;

val _ = Defn.save_defn store_assign_defn;

(* Declarations *)
val _ = Hol_datatype `
 dec =
  (* Top-level bindings
     The pattern allows several names to be bound at once *)
    Dlet of pat => exp
  (* Mutually recursive function definition *)
  | Dletrec of (varN # varN # exp) list
  (* Type definition
     Defines several types, each of which has several named variants, which can
     in turn have several arguments *)
  | Dtype of ( tvarN list # typeN # (conN # t list) list) list`;


val _ = type_abbrev( "decs" , ``: dec list``);

(* Maps each constructor to its arity and the set of all constructors of that
 * type *)
val _ = type_abbrev( "envC" , ``: (conN, (num # conN set)) env``);

(* Evaluation contexts
 * The hole is denoted by the unit type
 * The env argument contins bindings for the free variables of expressions in
     the context *)
val _ = Hol_datatype `
 ctxt_frame =
    Capp1 of op => unit => exp
  | Capp2 of op => v => unit
  | Clog of log => unit => exp
  | Cif of unit => exp => exp
  | Cmat of unit => (pat # exp) list
  | Clet of varN => unit => exp
  (* Evaluating a constructor's arguments
   * The v list should be in reverse order. *)
  | Ccon of conN => v list => unit => exp list
  | Cuapp of uop => unit`;

val _ = type_abbrev( "ctxt" , ``: ctxt_frame # envE``);

(*val lit_same_type : lit -> lit -> bool*)
val _ = Define `
 (lit_same_type l1 l2 =
  (case (l1,l2) of
      (IntLit _, IntLit _) => T
    | (Bool _, Bool _) => T
    | (Unit, Unit) => T
    | _ => F
  ))`;


val _ = Hol_datatype `
 match_result =
    No_match
  | Match_type_error
  | Match of envE`;


(* A big-step pattern matcher.  If the value
 * matches the pattern, return an environment with the pattern variables bound
 * to the corresponding sub-terms of the value; this environment extends the
 * environment given as an argument.  No_match is returned when there is no
 * match, but any constructors encountered in determining the match failure are
 * applied to the correct number of arguments, and constructors in
 * corresponding positions in the pattern and value come from the same type.
 * Match_type_error is returned when one of these conditions is violated *)

(*val pmatch : envC -> store -> pat -> v -> envE -> match_result*)
 val pmatch_defn = Hol_defn "pmatch" `

(pmatch envC s (Pvar n) v' env =( Match ((((bind n) v') env))))
/\
(pmatch envC s (Plit l) (Litv l') env =
  if l = l' then(
    Match env)
  else if(( lit_same_type l) l') then
    No_match
  else
    Match_type_error)
/\
(pmatch envC s (Pcon n ps) (Conv n' vs) env =
  (case (((lookup n) envC),(( lookup n') envC)) of
      (SOME (l, ns), SOME (l', ns')) =>
        if n IN ns' /\ n' IN ns /\ ((LENGTH ps) = l) /\ ((LENGTH vs) = l')
        then
          if n = n' then(((((
            pmatch_list envC) s) ps) vs) env)
          else
            No_match
        else
          Match_type_error
    | (_, _) => Match_type_error
  ))
/\
(pmatch envC s (Pref p) (Loc lnum) env =
  (case(( store_lookup lnum) s) of
      SOME v =>((((( pmatch envC) s) p) v) env)
    | NONE => Match_type_error
  ))
/\
(pmatch envC _ _ _ env = Match_type_error)
/\
(pmatch_list envC s [] [] env =( Match env))
/\
(pmatch_list envC s (p::ps) (v::vs) env =
  (case((((( pmatch envC) s) p) v) env) of
      No_match => No_match
    | Match_type_error => Match_type_error
    | Match env' =>((((( pmatch_list envC) s) ps) vs) env')
  ))
/\
(pmatch_list envC s _ _ env = Match_type_error)`;

val _ = Defn.save_defn pmatch_defn;

(* Accumulates the bindings of a patterns *)
(*val pat_bindings : pat -> list varN -> list varN*)
 val pat_bindings_defn = Hol_defn "pat_bindings" `

(pat_bindings (Pvar n) already_bound =
  n::already_bound)
/\
(pat_bindings (Plit l) already_bound = 
  already_bound)
/\
(pat_bindings (Pcon _ ps) already_bound =((
  pats_bindings ps) already_bound))
/\
(pat_bindings (Pref p) already_bound =(( 
  pat_bindings p) already_bound))
/\
(pats_bindings [] already_bound =
  already_bound)
/\
(pats_bindings (p::ps) already_bound =((
  pats_bindings ps) (((pat_bindings p) already_bound))))`;

val _ = Defn.save_defn pat_bindings_defn;

(* State for CEK-style expression evaluation
 * - constructor data
 * - the environment for the free variables of the current expression
 * - the current expression to evaluate, or a value if finished
 * - the context stack (continuation) of what to do once the current expression
 *   is finished.  Each entry has an environment for it's free variables *)
val _ = Hol_datatype `
 exp_or_val =
    Exp of exp
  | Val of v`;


val _ = type_abbrev( "state" , ``: envC # store # envE # exp_or_val # ctxt list``);

val _ = Hol_datatype `
 e_step_result =
    Estep of state
  | Etype_error
  | Estuck`;


(* The semantics are deterministic, and presented functionally instead of
 * relationally for proof rather that readability; the steps are very small: we
 * push individual frames onto the context stack instead of finding a redex in a
 * single step *)

(*val push : envC -> store -> envE -> exp -> ctxt_frame -> list ctxt -> e_step_result*)
val _ = Define `
 (push envC s env e c' cs =( Estep (envC, s, env,( Exp e), (c',env)::cs)))`;


(*val return : envC -> store -> envE -> v -> list ctxt -> e_step_result*)
val _ = Define `
 (return envC s env v c =( Estep (envC, s, env,( Val v), c)))`;


(* Bind each function of a mutually recursive set of functions to its closure *)
(*val build_rec_env : list (varN * varN * exp) -> envE -> envE*)
 val build_rec_env_defn = Hol_defn "build_rec_env" `
 (build_rec_env funs env =(((
  FOLDR 
    (\ (f,x,e) env' .((( bind f) ((((Recclosure env) funs) f))) env'))) 
    env) 
    funs))`;

val _ = Defn.save_defn build_rec_env_defn;

(* Lookup in the list of mutually recursive functions *)
(*val find_recfun : varN -> list (varN * varN * exp) -> option (varN * exp)*)
 val find_recfun_defn = Hol_defn "find_recfun" `
 (find_recfun n funs =
  (case funs of
      [] => NONE
    | (f,x,e) :: funs =>
        if f = n then(
          SOME (x,e))
        else((
          find_recfun n) funs)
  ))`;

val _ = Defn.save_defn find_recfun_defn;

(* Do an application *)
(*val do_app : store -> envE -> op -> v -> v -> option (store * envE * exp)*)
val _ = Define `
 (do_app s env' op v1 v2 =
  (case (op, v1, v2) of
      (Opapp, Closure env n e, v) =>(
        SOME (s,((( bind n) v) env), e))
    | (Opapp, Recclosure env funs n, v) =>
        (case(( find_recfun n) funs) of
            SOME (n,e) =>( SOME (s,((( bind n) v) (((build_rec_env funs) env))), e))
          | NONE => NONE
        )
    | (Opn op, Litv (IntLit n1), Litv (IntLit n2)) =>
        if ((op = Divide) \/ (op = Modulo)) /\ (n2 =( & 0)) then(
          SOME (s, env',( Raise Div_error)))
        else(
          SOME (s, env',(Lit ((IntLit ((((opn_lookup op) n1) n2)))))))
    | (Opb op, Litv (IntLit n1), Litv (IntLit n2)) =>(
        SOME (s, env',( Lit ((Bool ((((opb_lookup op) n1) n2)))))))
    | (Equality, v1, v2) =>(
        (* TODO: Check for closures in v1 and v2, and possibly check that they
         * have the same type *)
        SOME (s, env',( Lit ((Bool (v1 = v2))))))
    | (Opassign, (Loc lnum), v) =>(
        SOME ((((store_assign lnum) v) s), env',( Lit Unit))) 
    | _ => NONE
  ))`;


(* Do a logical operation *)
(*val do_log : log -> v -> exp -> option exp*)
val _ = Define `
 (do_log l v e =
  (case (l, v) of
      (And, Litv (Bool T)) =>( SOME e)
    | (Or, Litv (Bool F)) =>( SOME e)
    | (_, Litv (Bool b)) =>( SOME ((Lit ((Bool b)))))
    | _ => NONE
  ))`;


(* Do an if-then-else *)
(*val do_if : v -> exp -> exp -> option exp*)
val _ = Define `
 (do_if v e1 e2 =
  if v =( Litv ((Bool T))) then(
    SOME e1)
  else if v =( Litv ((Bool F))) then(
    SOME e2)
  else
    NONE)`;


(* Check that a constructor is properly applied *)
(*val do_con_check : envC -> conN -> num -> bool*)
val _ = Define `
 (do_con_check envC n l =
  (case(( lookup n) envC) of
      NONE => F
    | SOME (l',ns) => l = l'
  ))`;


(*val do_uapp : store -> uop -> v -> option (store * v)*)
val _ = Define `
 (do_uapp s uop v =
  (case uop of
      Deref =>
        (case v of
            Loc n =>
              (case(( store_lookup n) s) of
                  SOME v =>( SOME (s,v))
                | NONE => NONE
              )
          | _ => NONE
        )
    | Ref =>
        let (s',n) =(( store_alloc v) s) in(
          SOME (s',( Loc n)))
  ))`;


(* apply a context to a value *)
(*val continue : envC -> store -> v -> list ctxt -> e_step_result*)
val _ = Define `
 (continue envC s v cs =
  (case cs of
      [] => Estuck
    | (Capp1 op () e, env) :: c =>((((((
        push envC) s) env) e) ((((Capp2 op) v) ()))) c)
    | (Capp2 op v' (), env) :: c =>
        (case((((( do_app s) env) op) v') v) of
            SOME (s',env,e) =>( Estep (envC, s', env,( Exp e), c))
          | NONE => Etype_error
        )
    | (Clog l () e, env) :: c =>
        (case((( do_log l) v) e) of
            SOME e =>( Estep (envC, s, env,( Exp e), c))
          | NONE => Etype_error
        )
    | (Cif () e1 e2, env) :: c =>
        (case((( do_if v) e1) e2) of
            SOME e =>( Estep (envC, s, env,( Exp e), c))
          | NONE => Etype_error
        )
    | (Cmat () [], env) :: c =>(
        Estep (envC, s, env,( Exp ((Raise Bind_error))), c))
    | (Cmat () ((p,e)::pes), env) :: c =>
        if( ALL_DISTINCT (((pat_bindings p) []))) then
          (case((((( pmatch envC) s) p) v) env) of
              Match_type_error => Etype_error
            | No_match =>( Estep (envC, s, env,( Val v), (((Cmat ()) pes),env)::c))
            | Match env' =>( Estep (envC, s, env',( Exp e), c))
          )
        else
          Etype_error
    | (Clet n () e, env) :: c =>(
        Estep (envC, s,((( bind n) v) env),( Exp e), c))
    | (Ccon n vs () [], env) :: c =>
        if((( do_con_check envC) n) ((LENGTH vs) + 1)) then(((((
          return envC) s) env) (((Conv n) ((REVERSE (v::vs)))))) c)
        else
          Etype_error
    | (Ccon n vs () (e::es), env) :: c =>
        if((( do_con_check envC) n) ((LENGTH vs) + 1 + 1 +( LENGTH es))) then((((((
          push envC) s) env) e) (((((Ccon n) (v::vs)) ()) es))) c)
        else
          Etype_error
    | (Cuapp uop (), env) :: c =>
       (case((( do_uapp s) uop) v) of
           SOME (s',v') =>((((( return envC) s') env) v') c)
         | NONE => Etype_error 
       )
  ))`;


(* The single step expression evaluator.  Returns None if there is nothing to
 * do, but no type error.  Returns Type_error on encountering free variables,
 * mis-applied (or non-existent) constructors, and when the wrong kind of value
 * if given to a primitive.  Returns Bind_error when no pattern in a match
 * matches the value.  Otherwise it returns the next state *)

(*val e_step : state -> e_step_result*)
val _ = Define `
 (e_step (envC, s, env, ev, c) =
  (case ev of
      Val v  =>((((
	continue envC) s) v) c)
    | Exp e =>
        (case e of
            Lit l =>((((( return envC) s) env) ((Litv l))) c)
          | Raise e =>
              (case c of
                  [] => Estuck
                | _::c =>( Estep (envC,s,env,(Exp ((Raise e))),c))
              )
          | Con n es =>
              if((( do_con_check envC) n) ((LENGTH es))) then
                (case es of
                    [] =>((((( return envC) s) env) (((Conv n) []))) c)
                  | e::es =>((((((
                      push envC) s) env) e) (((((Ccon n) []) ()) es))) c)
                )
              else
                Etype_error
          | Var n =>
              (case(( lookup n) env) of
                  NONE => Etype_error
                | SOME v =>((((( return envC) s) env) v) c)
              )
          | Fun n e =>((((( return envC) s) env) ((((Closure env) n) e))) c)
          | App op e1 e2 =>(((((( push envC) s) env) e1) ((((Capp1 op) ()) e2))) c)
          | Log l e1 e2 =>(((((( push envC) s) env) e1) ((((Clog l) ()) e2))) c)
          | If e1 e2 e3 =>(((((( push envC) s) env) e1) ((((Cif ()) e2) e3))) c)
          | Mat e pes =>(((((( push envC) s) env) e) (((Cmat ()) pes))) c)
          | Let n e1 e2 =>(((((( push envC) s) env) e1) ((((Clet n) ()) e2))) c)
          | Letrec funs e =>
              if( ~  ((ALL_DISTINCT (((MAP (\ (x,y,z) . x)) funs))))) then
                Etype_error
              else(
                Estep (envC, s,(( build_rec_env funs) env),( Exp e), c))
          | Uapp uop e =>((((((
              push envC) s) env) e) (((Cuapp uop) ()))) c)
        ) 
  ))`;


(* Add the given type definition to the given constructor environment *)
(*val build_tdefs : list (list tvarN * typeN * list (conN * list t)) -> envC*)
val _ = Define `
 (build_tdefs tds =(
  REVERSE ((FLAT
    (((MAP
      (\ (tvs, tn, condefs) .((
         MAP
           (\ (conN, ts) .
              (conN, ((LENGTH ts),
                         {cn | cn,ts | ((( MEM(cn,ts)) condefs)) /\ T}))))
           condefs)))
      tds))))))`;


(* Checks that no constructor is defined twice *)
(*val check_dup_ctors :
    forall 'a. list (list tvarN * typeN * list (conN * list t)) -> env conN 'a -> bool*)
val _ = Define `
 (check_dup_ctors tds envC =
  (! ((tvs, tn, condefs) ::( LIST_TO_SET tds)) ((n, ts) ::( LIST_TO_SET condefs)).((
   lookup n) envC) = NONE) /\(
  ALL_DISTINCT
    (let x2 = [] in((( FOLDR  (\(tvs, tn, condefs) x2 .((( FOLDR  (\(n, ts) x2 . if T then n:: x2 else x2))  x2)  condefs)))  x2)  tds))))`;


(* Whole program state
 * - constructor data
 * - values bound be previous definitions
 * - remaining definitions
 * - current state for evaluating the current definition *)
val _ = type_abbrev( "d_state" , ``: envC # store # envE # decs # (pat # state)option``);

val _ = Hol_datatype `
 d_step_result =
    Dstep of d_state
  | Draise of error
  | Dtype_error
  | Dstuck`;


(*val d_step : d_state -> d_step_result*)
val _ = Define `
 (d_step (envC, s, env, ds, st) =
  (case st of
      SOME (p, (envC', s', env', Val v, [])) =>
        if( ALL_DISTINCT (((pat_bindings p) []))) then
          (case((((( pmatch envC) s') p) v) env) of
              Match env' =>( Dstep (envC, s', env', ds, NONE))
            | No_match =>( Draise Bind_error)
            | Match_type_error => Dtype_error
          )
        else
          Dtype_error
    | SOME (p, (envC, s', env', Exp (Raise err), [])) =>(
        Draise err)
    | SOME (p, (envC', s', env', e, c)) =>
        (case( e_step (envC', s', env', e, c)) of
            Estep st =>( Dstep (envC, empty_store, env, ds,( SOME (p, st))))
          | Etype_error => Dtype_error
          | Estuck => Dstuck
        )
    | NONE =>
        (case ds of
            [] => Dstuck
          | (Dlet p e) :: ds =>(
              Dstep (envC, empty_store, env, ds,( SOME (p, (envC, s, env,( Exp e), [])))))
          | (Dletrec funs) :: ds =>
              if( ~  ((ALL_DISTINCT (((MAP (\ (x,y,z) . x)) funs))))) then
                Dtype_error
              else(
                Dstep (envC, s,(( build_rec_env funs) env), ds, NONE))
          | (Dtype tds) :: ds =>
              if(( check_dup_ctors tds) envC) then(
                Dstep (((merge ((build_tdefs tds))) envC), s, env, ds, NONE))
              else
                Dtype_error
      )
  ))`;


(* Define a semantic function using the steps *)

val _ = Hol_datatype `
 error_result =
    Rtype_error
  | Rraise of error`;


val _ = Hol_datatype `
(*  'a *) result =
    Rval of 'a
  | Rerr of error_result`;


(*val e_step_reln : state -> state -> bool*)
(*val small_eval : envC -> store -> envE -> exp -> list ctxt -> result (store * v) -> bool*)
(*val d_step_reln : d_state -> d_state -> bool*)
(*val d_small_eval : envC -> store -> envE -> list dec -> option (pat * state) -> result (envC * store * envE) -> bool*)

val _ = Define `
 (e_step_reln st1 st2 =
  ((e_step st1) =( Estep st2)))`;


 val small_eval_defn = Hol_defn "small_eval" `

(small_eval cenv s env e c (Rval (s',v)) =
  ? env'.(( ((RTC e_step_reln)) (cenv,s,env,(Exp e),c)) (cenv,s',env',(Val v),[])))
/\
(small_eval cenv s env e c (Rerr (Rraise err)) =
  ? s' env'.(( ((RTC e_step_reln)) (cenv,s,env,(Exp e),c)) (cenv,s',env',(Exp ((Raise err))),[])))
/\
(small_eval cenv s env e c (Rerr Rtype_error) =
  ? s' env' e' c'.((
    ((RTC e_step_reln)) (cenv,s,env,(Exp e),c)) (cenv,s',env',e',c')) /\
    ((e_step (cenv,s',env',e',c')) = Etype_error))`;

val _ = Defn.save_defn small_eval_defn;

(*val e_diverges : envC -> store -> envE -> exp -> bool*)
val _ = Define `
 (e_diverges cenv s env e =
  ! cenv' s' env' e' c'.((
    ((RTC e_step_reln)) (cenv,s,env,(Exp e),[])) (cenv',s',env', e',c'))
    ==>
    (? cenv'' s'' env'' e'' c''.((
      e_step_reln (cenv',s',env', e',c')) (cenv'',s'',env'',e'',c''))))`;


val _ = Define `
 (d_step_reln st st' =
  ((d_step st) =( Dstep st')))`;


 val d_small_eval_defn = Hol_defn "d_small_eval" `

(d_small_eval cenv s env ds c (Rval (cenv',s',env')) =((
  ((RTC d_step_reln)) (cenv,s,env,ds,c)) (cenv',s',env',[],NONE)))
/\
(d_small_eval cenv s env ds c (Rerr Rtype_error) =
  ? cenv' s' env' ds' c'.((
    ((RTC d_step_reln)) (cenv,s,env,ds,c)) (cenv',s',env',ds',c')) /\
    ((d_step (cenv',s',env',ds',c')) = Dtype_error))
/\
(d_small_eval cenv s env ds c (Rerr (Rraise err)) =
  ? cenv' s' env' ds' c'.((
    ((RTC d_step_reln)) (cenv,s,env,ds,c)) (cenv',s',env',ds',c')) /\
    ((d_step (cenv',s',env',ds',c')) =( Draise err)))`;

val _ = Defn.save_defn d_small_eval_defn;

(*val diverges : envC -> store -> envE -> list dec -> bool*)
val _ = Define `
 (diverges cenv s env ds =
  ! cenv' s' env' ds' c'.((
    ((RTC d_step_reln)) (cenv,s,env,ds,NONE)) (cenv',s',env',ds',c'))
    ==>
    (? cenv'' s'' env'' ds'' c''.((
      d_step_reln (cenv',s',env',ds',c')) (cenv'',s'',env'',ds'',c''))))`;


(* ------------------------ Big step semantics -------------------------- *)
(*val evaluate : envC -> store -> envE -> exp -> result (store * v) -> bool*)
(*val evaluate_list : envC -> store -> envE -> list exp -> result (store * list v) -> bool*)
(*val evaluate_match : envC -> store -> envE -> v -> list (pat * exp) -> result (store * v) -> bool*)
(*val evaluate_decs : envC -> store -> envE -> list dec -> result (envC * store * envE) -> bool*)

val _ = Hol_reln `

(! cenv env l s.
T
==>
evaluate cenv s env ((Lit l)) ((Rval (s,( Litv l)))))

/\

(! cenv env err s.
T
==>
evaluate cenv s env ((Raise err)) ((Rerr ((Rraise err)))))

/\

(! cenv env cn es vs s s'.(((
do_con_check cenv) cn) ((LENGTH es))) /\(((((
evaluate_list cenv) s) env) es) ((Rval (s',vs))))
==>
evaluate cenv s env (((Con cn) es)) ((Rval (s',(( Conv cn) vs)))))

/\

(! cenv env cn es s.(
~  ((((do_con_check cenv) cn) ((LENGTH es)))))
==>
evaluate cenv s env (((Con cn) es)) ((Rerr Rtype_error)))

/\

(! cenv env cn es err s.(((
do_con_check cenv) cn) ((LENGTH es))) /\(((((
evaluate_list cenv) s) env) es) ((Rerr err)))
==>
evaluate cenv s env (((Con cn) es)) ((Rerr err)))

/\

(! cenv env n v s.
(((lookup n) env) =( SOME v))
==>
evaluate cenv s env ((Var n)) ((Rval (s,v))))

/\

(! cenv env n s.
(((lookup n) env) = NONE)
==>
evaluate cenv s env ((Var n)) ((Rerr Rtype_error)))

/\

(! cenv env n e s.
T
==>
evaluate cenv s env (((Fun n) e)) ((Rval (s,((( Closure env) n) e)))))

/\

(! cenv env uop e v v' s1 s2 s3.(((((
evaluate cenv) s1) env) e) ((Rval (s2, v)))) /\
((((do_uapp s2) uop) v) =( SOME (s3,v')))
==>
evaluate cenv s1 env (((Uapp uop) e)) ((Rval (s3,v'))))

/\

(! cenv env uop e v s1 s2.(((((
evaluate cenv) s1) env) e) ((Rval (s2, v)))) /\
((((do_uapp s2) uop) v) = NONE)
==>
evaluate cenv s1 env (((Uapp uop) e)) ((Rerr Rtype_error)))

/\

(! cenv env uop e err s.(((((
evaluate cenv) s) env) e) ((Rerr err)))
==>
evaluate cenv s env (((Uapp uop) e)) ((Rerr err)))

/\

(! cenv env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 s4.(((((
evaluate cenv) s1) env) e1) ((Rval (s2,v1)))) /\(((((
evaluate cenv) s2) env) e2) ((Rval (s3,v2)))) /\
((((((do_app s3) env) op) v1) v2) =( SOME (s4, env', e3))) /\(((((
evaluate cenv) s4) env') e3) bv)
==>
evaluate cenv s1 env ((((App op) e1) e2)) bv)

/\

(! cenv env op e1 e2 v1 v2 s1 s2 s3.(((((
evaluate cenv) s1) env) e1) ((Rval (s2,v1)))) /\(((((
evaluate cenv) s2) env) e2) ((Rval (s3,v2)))) /\
((((((do_app s3) env) op) v1) v2) = NONE)
==>
evaluate cenv s1 env ((((App op) e1) e2)) ((Rerr Rtype_error)))

/\

(! cenv env op e1 e2 v1 err s1 s2.(((((
evaluate cenv) s1) env) e1) ((Rval (s2,v1)))) /\(((((
evaluate cenv) s2) env) e2) ((Rerr err)))
==>
evaluate cenv s1 env ((((App op) e1) e2)) ((Rerr err)))

/\

(! cenv env op e1 e2 err s.(((((
evaluate cenv) s) env) e1) ((Rerr err)))
==>
evaluate cenv s env ((((App op) e1) e2)) ((Rerr err)))

/\

(! cenv env op e1 e2 v e' bv s1 s2.(((((
evaluate cenv) s1) env) e1) ((Rval (s2,v)))) /\
((((do_log op) v) e2) =( SOME e')) /\(((((
evaluate cenv) s2) env) e') bv)
==>
evaluate cenv s1 env ((((Log op) e1) e2)) bv)

/\

(! cenv env op e1 e2 v s1 s2.(((((
evaluate cenv) s1) env) e1) ((Rval (s2,v)))) /\
((((do_log op) v) e2) = NONE)
==>
evaluate cenv s1 env ((((Log op) e1) e2)) ((Rerr Rtype_error)))

/\

(! cenv env op e1 e2 err s.(((((
evaluate cenv) s) env) e1) ((Rerr err)))
==>
evaluate cenv s env ((((Log op) e1) e2)) ((Rerr err)))

/\

(! cenv env e1 e2 e3 v e' bv s1 s2.(((((
evaluate cenv) s1) env) e1) ((Rval (s2,v)))) /\
((((do_if v) e2) e3) =( SOME e')) /\(((((
evaluate cenv) s2) env) e') bv)
==>
evaluate cenv s1 env ((((If e1) e2) e3)) bv)

/\

(! cenv env e1 e2 e3 v s1 s2.(((((
evaluate cenv) s1) env) e1) ((Rval (s2,v)))) /\
((((do_if v) e2) e3) = NONE)
==>
evaluate cenv s1 env ((((If e1) e2) e3)) ((Rerr Rtype_error)))

/\

(! cenv env e1 e2 e3 err s.(((((
evaluate cenv) s) env) e1) ((Rerr err)))
==>
evaluate cenv s env ((((If e1) e2) e3)) ((Rerr err)))

/\

(! cenv env e pes v bv s1 s2.(((((
evaluate cenv) s1) env) e) ((Rval (s2,v)))) /\((((((
evaluate_match cenv) s2) env) v) pes) bv)
==>
evaluate cenv s1 env (((Mat e) pes)) bv)

/\

(! cenv env e pes err s.(((((
evaluate cenv) s) env) e) ((Rerr err)))
==>
evaluate cenv s env (((Mat e) pes)) ((Rerr err)))

/\

(! cenv env n e1 e2 v bv s1 s2.(((((
evaluate cenv) s1) env) e1) ((Rval (s2,v)))) /\(((((
evaluate cenv) s2) ((((bind n) v) env))) e2) bv)
==>
evaluate cenv s1 env ((((Let n) e1) e2)) bv)

/\

(! cenv env n e1 e2 err s.(((((
evaluate cenv) s) env) e1) ((Rerr err)))
==>
evaluate cenv s env ((((Let n) e1) e2)) ((Rerr err)))

/\

(! cenv env funs e bv s.(
ALL_DISTINCT (((MAP (\ (x,y,z) . x)) funs))) /\(((((
evaluate cenv) s) (((build_rec_env funs) env))) e) bv)
==>
evaluate cenv s env (((Letrec funs) e)) bv)

/\

(! cenv env funs e s.(
~  ((ALL_DISTINCT (((MAP (\ (x,y,z) . x)) funs)))))
==>
evaluate cenv s env (((Letrec funs) e)) ((Rerr Rtype_error)))

/\

(! cenv env s.
T
==>
evaluate_list cenv s env [] ((Rval (s,[]))))

/\

(! cenv env e es v vs s1 s2 s3.(((((
evaluate cenv) s1) env) e) ((Rval (s2,v)))) /\(((((
evaluate_list cenv) s2) env) es) ((Rval (s3,vs))))
==>
evaluate_list cenv s1 env (e::es) ((Rval (s3, v::vs))))

/\

(! cenv env e es err s.(((((
evaluate cenv) s) env) e) ((Rerr err)))
==>
evaluate_list cenv s env (e::es) ((Rerr err)))

/\

(! cenv env e es v err s1 s2.(((((
evaluate cenv) s1) env) e) ((Rval (s2,v)))) /\(((((
evaluate_list cenv) s2) env) es) ((Rerr err)))
==>
evaluate_list cenv s1 env (e::es) ((Rerr err)))

/\

(! cenv env v s.
T
==>
evaluate_match cenv s env v [] ((Rerr ((Rraise Bind_error)))))

/\

(! cenv env v p e pes env' bv s.(
ALL_DISTINCT (((pat_bindings p) []))) /\
((((((pmatch cenv) s) p) v) env) =( Match env')) /\(((((
evaluate cenv) s) env') e) bv)
==>
evaluate_match cenv s env v ((p,e)::pes) bv)

/\

(! cenv env v p e pes bv s.(
ALL_DISTINCT (((pat_bindings p) []))) /\
((((((pmatch cenv) s) p) v) env) = No_match) /\((((((
evaluate_match cenv) s) env) v) pes) bv)
==>
evaluate_match cenv s env v ((p,e)::pes) bv)

/\

(! cenv env v p e pes s.
((((((pmatch cenv) s) p) v) env) = Match_type_error)
==>
evaluate_match cenv s env v ((p,e)::pes) ((Rerr Rtype_error)))

/\

(! cenv env v p e pes s.(
~  ((ALL_DISTINCT (((pat_bindings p) [])))))
==>
evaluate_match cenv s env v ((p,e)::pes) ((Rerr Rtype_error)))`;

val _ = Hol_reln `

(! cenv env s.
T
==>
evaluate_decs cenv s env [] ((Rval (cenv,s,env))))

/\

(! cenv env p e ds v env' r s1 s2.(((((
evaluate cenv) s1) env) e) ((Rval (s2,v)))) /\(
ALL_DISTINCT (((pat_bindings p) []))) /\
((((((pmatch cenv) s2) p) v) env) =( Match env')) /\(((((
evaluate_decs cenv) s2) env') ds) r)
==>
evaluate_decs cenv s1 env (((Dlet p) e) :: ds) r)

/\

(! cenv env p e ds v s1 s2.(((((
evaluate cenv) s1) env) e) ((Rval (s2,v)))) /\(
ALL_DISTINCT (((pat_bindings p) []))) /\
((((((pmatch cenv) s2) p) v) env) = No_match)
==>
evaluate_decs cenv s1 env (((Dlet p) e) :: ds) ((Rerr ((Rraise Bind_error)))))

/\

(! cenv env p e ds v s1 s2.(((((
evaluate cenv) s1) env) e) ((Rval (s2,v)))) /\
((((((pmatch cenv) s2) p) v) env) = Match_type_error)
==>
evaluate_decs cenv s1 env (((Dlet p) e) :: ds) ((Rerr (Rtype_error))))

/\

(! cenv env p e ds v s1 s2.(((((
evaluate cenv) s1) env) e) ((Rval (s2,v)))) /\(
~  ((ALL_DISTINCT (((pat_bindings p) [])))))
==>
evaluate_decs cenv s1 env (((Dlet p) e) :: ds) ((Rerr (Rtype_error))))

/\

(! cenv env p e ds err s.(((((
evaluate cenv) s) env) e) ((Rerr err)))
==>
evaluate_decs cenv s env (((Dlet p) e) :: ds) ((Rerr err)))

/\

(! cenv env funs ds r s.(
ALL_DISTINCT (((MAP (\ (x,y,z) . x)) funs))) /\(((((
evaluate_decs cenv) s) (((build_rec_env funs) env))) ds) r)
==>
evaluate_decs cenv s env ((Dletrec funs) :: ds) r)

/\

(! cenv env funs ds s.(
~  ((ALL_DISTINCT (((MAP (\ (x,y,z) . x)) funs)))))
==>
evaluate_decs cenv s env ((Dletrec funs) :: ds) ((Rerr Rtype_error)))

/\

(! cenv env tds ds r s.((
check_dup_ctors tds) cenv) /\(((((
evaluate_decs (((merge ((build_tdefs tds))) cenv))) s) env) ds) r)
==>
evaluate_decs cenv s env ((Dtype tds) :: ds) r)

/\

(! cenv env tds ds s.(
~  (((check_dup_ctors tds) cenv)))
==>
evaluate_decs cenv s env ((Dtype tds) :: ds) ((Rerr Rtype_error)))`;

(* ------------------------ Type system --------------------------------- *)

(* constructor type environments: each constructor has a type
 * forall tyvars. t list -> (tyvars) typeN *)
val _ = type_abbrev( "tenvC" , ``: (conN, ( tvarN list # t list # typeN)) env``);

(* Type environments *)
val _ = Hol_datatype `
 tenvE = 
    Env_empty
  (* Bind a number of deBruijn type variables *)
  | Tvar_bind of num => tenvE
  (* The number is how many deBruijn indices the type scheme binds. *)
  | Var_bind of num => varN => t => tenvE`;


(* Increment the deBruijn indices in a type by n levels, skipping all levels 
 * less than skip. *)
(*val deBruijn_inc : num -> num -> t -> t*)
 val deBruijn_inc_defn = Hol_defn "deBruijn_inc" `

(deBruijn_inc skip n (Tvar tv) =( Tvar tv))
/\
(deBruijn_inc skip n (Tvar_db m) = 
  if m < skip then(
    Tvar_db m)
  else(
    Tvar_db (m + n)))
/\
(deBruijn_inc skip n (Tapp ts tn) =(( Tapp (((MAP (((deBruijn_inc skip) n))) ts))) tn))
/\
(deBruijn_inc skip n (Tfn t1 t2) =(( 
  Tfn ((((deBruijn_inc skip) n) t1))) ((((deBruijn_inc skip) n) t2))))
/\
(deBruijn_inc skip n Tnum = Tnum)
/\
(deBruijn_inc skip n Tbool = Tbool)`;

val _ = Defn.save_defn deBruijn_inc_defn;

(* Lookup a variable, incrementing its deBruijn indices by how many type
 * variable quantifiers it is lifted past. *)
(*val lookup_var : varN -> num -> tenvE -> option (t * num)*)
 val lookup_var_defn = Hol_defn "lookup_var" `

(lookup_var n inc Env_empty = NONE)
/\
(lookup_var n inc (Tvar_bind levels tenv) =((( lookup_var n) (inc + levels)) tenv))
/\
(lookup_var n inc (Var_bind levels n' t tenv) = 
  if n = n' then(
    SOME ((((deBruijn_inc levels) inc) t), levels))
  else(((
    lookup_var n) inc) tenv))`;

val _ = Defn.save_defn lookup_var_defn;

(* A pattern matches values of a certain type and extends the type environment
 * with the pattern's binders. *)
(*val type_p : tenvC -> pat -> t -> list (varN * t) -> bool*)

(* An expression has a type *)
(*val type_e : tenvC -> tenvE -> exp -> t -> bool*)

(* A list of expressions has a list of types *)
(*val type_es : tenvC -> tenvE -> list exp -> list t -> bool*)

(* Type a mutually recursive bundle of functions.  Unlike pattern typing, the
 * resulting environment does not extend the input environment, but just
 * represents the functions *)
(*val type_funs : tenvC -> tenvE -> list (varN * varN * exp) -> 
                list (varN * t) -> bool*)

(* Check a declaration and update the top-level environments *)
(*val type_d : tenvC -> tenvE -> dec -> tenvC -> tenvE -> bool*)

(*val type_ds : tenvC -> tenvE -> list dec -> tenvC -> tenvE -> bool*)

(* Check that the operator can have type (t1 -> t2 -> t3) *)
(*val type_op : op -> t -> t -> t -> bool*)
val _ = Define `
 (type_op op t1 t2 t3 =
  (case (op,t1,t2) of
      (Opapp, Tfn t2' t3', _) => (t2 = t2') /\ (t3 = t3')
    | (Opn _, Tnum, Tnum) => (t3 = Tnum)
    | (Opb _, Tnum, Tnum) => (t3 = Tbool)
    | (Equality, t1, t2) => (t1 = t2) /\ (t3 = Tbool)
    | _ => F
  ))`;


(* Check that the operator can have type (t1 -> t2) *)
(*val type_uop : uop -> t -> t -> bool*)
val _ = Define `
 (type_uop uop t1 t2 =
  (case (uop,t1) of
      (Ref, _) => t2 =( Tref t1)
    | (Deref, Tref t1') => t2 = t1'
    | _ => F
  ))`;


(* Check that the free type variables are in the given list.  If dbok is true,
 * the deBuijn type variables are permitted.  Otherwise, they are not. *)
(*val check_freevars : bool -> list tvarN -> t -> bool*)
 val check_freevars_defn = Hol_defn "check_freevars" `

(check_freevars dbok tvs (Tvar tv) =((
  MEM tv) tvs))
/\
(check_freevars dbok tvs (Tapp ts tn) =((
  EVERY (((check_freevars dbok) tvs))) ts))
/\
(check_freevars dbok tvs (Tfn t1 t2) =(((
  check_freevars dbok) tvs) t1) /\((( check_freevars dbok) tvs) t2))
/\
(check_freevars dbok tvs Tnum = T)
/\
(check_freevars dbok tvs Tbool = T)
/\
(check_freevars dbok tvs (Tvar_db _) = dbok)`;

val _ = Defn.save_defn check_freevars_defn;

(* Check that a type definition defines no already defined (or duplicate)
 * constructors or types, and that the free type variables of each constructor
 * argument type are included in the type's type parameters. *)
(*val check_ctor_tenv :
  tenvC -> list (list tvarN * typeN * list (conN * list t)) -> bool*)
val _ = Define `
 (check_ctor_tenv tenvC tds =((
  check_dup_ctors tds) tenvC) /\((
  EVERY
    (\ (tvs,tn,ctors) .(
       ALL_DISTINCT tvs) /\((
       EVERY
         (\ (cn,ts) . (((EVERY (((check_freevars F) tvs))) ts))))
         ctors)))
    tds) /\(
  ALL_DISTINCT (((MAP ( \x . (case x of (_,tn,_) => tn))) tds))) /\((
  EVERY
    (\ (tvs,tn,ctors) .((
       EVERY ( \x . (case x of (_,(_,_,tn')) => tn <> tn'))) tenvC)))
    tds))`;


(*val build_ctor_tenv : list (list tvarN * typeN * list (conN * list t)) -> tenvC*)
val _ = Define `
 (build_ctor_tenv tds =(
  FLAT
    (((MAP
       (\ (tvs,tn,ctors) .((
          MAP (\ (cn,ts) . (cn,(tvs,ts,tn)))) ctors)))
       tds))))`;


(* Simultaneous substitution of types for type variables in a type *)
(*val type_subst : env tvarN t -> t -> t*)
 val type_subst_defn = Hol_defn "type_subst" `

(type_subst s (Tvar tv) =
  (case(( lookup tv) s) of
      NONE =>( Tvar tv)
    | SOME(t) => t
  ))
/\
(type_subst s (Tapp ts tn) =((
  Tapp (((MAP ((type_subst s))) ts))) tn))
/\
(type_subst s (Tfn t1 t2) =((
  Tfn (((type_subst s) t1))) (((type_subst s) t2))))
/\
(type_subst s Tnum = Tnum)
/\
(type_subst s Tbool = Tbool)
/\
(type_subst s (Tvar_db n) =( Tvar_db n))`;

val _ = Defn.save_defn type_subst_defn;

(* skip the lowest given indices and replace the next (LENGTH ts) with the given types and reduce all the higher ones *)
(*val deBruijn_subst : num -> list t -> t -> t*)
 val deBruijn_subst_defn = Hol_defn "deBruijn_subst" `

(deBruijn_subst skip ts (Tvar tv) =( Tvar tv))
/\
(deBruijn_subst skip ts (Tvar_db n) =
  if( ~  (n < skip)) /\ n <( LENGTH ts) + skip then((
    EL  (n - skip))  ts)
  else if( ~  (n < skip)) then(
    Tvar_db (n -( LENGTH ts)))
  else( 
    Tvar_db n))
/\
(deBruijn_subst skip ts (Tapp ts' tn) =((
  Tapp (((MAP (((deBruijn_subst skip) ts))) ts'))) tn))
/\
(deBruijn_subst skip ts (Tfn t1 t2) =((
  Tfn ((((deBruijn_subst skip) ts) t1))) ((((deBruijn_subst skip) ts) t2))))
/\
(deBruijn_subst skip ts Tnum = Tnum)
/\
(deBruijn_subst skip ts Tbool = Tbool)`;

val _ = Defn.save_defn deBruijn_subst_defn;

(*val bind_var_list : num -> list (varN * t) -> tenvE -> tenvE*)
 val bind_var_list_defn = Hol_defn "bind_var_list" `
 
(bind_var_list levels [] tenv = tenv)
/\
(bind_var_list levels ((n,t)::binds) tenv =(((( 
  Var_bind levels) n) t) ((((bind_var_list levels) binds) tenv))))`;

val _ = Defn.save_defn bind_var_list_defn;

val _ = Hol_reln `

(! cenv n t.(((
check_freevars T) []) t)
==>
type_p cenv ((Pvar n)) t [(n,t)])

/\

(! cenv b.
T
==>
type_p cenv ((Plit ((Bool b)))) Tbool [])

/\

(! cenv n.
T
==>
type_p cenv ((Plit ((IntLit n)))) Tnum [])

/\

(! cenv.
T
==>
type_p cenv ((Plit Unit)) Tunit [])

/\

(! cenv cn ps ts tvs tn ts' tenv.((
EVERY (((check_freevars T) []))) ts') /\
((LENGTH ts') =( LENGTH tvs)) /\((((
type_ps cenv) ps) (((MAP ((type_subst ((ZIP ( tvs, ts')))))) ts))) tenv) /\
(((lookup cn) cenv) =( SOME (tvs, ts, tn)))
==>
type_p cenv (((Pcon cn) ps)) (((Tapp ts') tn)) tenv)

/\

(! cenv p t tenv.((((
type_p cenv) p) t) tenv)
==>
type_p cenv ((Pref p)) ((Tref t)) tenv)

/\

(! cenv .
T
==>
type_ps cenv [] [] [])

/\

(! cenv p ps t ts tenv tenv'.((((
type_p cenv) p) t) tenv) /\((((
type_ps cenv) ps) ts) tenv')
==>
type_ps cenv (p::ps) (t::ts) (tenv++tenv'))`;

val _ = Hol_reln `

(! cenv tenv b.
T
==>
type_e cenv tenv ((Lit ((Bool b)))) Tbool)

/\

(! cenv tenv n.
T
==>
type_e cenv tenv ((Lit ((IntLit n)))) Tnum)

/\

(! cenv tenv.
T
==>
type_e cenv tenv ((Lit Unit)) Tnum)

/\

(! cenv tenv err t.
T
==>
type_e cenv tenv ((Raise err)) t)

/\

(! cenv tenv cn es tvs tn ts' ts.((
EVERY (((check_freevars T) []))) ts') /\
((LENGTH tvs) =( LENGTH ts')) /\((((
type_es cenv) tenv) es) (((MAP ((type_subst ((ZIP ( tvs, ts')))))) ts))) /\
(((lookup cn) cenv) =( SOME (tvs, ts, tn)))
==>
type_e cenv tenv (((Con cn) es)) (((Tapp ts') tn)))

/\

(! cenv tenv levels n t ts.
(levels =( LENGTH ts)) /\((
EVERY (((check_freevars T) []))) ts) /\
((((lookup_var n) 0) tenv) =( SOME (t,levels)))
==>
type_e cenv tenv ((Var n)) ((((deBruijn_subst 0) ts) t)))

/\

(! cenv tenv n e t1 t2.(((
check_freevars T) []) t1) /\((((
type_e cenv) (((((Var_bind 0) n) t1) tenv))) e) t2)
==>
type_e cenv tenv (((Fun n) e)) (((Tfn t1) t2)))

/\

(! cenv tenv uop e t1 t2.((((
type_e cenv) tenv) e) t1) /\((( 
type_uop uop) t1) t2)
==>
type_e cenv tenv (((Uapp uop) e)) t2)

/\

(! cenv tenv op e1 e2 t1 t2 t3.((((
type_e cenv) tenv) e1) t1) /\((((
type_e cenv) tenv) e2) t2) /\((((
type_op op) t1) t2) t3)
==>
type_e cenv tenv ((((App op) e1) e2)) t3)

/\

(! cenv tenv l e1 e2.((((
type_e cenv) tenv) e1) Tbool) /\((((
type_e cenv) tenv) e2) Tbool)
==>
type_e cenv tenv ((((Log l) e1) e2)) Tbool)

/\

(! cenv tenv e1 e2 e3 t.((((
type_e cenv) tenv) e1) Tbool) /\((((
type_e cenv) tenv) e2) t) /\((((
type_e cenv) tenv) e3) t)
==>
type_e cenv tenv ((((If e1) e2) e3)) t)

/\

(! cenv tenv e pes t1 t2.((((
type_e cenv) tenv) e) t1) /\
(! ((p,e) ::( LIST_TO_SET pes)) tenv'.(
   ALL_DISTINCT (((pat_bindings p) []))) /\((((
   type_p cenv) p) t1) tenv') /\((((
   type_e cenv) ((((bind_var_list 0) tenv') tenv))) e) t2))
==>
type_e cenv tenv (((Mat e) pes)) t2)

/\

(* Don't do let-polymorphism for nested expressions *)
(! cenv tenv n e1 e2 t1 t2.((((
type_e cenv) tenv) e1) t1) /\(((
check_freevars T) []) t1) /\((((
type_e cenv) (((((Var_bind 0) n) t1) tenv))) e2) t2)
==>
type_e cenv tenv ((((Let n) e1) e2)) t2)

/\

(* Don't do let-polymorphism for nested expressions *)
(! cenv tenv funs e t tenv'.((((
type_funs cenv) ((((bind_var_list 0) tenv') tenv))) funs) tenv') /\((((
type_e cenv) ((((bind_var_list 0) tenv') tenv))) e) t)
==>
type_e cenv tenv (((Letrec funs) e)) t)
 
/\

(! cenv tenv.
T
==>
type_es cenv tenv [] [])

/\

(! cenv tenv e es t ts.((((
type_e cenv) tenv) e) t) /\((((
type_es cenv) tenv) es) ts)
==>
type_es cenv tenv (e::es) (t::ts))

/\

(! cenv env.
T
==>
type_funs cenv env [] [])

/\

(! cenv env fn n e funs env' t1 t2.(((
check_freevars T) []) (((Tfn t1) t2))) /\((((
type_e cenv) (((((Var_bind 0) n) t1) env))) e) t2) /\((((
type_funs cenv) env) funs) env') /\
(((lookup fn) env') = NONE)
==>
type_funs cenv env ((fn, n, e)::funs) ((fn,(( Tfn t1) t2))::env'))`;

val _ = Hol_reln `

(! levels cenv tenv p e t tenv'.(
ALL_DISTINCT (((pat_bindings p) []))) /\((((
type_p cenv) p) t) tenv') /\((((
type_e cenv) (((Tvar_bind levels) tenv))) e) t)
==>
type_d cenv tenv (((Dlet p) e)) emp ((((bind_var_list levels) tenv') tenv)))

/\

(! cenv tenv funs tenv' levels.((((
type_funs cenv) ((((bind_var_list 0) tenv') (((Tvar_bind levels) tenv))))) funs) tenv')
==>
type_d cenv tenv ((Dletrec funs)) emp ((((bind_var_list levels) tenv') tenv)))

/\

(! cenv tenv tdecs.((
check_ctor_tenv cenv) tdecs)
==>
type_d cenv tenv ((Dtype tdecs)) ((build_ctor_tenv tdecs)) tenv)`;

val _ = Hol_reln `

(! cenv tenv.
T
==>
type_ds cenv tenv [] emp tenv)

/\

(! cenv tenv d ds cenv' tenv' cenv'' tenv''.(((((
type_d cenv) tenv) d) cenv') tenv') /\(((((
type_ds (((merge ((REVERSE cenv'))) cenv))) tenv') ds) cenv'') tenv'')
==>
type_ds cenv tenv (d::ds) (((merge cenv') cenv'')) tenv'')`;

(* --------- Auxiliary definitions used in the type soundness proofs -------- *)

val _ = type_abbrev( "tenvS" , ``: (num, t) env``);

(* A value has a type *)
(*val type_v : tenvC -> tenvS -> v -> t -> bool*)

(* A value environment has a corresponding type environment.  Since all of the
 * entries in the environment are values, and values have no free variables,
 * each entry in the environment can be typed in the empty environment (if at
 * all) *)
(*val type_env : tenvC -> tenvS -> envE -> tenvE -> bool*)

(* An evaluation context has the second type when its hole is filled with a
 * value of the first type. *)
(*val type_ctxt : tenvC -> tenvS -> tenvE -> ctxt_frame -> t -> t -> bool*)
(*val type_ctxts : tenvC -> tenvS -> list ctxt -> t -> t -> bool*)
(*val type_state : tenvC -> state -> t -> bool*)

val _ = Hol_reln `  

(! cenv senv b.
T
==>
type_v cenv senv ((Litv ((Bool b)))) Tbool)

/\

(! cenv senv n.
T
==>
type_v cenv senv ((Litv ((IntLit n)))) Tnum)

/\

(! cenv senv cn vs tvs tn ts' ts.((
EVERY (((check_freevars T) []))) ts') /\
((LENGTH tvs) =( LENGTH ts')) /\((((
type_vs cenv) senv) vs) (((MAP ((type_subst ((ZIP ( tvs, ts')))))) ts))) /\
(((lookup cn) cenv) =( SOME (tvs, ts, tn)))
==>
type_v cenv senv (((Conv cn) vs)) (((Tapp ts') tn)))

/\

(! cenv senv env tenv n e t1 t2.((((
type_env cenv) senv) env) tenv) /\(((
check_freevars T) []) t1) /\(((( 
type_e cenv) (((((Var_bind 0) n) t1) tenv))) e) t2)
==>
type_v cenv senv ((((Closure env) n) e)) (((Tfn t1) t2)))

/\

(! cenv senv env funs n t tenv tenv'.((((
type_env cenv) senv) env) tenv) /\((((
type_funs cenv) ((((bind_var_list 0) tenv') tenv))) funs) tenv') /\
(((lookup n) tenv') =( SOME t))
==>
type_v cenv senv ((((Recclosure env) funs) n)) t)

/\

(! cenv senv n t.
(((lookup n) senv) =( SOME t))
==>
type_v cenv senv ((Loc n)) t)

/\

(! cenv senv.
T
==>
type_vs cenv senv [] [])

/\

(! cenv senv v vs t ts.((((
type_v cenv) senv) v) t) /\((((
type_vs cenv) senv) vs) ts)
==>
type_vs cenv senv (v::vs) (t::ts))

/\

(! cenv senv.
T
==>
type_env cenv senv [] Env_empty)

/\

(! cenv senv n v env t tenv levels.((((
type_v cenv) senv) v) t) /\(((
check_freevars T) []) t) /\((((
type_env cenv) senv) env) tenv)
==>
type_env cenv senv ((((bind n) v) env)) (((((Var_bind levels) n) t) tenv)))`;

val _ = Hol_reln `

(! cenv senv tenv e op t1 t2 t3.((((
type_e cenv) tenv) e) t2) /\((((
type_op op) t1) t2) t3)
==>
type_ctxt cenv senv tenv ((((Capp1 op) ()) e)) t1 t3)

/\

(! cenv senv tenv op v t1 t2 t3.((((
type_v cenv) senv) v) t1) /\((((
type_op op) t1) t2) t3)
==>
type_ctxt cenv senv tenv ((((Capp2 op) v) ())) t2 t3)

/\

(! cenv senv tenv op e.((((
type_e cenv) tenv) e) Tbool)
==>
type_ctxt cenv senv tenv ((((Clog op) ()) e)) Tbool Tbool)

/\

(! cenv senv tenv e1 e2 t.((((
type_e cenv) tenv) e1) t) /\((((
type_e cenv) tenv) e2) t)
==>
type_ctxt cenv senv tenv ((((Cif ()) e1) e2)) Tbool t)

/\

(! cenv senv tenv t1 t2 pes.
(! ((p,e) ::( LIST_TO_SET pes)) tenv'.(
   ALL_DISTINCT (((pat_bindings p) []))) /\((((
   type_p cenv) p) t1) tenv') /\((((
   type_e cenv) ((((bind_var_list 0) tenv') tenv))) e) t2))
==>
type_ctxt cenv senv tenv (((Cmat ()) pes)) t1 t2)

/\

(! cenv senv tenv e t1 t2 levels n.(((
check_freevars T) []) t1) /\((((
type_e cenv) (((((Var_bind levels) n) t1) tenv))) e) t2)
==>
type_ctxt cenv senv tenv ((((Clet n) ()) e)) t1 t2)

/\

(! cenv senv tenv cn vs es ts1 ts2 t tn ts' tvs.((
EVERY (((check_freevars T) []))) ts') /\
((LENGTH tvs) =( LENGTH ts')) /\((((
type_vs cenv) senv) ((REVERSE vs)))
        (((MAP ((type_subst ((ZIP ( tvs, ts')))))) ts1))) /\((((
type_es cenv) tenv) es) (((MAP ((type_subst ((ZIP ( tvs, ts')))))) ts2))) /\
(((lookup cn) cenv) =( SOME (tvs, ts1++([t]++ts2), tn)))
==>
type_ctxt cenv senv tenv (((((Ccon cn) vs) ()) es)) (((type_subst ((ZIP ( tvs, ts')))) t))
          (((Tapp ts') tn)))`;

val _ = Hol_reln `

(! tenvC senv t.
T
==>
type_ctxts tenvC senv [] t t)

/\

(! tenvC senv c env cs tenv t1 t2 t3.((((
type_env tenvC) senv) env) tenv) /\((((((
type_ctxt tenvC) senv) tenv) c) t1) t2) /\(((((
type_ctxts tenvC) senv) cs) t2) t3)
==>
type_ctxts tenvC senv ((c,env)::cs) t1 t3)`;

val _ = Hol_reln `

(! tenvC senv envC s env e c t1 t2 tenv.(((((
type_ctxts tenvC) senv) c) t1) t2) /\((((
type_env tenvC) senv) env) tenv) /\((((
type_e tenvC) tenv) e) t1)
==>
type_state tenvC (envC, s, env,( Exp e), c) t2)

/\

(! tenvC senv envC s env v c t1 t2 tenv.(((((
type_ctxts tenvC) senv) c) t1) t2) /\((((
type_env tenvC) senv) env) tenv) /\((((
type_v tenvC) senv) v) t1)
==>
type_state tenvC (envC, s, env,( Val v), c) t2)`;

val _ = Hol_reln `

(! tenvC senv envC s env ds tenvC' tenv tenv'.((((
type_env tenvC) senv) env) tenv) /\(((((
type_ds tenvC) tenv) ds) tenvC') tenv')
==>
type_d_state tenvC (envC, s, env, ds, NONE) tenvC' tenv')

/\

(! tenvC senv envC s env ds tenvC' tenv tenv' p s' env' e c t tenv''.((((
type_env tenvC) senv) env) tenv) /\(((
type_state tenvC) (envC,s',env',e,c)) t) /\(
ALL_DISTINCT (((pat_bindings p) []))) /\((((
type_p tenvC) p) t) tenv') /\(((((
type_ds tenvC) ((((bind_var_list 0) tenv') tenv))) ds) tenvC') tenv'')
==>
type_d_state tenvC (envC, s, env, ds,( SOME (p, (envC,s',env',e,c)))) tenvC' tenv'')`;

(* ------ Auxiliary relations for proving big/small step equivalence ------ *)

(*val evaluate_ctxt : envC -> store -> envE -> ctxt_frame -> v -> result (store * v) -> bool*)
(*val evaluate_ctxts : envC -> store -> list ctxt -> v -> result (store * v) -> bool*)
(*val evaluate_state : state -> result (store * v) -> bool*)

val _ = Hol_reln `

(! cenv env op e2 v1 v2 env' e3 bv s1 s2 s3.(((((
evaluate cenv) s1) env) e2) ((Rval (s2,v2)))) /\
((((((do_app s2) env) op) v1) v2) =( SOME (s3,env', e3))) /\(((((
evaluate cenv) s3) env') e3) bv)
==>
evaluate_ctxt cenv s1 env ((((Capp1 op) ()) e2)) v1 bv)

/\

(! cenv env op e2 v1 v2 s1 s2.(((((
evaluate cenv) s1) env) e2) ((Rval (s2,v2)))) /\
((((((do_app s2) env) op) v1) v2) = NONE)
==>
evaluate_ctxt cenv s1 env ((((Capp1 op) ()) e2)) v1 ((Rerr Rtype_error)))

/\

(! cenv env op e2 v1 err s.(((((
evaluate cenv) s) env) e2) ((Rerr err)))
==>
evaluate_ctxt cenv s env ((((Capp1 op) ()) e2)) v1 ((Rerr err)))

/\

(! cenv env op v1 v2 env' e3 bv s1 s2.
((((((do_app s1) env) op) v1) v2) =( SOME (s2, env', e3))) /\(((((
evaluate cenv) s2) env') e3) bv)
==>
evaluate_ctxt cenv s1 env ((((Capp2 op) v1) ())) v2 bv)

/\

(! cenv env op v1 v2 s.
((((((do_app s) env) op) v1) v2) = NONE)
==>
evaluate_ctxt cenv s env ((((Capp2 op) v1) ())) v2 ((Rerr Rtype_error)))

/\

(! cenv env uop v v' s1 s2.
((((do_uapp s1) uop) v) =( SOME (s2,v')))
==>
evaluate_ctxt cenv s1 env (((Cuapp uop) ())) v ((Rval (s2,v'))))

/\

(! cenv env uop v s.
((((do_uapp s) uop) v) = NONE)
==>
evaluate_ctxt cenv s env (((Cuapp uop) ())) v ((Rerr Rtype_error)))

/\

(! cenv env op e2 v e' bv s.
((((do_log op) v) e2) =( SOME e')) /\(((((
evaluate cenv) s) env) e') bv)
==>
evaluate_ctxt cenv s env ((((Clog op) ()) e2)) v bv)

/\

(! cenv env op e2 v s.
((((do_log op) v) e2) = NONE)
==>
evaluate_ctxt cenv s env ((((Clog op) ()) e2)) v ((Rerr Rtype_error)))

/\
(! cenv env e2 e3 v e' bv s.
((((do_if v) e2) e3) =( SOME e')) /\(((((
evaluate cenv) s) env) e') bv)
==>
evaluate_ctxt cenv s env ((((Cif ()) e2) e3)) v bv)

/\

(! cenv env e2 e3 v s.
((((do_if v) e2) e3) = NONE)
==>
evaluate_ctxt cenv s env ((((Cif ()) e2) e3)) v ((Rerr Rtype_error)))

/\

(! cenv env pes v bv s.((((((
evaluate_match cenv) s) env) v) pes) bv)
==>
evaluate_ctxt cenv s env (((Cmat ()) pes)) v bv)

/\

(! cenv env n e2 v bv s.(((((
evaluate cenv) s) ((((bind n) v) env))) e2) bv)
==>
evaluate_ctxt cenv s env ((((Clet n) ()) e2)) v bv)

/\

(! cenv env cn es vs v vs' s1 s2.(((
do_con_check cenv) cn) ((LENGTH vs) +( LENGTH es) + 1)) /\(((((
evaluate_list cenv) s1) env) es) ((Rval (s2,vs'))))
==>
evaluate_ctxt cenv s1 env (((((Ccon cn) vs) ()) es)) v ((Rval (s2,((Conv cn) ((REVERSE vs) ++ ([v] ++ vs')))))))

/\

(! cenv env cn es vs v s.(
~  ((((do_con_check cenv) cn) ((LENGTH vs) +( LENGTH es) + 1))))
==>
evaluate_ctxt cenv s env (((((Ccon cn) vs) ()) es)) v ((Rerr Rtype_error)))

/\

(! cenv env cn es vs v err s.(((
do_con_check cenv) cn) ((LENGTH vs) +( LENGTH es) + 1)) /\(((((
evaluate_list cenv) s) env) es) ((Rerr err)))
==>
evaluate_ctxt cenv s env (((((Ccon cn) vs) ()) es)) v ((Rerr err)))`;

val _ = Hol_reln `

(! cenv v s.
T
==>
evaluate_ctxts cenv s [] v ((Rval (s,v))))

/\

(! cenv c cs env v v' bv s1 s2.((((((
evaluate_ctxt cenv) s1) env) c) v) ((Rval (s2,v')))) /\(((((
evaluate_ctxts cenv) s2) cs) v') bv)
==>
evaluate_ctxts cenv s1 ((c,env)::cs) v bv)

/\

(! cenv c cs v env err s.((((((
evaluate_ctxt cenv) s) env) c) v) ((Rerr err)))
==>
evaluate_ctxts cenv s ((c,env)::cs) v ((Rerr err)))`;

val _ = Hol_reln `

(! cenv env e c v bv s1 s2.(((((
evaluate cenv) s1) env) e) ((Rval (s2,v)))) /\(((((
evaluate_ctxts cenv) s2) c) v) bv)
==>
evaluate_state (cenv, s1, env,( Exp e), c) bv)

/\

(! cenv env e c err s.(((((
evaluate cenv) s) env) e) ((Rerr err)))
==>
evaluate_state (cenv, s, env,( Exp e), c) ((Rerr err)))

/\

(! cenv s env v c bv.(((((
evaluate_ctxts cenv) s) c) v) bv)
==>
evaluate_state (cenv, s, env,( Val v), c) bv)`; 


(* ------------------------------------------------------------------------- *)

(* A version of the big-step expression semantics that doesn't use the
 * constructor environment to know if a value is ok or not.  Is equivalent to
 * the normal one for well-typed programs. *)

(*val pmatch' : store -> pat -> v -> envE -> match_result*)
 val pmatch'_defn = Hol_defn "pmatch'" `

(pmatch' s (Pvar n) v' env =( Match ((((bind n) v') env))))
/\
(pmatch' s (Plit l) (Litv l') env =
  if l = l' then(
    Match env)
  else if(( lit_same_type l) l') then
    No_match
  else
    Match_type_error)
/\
(pmatch' s (Pcon n ps) (Conv n' vs) env =
  if ((LENGTH ps) =( LENGTH vs)) /\ (n = n') then((((
    pmatch_list' s) ps) vs) env)
  else
    No_match)
/\
(pmatch' s (Pref p) (Loc lnum) env =
  (case(( store_lookup lnum) s) of
      SOME v =>(((( pmatch' s) p) v) env)
    | NONE => Match_type_error
  ))
/\
(pmatch' _ _ _ env = Match_type_error)
/\
(pmatch_list' s [] [] env =( Match env))
/\
(pmatch_list' s (p::ps) (v::vs) env =
  (case(((( pmatch' s) p) v) env) of
      No_match => No_match
    | Match_type_error => Match_type_error
    | Match env' =>(((( pmatch_list' s) ps) vs) env')
  ))
/\
(pmatch_list' _ _ _ env = Match_type_error)`;

val _ = Defn.save_defn pmatch'_defn;


val _ = Hol_reln `

(! env l s.
T
==>
evaluate' s env ((Lit l)) ((Rval (s,(Litv l)))))

/\

(! env err s.
T
==>
evaluate' s env ((Raise err)) ((Rerr ((Rraise err)))))

/\

(! env cn es vs s1 s2.((((
evaluate_list' s1) env) es) ((Rval (s2,vs))))
==>
evaluate' s1 env (((Con cn) es)) ((Rval (s2,((Conv cn) vs)))))

/\

(! env cn es err s.((((
evaluate_list' s) env) es) ((Rerr err)))
==>
evaluate' s env (((Con cn) es)) ((Rerr err)))

/\

(! env n v s.
(((lookup n) env) =( SOME v))
==>
evaluate' s env ((Var n)) ((Rval (s,v))))

/\

(! env n s.
(((lookup n) env) = NONE)
==>
evaluate' s env ((Var n)) ((Rerr Rtype_error)))

/\

(! env n e s.
T
==>
evaluate' s env (((Fun n) e)) ((Rval (s,((( Closure env) n) e)))))

/\

(! env uop e v v' s1 s2 s3.((((
evaluate' s1) env) e) ((Rval (s2, v)))) /\
((((do_uapp s2) uop) v) =( SOME (s3,v')))
==>
evaluate' s1 env (((Uapp uop) e)) ((Rval (s3,v'))))

/\

(! env uop e v s1 s2.((((
evaluate' s1) env) e) ((Rval (s2, v)))) /\
((((do_uapp s2) uop) v) = NONE)
==>
evaluate' s1 env (((Uapp uop) e)) ((Rerr Rtype_error)))

/\

(! env uop e err s.((((
evaluate' s) env) e) ((Rerr err)))
==>
evaluate' s env (((Uapp uop) e)) ((Rerr err)))

/\

(! env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 s4.((((
evaluate' s1) env) e1) ((Rval (s2,v1)))) /\((((
evaluate' s2) env) e2) ((Rval (s3,v2)))) /\
((((((do_app s3) env) op) v1) v2) =( SOME (s4, env', e3))) /\((((
evaluate' s4) env') e3) bv)
==>
evaluate' s1 env ((((App op) e1) e2)) bv)

/\

(! env op e1 e2 v1 v2 s1 s2 s3.((((
evaluate' s1) env) e1) ((Rval (s2,v1)))) /\((((
evaluate' s2) env) e2) ((Rval (s3,v2)))) /\
((((((do_app s3) env) op) v1) v2) = NONE)
==>
evaluate' s1 env ((((App op) e1) e2)) ((Rerr Rtype_error)))

/\

(! env op e1 e2 v1 err s1 s2.((((
evaluate' s1) env) e1) ((Rval (s2,v1)))) /\((((
evaluate' s2) env) e2) ((Rerr err)))
==>
evaluate' s1 env ((((App op) e1) e2)) ((Rerr err)))

/\

(! env op e1 e2 err s.((((
evaluate' s) env) e1) ((Rerr err)))
==>
evaluate' s env ((((App op) e1) e2)) ((Rerr err)))

/\

(! env op e1 e2 v e' bv s1 s2.((((
evaluate' s1) env) e1) ((Rval (s2,v)))) /\
((((do_log op) v) e2) =( SOME e')) /\((((
evaluate' s2) env) e') bv)
==>
evaluate' s1 env ((((Log op) e1) e2)) bv)

/\

(! env op e1 e2 v s1 s2.((((
evaluate' s1) env) e1) ((Rval (s2,v)))) /\
((((do_log op) v) e2) = NONE)
==>
evaluate' s1 env ((((Log op) e1) e2)) ((Rerr Rtype_error)))

/\

(! env op e1 e2 err s.((((
evaluate' s) env) e1) ((Rerr err)))
==>
evaluate' s env ((((Log op) e1) e2)) ((Rerr err)))

/\

(! env e1 e2 e3 v e' bv s1 s2.((((
evaluate' s1) env) e1) ((Rval (s2,v)))) /\
((((do_if v) e2) e3) =( SOME e')) /\((((
evaluate' s2) env) e') bv)
==>
evaluate' s1 env ((((If e1) e2) e3)) bv)

/\

(! env e1 e2 e3 v s1 s2.((((
evaluate' s1) env) e1) ((Rval (s2,v)))) /\
((((do_if v) e2) e3) = NONE)
==>
evaluate' s1 env ((((If e1) e2) e3)) ((Rerr Rtype_error)))

/\


(! env e1 e2 e3 err s.((((
evaluate' s) env) e1) ((Rerr err)))
==>
evaluate' s env ((((If e1) e2) e3)) ((Rerr err)))

/\

(! env e pes v bv s1 s2.((((
evaluate' s1) env) e) ((Rval (s2,v)))) /\(((((
evaluate_match' s2) env) v) pes) bv)
==>
evaluate' s1 env (((Mat e) pes)) bv)

/\

(! env e pes err s.((((
evaluate' s) env) e) ((Rerr err)))
==>
evaluate' s env (((Mat e) pes)) ((Rerr err)))

/\

(! env n e1 e2 v bv s1 s2.((((
evaluate' s1) env) e1) ((Rval (s2,v)))) /\((((
evaluate' s2) ((((bind n) v) env))) e2) bv)
==>
evaluate' s1 env ((((Let n) e1) e2)) bv)

/\

(! env n e1 e2 err s.((((
evaluate' s) env) e1) ((Rerr err)))
==>
evaluate' s env ((((Let n) e1) e2)) ((Rerr err)))

/\

(! env funs e bv s.(
ALL_DISTINCT (((MAP (\ (x,y,z) . x)) funs))) /\((((
evaluate' s) (((build_rec_env funs) env))) e) bv)
==>
evaluate' s env (((Letrec funs) e)) bv)

/\

(! env funs e s.(
~  ((ALL_DISTINCT (((MAP (\ (x,y,z) . x)) funs)))))
==>
evaluate' s env (((Letrec funs) e)) ((Rerr Rtype_error)))

/\

(! env s.
T
==>
evaluate_list' s env [] ((Rval (s,[]))))

/\

(! env e es v vs s1 s2 s3.((((
evaluate' s1) env) e) ((Rval (s2,v)))) /\((((
evaluate_list' s2) env) es) ((Rval (s3,vs))))
==>
evaluate_list' s1 env (e::es) ((Rval (s3,v::vs))))

/\

(! env e es err s.((((
evaluate' s) env) e) ((Rerr err)))
==>
evaluate_list' s env (e::es) ((Rerr err)))

/\

(! env e es v err s1 s2.((((
evaluate' s1) env) e) ((Rval (s2,v)))) /\((((
evaluate_list' s2) env) es) ((Rerr err)))
==>
evaluate_list' s1 env (e::es) ((Rerr err)))

/\

(! env v s.
T
==>
evaluate_match' s env v [] ((Rerr ((Rraise Bind_error)))))

/\

(! env v p e pes env' bv s.(
ALL_DISTINCT (((pat_bindings p) []))) /\
(((((pmatch' s) p) v) env) =( Match env')) /\((((
evaluate' s) env') e) bv)
==>
evaluate_match' s env v ((p,e)::pes) bv)

/\

(! env v p e pes bv s.(
ALL_DISTINCT (((pat_bindings p) []))) /\
(((((pmatch' s) p) v) env) = No_match) /\(((((
evaluate_match' s) env) v) pes) bv)
==>
evaluate_match' s env v ((p,e)::pes) bv)

/\

(! env v p e pes s.
(((((pmatch' s) p) v) env) = Match_type_error)
==>
evaluate_match' s env v ((p,e)::pes) ((Rerr Rtype_error)))

/\

(! env v p e pes s.(
~  ((ALL_DISTINCT (((pat_bindings p) [])))))
==>
evaluate_match' s env v ((p,e)::pes) ((Rerr Rtype_error)))`;


val _ = Hol_reln `

(! cenv env s.
T
==>
evaluate_decs' cenv s env [] ((Rval (cenv,s,env))))

/\

(! cenv env p e ds v env' r s1 s2.((((
evaluate' s1) env) e) ((Rval (s2,v)))) /\(
ALL_DISTINCT (((pat_bindings p) []))) /\
((((((pmatch cenv) s2) p) v) env) =( Match env')) /\(((((
evaluate_decs' cenv) s2) env') ds) r)
==>
evaluate_decs' cenv s1 env (((Dlet p) e) :: ds) r)

/\

(! cenv env p e ds v s1 s2.((((
evaluate' s1) env) e) ((Rval (s2,v)))) /\(
ALL_DISTINCT (((pat_bindings p) []))) /\
((((((pmatch cenv) s2) p) v) env) = No_match)
==>
evaluate_decs' cenv s1 env (((Dlet p) e) :: ds) ((Rerr ((Rraise Bind_error)))))

/\

(! cenv env p e ds v s1 s2.((((
evaluate' s1) env) e) ((Rval (s2,v)))) /\
((((((pmatch cenv) s2) p) v) env) = Match_type_error)
==>
evaluate_decs' cenv s1 env (((Dlet p) e) :: ds) ((Rerr (Rtype_error))))

/\

(! cenv env p e ds v s1 s2.((((
evaluate' s1) env) e) ((Rval (s2,v)))) /\(
~  ((ALL_DISTINCT (((pat_bindings p) [])))))
==>
evaluate_decs' cenv s1 env (((Dlet p) e) :: ds) ((Rerr (Rtype_error))))

/\

(! cenv env p e ds err s.((((
evaluate' s) env) e) ((Rerr err)))
==>
evaluate_decs' cenv s env (((Dlet p) e) :: ds) ((Rerr err)))

/\

(! cenv env funs ds r s.(
ALL_DISTINCT (((MAP (\ (x,y,z) . x)) funs))) /\(((((
evaluate_decs' cenv) s) (((build_rec_env funs) env))) ds) r)
==>
evaluate_decs' cenv s env ((Dletrec funs) :: ds) r)

/\

(! cenv env funs ds s.(
~  ((ALL_DISTINCT (((MAP (\ (x,y,z) . x)) funs)))))
==>
evaluate_decs' cenv s env ((Dletrec funs) :: ds) ((Rerr Rtype_error)))

/\

(! cenv env tds ds r s.((
check_dup_ctors tds) cenv) /\(((((
evaluate_decs' (((merge ((build_tdefs tds))) cenv))) s) env) ds) r)
==>
evaluate_decs' cenv s env ((Dtype tds) :: ds) r)

/\

(! cenv env tds ds s.(
~  (((check_dup_ctors tds) cenv)))
==>
evaluate_decs' cenv s env ((Dtype tds) :: ds) ((Rerr Rtype_error)))`;
val _ = export_theory()

