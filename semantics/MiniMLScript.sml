(*Generated by Lem from semantics/miniML.lem.*)
open bossLib Theory Parse res_quanTheory
open finite_mapTheory listTheory pairTheory pred_setTheory integerTheory
open set_relationTheory sortingTheory stringTheory wordsTheory

val _ = numLib.prefer_num();

val _ = new_theory "MiniML"

open TokensTheory

(* By Scott Owens, University of Cambridge, Copyright 2011, 2012
 *                 University of Kent 2012, 2013
 *
 * MiniML is a simple ML-like language. It has no type abbreviations, or
 * records, and only simple top-level modules.  It has mutually recursive
 * datatypes (at the top-level and module top-level only) and functions, as
 * well as higher-order functions.  It also supports pattern matching for
 * nested patterns (which can fail due to non-exhaustive patterns).  Only
 * booleans and integer types are built-in.  Syntactic sugar is generally
 * omitted.
 *
 * In some ways it makes more sense to write these kind of semantics in Ott (to
 * get a presentation that looks like ML concrete-syntax-wise, and that has the
 * usual syntax for type systems and operational semantics, i.e., with |- and
 * horizontal lines).  Here in Lem, everything looks like abstract syntax;
 * however, unlike Ott, we get good support for functions, and not just
 * relations.
 *
 * The small-step operational semantics is based on the CEK machine.  The type
 * system is typical.  The big step semantics is also typical.  The small-step
 * and big-step semantics agree even on untyped programs. *)

(*val i : num -> Int.int*)

(*val all_distinct : forall 'a. list 'a -> bool*)

(*val rtc : forall 'a. ('a -> 'a -> bool) -> ('a -> 'a -> bool)*)

(*val option_map : forall 'a 'b. ('a -> 'b) -> option 'a -> option 'b*)
val _ = Define `
 (option_map f x = 
  (case x of
      NONE => NONE
    | SOME y => SOME (f y)
  ))`;


(* Change the nth element in the list to 'a *)
(*val LUPDATE : forall 'a. 'a -> num -> list 'a -> list 'a*)

(* Environments *)
val _ = type_abbrev((* ( 'a, 'b) *) "env" , ``: ('a#'b) list``);

(*val emp : forall 'a 'b. env 'a 'b*)
val _ = Define `
 emp = []`;


(*val lookup : forall 'a 'b. 'a -> env 'a 'b -> option 'b*)
 val lookup_defn = Hol_defn "lookup" `

(lookup n [] = NONE)
/\
(lookup n ((n',v)::e) =
  if n' = n then
    SOME v
  else
    lookup n e)`;

val _ = Defn.save_defn lookup_defn;

(*val bind : forall 'a 'b. 'a -> 'b -> env 'a 'b -> env 'a 'b*)
val _ = Define `
 (bind n v e = (n,v) ::e)`;


(*val merge : forall 'a 'b. env 'a 'b -> env 'a 'b -> env 'a 'b*)
val _ = Define `
 (merge e1 e2 = e1 ++ e2)`;


(* ------------------------------------------------------------------------ *) 
(*   The Abstract Syntax                                                    *)
(* ------------------------------------------------------------------------ *) 

(* Literal constants *)
val _ = Hol_datatype `
 lit =
    IntLit of int
  | Bool of bool
  | Unit`;


(* Built-in binary operations (including function application) *)

val _ = Hol_datatype `
 opn = Plus | Minus | Times | Divide | Modulo`;

val _ = Hol_datatype `
 opb = Lt | Gt | Leq | Geq`;


val _ = Define `
 (opn_lookup n = (case n of
    Plus => int_add
  | Minus => (int_sub)
  | Times => int_mul
  | Divide => int_div
  | Modulo => int_mod
))`;


val _ = Define `
 (opb_lookup n : int -> int -> bool = (case n of
    Lt => int_lt
  | Gt => int_gt
  | Leq => int_le
  | Geq => int_ge
))`;


(* Opapp is function application *)
val _ = Hol_datatype `
 op =
    Opn of opn
  | Opb of opb
  | Equality
  | Opapp
  | Opassign`;


val _ = Hol_datatype `
 uop =
    Opref
  | Opderef`;


(* Built-in logical operations *)
val _ = Hol_datatype `
 log =
    And
  | Or`;


(* Module names *)
val _ = type_abbrev( "modN" , ``: string``);
(* Identifiers *)
val _ = Hol_datatype `
 id =
    Short of 'a
  | Long of modN => 'a`;

(* Variable names *)
val _ = type_abbrev( "varN" , ``: string``);
(* Constructor names (from datatype definitions) *)
val _ = type_abbrev( "conN" , ``: string``);
(* Type names *)
val _ = type_abbrev( "typeN" , ``: string``);
(* Type variable names *)
val _ = type_abbrev( "tvarN" , ``: string``);

(*val mk_id : forall 'a. option modN -> 'a -> id 'a*)
val _ = Define `
 (mk_id mn_opt n =
  (case mn_opt of
      NONE => Short n
    | SOME mn => Long mn n
  ))`;


(* Types
 * 0-ary type applications represent unparameterised types (e.g., num or string)
 *)
val _ = Hol_datatype `
 tc0 = 
    TC_name of typeN id
  | TC_int
  | TC_bool
  | TC_unit
  | TC_ref
  | TC_fn`;


val _ = Hol_datatype `
 t =
    Tvar of tvarN
  (* DeBruin indexed type variables. *)
  | Tvar_db of num
  | Tapp of t list =>tc0`;


val _ = Define `
 Tint = Tapp [] TC_int`;

val _ = Define `
 Tunit = Tapp [] TC_unit`;

val _ = Define `
 Tbool = Tapp [] TC_bool`;

val _ = Define `
 (Tref t = Tapp [t] TC_ref)`;

val _ = Define `
 (Tfn t1 t2 = Tapp [t1;t2] TC_fn)`;


(* Patterns *)
val _ = Hol_datatype `
 pat =
  (* We optionally type annotate all binders *)
    Pvar of varN => 'a option
  | Plit of lit
  (* Constructor applications. *)
  | Pcon of conN id => (pat) list
  | Pref of pat`;


(* Runtime errors.  Temporary: later on we want to move to SML-style declared
 * exception constructors *)
val _ = Hol_datatype `
 error =
    Bind_error
  | Div_error
  | Int_error of int`;


(* Expressions *)
(* We optionally type annotate all binders with a value of type 'a *)
val _ = Hol_datatype `
 exp =
  (* Temporary: later on we want Raise of exp *)
    Raise of error
  (* Temporary: later on we want Handle of exp * list (pat 'a * exp) *)
  (* We don't type annotate this binder because it must be an int *)
  | Handle of exp => varN => exp
  | Lit of lit
  (* Constructor application. *)
  | Con of conN id => (exp) list
  (* The optional type list is the type application in the case that the
   * variable references a polymorphic binding. *)
  | Var of varN id => ( 'a list) option
  | Fun of varN => 'a option => exp
  (* Application of a unary operator *)
  | Uapp of uop => exp
  (* Application of an operator (including function application) *)
  | App of op => exp => exp
  (* Logical operations (and, or) *)
  | Log of log => exp => exp
  | If of exp => exp => exp
  (* Pattern matching *)
  | Mat of exp => ( 'a pat # exp) list
  (* The number is how many type variables are bound. *)
  | Let of num option => varN => 'a option => exp => exp
  (* Local definition of (potentially) mutually recursive functions
   * The first varN is the function's name, and the second varN is its
   * parameter.
   * The number is how many type variables are bound. *)
  | Letrec of num option => (varN # 'a option # varN # 'a option # exp) list => exp`;


val _ = type_abbrev( "type_def" , ``: ( tvarN list # typeN # (conN # t list) list) list``);

(* Declarations *)
val _ = Hol_datatype `
 dec =
  (* Top-level bindings
   * The number is how many type variables are bound.
   * The pattern allows several names to be bound at once *)
    Dlet of num option => 'a pat => 'a exp
  (* Mutually recursive function definition
   * The number is how many type variables are bound. *)
  | Dletrec of num option => (varN # 'a option # varN # 'a option # 'a exp) list
  (* Type definition
     Defines several types, each of which has several named variants, which can
     in turn have several arguments *)
  | Dtype of type_def`;


val _ = type_abbrev((*  'a *) "decs" , ``: ( 'a dec) list``);

val _ = Hol_datatype `
 spec =
    Sval of varN => t
  | Stype of type_def
  | Stype_opq of typeN`;


val _ = type_abbrev( "specs" , ``: spec list``);

val _ = Hol_datatype `
 top =
    Tmod of modN => specs => 'a decs
  | Tdec of 'a dec`;


val _ = type_abbrev((*  'a *) "prog" , ``: ( 'a top) list``);


(* ------------------------------------------------------------------------ *) 
(*   The Semantics                                                          *)
(* ------------------------------------------------------------------------ *) 

(* Value forms *)
val _ = Hol_datatype `
 v =
    Litv of lit
  (* Constructor application. *)
  | Conv of conN id => (v) list
  (* Function closures
     The environment is used for the free variables in the function *)
  | Closure of (varN, (v # (num # 'a) option)) env => varN => 'a option => 'a exp
  (* Function closure for recursive functions
   * See Closure and Letrec above
   * The last variable name indicates which function from the mutually
   * recursive bundle this closure value represents *)
  | Recclosure of (varN, (v # (num # 'a) option)) env => (varN # 'a option # varN # 'a option # 'a exp) list => varN
  | Loc of num`;



(* Type substitution *)

(* Increment the deBruijn indices in a type by n levels, skipping all levels
 * less than skip. *)
(*val deBruijn_inc : num -> num -> t -> t*)
 val deBruijn_inc_defn = Hol_defn "deBruijn_inc" `

(deBruijn_inc skip n (Tvar tv) = Tvar tv)
/\
(deBruijn_inc skip n (Tvar_db m) =
  if m < skip then
    Tvar_db m
  else
    Tvar_db (m + n))
/\
(deBruijn_inc skip n (Tapp ts tn) = Tapp ( MAP (deBruijn_inc skip n) ts) tn)`;

val _ = Defn.save_defn deBruijn_inc_defn;

(* skip the lowest given indices and replace the next (LENGTH ts) with the given types and reduce all the higher ones *)
(*val deBruijn_subst : num -> list t -> t -> t*)
 val deBruijn_subst_defn = Hol_defn "deBruijn_subst" `

(deBruijn_subst skip ts (Tvar tv) = Tvar tv)
/\
(deBruijn_subst skip ts (Tvar_db n) =
  if ~  (n < skip) /\ n < LENGTH ts + skip then EL  (n - skip)  ts
  else if ~  (n < skip) then
    Tvar_db (n - LENGTH ts)
  else
    Tvar_db n)
/\
(deBruijn_subst skip ts (Tapp ts' tn) =
  Tapp ( MAP (deBruijn_subst skip ts) ts') tn)`;

val _ = Defn.save_defn deBruijn_subst_defn;

(*val deBruijn_subst_p : num -> list t -> pat t -> pat t*) 
 val deBruijn_subst_p_defn = Hol_defn "deBruijn_subst_p" `

(deBruijn_subst_p skip ts (Pvar x topt) =
  Pvar x (option_map (deBruijn_subst skip ts) topt))
/\
(deBruijn_subst_p skip ts (Plit l) = Plit l)
/\
(deBruijn_subst_p skip ts (Pcon cn ps) = 
  Pcon cn ( MAP (deBruijn_subst_p skip ts) ps))
/\
(deBruijn_subst_p skip ts (Pref p) =
  Pref (deBruijn_subst_p skip ts p))`;

val _ = Defn.save_defn deBruijn_subst_p_defn;

(*val deBruijn_subst_e : num -> list t -> exp t -> exp t*) 
 val deBruijn_subst_e_defn = Hol_defn "deBruijn_subst_e" `

(deBruijn_subst_e skip ts (Raise err) = Raise err)
/\
(deBruijn_subst_e skip ts (Handle e1 n e2) = 
  Handle (deBruijn_subst_e skip ts e1) n (deBruijn_subst_e skip ts e2))
/\
(deBruijn_subst_e skip ts (Lit l) = Lit l)
/\
(deBruijn_subst_e skip ts (Con cn es) =
  Con cn ( MAP (deBruijn_subst_e skip ts) es))
/\
(deBruijn_subst_e skip ts (Var v targs_opt) =
  Var v (option_map ( MAP (deBruijn_subst skip ts)) targs_opt))
/\
(deBruijn_subst_e skip ts (Fun x topt e) =
  Fun x (option_map (deBruijn_subst skip ts) topt) (deBruijn_subst_e skip ts e))
/\
(deBruijn_subst_e skip ts (Uapp uop e) =
  Uapp uop (deBruijn_subst_e skip ts e))
/\
(deBruijn_subst_e skip ts (App bop e1 e2) =
  App bop (deBruijn_subst_e skip ts e1) (deBruijn_subst_e skip ts e2))
/\
(deBruijn_subst_e skip ts (Log lop e1 e2) =
  Log lop (deBruijn_subst_e skip ts e1) (deBruijn_subst_e skip ts e2))
/\
(deBruijn_subst_e skip ts (If e1 e2 e3) =
  If (deBruijn_subst_e skip ts e1) (deBruijn_subst_e skip ts e2) (deBruijn_subst_e skip ts e3))
/\
(deBruijn_subst_e skip ts (Mat e pes) =
  Mat (deBruijn_subst_e skip ts e) 
      ( MAP (\ (p,e) . (deBruijn_subst_p skip ts p, deBruijn_subst_e skip ts e)) pes))
/\
(deBruijn_subst_e skip ts (Let tvs x topt e1 e2) =
  let skip' = (case tvs of   NONE => skip | SOME x => x + skip ) in
  let ts' = (case tvs of   NONE => ts | SOME tvs => MAP (deBruijn_inc 0 tvs) ts ) in
    Let tvs x 
      (option_map (deBruijn_subst skip' ts') topt)
      (deBruijn_subst_e skip' ts' e1)
      (deBruijn_subst_e skip ts e2))
/\
(deBruijn_subst_e skip ts (Letrec tvs funs e) =
  let skip' = (case tvs of   NONE => skip | SOME x => x + skip ) in
  let ts' = (case tvs of   NONE => ts | SOME tvs => MAP (deBruijn_inc 0 tvs) ts ) in
    Letrec tvs 
      ( MAP (\ (f,topt1,x,topt2,e) . 
                   (f,
                    option_map (deBruijn_subst skip' ts') topt1,
                    x,
                    option_map (deBruijn_subst skip' ts') topt2,
                    (deBruijn_subst_e skip' ts' e)))
         funs) 
      (deBruijn_subst_e skip ts e))`;

val _ = Defn.save_defn deBruijn_subst_e_defn;

(*val deBruijn_subst_v : list t -> v t -> v t*)
 val deBruijn_subst_v_defn = Hol_defn "deBruijn_subst_v" `

(deBruijn_subst_v ts (Litv lit) = Litv lit)
/\
(deBruijn_subst_v ts (Conv cn vs) =
  Conv cn ( MAP (deBruijn_subst_v ts) vs))
/\
(deBruijn_subst_v ts (Closure env x topt e) =
  Closure env x (option_map (deBruijn_subst 0 ts) topt) (deBruijn_subst_e 0 ts e))
/\
(deBruijn_subst_v ts (Recclosure env funs f) =
  Recclosure env
      ( MAP (\ (f,topt1,x,topt2,e) . 
                   (f,
                    option_map (deBruijn_subst 0 ts) topt1,
                    x,
                    option_map (deBruijn_subst 0 ts) topt2,
                    (deBruijn_subst_e 0 ts e)))
         funs) 
    f)
/\
(deBruijn_subst_v ts (Loc l) = Loc l)`;

val _ = Defn.save_defn deBruijn_subst_v_defn;

(* Environments *)

(* Maps each constructor to its arity and which type it is from *)
val _ = type_abbrev( "envC" , ``: (( conN id), (num # typeN id)) env``);

(* The optional type scheme annotation's type variable binding scopes over the
 * value too *)
val _ = type_abbrev((*  'a *) "envE" , ``: (varN, ( 'a v # (num # 'a) option)) env``);

(* The bindings of a module *)
val _ = type_abbrev((*  'a *) "envM" , ``: (modN, ( 'a envE)) env``);

(*val lookup_var_id : forall 'a. id varN -> envM 'a -> envE 'a -> option (v 'a * option (num * 'a))*)
val _ = Define `
 (lookup_var_id id menv envE =
  (case id of
      Short x => lookup x envE
    | Long x y =>
        (case lookup x menv of
            NONE => NONE
          | SOME env => lookup y env
        )
  ))`;


(*val add_tvs : forall 'a. option num -> option 'a -> option (num * 'a)*)
val _ = Define `
 (add_tvs tvsopt topt =
  (case topt of
      NONE => NONE
    | SOME t => 
        (case tvsopt of
            NONE => NONE
          | SOME tvs => SOME (tvs, t)
        )
  ))`;


(* Stores *)
(* The nth item in the list is the value at location n *)
val _ = type_abbrev((*  'a *) "store" , ``: ( 'a v) list``);

(*val empty_store : forall 'a. store 'a*)
val _ = Define `
 empty_store = []`;


(*val store_lookup : forall 'a. num -> store 'a -> option (v 'a)*)
val _ = Define `
 (store_lookup l st =
  if l < LENGTH st then
    SOME ( EL  l  st)
  else
    NONE)`;


(*val store_alloc : forall 'a. v 'a -> store 'a -> store 'a * num*)
val _ = Define `
 (store_alloc v st =
  (st ++ [v], LENGTH st))`;


(*val store_assign : forall 'a. num -> v 'a -> store 'a -> option (store 'a)*)
val _ = Define `
 (store_assign n v st =
  if n < LENGTH st then
    SOME ( LUPDATE v n st)
  else
    NONE)`;



(* Evaluation contexts
 * The hole is denoted by the unit type
 * The env argument contains bindings for the free variables of expressions in
     the context *)
val _ = Hol_datatype `
 ctxt_frame =
    Chandle of unit => varN => 'a exp
  | Capp1 of op => unit => 'a exp
  | Capp2 of op => 'a v => unit
  | Clog of log => unit => 'a exp
  | Cif of unit => 'a exp => 'a exp
  | Cmat of unit => ( 'a pat # 'a exp) list
  | Clet of num option => varN => 'a option => unit => 'a exp
  (* Evaluating a constructor's arguments
   * The v list should be in reverse order. *)
  | Ccon of conN id => ( 'a v) list => unit => ( 'a exp) list
  | Cuapp of uop => unit`;

val _ = type_abbrev((*  'a *) "ctxt" , ``: 'a ctxt_frame # 'a envE``);

(*val lit_same_type : lit -> lit -> bool*)
val _ = Define `
 (lit_same_type l1 l2 =
  (case (l1,l2) of
      (IntLit _, IntLit _) => T
    | (Bool _, Bool _) => T
    | (Unit, Unit) => T
    | _ => F
  ))`;


val _ = Hol_datatype `
 match_result =
    No_match
  | Match_type_error
  | Match of 'a envE`;


(* A big-step pattern matcher.  If the value matches the pattern, return an
 * environment with the pattern variables bound to the corresponding sub-terms
 * of the value; this environment extends the environment given as an argument.
 * No_match is returned when there is no match, but any constructors
 * encountered in determining the match failure are applied to the correct
 * number of arguments, and constructors in corresponding positions in the
 * pattern and value come from the same type.  Match_type_error is returned
 * when one of these conditions is violated *)
(*val pmatch : forall 'a. option num -> envC -> store 'a -> pat 'a -> v 'a -> envE 'a -> match_result 'a*)
 val pmatch_defn = Hol_defn "pmatch" `

(pmatch tvs envC s (Pvar x topt) v' env = Match (bind x (v', add_tvs tvs topt) env))
/\
(pmatch tvs envC s (Plit l) (Litv l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error)
/\
(pmatch tvs envC s (Pcon n ps) (Conv n' vs) env =
  (case (lookup n envC, lookup n' envC) of
      (SOME (l, t), SOME (l', t')) =>
        if (t = t') /\ ( LENGTH ps = l) /\ ( LENGTH vs = l') then
          if n = n' then
            pmatch_list tvs envC s ps vs env
          else
            No_match
        else
          Match_type_error
    | (_, _) => Match_type_error
  ))
/\
(pmatch tvs envC s (Pref p) (Loc lnum) env =
  (case store_lookup lnum s of
      SOME v => pmatch tvs envC s p v env
    | NONE => Match_type_error
  ))
/\
(pmatch tvs envC _ _ _ env = Match_type_error)
/\
(pmatch_list tvs envC s [] [] env = Match env)
/\
(pmatch_list tvs envC s (p::ps) (v::vs) env =
  (case pmatch tvs envC s p v env of
      No_match => No_match
    | Match_type_error => Match_type_error
    | Match env' => pmatch_list tvs envC s ps vs env'
  ))
/\
(pmatch_list tvs envC s _ _ env = Match_type_error)`;

val _ = Defn.save_defn pmatch_defn;

(* Accumulates the bindings of a patterns *)
(*val pat_bindings : forall 'a. pat 'a -> list varN -> list varN*)
 val pat_bindings_defn = Hol_defn "pat_bindings" `

(pat_bindings (Pvar n topt) already_bound =
  n ::already_bound)
/\
(pat_bindings (Plit l) already_bound =
  already_bound)
/\
(pat_bindings (Pcon _ ps) already_bound =
  pats_bindings ps already_bound)
/\
(pat_bindings (Pref p) already_bound =
  pat_bindings p already_bound)
/\
(pats_bindings [] already_bound =
  already_bound)
/\
(pats_bindings (p::ps) already_bound =
  pats_bindings ps (pat_bindings p already_bound))`;

val _ = Defn.save_defn pat_bindings_defn;

(* State for CEK-style expression evaluation
 * - constructor data
 * - the store
 * - the environment for the free variables of the current expression
 * - the current expression to evaluate, or a value if finished
 * - the context stack (continuation) of what to do once the current expression
 *   is finished.  Each entry has an environment for it's free variables *)
val _ = Hol_datatype `
 exp_or_val =
    Exp of 'a exp
  | Val of 'a v`;


val _ = type_abbrev((*  'a *) "state" , ``: 'a envM # envC # 'a store # 'a envE # 'a exp_or_val # ( 'a ctxt) list``);

val _ = Hol_datatype `
 e_step_result =
    Estep of 'a state
  | Etype_error
  | Estuck`;


(* The semantics are deterministic, and presented functionally instead of
 * relationally for proof rather that readability; the steps are very small: we
 * push individual frames onto the context stack instead of finding a redex in a
 * single step *)

(*val push : forall 'a. envM 'a -> envC -> store 'a -> envE 'a -> exp 'a -> ctxt_frame 'a -> list (ctxt 'a) -> e_step_result 'a*)
val _ = Define `
 (push envM envC s env e c' cs = Estep (envM, envC, s, env, Exp e, (c',env) ::cs))`;


(*val return : forall 'a. envM 'a -> envC -> store 'a -> envE 'a -> v 'a -> list (ctxt 'a) -> e_step_result 'a*)
val _ = Define `
 (return envM envC s env v c = Estep (envM, envC, s, env, Val v, c))`;


(* Bind each function of a mutually recursive set of functions to its closure *)
(*val build_rec_env : forall 'a. option num -> list (varN * option 'a * varN * option 'a * exp 'a) -> envE 'a -> envE 'a -> envE 'a*)
val _ = Define `
 (build_rec_env tvs funs cl_env add_to_env = FOLDR 
    (\ (f,topt,x,topt',e) env' . bind f (Recclosure cl_env funs f, add_tvs tvs topt) env') 
    add_to_env 
    funs)`;


(* Lookup in the list of mutually recursive functions *)
(*val find_recfun : forall 'a. varN -> list (varN * option 'a * varN * option 'a * exp 'a) -> option (varN * option 'a * exp 'a)*)
 val find_recfun_defn = Hol_defn "find_recfun" `
 (find_recfun n funs =
  (case funs of
      [] => NONE
    | (f,_,x,topt,e) :: funs =>
        if f = n then
          SOME (x,topt,e)
        else
          find_recfun n funs
  ))`;

val _ = Defn.save_defn find_recfun_defn;

(* Do an application *)
(*val do_app : forall 'a. store 'a -> envE 'a -> op -> v 'a -> v 'a -> option (store 'a * envE 'a * exp 'a)*)
val _ = Define `
 (do_app s env' op v1 v2 =
  (case (op, v1, v2) of
      (Opapp, Closure env n topt e, v) =>
        SOME (s, bind n (v, add_tvs (SOME 0) topt) env, e)
    | (Opapp, Recclosure env funs n, v) =>
        (case find_recfun n funs of
            SOME (n,topt,e) => SOME (s, bind n (v, add_tvs (SOME 0) topt) (build_rec_env (SOME 0) funs env env), e)
          | NONE => NONE
        )
    | (Opn op, Litv (IntLit n1), Litv (IntLit n2)) =>
        if ((op = Divide) \/ (op = Modulo)) /\ (n2 = & 0) then
          SOME (s, env', Raise Div_error)
        else
          SOME (s, env',Lit (IntLit (opn_lookup op n1 n2)))
    | (Opb op, Litv (IntLit n1), Litv (IntLit n2)) =>
        SOME (s, env', Lit (Bool (opb_lookup op n1 n2)))
    | (Equality, v1, v2) =>
        (* TODO: Check for closures in v1 and v2, and possibly check that they
         * have the same type *)
        SOME (s, env', Lit (Bool (v1 = v2)))
    | (Opassign, (Loc lnum), v) =>
        (case store_assign lnum v s of
          SOME st => SOME (st, env', Lit Unit)
        | NONE => NONE
        )
    | _ => NONE
  ))`;


(* Do a logical operation *)
(*val do_log : forall 'a. log -> v 'a -> exp 'a -> option (exp 'a)*)
val _ = Define `
 (do_log l v e =
  (case (l, v) of
      (And, Litv (Bool T)) => SOME e
    | (Or, Litv (Bool F)) => SOME e
    | (_, Litv (Bool b)) => SOME (Lit (Bool b))
    | _ => NONE
  ))`;


(* Do an if-then-else *)
(*val do_if : forall 'a. v 'a -> exp 'a -> exp 'a -> option (exp 'a)*)
val _ = Define `
 (do_if v e1 e2 =
  if v = Litv (Bool T) then
    SOME e1
  else if v = Litv (Bool F) then
    SOME e2
  else
    NONE)`;


(* Check that a constructor is properly applied *)
(*val do_con_check : envC -> id conN -> num -> bool*)
val _ = Define `
 (do_con_check cenv n l =
  (case lookup n cenv of
      NONE => F
    | SOME (l',ns) => l = l'
  ))`;


(*val do_uapp : forall 'a. store 'a -> uop -> v 'a -> option (store 'a * v 'a)*)
val _ = Define `
 (do_uapp s uop v =
  (case uop of
      Opderef =>
        (case v of
            Loc n =>
              (case store_lookup n s of
                  SOME v => SOME (s,v)
                | NONE => NONE
              )
          | _ => NONE
        )
    | Opref =>
        let (s',n) = store_alloc v s in
          SOME (s', Loc n)
  ))`;


(* apply a context to a value *)
(*val continue : forall 'a. envM 'a -> envC -> store 'a -> v 'a -> list (ctxt 'a) -> e_step_result 'a*)
val _ = Define `
 (continue envM envC s v cs =
  (case cs of
      [] => Estuck
    | (Chandle ()  n e, env) :: c =>
        return envM envC s env v c
    | (Capp1 op ()  e, env) :: c =>
        push envM envC s env e (Capp2 op v () ) c
    | (Capp2 op v' () , env) :: c =>
        (case do_app s env op v' v of
            SOME (s',env,e) => Estep (envM, envC, s', env, Exp e, c)
          | NONE => Etype_error
        )
    | (Clog l ()  e, env) :: c =>
        (case do_log l v e of
            SOME e => Estep (envM, envC, s, env, Exp e, c)
          | NONE => Etype_error
        )
    | (Cif ()  e1 e2, env) :: c =>
        (case do_if v e1 e2 of
            SOME e => Estep (envM, envC, s, env, Exp e, c)
          | NONE => Etype_error
        )
    | (Cmat ()  [], env) :: c =>
        Estep (envM, envC, s, env, Exp (Raise Bind_error), c)
    | (Cmat ()  ((p,e)::pes), env) :: c =>
        if ALL_DISTINCT (pat_bindings p []) then
          (case pmatch (SOME 0) envC s p v env of
              Match_type_error => Etype_error
            | No_match => Estep (envM, envC, s, env, Val v, (Cmat ()  pes,env) ::c)
            | Match env' => Estep (envM, envC, s, env', Exp e, c)
          )
        else
          Etype_error
    | (Clet tvs n topt ()  e, env) :: c =>
        Estep (envM, envC, s, bind n (v, add_tvs tvs topt) env, Exp e, c)
    | (Ccon n vs ()  [], env) :: c =>
        if do_con_check envC n ( LENGTH vs + 1) then
          return envM envC s env (Conv n ( REVERSE (v ::vs))) c
        else
          Etype_error
    | (Ccon n vs ()  (e::es), env) :: c =>
        if do_con_check envC n ( LENGTH vs + 1 + 1 + LENGTH es) then
          push envM envC s env e (Ccon n (v ::vs) ()  es) c
        else
          Etype_error
    | (Cuapp uop () , env) :: c =>
       (case do_uapp s uop v of
           SOME (s',v') => return envM envC s' env v' c
         | NONE => Etype_error
       )
  ))`;


(*val do_tapp : option (num * t) -> option (list t) -> v t -> v t*)
val _ = Define `
 (do_tapp tscheme_opt targs_opt v =
  (case (tscheme_opt, targs_opt) of
      (SOME (tvs, tscheme), SOME targs) =>
        if tvs = LENGTH targs then
          deBruijn_subst_v targs v
        else
          v
    | _ => v
  ))`;


(* The single step expression evaluator.  Returns None if there is nothing to
 * do, but no type error.  Returns Type_error on encountering free variables,
 * mis-applied (or non-existent) constructors, and when the wrong kind of value
 * if given to a primitive.  Returns Bind_error when no pattern in a match
 * matches the value.  Otherwise it returns the next state *)

(*val e_step : state t -> e_step_result t*)
val _ = Define `
 (e_step (envM, envC, s, env, ev, c) =
  (case ev of
      Val v  =>
	continue envM envC s v c
    | Exp e =>
        (case e of
            Lit l => return envM envC s env (Litv l) c
          | Raise e =>
              (case c of
                  [] => Estuck
                | ((Chandle ()  n e',env') :: c) =>
                     (case e of
                          Int_error i =>
                           Estep (envM,envC,s,(bind n (Litv (IntLit i), SOME (0,Tint)) env'),Exp e',c)
                        | _ => Estep (envM,envC,s,env,Exp (Raise e),c)
                     )
                | _::c => Estep (envM,envC,s,env,Exp (Raise e),c)
              )
          | Handle e n e' =>
              push envM envC s env e (Chandle ()  n e') c
          | Con n es =>
              if do_con_check envC n ( LENGTH es) then
                (case es of
                    [] => return envM envC s env (Conv n []) c
                  | e::es =>
                      push envM envC s env e (Ccon n [] ()  es) c
                )
              else
                Etype_error
          | Var n targs_opt =>
              (case lookup_var_id n envM env of
                  NONE => Etype_error
                | SOME (v,type_scheme_opt) => 
                    return envM envC s env (do_tapp type_scheme_opt targs_opt v) c
              )
          | Fun n topt e => return envM envC s env (Closure env n topt e) c
          | App op e1 e2 => push envM envC s env e1 (Capp1 op ()  e2) c
          | Log l e1 e2 => push envM envC s env e1 (Clog l ()  e2) c
          | If e1 e2 e3 => push envM envC s env e1 (Cif ()  e2 e3) c
          | Mat e pes => push envM envC s env e (Cmat ()  pes) c
          | Let tvs n topt e1 e2 => push envM envC s env e1 (Clet tvs n topt ()  e2) c
          | Letrec tvs funs e =>
              if ~  ( ALL_DISTINCT ( MAP (\ (x,a,y,b,z) . x) funs)) then
                Etype_error
              else
                Estep (envM,envC, s, build_rec_env tvs funs env env, Exp e, c)
          | Uapp uop e =>
              push envM envC s env e (Cuapp uop () ) c
        )
  ))`;


(* Define a semantic function using the steps *)

val _ = Hol_datatype `
 error_result =
    Rtype_error
  | Rraise of error`;


val _ = Hol_datatype `
 result =
    Rval of 'a
  | Rerr of error_result`;


(*val e_step_reln : state t -> state t -> bool*)
(*val small_eval : envM t -> envC -> store t -> envE t -> exp t -> list (ctxt t) -> store t * result (v t) -> bool*)

val _ = Define `
 (e_step_reln st1 st2 =
  (e_step st1 = Estep st2))`;


 val small_eval_def = Define `

(small_eval menv cenv s env e c (s', Rval v) =
  ? env'. ( RTC e_step_reln) (menv,cenv,s,env,Exp e,c) (menv,cenv,s',env',Val v,[]))
/\
(small_eval menv cenv s env e c (s', Rerr (Rraise err)) =
  ? env'. ( RTC e_step_reln) (menv,cenv,s,env,Exp e,c) (menv,cenv,s',env',Exp (Raise err),[]))
/\
(small_eval menv cenv s env e c (s', Rerr Rtype_error) =
  ? env' e' c'.
    ( RTC e_step_reln) (menv,cenv,s,env,Exp e,c) (menv,cenv,s',env',e',c') /\
    (e_step (menv,cenv,s',env',e',c') = Etype_error))`;


(*val e_diverges : envM t -> envC -> store t -> envE t -> exp t -> bool*)
val _ = Define `
 (e_diverges menv cenv s env e =
  ! menv' cenv' s' env' e' c'.
    ( RTC e_step_reln) (menv,cenv,s,env,Exp e,[]) (menv',cenv',s',env', e',c') ==>
    (? menv'' cenv'' s'' env'' e'' c''.
      e_step_reln (menv',cenv',s',env', e',c') (menv'',cenv'',s'',env'',e'',c'')))`;


(* ------------------------ Big step semantics -------------------------- *)
(*val evaluate : envM t -> envC -> store t -> envE t -> exp t -> store t * result (v t) -> bool*)
(*val evaluate_list : envM t -> envC -> store t -> envE t -> list (exp t) -> store t * result (list (v t)) -> bool*)
(*val evaluate_match : envM t -> envC -> store t -> envE t -> v t -> list (pat t * exp t) -> store t * result (v t) -> bool*)
(*val evaluate_dec : option modN -> envM t -> envC -> store t -> envE t -> dec t -> store t * result (envC * envE t) -> bool*)
(*val evaluate_decs : option modN -> envM t -> envC -> store t -> envE t -> list (dec t) -> store t * result (envC * envE t) -> bool*)
(*val evaluate_prog : envM t -> envC -> store t -> envE t -> prog t -> store t * result (envM t * envC * envE t) -> bool*)

val _ = Hol_reln `

(! menv cenv env l s.
T
==>
evaluate menv cenv s env (Lit l) (s, Rval (Litv l)))

/\

(! menv cenv env err s.
T
==>
evaluate menv cenv s env (Raise err) (s, Rerr (Rraise err)))

/\

(! menv cenv s1 s2 env e1 e2 v var.
evaluate menv cenv s1 env e1 (s2, Rval v)
==>
evaluate menv cenv s1 env (Handle e1 var e2) (s2, Rval v))

/\

(! menv cenv s1 s2 env e1 e2 n var bv.
evaluate menv cenv s1 env e1 (s2, Rerr (Rraise (Int_error n))) /\
evaluate menv cenv s2 (bind var (Litv (IntLit n), SOME (0, Tint)) env) e2 bv
==>
evaluate menv cenv s1 env (Handle e1 var e2) bv)

/\

(! menv cenv s1 s2 env e1 e2 var err.
evaluate menv cenv s1 env e1 (s2, Rerr err) /\
((err = Rtype_error) \/ (err = Rraise Bind_error) \/ (err = Rraise Div_error))
==>
evaluate menv cenv s1 env (Handle e1 var e2) (s2, Rerr err))

/\

(! menv cenv env cn es vs s s'.
do_con_check cenv cn ( LENGTH es) /\
evaluate_list menv cenv s env es (s', Rval vs)
==>
evaluate menv cenv s env (Con cn es) (s', Rval (Conv cn vs)))

/\

(! menv cenv env cn es s. ~  (do_con_check cenv cn ( LENGTH es))
==>
evaluate menv cenv s env (Con cn es) (s, Rerr Rtype_error))

/\

(! menv cenv env cn es err s s'.
do_con_check cenv cn ( LENGTH es) /\
evaluate_list menv cenv s env es (s', Rerr err)
==>
evaluate menv cenv s env (Con cn es) (s', Rerr err))

/\

(! menv cenv env n v s targs_opt type_scheme_opt.
(lookup_var_id n menv env = SOME (v,type_scheme_opt))
==>
evaluate menv cenv s env (Var n targs_opt) (s, Rval (do_tapp type_scheme_opt targs_opt v)))

/\

(! menv cenv env n s tparams_opt.
(lookup_var_id n menv env = NONE)
==>
evaluate menv cenv s env (Var n tparams_opt) (s, Rerr Rtype_error))

/\

(! menv cenv env n e s topt.
T
==>
evaluate menv cenv s env (Fun n topt e) (s, Rval (Closure env n topt e)))

/\

(! menv cenv env uop e v v' s1 s2 s3.
evaluate menv cenv s1 env e (s2, Rval v) /\
(
do_uapp s2 uop v = SOME (s3,v'))
==>
evaluate menv cenv s1 env (Uapp uop e) (s3, Rval v'))

/\

(! menv cenv env uop e v s1 s2.
evaluate menv cenv s1 env e (s2, Rval v) /\
(
do_uapp s2 uop v = NONE)
==>
evaluate menv cenv s1 env (Uapp uop e) (s2, Rerr Rtype_error))

/\

(! menv cenv env uop e err s s'.
evaluate menv cenv s env e (s', Rerr err)
==>
evaluate menv cenv s env (Uapp uop e) (s', Rerr err))

/\

(! menv cenv env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 s4.
evaluate menv cenv s1 env e1 (s2, Rval v1) /\
evaluate menv cenv s2 env e2 (s3, Rval v2) /\
(
do_app s3 env op v1 v2 = SOME (s4, env', e3)) /\
evaluate menv cenv s4 env' e3 bv
==>
evaluate menv cenv s1 env (App op e1 e2) bv)

/\

(! menv cenv env op e1 e2 v1 v2 s1 s2 s3.
evaluate menv cenv s1 env e1 (s2, Rval v1) /\
evaluate menv cenv s2 env e2 (s3, Rval v2) /\
(
do_app s3 env op v1 v2 = NONE)
==>
evaluate menv cenv s1 env (App op e1 e2) (s3, Rerr Rtype_error))

/\

(! menv cenv env op e1 e2 v1 err s1 s2 s3.
evaluate menv cenv s1 env e1 (s2, Rval v1) /\
evaluate menv cenv s2 env e2 (s3, Rerr err)
==>
evaluate menv cenv s1 env (App op e1 e2) (s3, Rerr err))

/\

(! menv cenv env op e1 e2 err s s'.
evaluate menv cenv s env e1 (s', Rerr err)
==>
evaluate menv cenv s env (App op e1 e2) (s', Rerr err))

/\

(! menv cenv env op e1 e2 v e' bv s1 s2.
evaluate menv cenv s1 env e1 (s2, Rval v) /\
(
do_log op v e2 = SOME e') /\
evaluate menv cenv s2 env e' bv
==>
evaluate menv cenv s1 env (Log op e1 e2) bv)

/\

(! menv cenv env op e1 e2 v s1 s2.
evaluate menv cenv s1 env e1 (s2, Rval v) /\
(
do_log op v e2 = NONE)
==>
evaluate menv cenv s1 env (Log op e1 e2) (s2, Rerr Rtype_error))

/\

(! menv cenv env op e1 e2 err s s'.
evaluate menv cenv s env e1 (s', Rerr err)
==>
evaluate menv cenv s env (Log op e1 e2) (s', Rerr err))

/\

(! menv cenv env e1 e2 e3 v e' bv s1 s2.
evaluate menv cenv s1 env e1 (s2, Rval v) /\
(
do_if v e2 e3 = SOME e') /\
evaluate menv cenv s2 env e' bv
==>
evaluate menv cenv s1 env (If e1 e2 e3) bv)

/\

(! menv cenv env e1 e2 e3 v s1 s2.
evaluate menv cenv s1 env e1 (s2, Rval v) /\
(
do_if v e2 e3 = NONE)
==>
evaluate menv cenv s1 env (If e1 e2 e3) (s2, Rerr Rtype_error))

/\

(! menv cenv env e1 e2 e3 err s s'.
evaluate menv cenv s env e1 (s', Rerr err)
==>
evaluate menv cenv s env (If e1 e2 e3) (s', Rerr err))

/\

(! menv cenv env e pes v bv s1 s2.
evaluate menv cenv s1 env e (s2, Rval v) /\
evaluate_match menv cenv s2 env v pes bv
==>
evaluate menv cenv s1 env (Mat e pes) bv)

/\

(! menv cenv env e pes err s s'.
evaluate menv cenv s env e (s', Rerr err)
==>
evaluate menv cenv s env (Mat e pes) (s', Rerr err))

/\

(! menv cenv env n e1 e2 v bv s1 s2 topt tvs.
evaluate menv cenv s1 env e1 (s2, Rval v) /\
evaluate menv cenv s2 (bind n (v, add_tvs tvs topt) env) e2 bv
==>
evaluate menv cenv s1 env (Let tvs n topt e1 e2) bv)

/\

(! menv cenv env n e1 e2 err s s' topt tvs.
evaluate menv cenv s env e1 (s', Rerr err)
==>
evaluate menv cenv s env (Let tvs n topt e1 e2) (s', Rerr err))

/\

(! menv cenv env funs e bv s tvs. ALL_DISTINCT ( MAP (\ (x,a,y,b,z) . x) funs) /\
evaluate menv cenv s (build_rec_env tvs funs env env) e bv
==>
evaluate menv cenv s env (Letrec tvs funs e) bv)

/\

(! menv cenv env funs e s tvs. ~  ( ALL_DISTINCT ( MAP (\ (x,a,y,b,z) . x) funs))
==>
evaluate menv cenv s env (Letrec tvs funs e) (s, Rerr Rtype_error))

/\

(! menv cenv env s.
T
==>
evaluate_list menv cenv s env [] (s, Rval []))

/\

(! menv cenv env e es v vs s1 s2 s3.
evaluate menv cenv s1 env e (s2, Rval v) /\
evaluate_list menv cenv s2 env es (s3, Rval vs)
==>
evaluate_list menv cenv s1 env (e ::es) (s3, Rval (v ::vs)))

/\

(! menv cenv env e es err s s'.
evaluate menv cenv s env e (s', Rerr err)
==>
evaluate_list menv cenv s env (e ::es) (s', Rerr err))

/\

(! menv cenv env e es v err s1 s2 s3.
evaluate menv cenv s1 env e (s2, Rval v) /\
evaluate_list menv cenv s2 env es (s3, Rerr err)
==>
evaluate_list menv cenv s1 env (e ::es) (s3, Rerr err))

/\

(! menv cenv env v s.
T
==>
evaluate_match menv cenv s env v [] (s, Rerr (Rraise Bind_error)))

/\

(! menv cenv env v p e pes env' bv s. ALL_DISTINCT (pat_bindings p []) /\
(pmatch (SOME 0) cenv s p v env = Match env') /\
evaluate menv cenv s env' e bv
==>
evaluate_match menv cenv s env v ((p,e) ::pes) bv)

/\

(! menv cenv env v p e pes bv s. ALL_DISTINCT (pat_bindings p []) /\
(pmatch (SOME 0) cenv s p v env = No_match) /\
evaluate_match menv cenv s env v pes bv
==>
evaluate_match menv cenv s env v ((p,e) ::pes) bv)

/\

(! menv cenv env v p e pes s.
(pmatch (SOME 0) cenv s p v env = Match_type_error)
==>
evaluate_match menv cenv s env v ((p,e) ::pes) (s, Rerr Rtype_error))

/\

(! menv cenv env v p e pes s. ~  ( ALL_DISTINCT (pat_bindings p []))
==>
evaluate_match menv cenv s env v ((p,e) ::pes) (s, Rerr Rtype_error))`;

(* Semantic helpers for definitions *)

(* Add the given type definition to the given constructor environment *)
(*val build_tdefs : option modN -> list (list tvarN * typeN * list (conN * list t)) -> envC*)
val _ = Define `
 (build_tdefs mn tds = FLAT
    ( MAP
      (\ (tvs, tn, condefs) . MAP
           (\ (conN, ts) .
              (mk_id mn conN, ( LENGTH ts, mk_id mn tn)))
           condefs)
      tds))`;


(* Checks that no constructor is defined twice *)
(*val check_dup_ctors :
    forall 'a. option modN -> env (id conN) 'a -> list (list tvarN * typeN * list (conN * list t)) -> bool*)
val _ = Define `
 (check_dup_ctors mn_opt cenv tds =
  (! ((tvs, tn, condefs) :: 
  LIST_TO_SET tds) ((n, ts) :: LIST_TO_SET condefs).
     lookup (mk_id mn_opt n) cenv = NONE) /\ ALL_DISTINCT (let x2 = 
  [] in FOLDR  (\(tvs, tn, condefs) x2 . FOLDR  (\(n, ts) x2 . 
  if T then n :: x2 else x2)  x2  condefs)  x2  tds))`;


val _ = Hol_reln `

(! mn menv cenv env p e v env' s1 s2 tvs.
evaluate menv cenv s1 env e (s2, Rval v) /\ ALL_DISTINCT (pat_bindings p []) /\
(pmatch tvs cenv s2 p v emp = Match env')
==>
evaluate_dec mn menv cenv s1 env (Dlet tvs p e) (s2, Rval (emp, env')))

/\

(! mn menv cenv env p e v s1 s2 tvs.
evaluate menv cenv s1 env e (s2, Rval v) /\ ALL_DISTINCT (pat_bindings p []) /\
(pmatch tvs cenv s2 p v emp = No_match)
==>
evaluate_dec mn menv cenv s1 env (Dlet tvs p e) (s2, Rerr (Rraise Bind_error)))

/\

(! mn menv cenv env p e v s1 s2 tvs.
evaluate menv cenv s1 env e (s2, Rval v) /\
(pmatch tvs cenv s2 p v emp = Match_type_error)
==>
evaluate_dec mn menv cenv s1 env (Dlet tvs p e) (s2, Rerr Rtype_error))

/\

(! mn menv cenv env p e v s1 s2 tvs.
evaluate menv cenv s1 env e (s2, Rval v) /\ ~  ( ALL_DISTINCT (pat_bindings p []))
==>
evaluate_dec mn menv cenv s1 env (Dlet tvs p e) (s2, Rerr Rtype_error))

/\

(! mn menv cenv env p e err s s' tvs.
evaluate menv cenv s env e (s', Rerr err)
==>
evaluate_dec mn menv cenv s env (Dlet tvs p e) (s', Rerr err))

/\

(! mn menv cenv env funs s tvs. ALL_DISTINCT ( MAP (\ (x,topt1,y,topt2,z) . x) funs)
==>
evaluate_dec mn menv cenv s env (Dletrec tvs funs) (s, Rval (emp, build_rec_env tvs funs env emp)))

/\

(! mn menv cenv env funs s tvs. ~  ( ALL_DISTINCT ( MAP (\ (x,topt1,y,topt2,z) . x) funs))
==>
evaluate_dec mn menv cenv s env (Dletrec tvs funs) (s, Rerr Rtype_error))

/\

(! mn menv cenv env tds s.
check_dup_ctors mn cenv tds
==>
evaluate_dec mn menv cenv s env (Dtype tds) (s, Rval (build_tdefs mn tds, emp)))

/\

(! mn menv cenv env tds s. ~  (check_dup_ctors mn cenv tds)
==>
evaluate_dec mn menv cenv s env (Dtype tds) (s, Rerr Rtype_error))`;

(*val combine_dec_result : forall 'a 'b 'c 'd. env 'a 'b -> env 'c 'd -> result (env 'a 'b * env 'c 'd) -> result (env 'a 'b * env 'c 'd)*)
val _ = Define `
 (combine_dec_result cenv env r =
  (case r of
      Rerr e => Rerr e
    | Rval (cenv',env') => Rval (merge cenv' cenv, merge env' env)
  ))`;


val _ = Hol_reln `

(! mn menv cenv s env.
T
==>
evaluate_decs mn menv cenv s env [] (s, Rval (emp, emp)))

/\

(! mn menv cenv s1 s2 env d ds e.
evaluate_dec mn menv cenv s1 env d (s2, Rerr e)
==>
evaluate_decs mn menv cenv s1 env (d ::ds) (s2, Rerr e))

/\

(! mn menv cenv s1 s2 s3 env d ds new_tds new_env r.
evaluate_dec mn menv cenv s1 env d (s2, Rval (new_tds,new_env)) /\
evaluate_decs mn menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, r)
==>
evaluate_decs mn menv cenv s1 env (d ::ds) (s3, combine_dec_result new_tds new_env r))`;

(*val combine_mod_result : forall 'a 'b 'c 'd 'e 'f. env 'a 'b -> env 'c 'd -> env 'e 'f -> result (env 'a 'b * env 'c 'd * env 'e 'f) -> result (env 'a 'b * env 'c 'd * env 'e 'f)*)
val _ = Define `
 (combine_mod_result menv cenv env r =
  (case r of
      Rerr e => Rerr e
    | Rval (menv',cenv',env') => Rval (merge menv' menv, merge cenv' cenv, merge env' env)
  ))`;


val _ = Hol_reln `

(! menv cenv s env.
T
==>
evaluate_prog menv cenv s env [] (s, Rval (emp, emp, emp)))

/\

(! menv cenv s1 s2 s3 env d ds new_tds new_env r.
evaluate_dec NONE menv cenv s1 env d (s2, Rval (new_tds,new_env)) /\
evaluate_prog menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, r)
==>
evaluate_prog menv cenv s1 env (Tdec d ::ds) (s3, combine_mod_result emp new_tds new_env r))

/\

(! menv cenv s1 s2 env d ds e.
evaluate_dec NONE menv cenv s1 env d (s2, Rerr e)
==>
evaluate_prog menv cenv s1 env (Tdec d ::ds) (s2, Rerr e))

/\

(! menv cenv s1 s2 s3 env ds1 ds2 mn specs new_tds new_env r. ~  ( MEM mn ( MAP FST menv)) /\
evaluate_decs (SOME mn) menv cenv s1 env ds1 (s2, Rval (new_tds,new_env)) /\
evaluate_prog (bind mn new_env menv) (merge new_tds cenv) s2 env ds2 (s3, r)
==>
evaluate_prog menv cenv s1 env (Tmod mn specs ds1 ::ds2) (s3, combine_mod_result [(mn,new_env)] new_tds emp r))

/\

(! menv cenv s1 s2 env mn specs ds1 ds2 e. ~  ( MEM mn ( MAP FST menv)) /\
evaluate_decs (SOME mn) menv cenv s1 env ds1 (s2, Rerr e)
==>
evaluate_prog menv cenv s1 env (Tmod mn specs ds1 ::ds2) (s2, Rerr e))

/\

(! menv cenv s env mn specs ds1 ds2. MEM mn ( MAP FST menv)
==>
evaluate_prog menv cenv s env (Tmod mn specs ds1 ::ds2) (s, Rerr Rtype_error))`;


(*val dec_diverges : envM t -> envC -> store t -> envE t -> dec t -> bool*)
(*val decs_diverges : option modN -> envM t -> envC -> store t -> envE t -> decs t -> bool*)
(*val prog_diverges : envM t -> envC -> store t -> envE t -> prog t -> bool*)

val _ = Define `
 (dec_diverges menv cenv st env d =
  (case d of
      Dlet tvs p e => e_diverges menv cenv st env e
    | Dletrec tvs funs => F
    | Dtype tds => F
  ))`;


val _ = Hol_reln `

(! mn menv cenv st env d ds.
dec_diverges menv cenv st env d
==>
decs_diverges mn menv cenv st env (d ::ds)) 

/\

(! mn menv cenv s1 s2 env d ds new_tds new_env.
evaluate_dec mn menv cenv s1 env d (s2, Rval (new_tds, new_env)) /\
decs_diverges mn menv (merge new_tds cenv) s2 (merge new_env env) ds
==>
decs_diverges mn menv cenv s1 env (d ::ds))`;

val _ = Hol_reln `

(! menv cenv st env d ds.
dec_diverges menv cenv st env d
==>
prog_diverges menv cenv st env (Tdec d ::ds))

/\

(! menv cenv s1 s2 env d ds new_tds new_env.
evaluate_dec NONE menv cenv s1 env d (s2, Rval (new_tds, new_env)) /\
prog_diverges menv (merge new_tds cenv) s2 (merge new_env env) ds
==>
prog_diverges menv cenv s1 env (Tdec d ::ds)) 

/\

(! menv cenv s1 env ds1 ds2 mn specs. ~  ( MEM mn ( MAP FST menv)) /\
decs_diverges (SOME mn) menv cenv s1 env ds1
==>
prog_diverges menv cenv s1 env (Tmod mn specs ds1 ::ds2))

/\

(! menv cenv s1 s2 env ds1 ds2 mn specs new_tds new_env. ~  ( MEM mn ( MAP FST menv)) /\
evaluate_decs (SOME mn) menv cenv s1 env ds1 (s2, Rval (new_tds,new_env)) /\
prog_diverges (bind mn new_env menv) (merge new_tds cenv) s2 env ds2
==>
prog_diverges menv cenv s1 env (Tmod mn specs ds1 ::ds2))`;


(* ------------------------------------------------------------------------ *) 
(*   The Type System                                                        *)
(* ------------------------------------------------------------------------ *) 


(* constructor type environments: each constructor has a type
 * forall tyvars. t list -> (tyvars) typeN *)
val _ = type_abbrev( "tenvC" , ``: (( conN id), ( tvarN list # t list # typeN id)) env``);

(* Type environments *)
val _ = Hol_datatype `
 tenvE =
    Empty
  (* Binds several de Bruijn type variables *)
  | Bind_tvar of num => tenvE
  (* The number is how many de Bruijn type variables the typescheme binds *)
  | Bind_name of varN => num => t => tenvE`;


val _ = type_abbrev( "tenvM" , ``: (modN, ( (varN, (num # t))env)) env``);

val _ = Define `
 (bind_tvar tvs tenv = if tvs = 0 then tenv else Bind_tvar tvs tenv)`;


(*val lookup_tenv : varN -> num -> tenvE -> option (num * t)*) 
 val lookup_tenv_defn = Hol_defn "lookup_tenv" `

(lookup_tenv n inc Empty = NONE)
/\
(lookup_tenv n inc (Bind_tvar tvs e) = lookup_tenv n (inc + tvs) e)
/\
(lookup_tenv n inc (Bind_name n' tvs t e) =
  if n' = n then
    SOME (tvs, deBruijn_inc tvs inc t)
  else
    lookup_tenv n inc e)`;

val _ = Defn.save_defn lookup_tenv_defn;

(*val bind_tenv : varN -> num -> t -> tenvE -> tenvE*)
val _ = Define `
 (bind_tenv n tvs t e = Bind_name n tvs t e)`;


(*val t_lookup_var_id : id varN -> tenvM -> tenvE -> option (num * t)*)
val _ = Define `
 (t_lookup_var_id id tenvM tenvE =
  (case id of
      Short x => lookup_tenv x 0 tenvE
    | Long x y =>
        (case lookup x tenvM of
            NONE => NONE
          | SOME tenvE' => lookup y tenvE'
        )
  ))`;


(*val num_tvs : tenvE -> num*)
 val num_tvs_defn = Hol_defn "num_tvs" `
 
(num_tvs Empty = 0)
/\
(num_tvs (Bind_tvar tvs e) = tvs + num_tvs e)
/\
(num_tvs (Bind_name n tvs t e) = num_tvs e)`;

val _ = Defn.save_defn num_tvs_defn;

(* A pattern matches values of a certain type and extends the type environment
 * with the pattern's binders. The number is the maximum deBruijn type variable
 * allowed. *)
(*val type_p : num -> tenvC -> pat t -> t -> list (varN * t) -> bool*)

(* An expression has a type *)
(*val type_e : tenvM -> tenvC -> tenvE -> exp t -> t -> bool*)

(* A list of expressions has a list of types *)
(*val type_es : tenvM -> tenvC -> tenvE -> list (exp t) -> list t -> bool*)

(* Type a mutually recursive bundle of functions.  Unlike pattern typing, the
 * resulting environment does not extend the input environment, but just
 * represents the functions *)
(*val type_funs : tenvM -> tenvC -> tenvE -> list (varN * option t * varN * option t * exp t) ->
                list (varN * t) -> bool*)

(* Check a declaration and update the top-level environments *)
(*val type_d : option modN -> tenvM -> tenvC -> tenvE -> dec t -> tenvC -> env varN (num * t) -> bool*)

(*val type_ds : option modN -> tenvM -> tenvC -> tenvE -> list (dec t) -> tenvC -> env varN (num * t) -> bool*)

(*val type_prog : tenvM -> tenvC -> tenvE -> list (top t) -> tenvM -> tenvC -> env varN (num * t) -> bool*)

(* Check that the operator can have type (t1 -> t2 -> t3) *)
(*val type_op : op -> t -> t -> t -> bool*)
val _ = Define `
 (type_op op t1 t2 t3 =
  (case (op,t1,t2) of
      (Opapp, Tapp [t2'; t3'] TC_fn, _) => (t2 = t2') /\ (t3 = t3')
    | (Opn _, Tapp [] TC_int, Tapp [] TC_int) => (t3 = Tint)
    | (Opb _, Tapp [] TC_int, Tapp [] TC_int) => (t3 = Tbool)
    | (Equality, t1, t2) => (t1 = t2) /\ (t3 = Tbool)
    | (Opassign, Tapp [t1] TC_ref, t2) => (t1 = t2) /\ (t3 = Tunit)
    | _ => F
  ))`;


(* Check that the operator can have type (t1 -> t2) *)
(*val type_uop : uop -> t -> t -> bool*)
val _ = Define `
 (type_uop uop t1 t2 =
  (case (uop,t1) of
      (Opref, _) => t2 = Tref t1
    | (Opderef, Tapp [t1'] TC_ref) => t2 = t1'
    | _ => F
  ))`;


(* Check that the free type variables are in the given list.  Every deBruijn
 * variable must be smaller than the first argument.  So if it is 0, no deBruijn
 * indices are permitted. *)
(*val check_freevars : num -> list tvarN -> t -> bool*)
 val check_freevars_defn = Hol_defn "check_freevars" `

(check_freevars dbmax tvs (Tvar tv) = MEM tv tvs)
/\
(check_freevars dbmax tvs (Tapp ts tn) = EVERY (check_freevars dbmax tvs) ts)
/\
(check_freevars dbmax tvs (Tvar_db n) = n < dbmax)`;

val _ = Defn.save_defn check_freevars_defn;

(* Check that a type definition defines no already defined (or duplicate)
 * constructors or types, and that the free type variables of each constructor
 * argument type are included in the type's type parameters. *)
(*val check_ctor_tenv :
   option modN -> tenvC -> list (list tvarN * typeN * list (conN * list t)) -> bool*)
val _ = Define `
 (check_ctor_tenv mn tenvC tds =
  check_dup_ctors mn tenvC tds /\ EVERY
    (\ (tvs,tn,ctors) . ALL_DISTINCT tvs /\ EVERY
         (\ (cn,ts) . ( EVERY (check_freevars 0 tvs) ts))
         ctors)
    tds /\ ALL_DISTINCT ( MAP (\p . 
  (case (p ) of ( (_,tn,_) ) => tn )) tds) /\ EVERY
    (\ (tvs,tn,ctors) . EVERY (\p . 
  (case (p ) of ( (_,(_,_,tn')) ) => mk_id mn tn <> tn' )) tenvC)
    tds)`;


(*val build_ctor_tenv : option modN -> list (list tvarN * typeN * list (conN * list t)) -> tenvC*)
val _ = Define `
 (build_ctor_tenv mn tds = FLAT
    ( MAP
       (\ (tvs,tn,ctors) . MAP (\ (cn,ts) . (mk_id mn cn,(tvs,ts, mk_id mn tn))) ctors)
       tds))`;


(* Simultaneous substitution of types for type variables in a type *)
(*val type_subst : env tvarN t -> t -> t*)
 val type_subst_defn = Hol_defn "type_subst" `

(type_subst s (Tvar tv) =
  (case lookup tv s of
      NONE => Tvar tv
    | SOME(t) => t
  ))
/\
(type_subst s (Tapp ts tn) =
  Tapp ( MAP (type_subst s) ts) tn)
/\
(type_subst s (Tvar_db n) = Tvar_db n)`;

val _ = Defn.save_defn type_subst_defn;

(*val bind_var_list : num -> list (varN * t) -> tenvE -> tenvE*)
 val bind_var_list_defn = Hol_defn "bind_var_list" `

(bind_var_list tvs [] tenv = tenv)
/\
(bind_var_list tvs ((n,t)::binds) tenv =
  bind_tenv n tvs t (bind_var_list tvs binds tenv))`;

val _ = Defn.save_defn bind_var_list_defn;

(*val bind_var_list2 : env varN (num * t) -> tenvE -> tenvE*)
 val bind_var_list2_defn = Hol_defn "bind_var_list2" `

(bind_var_list2 [] tenv = tenv)
/\
(bind_var_list2 ((n,(tvs,t))::binds) tenv =
  bind_tenv n tvs t (bind_var_list2 binds tenv))`;

val _ = Defn.save_defn bind_var_list2_defn;


(* For the value restriction on let-based polymorphism *)
(*val is_value : forall 'a. exp 'a -> bool*)
 val is_value_defn = Hol_defn "is_value" `
 
(is_value (Lit _) = T)
/\
(is_value (Con _ es) = EVERY is_value es)
/\
(is_value (Var _ _) = T)
/\
(is_value (Fun _ _ _) = T)
/\
(is_value _ = F)`;

val _ = Defn.save_defn is_value_defn;

val _ = Hol_reln `

(! tvs cenv n t.
check_freevars tvs [] t
==>
type_p tvs cenv (Pvar n (SOME t)) t [(n,t)])

/\

(! tvs cenv b.
T
==>
type_p tvs cenv (Plit (Bool b)) Tbool [])

/\

(! tvs cenv n.
T
==>
type_p tvs cenv (Plit (IntLit n)) Tint [])

/\

(! tvs cenv.
T
==>
type_p tvs cenv (Plit Unit) Tunit [])

/\

(! tvs cenv cn ps ts tvs' tn ts' tenv. EVERY (check_freevars tvs []) ts' /\ ( LENGTH ts' = LENGTH tvs') /\
type_ps tvs cenv ps ( MAP (type_subst ( ZIP ( tvs', ts'))) ts) tenv /\
(
lookup cn cenv = SOME (tvs', ts, tn))
==>
type_p tvs cenv (Pcon cn ps) (Tapp ts' (TC_name tn)) tenv)

/\

(! tvs cenv p t tenv.
type_p tvs cenv p t tenv
==>
type_p tvs cenv (Pref p) (Tref t) tenv)

/\

(! tvs cenv.
T
==>
type_ps tvs cenv [] [] [])

/\

(! tvs cenv p ps t ts tenv tenv'.
type_p tvs cenv p t tenv /\
type_ps tvs cenv ps ts tenv'
==>
type_ps tvs cenv (p ::ps) (t ::ts) (tenv' ++tenv))`;

val _ = Hol_reln `

(! menv cenv tenv b.
T
==>
type_e menv cenv tenv (Lit (Bool b)) Tbool)

/\

(! menv cenv tenv n.
T
==>
type_e menv cenv tenv (Lit (IntLit n)) Tint)

/\

(! menv cenv tenv.
T
==>
type_e menv cenv tenv (Lit Unit) Tunit)

/\

(! menv cenv tenv err t.
check_freevars (num_tvs tenv) [] t
==>
type_e menv cenv tenv (Raise err) t)

/\

(! menv cenv tenv e1 var e2 t.
type_e menv cenv tenv e1 t /\
type_e menv cenv (bind_tenv var 0 Tint tenv) e2 t
==>
type_e menv cenv tenv (Handle e1 var e2) t)

/\

(! menv cenv tenv cn es tvs tn ts' ts. EVERY (check_freevars (num_tvs tenv) []) ts' /\ ( LENGTH tvs = LENGTH ts') /\
type_es menv cenv tenv es ( MAP (type_subst ( ZIP ( tvs, ts'))) ts) /\
(
lookup cn cenv = SOME (tvs, ts, tn))
==>
type_e menv cenv tenv (Con cn es) (Tapp ts' (TC_name tn)))

/\

(! menv cenv tenv n t targs tvs.
(tvs = LENGTH targs) /\ EVERY (check_freevars (num_tvs tenv) []) targs /\
(t_lookup_var_id n menv tenv = SOME (tvs,t))
==>
type_e menv cenv tenv (Var n (SOME targs)) (deBruijn_subst 0 targs t))

/\

(! menv cenv tenv n e t1 t2.
check_freevars (num_tvs tenv) [] t1 /\
type_e menv cenv (bind_tenv n 0 t1 tenv) e t2
==>
type_e menv cenv tenv (Fun n (SOME t1) e) (Tfn t1 t2))

/\

(! menv cenv tenv uop e t1 t2.
type_e menv cenv tenv e t1 /\
type_uop uop t1 t2
==>
type_e menv cenv tenv (Uapp uop e) t2)

/\

(! menv cenv tenv op e1 e2 t1 t2 t3.
type_e menv cenv tenv e1 t1 /\
type_e menv cenv tenv e2 t2 /\
type_op op t1 t2 t3
==>
type_e menv cenv tenv (App op e1 e2) t3)

/\

(! menv cenv tenv l e1 e2.
type_e menv cenv tenv e1 Tbool /\
type_e menv cenv tenv e2 Tbool
==>
type_e menv cenv tenv (Log l e1 e2) Tbool)

/\

(! menv cenv tenv e1 e2 e3 t.
type_e menv cenv tenv e1 Tbool /\
type_e menv cenv tenv e2 t /\
type_e menv cenv tenv e3 t
==>
type_e menv cenv tenv (If e1 e2 e3) t)

/\

(! menv cenv tenv e pes t1 t2.
type_e menv cenv tenv e t1 /\
(pes <> []) /\
(! ((p,e) :: LIST_TO_SET pes) . ? tenv'. ALL_DISTINCT (pat_bindings p []) /\
   type_p (num_tvs tenv) cenv p t1 tenv' /\
   type_e menv cenv (bind_var_list 0 tenv' tenv) e t2)
==>
type_e menv cenv tenv (Mat e pes) t2)

/\

(! menv cenv tenv n e1 e2 t1 t2 tvs.
is_value e1 /\
type_e menv cenv (bind_tvar tvs tenv) e1 t1 /\
type_e menv cenv (bind_tenv n tvs t1 tenv) e2 t2
==>
type_e menv cenv tenv (Let (SOME tvs) n (SOME t1) e1 e2) t2)

/\

(! menv cenv tenv n e1 e2 t1 t2.
type_e menv cenv tenv e1 t1 /\
type_e menv cenv (bind_tenv n 0 t1 tenv) e2 t2
==>
type_e menv cenv tenv (Let (SOME 0) n (SOME t1) e1 e2) t2)

/\

(! menv cenv tenv funs e t tenv' tvs.
type_funs menv cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv' /\
type_e menv cenv (bind_var_list tvs tenv' tenv) e t
==>
type_e menv cenv tenv (Letrec (SOME tvs) funs e) t)

/\

(! menv cenv tenv.
T
==>
type_es menv cenv tenv [] [])

/\

(! menv cenv tenv e es t ts.
type_e menv cenv tenv e t /\
type_es menv cenv tenv es ts
==>
type_es menv cenv tenv (e ::es) (t ::ts))

/\

(! menv cenv env.
T
==>
type_funs menv cenv env [] [])

/\

(! menv cenv env fn n e funs env' t1 t2.
check_freevars (num_tvs env) [] (Tfn t1 t2) /\
type_e menv cenv (bind_tenv n 0 t1 env) e t2 /\
type_funs menv cenv env funs env' /\
(
lookup fn env' = NONE)
==>
type_funs menv cenv env ((fn, SOME (Tfn t1 t2), n, SOME t1, e) ::funs) ((fn, Tfn t1 t2) ::env'))`;

(*val tenv_add_tvs : num -> env varN t -> env varN (num * t)*)
val _ = Define `
 (tenv_add_tvs tvs tenv = MAP (\ (n,t) . (n,(tvs,t))) tenv)`;


val _ = Hol_reln `

(! tvs mn menv cenv tenv p e t tenv'.
is_value e /\ ALL_DISTINCT (pat_bindings p []) /\
type_p tvs cenv p t tenv' /\
type_e menv cenv (bind_tvar tvs tenv) e t
==>
type_d mn menv cenv tenv (Dlet (SOME tvs) p e) emp (tenv_add_tvs tvs tenv'))

/\

(! mn menv cenv tenv p e t tenv'. ALL_DISTINCT (pat_bindings p []) /\
type_p 0 cenv p t tenv' /\
type_e menv cenv tenv e t
==>
type_d mn menv cenv tenv (Dlet (SOME 0) p e) emp (tenv_add_tvs 0 tenv'))

/\

(! mn menv cenv tenv funs tenv' tvs.
type_funs menv cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv'
==>
type_d mn menv cenv tenv (Dletrec (SOME tvs) funs) emp (tenv_add_tvs tvs tenv'))

/\

(! mn menv cenv tenv tdecs.
check_ctor_tenv mn cenv tdecs
==>
type_d mn menv cenv tenv (Dtype tdecs) (build_ctor_tenv mn tdecs) emp)`;

val _ = Hol_reln `

(! mn menv cenv tenv.
T
==>
type_ds mn menv cenv tenv [] emp emp)

/\

(! mn menv cenv tenv d ds cenv' tenv' cenv'' tenv''.
type_d mn menv cenv tenv d cenv' tenv' /\
type_ds mn menv (merge cenv' cenv) (bind_var_list2 tenv' tenv) ds cenv'' tenv''
==>
type_ds mn menv cenv tenv (d ::ds) (merge cenv'' cenv') (merge tenv'' tenv'))`;

val _ = Hol_reln `

(! menv cenv tenv.
T
==>
type_prog menv cenv tenv [] emp emp emp)

/\

(! menv cenv tenv d ds cenv' tenv' menv'' cenv'' tenv''.
type_d NONE menv cenv tenv d cenv' tenv' /\
type_prog menv (merge cenv' cenv) (bind_var_list2 tenv' tenv) ds menv'' cenv'' tenv''
==>
type_prog menv cenv tenv (Tdec d :: ds) menv'' (merge cenv'' cenv') (merge tenv'' tenv'))

/\

(! menv cenv tenv mn spec ds1 ds2 cenv' menv'' tenv' cenv'' tenv''. ~  ( MEM mn ( MAP FST menv)) /\
type_ds (SOME mn) menv cenv tenv ds1 cenv' tenv' /\
type_prog (bind mn tenv' menv) (merge cenv' cenv) tenv ds2 menv'' cenv'' tenv''
==>
type_prog menv cenv tenv (Tmod mn spec ds1 :: ds2) (merge menv'' [(mn,tenv')]) (merge cenv'' cenv') tenv'')`;

(* ------------------------------------------------------------------------ *) 
(*   Auxiliary definitions used in the proofs                               *)
(* ------------------------------------------------------------------------ *) 

(* Store typing *)
val _ = type_abbrev( "tenvS" , ``: (num, t) env``);

(* A value has a type *)
(* The number is how many deBruijn type variables are bound in the context. *)
(*val type_v : num -> tenvM -> tenvC -> tenvS -> v t -> t -> bool*)

(* A value environment has a corresponding type environment.  Since all of the
 * entries in the environment are values, and values have no free variables,
 * each entry in the environment can be typed in the empty environment (if at
 * all) *)
(*val type_env : tenvM -> tenvC -> tenvS -> envE t -> tenvE -> bool*)

(* The type of the store *)
(*val type_s : tenvM -> tenvC -> tenvS -> store t -> bool*)

(* An evaluation context has the second type when its hole is filled with a
 * value of the first type. *)
(* The number is how many deBruijn type variables are bound in the context.
 * This is only used for constructor contexts, because the value restriction 
 * ensures that no other contexts can be created under a let binding. *)
(*val type_ctxt : num -> tenvM -> tenvC -> tenvS -> tenvE -> ctxt_frame t -> t -> t -> bool*)
(*val type_ctxts : num -> tenvM -> tenvC -> tenvS -> list (ctxt t) -> t -> t -> bool*)
(*val type_state : num -> tenvM -> tenvC -> tenvS -> state t -> t -> bool*)
(*val context_invariant : num -> list (ctxt t) -> num -> bool*)

val _ = Hol_reln `

(! tvs menv cenv senv b.
T
==>
type_v tvs menv cenv senv (Litv (Bool b)) Tbool)

/\

(! tvs menv cenv senv n.
T
==>
type_v tvs menv cenv senv (Litv (IntLit n)) Tint)

/\

(! tvs menv cenv senv.
T
==>
type_v tvs menv cenv senv (Litv Unit) Tunit)

/\

(! tvs menv cenv senv cn vs tvs' tn ts' ts. EVERY (check_freevars tvs []) ts' /\ ( LENGTH tvs' = LENGTH ts') /\
type_vs tvs menv cenv senv vs ( MAP (type_subst ( ZIP ( tvs', ts'))) ts) /\
(
lookup cn cenv = SOME (tvs', ts, tn))
==>
type_v tvs menv cenv senv (Conv cn vs) (Tapp ts' (TC_name tn)))

/\

(! tvs menv cenv senv env tenv n e t1 t2.
type_env menv cenv senv env tenv /\
check_freevars tvs [] t1 /\
type_e menv cenv (bind_tenv n 0 t1 (bind_tvar tvs tenv)) e t2
==>
type_v tvs menv cenv senv (Closure env n (SOME t1) e) (Tfn t1 t2))

/\

(! tvs menv cenv senv env funs n t tenv tenv'.
type_env menv cenv senv env tenv /\
type_funs menv cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv' /\
(
lookup n tenv' = SOME t)
==>
type_v tvs menv cenv senv (Recclosure env funs n) t)

/\

(! tvs menv cenv senv n t.
check_freevars 0 [] t /\
(lookup n senv = SOME t)
==>
type_v tvs menv cenv senv (Loc n) (Tref t))

/\

(! tvs menv cenv senv.
T
==>
type_vs tvs menv cenv senv [] [])

/\

(! tvs menv cenv senv v vs t ts.
type_v tvs menv cenv senv v t /\
type_vs tvs menv cenv senv vs ts
==>
type_vs tvs menv cenv senv (v ::vs) (t ::ts))

/\

(! menv cenv senv.
T
==>
type_env menv cenv senv emp Empty)

/\

(! menv cenv senv n v env t tenv tvs.
type_v tvs menv cenv senv v t /\
type_env menv cenv senv env tenv
==>
type_env menv cenv senv (bind n (v,SOME (tvs,t)) env) (bind_tenv n tvs t tenv))`;

val _ = Define `
 (type_s menv cenv senv s =
  ! l. 
    ((? t. lookup l senv = SOME t) = (? v. store_lookup l s = SOME v)) /\
    (! t v. ((lookup l senv = SOME t) /\ (store_lookup l s = SOME v)) ==> type_v 0 menv cenv senv v t))`;


val _ = Hol_reln ` 

(! n.
T
==>
context_invariant n [] n)

/\

(! dec_tvs c x e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Chandle ()  x e,env) :: c) 0)

/\

(! dec_tvs c op e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Capp1 op ()  e,env) :: c) 0)

/\

(! dec_tvs c op v env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Capp2 op v () ,env) :: c) 0)

/\

(! dec_tvs c l e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Clog l ()  e,env) :: c) 0)

/\

(! dec_tvs c e1 e2 env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cif ()  e1 e2,env) :: c) 0)

/\

(! dec_tvs c pes env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cmat ()  pes,env) :: c) 0)

/\

(! dec_tvs c tvs x topt e env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Clet (SOME tvs) x topt ()  e,env) :: c) tvs)

/\

(! dec_tvs c cn vs es tvs env.
context_invariant dec_tvs c tvs /\
(tvs <> 0 ==> EVERY is_value es)
==>
context_invariant dec_tvs ((Ccon cn vs ()  es,env) :: c) tvs)

/\

(! dec_tvs c op env.
context_invariant dec_tvs c 0
==>
context_invariant dec_tvs ((Cuapp op () ,env) :: c) 0)`;

val _ = Hol_reln `

(! tvs menv cenv senv tenv x e t.
type_e menv cenv (bind_tenv x 0 Tint tenv) e t
==>
type_ctxt tvs menv cenv senv tenv (Chandle ()  x e) t t)

/\

(! tvs menv cenv senv tenv uop t1 t2.
check_freevars tvs [] t1 /\
check_freevars tvs [] t2 /\
type_uop uop t1 t2
==>
type_ctxt tvs menv cenv senv tenv (Cuapp uop () ) t1 t2)

/\

(! tvs menv cenv senv tenv e op t1 t2 t3.
check_freevars tvs [] t1 /\
check_freevars tvs [] t3 /\
type_e menv cenv tenv e t2 /\
type_op op t1 t2 t3
==>
type_ctxt tvs menv cenv senv tenv (Capp1 op ()  e) t1 t3)

/\

(! tvs menv cenv senv tenv op v t1 t2 t3.
check_freevars tvs [] t2 /\
check_freevars tvs [] t3 /\
type_v 0 menv cenv senv v t1 /\
type_op op t1 t2 t3
==>
type_ctxt tvs menv cenv senv tenv (Capp2 op v () ) t2 t3)

/\

(! tvs menv cenv senv tenv op e.
type_e menv cenv tenv e Tbool
==>
type_ctxt tvs menv cenv senv tenv (Clog op ()  e) Tbool Tbool)

/\

(! tvs menv cenv senv tenv e1 e2 t.
type_e menv cenv tenv e1 t /\
type_e menv cenv tenv e2 t
==>
type_ctxt tvs menv cenv senv tenv (Cif ()  e1 e2) Tbool t)

/\

(! tvs menv cenv senv tenv t1 t2 pes.
((pes = []) ==> (check_freevars tvs [] t1 /\ check_freevars 0 [] t2)) /\
(! ((p,e) :: LIST_TO_SET pes) . ? tenv'. ALL_DISTINCT (pat_bindings p []) /\
   type_p tvs cenv p t1 tenv' /\
   type_e menv cenv (bind_var_list 0 tenv' tenv) e t2)
==>
type_ctxt tvs menv cenv senv tenv (Cmat ()  pes) t1 t2)

/\

(! tvs menv cenv senv tenv e t1 t2 n tvs'.
check_freevars tvs [] t1 /\
type_e menv cenv (bind_tenv n tvs' t1 tenv) e t2
==>
type_ctxt tvs menv cenv senv tenv (Clet (SOME tvs') n (SOME t1) ()  e) t1 t2)

/\

(! tvs menv cenv senv tenv cn vs es ts1 ts2 t tn ts' tvs'. EVERY (check_freevars tvs []) ts' /\ ( LENGTH tvs' = LENGTH ts') /\
type_vs tvs menv cenv senv ( REVERSE vs)
        ( MAP (type_subst ( ZIP ( tvs', ts'))) ts1) /\
type_es menv cenv (bind_tvar tvs tenv) es ( MAP (type_subst ( ZIP ( tvs', ts'))) ts2) /\
(
lookup cn cenv = SOME (tvs', ts1 ++([t] ++ts2), tn))
==>
type_ctxt tvs menv cenv senv tenv (Ccon cn vs ()  es) (type_subst ( ZIP ( tvs', ts')) t)
          (Tapp ts' (TC_name tn)))`;

val _ = Hol_reln `

(! dec_tvs tenvM tenvC senv t.
check_freevars dec_tvs [] t
==>
type_ctxts dec_tvs tenvM tenvC senv [] t t)

/\

(! dec_tvs tenvM tenvC senv c env cs tenv t1 t2 t3 tvs.
type_env tenvM tenvC senv env tenv /\
context_invariant dec_tvs ((c,env) ::cs) tvs /\
type_ctxt tvs tenvM tenvC senv tenv c t1 t2 /\
type_ctxts dec_tvs tenvM tenvC senv cs t2 t3
==>
type_ctxts dec_tvs tenvM tenvC senv ((c,env) ::cs) t1 t3)`;

val _ = Hol_reln `

(! dec_tvs tenvM tenvC senv envM envC s env e c t1 t2 tenv tvs.
type_ctxts dec_tvs tenvM tenvC senv c t1 t2 /\
type_env tenvM tenvC senv env tenv /\
type_s tenvM tenvC senv s /\
context_invariant dec_tvs c tvs /\
type_e tenvM tenvC (bind_tvar tvs tenv) e t1 /\
((tvs <> 0) ==> is_value e)
==>
type_state dec_tvs tenvM tenvC senv (envM,envC, s, env, Exp e, c) t2)

/\

(! dec_tvs tenvM tenvC senv envM envC s env v c t1 t2 tenv tvs.
type_ctxts dec_tvs tenvM tenvC senv c t1 t2 /\
type_env tenvM tenvC senv env tenv /\
type_s tenvM tenvC senv s /\
context_invariant dec_tvs c tvs /\
type_v tvs tenvM tenvC senv v t1
==>
type_state dec_tvs tenvM tenvC senv (envM, envC, s, env, Val v, c) t2)`;

(* ------ Auxiliary relations for proving big/small step equivalence ------ *)

(*val evaluate_ctxt : envM t -> envC -> store t -> envE t -> ctxt_frame t -> v t -> store t * result (v t) -> bool*)
(*val evaluate_ctxts : envM t -> envC -> store t -> list (ctxt t) -> result (v t) -> store t * result (v t) -> bool*)
(*val evaluate_state : state t -> store t * result (v t) -> bool*)

val _ = Hol_reln `

(! menv cenv s env v1 e2 var.
T
==>
evaluate_ctxt menv cenv s env (Chandle ()  var e2) v1 (s, Rval v1))

/\

(! menv cenv env op e2 v1 v2 env' e3 bv s1 s2 s3.
evaluate menv cenv s1 env e2 (s2, Rval v2) /\
(
do_app s2 env op v1 v2 = SOME (s3,env', e3)) /\
evaluate menv cenv s3 env' e3 bv
==>
evaluate_ctxt menv cenv s1 env (Capp1 op ()  e2) v1 bv)

/\

(! menv cenv env op e2 v1 v2 s1 s2.
evaluate menv cenv s1 env e2 (s2, Rval v2) /\
(
do_app s2 env op v1 v2 = NONE)
==>
evaluate_ctxt menv cenv s1 env (Capp1 op ()  e2) v1 (s2, Rerr Rtype_error))

/\

(! menv cenv env op e2 v1 err s s'.
evaluate menv cenv s env e2 (s', Rerr err)
==>
evaluate_ctxt menv cenv s env (Capp1 op ()  e2) v1 (s', Rerr err))

/\

(! menv cenv env op v1 v2 env' e3 bv s1 s2.
(
do_app s1 env op v1 v2 = SOME (s2, env', e3)) /\
evaluate menv cenv s2 env' e3 bv
==>
evaluate_ctxt menv cenv s1 env (Capp2 op v1 () ) v2 bv)

/\

(! menv cenv env op v1 v2 s.
(do_app s env op v1 v2 = NONE)
==>
evaluate_ctxt menv cenv s env (Capp2 op v1 () ) v2 (s, Rerr Rtype_error))

/\

(! menv cenv env uop v v' s1 s2.
(do_uapp s1 uop v = SOME (s2,v'))
==>
evaluate_ctxt menv cenv s1 env (Cuapp uop () ) v (s2, Rval v'))

/\

(! menv cenv env uop v s.
(do_uapp s uop v = NONE)
==>
evaluate_ctxt menv cenv s env (Cuapp uop () ) v (s, Rerr Rtype_error))

/\

(! menv cenv env op e2 v e' bv s.
(
do_log op v e2 = SOME e') /\
evaluate menv cenv s env e' bv
==>
evaluate_ctxt menv cenv s env (Clog op ()  e2) v bv)

/\

(! menv cenv env op e2 v s.
(do_log op v e2 = NONE)
==>
evaluate_ctxt menv cenv s env (Clog op ()  e2) v (s, Rerr Rtype_error))

/\
(! menv cenv env e2 e3 v e' bv s.
(
do_if v e2 e3 = SOME e') /\
evaluate menv cenv s env e' bv
==>
evaluate_ctxt menv cenv s env (Cif ()  e2 e3) v bv)

/\

(! menv cenv env e2 e3 v s.
(do_if v e2 e3 = NONE)
==>
evaluate_ctxt menv cenv s env (Cif ()  e2 e3) v (s, Rerr Rtype_error))

/\

(! menv cenv env pes v bv s.
evaluate_match menv cenv s env v pes bv
==>
evaluate_ctxt menv cenv s env (Cmat ()  pes) v bv)

/\

(! menv cenv env n e2 v bv s topt tvs.
evaluate menv cenv s (bind n (v,add_tvs tvs topt) env) e2 bv
==>
evaluate_ctxt menv cenv s env (Clet tvs n topt ()  e2) v bv)

/\

(! menv cenv env cn es vs v vs' s1 s2.
do_con_check cenv cn ( LENGTH vs + LENGTH es + 1) /\
evaluate_list menv cenv s1 env es (s2, Rval vs')
==>
evaluate_ctxt menv cenv s1 env (Ccon cn vs ()  es) v (s2, Rval (Conv cn ( REVERSE vs ++ ([v] ++ vs')))))

/\

(! menv cenv env cn es vs v s. ~  (do_con_check cenv cn ( LENGTH vs + LENGTH es + 1))
==>
evaluate_ctxt menv cenv s env (Ccon cn vs ()  es) v (s, Rerr Rtype_error))

/\

(! menv cenv env cn es vs v err s s'.
do_con_check cenv cn ( LENGTH vs + LENGTH es + 1) /\
evaluate_list menv cenv s env es (s', Rerr err)
==>
evaluate_ctxt menv cenv s env (Ccon cn vs ()  es) v (s', Rerr err))`;

val _ = Hol_reln `

(! menv cenv res s.
T
==>
evaluate_ctxts menv cenv s [] res (s, res))

/\

(! menv cenv c cs env v res bv s1 s2.
evaluate_ctxt menv cenv s1 env c v (s2, res) /\
evaluate_ctxts menv cenv s2 cs res bv
==>
evaluate_ctxts menv cenv s1 ((c,env) ::cs) (Rval v) bv)

/\

(! menv cenv c cs env err s bv.
evaluate_ctxts menv cenv s cs (Rerr err) bv /\
((! i e'. c <> Chandle ()  i e') \/
 (! i. err <> Rraise (Int_error i)))
==>
evaluate_ctxts menv cenv s ((c,env) ::cs) (Rerr err) bv)

/\

(! menv cenv cs env s s' var res1 res2 i e'.
evaluate menv cenv s (bind var (Litv (IntLit i), SOME (0,Tint)) env) e' (s', res1) /\
evaluate_ctxts menv cenv s' cs res1 res2
==>
evaluate_ctxts menv cenv s ((Chandle ()  var e',env) ::cs) (Rerr (Rraise (Int_error i))) res2)`;

val _ = Hol_reln `

(! menv cenv env e c res bv s1 s2.
evaluate menv cenv s1 env e (s2, res) /\
evaluate_ctxts menv cenv s2 c res bv
==>
evaluate_state (menv, cenv, s1, env, Exp e, c) bv)

/\

(! menv cenv s env v c bv.
evaluate_ctxts menv cenv s c (Rval v) bv
==>
evaluate_state (menv, cenv, s, env, Val v, c) bv)`;


(* ------------------------------------------------------------------------ *) 
(*   Alternate big-step semantics                                           *)
(* ------------------------------------------------------------------------ *) 

(* A version of the big-step expression semantics that doesn't use the
 * constructor environment to know if a value is ok or not.  It also has no
 * module environment. Is equivalent to the normal one for well-typed programs
 * that don't contain module references. *)

(*val pmatch' : forall 'a. option num -> store 'a -> pat 'a -> v 'a -> envE 'a -> match_result 'a*)
 val pmatch'_defn = Hol_defn "pmatch'" `

(pmatch' tvs s (Pvar n topt) v' env = Match (bind n (v', add_tvs tvs topt) env))
/\
(pmatch' tvs s (Plit l) (Litv l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error)
/\
(pmatch' tvs s (Pcon cn ps) (Conv cn' vs) env =
  if ( LENGTH ps = LENGTH vs) /\ (cn = cn') then
    pmatch_list' tvs s ps vs env
  else
    No_match)
/\
(pmatch' tvs s (Pref p) (Loc lnum) env =
  (case store_lookup lnum s of
      SOME v => pmatch' tvs s p v env
    | NONE => Match_type_error
  ))
/\
(pmatch' tvs _ _ _ env = Match_type_error)
/\
(pmatch_list' tvs s [] [] env = Match env)
/\
(pmatch_list' tvs s (p::ps) (v::vs) env =
  (case pmatch' tvs s p v env of
      No_match => No_match
    | Match_type_error => Match_type_error
    | Match env' => pmatch_list' tvs s ps vs env'
  ))
/\
(pmatch_list' tvs _ _ _ env = Match_type_error)`;

val _ = Defn.save_defn pmatch'_defn;


val _ = Hol_reln `

(! env l s.
T
==>
evaluate' s env (Lit l) (s, Rval (Litv l)))

/\

(! env err s.
T
==>
evaluate' s env (Raise err) (s, Rerr (Rraise err)))

/\

(! s1 s2 env e1 e2 v var.
evaluate' s1 env e1 (s2, Rval v)
==>
evaluate' s1 env (Handle e1 var e2) (s2, Rval v))

/\

(! s1 s2 env e1 e2 n var bv.
evaluate' s1 env e1 (s2, Rerr (Rraise (Int_error n))) /\
evaluate' s2 (bind var (Litv (IntLit n), SOME (0,Tint)) env) e2 bv
==>
evaluate' s1 env (Handle e1 var e2) bv)

/\

(! s1 s2 env e1 e2 var err.
evaluate' s1 env e1 (s2, Rerr err) /\
((err = Rtype_error) \/ (err = Rraise Bind_error) \/ (err = Rraise Div_error))
==>
evaluate' s1 env (Handle e1 var e2) (s2, Rerr err))

/\

(! env cn es vs s1 s2.
evaluate_list' s1 env es (s2, Rval vs)
==>
evaluate' s1 env (Con cn es) (s2, Rval (Conv cn vs)))

/\

(! env cn es err s s'.
evaluate_list' s env es (s', Rerr err)
==>
evaluate' s env (Con cn es) (s', Rerr err))

/\

(! env n v s targs_opt type_scheme_opt.
(lookup n env = SOME (v,type_scheme_opt))
==>
evaluate' s env (Var (Short n) targs_opt) (s, Rval (do_tapp type_scheme_opt targs_opt v)))

/\

(! env n s targs_opt.
(lookup n env = NONE)
==>
evaluate' s env (Var (Short n) targs_opt) (s, Rerr Rtype_error))

/\

(! env n e s topt.
T
==>
evaluate' s env (Fun n topt e) (s, Rval (Closure env n topt e)))

/\

(! env uop e v v' s1 s2 s3.
evaluate' s1 env e (s2, Rval v) /\
(
do_uapp s2 uop v = SOME (s3,v'))
==>
evaluate' s1 env (Uapp uop e) (s3, Rval v'))

/\

(! env uop e v s1 s2.
evaluate' s1 env e (s2, Rval v) /\
(
do_uapp s2 uop v = NONE)
==>
evaluate' s1 env (Uapp uop e) (s2, Rerr Rtype_error))

/\

(! env uop e err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate' s env (Uapp uop e) (s', Rerr err))

/\

(! env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 s4.
evaluate' s1 env e1 (s2, Rval v1) /\
evaluate' s2 env e2 (s3, Rval v2) /\
(
do_app s3 env op v1 v2 = SOME (s4, env', e3)) /\
evaluate' s4 env' e3 bv
==>
evaluate' s1 env (App op e1 e2) bv)

/\

(! env op e1 e2 v1 v2 s1 s2 s3.
evaluate' s1 env e1 (s2, Rval v1) /\
evaluate' s2 env e2 (s3, Rval v2) /\
(
do_app s3 env op v1 v2 = NONE)
==>
evaluate' s1 env (App op e1 e2) (s3, Rerr Rtype_error))

/\

(! env op e1 e2 v1 err s1 s2 s3.
evaluate' s1 env e1 (s2, Rval v1) /\
evaluate' s2 env e2 (s3, Rerr err)
==>
evaluate' s1 env (App op e1 e2) (s3, Rerr err))

/\

(! env op e1 e2 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (App op e1 e2) (s', Rerr err))

/\

(! env op e1 e2 v e' bv s1 s2.
evaluate' s1 env e1 (s2, Rval v) /\
(
do_log op v e2 = SOME e') /\
evaluate' s2 env e' bv
==>
evaluate' s1 env (Log op e1 e2) bv)

/\

(! env op e1 e2 v s1 s2.
evaluate' s1 env e1 (s2, Rval v) /\
(
do_log op v e2 = NONE)
==>
evaluate' s1 env (Log op e1 e2) (s2, Rerr Rtype_error))

/\

(! env op e1 e2 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (Log op e1 e2) (s', Rerr err))

/\

(! env e1 e2 e3 v e' bv s1 s2.
evaluate' s1 env e1 (s2, Rval v) /\
(
do_if v e2 e3 = SOME e') /\
evaluate' s2 env e' bv
==>
evaluate' s1 env (If e1 e2 e3) bv)

/\

(! env e1 e2 e3 v s1 s2.
evaluate' s1 env e1 (s2, Rval v) /\
(
do_if v e2 e3 = NONE)
==>
evaluate' s1 env (If e1 e2 e3) (s2, Rerr Rtype_error))

/\


(! env e1 e2 e3 err s s'.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (If e1 e2 e3) (s', Rerr err))

/\

(! env e pes v bv s1 s2.
evaluate' s1 env e (s2, Rval v) /\
evaluate_match' s2 env v pes bv
==>
evaluate' s1 env (Mat e pes) bv)

/\

(! env e pes err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate' s env (Mat e pes) (s', Rerr err))

/\

(! env n e1 e2 v bv s1 s2 topt tvs.
evaluate' s1 env e1 (s2, Rval v) /\
evaluate' s2 (bind n (v,add_tvs tvs topt) env) e2 bv
==>
evaluate' s1 env (Let tvs n topt e1 e2) bv)

/\

(! env n e1 e2 err s s' topt tvs.
evaluate' s env e1 (s', Rerr err)
==>
evaluate' s env (Let tvs n topt e1 e2) (s', Rerr err))

/\

(! env funs e bv s tvs. ALL_DISTINCT ( MAP (\ (x,topt1,y,topt2,z) . x) funs) /\
evaluate' s (build_rec_env tvs funs env env) e bv
==>
evaluate' s env (Letrec tvs funs e) bv)

/\

(! env funs e s tvs. ~  ( ALL_DISTINCT ( MAP (\ (x,topt1,y,topt2,z) . x) funs))
==>
evaluate' s env (Letrec tvs funs e) (s, Rerr Rtype_error))

/\

(! env s.
T
==>
evaluate_list' s env [] (s, Rval []))

/\

(! env e es v vs s1 s2 s3.
evaluate' s1 env e (s2, Rval v) /\
evaluate_list' s2 env es (s3, Rval vs)
==>
evaluate_list' s1 env (e ::es) (s3, Rval (v ::vs)))

/\

(! env e es err s s'.
evaluate' s env e (s', Rerr err)
==>
evaluate_list' s env (e ::es) (s', Rerr err))

/\

(! env e es v err s1 s2 s3.
evaluate' s1 env e (s2, Rval v) /\
evaluate_list' s2 env es (s3, Rerr err)
==>
evaluate_list' s1 env (e ::es) (s3, Rerr err))

/\

(! env v s.
T
==>
evaluate_match' s env v [] (s, Rerr (Rraise Bind_error)))

/\

(! env v p e pes env' bv s. ALL_DISTINCT (pat_bindings p []) /\
(pmatch' (SOME 0) s p v env = Match env') /\
evaluate' s env' e bv
==>
evaluate_match' s env v ((p,e) ::pes) bv)

/\

(! env v p e pes bv s. ALL_DISTINCT (pat_bindings p []) /\
(pmatch' (SOME 0) s p v env = No_match) /\
evaluate_match' s env v pes bv
==>
evaluate_match' s env v ((p,e) ::pes) bv)

/\

(! env v p e pes s.
(pmatch' (SOME 0) s p v env = Match_type_error)
==>
evaluate_match' s env v ((p,e) ::pes) (s, Rerr Rtype_error))

/\

(! env v p e pes s. ~  ( ALL_DISTINCT (pat_bindings p []))
==>
evaluate_match' s env v ((p,e) ::pes) (s, Rerr Rtype_error))`;

val _ = Hol_reln `

(! mn menv cenv env p e v env' s1 s2 tvs.
evaluate' s1 env e (s2, Rval v) /\ ALL_DISTINCT (pat_bindings p []) /\
(pmatch' tvs s2 p v emp = Match env')
==>
evaluate_dec' mn menv cenv s1 env (Dlet tvs p e) (s2, Rval (emp, env')))

/\

(! mn menv cenv env p e v s1 s2 tvs.
evaluate' s1 env e (s2, Rval v) /\ ALL_DISTINCT (pat_bindings p []) /\
(pmatch' tvs s2 p v emp = No_match)
==>
evaluate_dec' mn menv cenv s1 env (Dlet tvs p e) (s2, Rerr (Rraise Bind_error)))

/\

(! mn menv cenv env p e v s1 s2 tvs.
evaluate' s1 env e (s2, Rval v) /\
(pmatch' tvs s2 p v emp = Match_type_error)
==>
evaluate_dec' mn menv cenv s1 env (Dlet tvs p e) (s2, Rerr Rtype_error))

/\

(! mn menv cenv env p e v s1 s2 tvs.
evaluate' s1 env e (s2, Rval v) /\ ~  ( ALL_DISTINCT (pat_bindings p []))
==>
evaluate_dec' mn menv cenv s1 env (Dlet tvs p e) (s2, Rerr Rtype_error))

/\

(! mn menv cenv env p e err s s' tvs.
evaluate' s env e (s', Rerr err)
==>
evaluate_dec' mn menv cenv s env (Dlet tvs p e) (s', Rerr err))

/\

(! mn menv cenv env funs s tvs. ALL_DISTINCT ( MAP (\ (x,topt1,y,topt2,z) . x) funs)
==>
evaluate_dec' mn menv cenv s env (Dletrec tvs funs) (s, Rval (emp, build_rec_env tvs funs env emp)))

/\

(! mn menv cenv env funs s tvs. ~  ( ALL_DISTINCT ( MAP (\ (x,topt1,y,topt2,z) . x) funs))
==>
evaluate_dec' mn menv cenv s env (Dletrec tvs funs) (s, Rerr Rtype_error))

/\

(! mn menv cenv env tds s.
check_dup_ctors mn cenv tds
==>
evaluate_dec' mn menv cenv s env (Dtype tds) (s, Rval (build_tdefs mn tds, emp)))

/\

(! mn menv cenv env tds s. ~  (check_dup_ctors mn cenv tds)
==>
evaluate_dec' mn menv cenv s env (Dtype tds) (s, Rerr Rtype_error))`;

val _ = Hol_reln `

(! mn menv cenv s env.
T
==>
evaluate_decs' mn menv cenv s env [] (s, Rval (emp, emp)))

/\

(! mn menv cenv s1 s2 env d ds e.
evaluate_dec' mn menv cenv s1 env d (s2, Rerr e)
==>
evaluate_decs' mn menv cenv s1 env (d ::ds) (s2, Rerr e))

/\

(! mn menv cenv s1 s2 s3 env d ds new_tds new_env r.
evaluate_dec' mn menv cenv s1 env d (s2, Rval (new_tds,new_env)) /\
evaluate_decs' mn menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, r)
==>
evaluate_decs' mn menv cenv s1 env (d ::ds) (s3, combine_dec_result new_tds new_env r))`;

val _ = Hol_reln `

(! menv cenv s env.
T
==>
evaluate_prog' menv cenv s env [] (s, Rval (emp, emp, emp)))

/\

(! menv cenv s1 s2 s3 env d ds new_tds new_env r.
evaluate_dec' NONE menv cenv s1 env d (s2, Rval (new_tds,new_env)) /\
evaluate_prog' menv (merge new_tds cenv) s2 (merge new_env env) ds (s3, r)
==>
evaluate_prog' menv cenv s1 env (Tdec d ::ds) (s3, combine_mod_result emp new_tds new_env r))

/\

(! menv cenv s1 s2 env d ds e.
evaluate_dec' NONE menv cenv s1 env d (s2, Rerr e)
==>
evaluate_prog' menv cenv s1 env (Tdec d ::ds) (s2, Rerr e))

/\

(! menv cenv s1 s2 s3 env ds1 ds2 mn specs new_tds new_env r. ~  ( MEM mn ( MAP FST menv)) /\
evaluate_decs' (SOME mn) menv cenv s1 env ds1 (s2, Rval (new_tds,new_env)) /\
evaluate_prog' (bind mn new_env menv) (merge new_tds cenv) s2 env ds2 (s3, r)
==>
evaluate_prog' menv cenv s1 env (Tmod mn specs ds1 ::ds2) (s3, combine_mod_result [(mn,new_env)] new_tds emp r))

/\

(! menv cenv s1 s2 env mn specs ds1 ds2 e. ~  ( MEM mn ( MAP FST menv)) /\
evaluate_decs' (SOME mn) menv cenv s1 env ds1 (s2, Rerr e)
==>
evaluate_prog' menv cenv s1 env (Tmod mn specs ds1 ::ds2) (s2, Rerr e))

/\

(! menv cenv s env mn specs ds1 ds2. MEM mn ( MAP FST menv)
==>
evaluate_prog' menv cenv s env (Tmod mn specs ds1 ::ds2) (s, Rerr Rtype_error))`;

val _ = export_theory()

