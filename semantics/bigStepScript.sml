(*Generated by Lem from bigStep.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extraTheory libTheory astTheory semanticPrimitivesTheory smallStepTheory;

val _ = numLib.prefer_num();



val _ = new_theory "bigStep"

(*open import Pervasives_extra*)
(*open import Lib*)
(*open import Ast*) 
(*open import SemanticPrimitives*)

(* To get the definition of expression divergence to use in defining definition
 * divergence *)
(*open import SmallStep*)

(* ------------------------ Big step semantics -------------------------- *)

(* If the first argument is true, the big step semantics counts down how many
   functions applications have happened, and raises an exception when the counter
   runs out. *)

val _ = type_abbrev((*  'a *) "count_store" , ``: num # 'a store``);

(*val dec_count : op -> nat -> nat*)
val _ = Define `
 (dec_count op count0 =  
 (if op = Opapp then
    count0 -  1
  else
    count0))`;


val _ = Hol_reln ` (! ck env l s.
T
==>
evaluate ck env s (Lit l) (s, Rval (Litv l)))

/\ (! ck env e s1 s2 v.
(evaluate ck s1 env e (s2, Rval v))
==>
evaluate ck s1 env (Raise e) (s2, Rerr (Rraise v)))

/\ (! ck env e s1 s2 err.
(evaluate ck s1 env e (s2, Rerr err))
==>
evaluate ck s1 env (Raise e) (s2, Rerr err))

/\ (! ck s1 s2 env e v pes.
(evaluate ck s1 env e (s2, Rval v))
==>
evaluate ck s1 env (Handle e pes) (s2, Rval v))

/\ (! ck s1 s2 env e pes v bv.
(evaluate ck env s1 e (s2, Rerr (Rraise v)) /\
evaluate_match ck env s2 v pes v bv)
==>
evaluate ck env s1 (Handle e pes) bv)

/\ (! ck s1 s2 env e pes err.
(evaluate ck env s1 e (s2, Rerr err) /\
((err = Rtimeout_error) \/ (err = Rtype_error)))
==>
evaluate ck env s1 (Handle e pes) (s2, Rerr err))

/\ (! ck env cn es vs s s' v.
(do_con_check (all_env_to_cenv env) cn (LENGTH es) /\
((build_conv (all_env_to_cenv env) cn vs = SOME v) /\
evaluate_list ck env s es (s', Rval vs)))
==>
evaluate ck env s (Con cn es) (s', Rval v))

/\ (! ck env cn es s.
(~ (do_con_check (all_env_to_cenv env) cn (LENGTH es)))
==>
evaluate ck env s (Con cn es) (s, Rerr Rtype_error))

/\ (! ck env cn es err s s'.
(do_con_check (all_env_to_cenv env) cn (LENGTH es) /\
evaluate_list ck env s es (s', Rerr err))
==>
evaluate ck env s (Con cn es) (s', Rerr err))

/\ (! ck env n v s.
(lookup_var_id n env = SOME v)
==>
evaluate ck env s (Var n) (s, Rval v))

/\ (! ck env n s.
(lookup_var_id n env = NONE)
==>
evaluate ck env s (Var n) (s, Rerr Rtype_error))

/\ (! ck env n e s.
T
==>
evaluate ck env s (Fun n e) (s, Rval (Closure env n e)))

/\ (! ck env uop e v v' s1 s2 count s3.
(evaluate ck env s1 e ((count,s2), Rval v) /\
(do_uapp s2 uop v = SOME (s3,v')))
==>
evaluate ck env s1 (Uapp uop e) ((count,s3), Rval v'))

/\ (! ck env uop e v s1 s2 count.
(evaluate ck env s1 e ((count,s2), Rval v) /\
(do_uapp s2 uop v = NONE))
==>
evaluate ck env s1 (Uapp uop e) ((count,s2), Rerr Rtype_error))

/\ (! ck env uop e err s s'.
(evaluate ck env s e (s', Rerr err))
==>
evaluate ck env s (Uapp uop e) (s', Rerr err))

/\ (! ck env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 count s4.
(evaluate ck env s1 e1 (s2, Rval v1) /\
(evaluate ck env s2 e2 ((count,s3), Rval v2) /\
((do_app env s3 op v1 v2 = SOME (env', s4, e3)) /\
(((ck /\ (op = Opapp)) ==> ~ (count =( 0))) /\
evaluate ck env' ((if ck then dec_count op count else count),s4) e3 bv))))
==>
evaluate ck env s1 (App op e1 e2) bv)

/\ (! ck env op e1 e2 v1 v2 env' e3 s1 s2 s3 count s4.
(evaluate ck env s1 e1 (s2, Rval v1) /\
(evaluate ck env s2 e2 ((count,s3), Rval v2) /\
((do_app env s3 op v1 v2 = SOME (env', s4, e3)) /\
((count = 0) /\
((op = Opapp) /\
ck)))))
==>
evaluate ck env s1 (App op e1 e2) (( 0,s4), Rerr Rtimeout_error))

/\ (! ck env op e1 e2 v1 v2 s1 s2 s3 count.
(evaluate ck env s1 e1 (s2, Rval v1) /\
(evaluate ck env s2 e2 ((count,s3), Rval v2) /\
(do_app env s3 op v1 v2 = NONE)))
==>
evaluate ck env s1 (App op e1 e2) ((count,s3), Rerr Rtype_error))

/\ (! ck env op e1 e2 v1 err s1 s2 s3.
(evaluate ck env s1 e1 (s2, Rval v1) /\
evaluate ck env s2 e2 (s3, Rerr err))
==>
evaluate ck env s1 (App op e1 e2) (s3, Rerr err))

/\ (! ck env op e1 e2 err s s'.
(evaluate ck env s e1 (s', Rerr err))
==>
evaluate ck env s (App op e1 e2) (s', Rerr err))

/\ (! ck env op e1 e2 v e' bv s1 s2.
(evaluate ck env s1 e1 (s2, Rval v) /\
((do_log op v e2 = SOME e') /\
evaluate ck env s2 e' bv))
==>
evaluate ck env s1 (Log op e1 e2) bv)

/\ (! ck env op e1 e2 v s1 s2.
(evaluate ck env s1 e1 (s2, Rval v) /\
(do_log op v e2 = NONE))
==>
evaluate ck env s1 (Log op e1 e2) (s2, Rerr Rtype_error))

/\ (! ck env op e1 e2 err s s'.
(evaluate ck env s e1 (s', Rerr err))
==>
evaluate ck env s (Log op e1 e2) (s', Rerr err))

/\ (! ck env e1 e2 e3 v e' bv s1 s2.
(evaluate ck env s1 e1 (s2, Rval v) /\
((do_if v e2 e3 = SOME e') /\
evaluate ck env s2 e' bv))
==>
evaluate ck env s1 (If e1 e2 e3) bv)

/\ (! ck env e1 e2 e3 v s1 s2.
(evaluate ck env s1 e1 (s2, Rval v) /\
(do_if v e2 e3 = NONE))
==>
evaluate ck env s1 (If e1 e2 e3) (s2, Rerr Rtype_error))

/\ (! ck env e1 e2 e3 err s s'.
(evaluate ck env s e1 (s', Rerr err))
==>
evaluate ck env s (If e1 e2 e3) (s', Rerr err))

/\ (! ck env e pes v bv s1 s2.
(evaluate ck env s1 e (s2, Rval v) /\
evaluate_match ck env s2 v pes (Conv (SOME (Short "Bind", TypeExn)) []) bv)
==>
evaluate ck env s1 (Mat e pes) bv)

/\ (! ck env e pes err s s'.
(evaluate ck env s e (s', Rerr err))
==>
evaluate ck env s (Mat e pes) (s', Rerr err))

/\ (! ck menv cenv env n e1 e2 v bv s1 s2.
(evaluate ck (menv,cenv,env) s1 e1 (s2, Rval v) /\
evaluate ck (menv,cenv,bind n v env) s2 e2 bv)
==>
evaluate ck (menv,cenv,env) s1 (Let n e1 e2) bv)

/\ (! ck env n e1 e2 err s s'.
(evaluate ck env s e1 (s', Rerr err))
==>
evaluate ck env s (Let n e1 e2) (s', Rerr err))

/\ (! ck menv cenv env funs e bv s.
(ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs) /\
evaluate ck (menv,cenv,build_rec_env funs (menv,cenv,env) env) s e bv)
==>
evaluate ck (menv,cenv,env) s (Letrec funs e) bv)

/\ (! ck env funs e s.
(~ (ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs)))
==>
evaluate ck env s (Letrec funs e) (s, Rerr Rtype_error))

/\ (! ck env s.
T
==>
evaluate_list ck env s [] (s, Rval []))

/\ (! ck env e es v vs s1 s2 s3.
(evaluate ck env s1 e (s2, Rval v) /\
evaluate_list ck env s2 es (s3, Rval vs))
==>
evaluate_list ck env s1 (e::es) (s3, Rval (v::vs)))

/\ (! ck env e es err s s'.
(evaluate ck env s e (s', Rerr err))
==>
evaluate_list ck env s (e::es) (s', Rerr err))

/\ (! ck env e es v err s1 s2 s3.
(evaluate ck env s1 e (s2, Rval v) /\
evaluate_list ck env s2 es (s3, Rerr err))
==>
evaluate_list ck env s1 (e::es) (s3, Rerr err))

/\ (! ck env v err_v s.
T
==>
evaluate_match ck env s v [] err_v (s, Rerr (Rraise err_v)))

/\ (! ck menv cenv env env' v p pes e bv err_v s count.
(ALL_DISTINCT (pat_bindings p []) /\
((pmatch cenv s p v env = Match env') /\
evaluate ck (menv,cenv,env') (count,s) e bv))
==>
evaluate_match ck (menv,cenv,env) (count,s) v ((p,e)::pes) err_v bv)

/\ (! ck menv cenv env v p e pes bv s count err_v.
(ALL_DISTINCT (pat_bindings p []) /\
((pmatch cenv s p v env = No_match) /\
evaluate_match ck (menv,cenv,env) (count,s) v pes err_v bv))
==>
evaluate_match ck (menv,cenv,env) (count,s) v ((p,e)::pes) err_v bv)

/\ (! ck menv cenv env v p e pes s count err_v.
(pmatch cenv s p v env = Match_type_error)
==>
evaluate_match ck (menv,cenv,env) (count,s) v ((p,e)::pes) err_v ((count,s), Rerr Rtype_error))

/\ (! ck env v p e pes s err_v.
(~ (ALL_DISTINCT (pat_bindings p [])))
==>
evaluate_match ck env s v ((p,e)::pes) err_v (s, Rerr Rtype_error))`;

val _ = Hol_reln ` (! mn env p e v env' s1 s2 count.
(evaluate F env ( 0,s1) e ((count,s2), Rval v) /\
(ALL_DISTINCT (pat_bindings p []) /\
(pmatch (all_env_to_cenv env) s2 p v emp = Match env')))
==>
evaluate_dec mn env s1 (Dlet p e) (s2, Rval (emp, env')))

/\ (! mn env p e v s1 s2 count.
(evaluate F env ( 0,s1) e ((count,s2), Rval v) /\
(ALL_DISTINCT (pat_bindings p []) /\
(pmatch (all_env_to_cenv env) s2 p v emp = No_match)))
==>
evaluate_dec mn env s1 (Dlet p e) (s2, Rerr (Rraise (Conv (SOME (Short "Bind", TypeExn)) []))))

/\ (! mn env p e v s1 s2 count.
(evaluate F env ( 0,s1) e ((count,s2), Rval v) /\
(ALL_DISTINCT (pat_bindings p []) /\
(pmatch (all_env_to_cenv env) s2 p v emp = Match_type_error)))
==>
evaluate_dec mn env s1 (Dlet p e) (s2, Rerr Rtype_error))

/\ (! mn env p e s.
(~ (ALL_DISTINCT (pat_bindings p [])))
==>
evaluate_dec mn env s (Dlet p e) (s, Rerr Rtype_error))

/\ (! mn env p e err s count s'.
(evaluate F env ( 0,s) e ((count,s'), Rerr err) /\
ALL_DISTINCT (pat_bindings p []))
==>
evaluate_dec mn env s (Dlet p e) (s', Rerr err))

/\ (! mn env funs s.
(ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs))
==>
evaluate_dec mn env s (Dletrec funs) (s, Rval (emp, build_rec_env funs env emp)))

/\ (! mn env funs s.
(~ (ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs)))
==>
evaluate_dec mn env s (Dletrec funs) (s, Rerr Rtype_error))

/\ (! mn env tds s.
(check_dup_ctors tds)
==>
evaluate_dec mn env s (Dtype tds) (s, Rval (build_tdefs mn tds, emp)))

/\ (! mn env tds s.
(~ (check_dup_ctors tds))
==>
evaluate_dec mn env s (Dtype tds) (s, Rerr Rtype_error))

/\ (! mn env cn ts s.
(lookup (Short cn) (all_env_to_cenv env) = NONE)
==>
evaluate_dec mn env s (Dexn cn ts) (s, Rval (bind (Short cn) (LENGTH ts, TypeExn) emp, emp)))

/\ (! mn env cn ts s.
(* TODO: Allow it to be bound to a constructor for a non-exception *)
( ~ ((lookup (Short cn) (all_env_to_cenv env)) = NONE))
==>
evaluate_dec mn env s (Dexn cn ts) (s, Rerr Rtype_error))`;

val _ = Hol_reln ` (! mn env s.
T
==>
evaluate_decs mn env s [] (s, emp, Rval emp))

/\ (! mn s1 s2 env d ds e.
(evaluate_dec mn env s1 d (s2, Rerr e))
==>
evaluate_decs mn env s1 (d::ds) (s2, emp, Rerr e))

/\ (! mn s1 s2 s3 menv cenv env d ds new_tds' new_tds new_env r.
(evaluate_dec mn (menv,cenv,env) s1 d (s2, Rval (new_tds,new_env)) /\
evaluate_decs mn (menv, merge new_tds cenv, merge new_env env) s2 ds (s3, new_tds', r))
==>
evaluate_decs mn (menv,cenv,env) s1 (d::ds) (s3, merge new_tds' new_tds, combine_dec_result new_env r))`;

val _ = Hol_reln ` (! s1 s2 env d new_tds new_env.
(evaluate_dec NONE env s1 d (s2, Rval (new_tds, new_env)))
==>
evaluate_top env s1 (Tdec d) (s2, new_tds, Rval (emp, new_env)))

/\ (! s1 s2 env d err.
(evaluate_dec NONE env s1 d (s2, Rerr err))
==>
evaluate_top env s1 (Tdec d) (s2, emp, Rerr err))

/\ (! s1 s2 env ds mn specs new_tds new_env.
 (~ (MEM mn (MAP FST (all_env_to_menv env))) /\
evaluate_decs (SOME mn) env s1 ds (s2, new_tds, Rval new_env))
==>
evaluate_top env s1 (Tmod mn specs ds) (s2, add_mod_prefix mn new_tds, Rval ([(mn,new_env)], emp)))

/\ (! s1 s2 env ds mn specs new_tds err.
 (~ (MEM mn (MAP FST (all_env_to_menv env))) /\
evaluate_decs (SOME mn) env s1 ds (s2, new_tds, Rerr err))
==>
evaluate_top env s1 (Tmod mn specs ds) (s2, add_mod_prefix mn new_tds, Rerr err))

/\ (! env s mn specs ds.
(MEM mn (MAP FST (all_env_to_menv env)))
==>
evaluate_top env s (Tmod mn specs ds) (s, emp, Rerr Rtype_error))`;

val _ = Hol_reln ` (! env s.
T
==>
evaluate_prog env s [] (s, emp, Rval (emp, emp)))

/\ (! s1 s2 s3 menv cenv env top tops new_mods new_tds new_tds' new_env r.
(evaluate_top (menv,cenv,env) s1 top (s2, new_tds, Rval (new_mods,new_env)) /\
evaluate_prog (merge new_mods menv,merge new_tds cenv, merge new_env env) s2 tops (s3, new_tds', r))
==>
evaluate_prog (menv,cenv,env) s1 (top::tops) (s3, merge new_tds' new_tds, combine_mod_result new_mods new_env r))

/\ (! s1 s2 env top tops err new_tds.
(evaluate_top env s1 top (s2, new_tds, Rerr err))
==>
evaluate_prog env s1 (top::tops) (s2, new_tds, Rerr err))`;

val _ = Define `
 (dec_diverges st env d =  
((case d of
      Dlet p e => ALL_DISTINCT (pat_bindings p []) /\ e_diverges st env e
    | Dletrec funs => F
    | Dtype tds => F
    | Dexn cn ts => F
  )))`;


val _ = Hol_reln ` (! mn st env d ds.
(dec_diverges env st d)
==>
decs_diverges mn env st (d::ds)) 

/\ (! mn s1 s2 menv cenv env d ds new_tds new_env.
(evaluate_dec mn (menv,cenv,env) s1 d (s2, Rval (new_tds, new_env)) /\
decs_diverges mn (menv, merge new_tds cenv, merge new_env env) s2 ds)
==>
decs_diverges mn (menv,cenv,env) s1 (d::ds))`;

val _ = Hol_reln ` (! st env d.
(dec_diverges env st d)
==>
top_diverges env st (Tdec d))

/\ (! env s1 ds mn specs.
(~ (MEM mn (MAP FST (all_env_to_menv env))) /\
decs_diverges (SOME mn) env s1 ds)
==>
top_diverges env s1 (Tmod mn specs ds))`;

val _ = Hol_reln ` (! st env top tops.
(top_diverges env st top)
==>
prog_diverges env st (top::tops))

/\ (! s1 s2 menv cenv env top tops new_mods new_tds new_env.
(evaluate_top (menv,cenv,env) s1 top (s2, new_tds, Rval (new_mods, new_env)) /\
prog_diverges (merge new_mods menv, merge new_tds cenv, merge new_env env) s2 tops)
==>
prog_diverges (menv,cenv,env) s1 (top::tops))`;
val _ = export_theory()

