(*Generated by Lem from bigStep.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extraTheory libTheory astTheory ffiTheory semanticPrimitivesTheory smallStepTheory;

val _ = numLib.prefer_num();



val _ = new_theory "bigStep"

(*open import Pervasives_extra*)
(*open import Lib*)
(*open import Ast*)
(*open import SemanticPrimitives*)
(*open import Ffi*)

(* To get the definition of expression divergence to use in defining definition
 * divergence *)
(*open import SmallStep*)

(* ------------------------ Big step semantics -------------------------- *)

(* If the first argument is true, the big step semantics counts down how many
   functions applications have happened, and raises an exception when the counter
   runs out. *)

val _ = Hol_reln ` (! ck oc env l s.
T
==>
evaluate ck oc env s (Lit l) (s, Rval (Litv l)))

/\ (! ck oc env e s1 s2 v.
(evaluate ck oc s1 env e (s2, Rval v))
==>
evaluate ck oc s1 env (Raise e) (s2, Rerr (Rraise v)))

/\ (! ck oc env e s1 s2 err.
(evaluate ck oc s1 env e (s2, Rerr err))
==>
evaluate ck oc s1 env (Raise e) (s2, Rerr err))

/\ (! ck oc s1 s2 env e v pes.
(evaluate ck oc s1 env e (s2, Rval v))
==>
evaluate ck oc s1 env (Handle e pes) (s2, Rval v))

/\ (! ck oc s1 s2 env e pes v bv.
(evaluate ck oc env s1 e (s2, Rerr (Rraise v)) /\
evaluate_match ck oc env s2 v pes v bv)
==>
evaluate ck oc env s1 (Handle e pes) bv)

/\ (! ck oc s1 s2 env e pes a.
(evaluate ck oc env s1 e (s2, Rerr (Rabort a)))
==>
evaluate ck oc env s1 (Handle e pes) (s2, Rerr (Rabort a)))

/\ (! ck oc env cn es vs s s' v.
(do_con_check env.c cn (LENGTH es) /\
(build_conv env.c cn (REVERSE vs) = SOME v) /\
evaluate_list ck oc env s (REVERSE es) (s', Rval vs))
==>
evaluate ck oc env s (Con cn es) (s', Rval v))

/\ (! ck oc env cn es s.
(~ (do_con_check env.c cn (LENGTH es)))
==>
evaluate ck oc env s (Con cn es) (s, Rerr (Rabort Rtype_error)))

/\ (! ck oc env cn es err s s'.
(do_con_check env.c cn (LENGTH es) /\
evaluate_list ck oc env s (REVERSE es) (s', Rerr err))
==>
evaluate ck oc env s (Con cn es) (s', Rerr err))

/\ (! ck oc env n v s.
(lookup_var_id n env = SOME v)
==>
evaluate ck oc env s (Var n) (s, Rval v))

/\ (! ck oc env n s.
(lookup_var_id n env = NONE)
==>
evaluate ck oc env s (Var n) (s, Rerr (Rabort Rtype_error)))

/\ (! ck oc env n e s.
T
==>
evaluate ck oc env s (Fun n e) (s, Rval (Closure env n e)))

/\ (! ck oc env es vs env' e bv s1 s2.
(evaluate_list ck oc env s1 (REVERSE es) (s2, Rval vs) /\
(do_opapp (REVERSE vs) = SOME (env', e)) /\
(ck ==> ~ (s2.clock =( 0))) /\
evaluate ck oc env' (if ck then ( s2 with<| clock := s2.clock -  1 |>) else s2) e bv)
==>
evaluate ck oc env s1 (App Opapp es) bv)

/\ (! ck oc env es vs env' e s1 s2.
(evaluate_list ck oc env s1 (REVERSE es) (s2, Rval vs) /\
(do_opapp (REVERSE vs) = SOME (env', e)) /\
(s2.clock = 0) /\
ck)
==>
evaluate ck oc env s1 (App Opapp es) (s2, Rerr (Rabort Rtimeout_error)))

/\ (! ck oc env es vs s1 s2.
(evaluate_list ck oc env s1 (REVERSE es) (s2, Rval vs) /\
(do_opapp (REVERSE vs) = NONE))
==>
evaluate ck oc env s1 (App Opapp es) (s2, Rerr (Rabort Rtype_error)))

/\ (! ck oc env op es vs res s1 s2 refs' ffi'.
(evaluate_list ck oc env s1 (REVERSE es) (s2, Rval vs) /\
(do_app oc (s2.refs,s2.ffi) op (REVERSE vs) = SOME ((refs',ffi'), res)) /\
(op <> Opapp))
==>
evaluate ck oc env s1 (App op es) (( s2 with<| refs := refs'; ffi :=ffi' |>), res))

/\ (! ck oc env op es vs s1 s2.
(evaluate_list ck oc env s1 (REVERSE es) (s2, Rval vs) /\
(do_app oc (s2.refs,s2.ffi) op (REVERSE vs) = NONE) /\
(op <> Opapp))
==>
evaluate ck oc env s1 (App op es) (s2, Rerr (Rabort Rtype_error)))

/\ (! ck oc env op es err s1 s2.
(evaluate_list ck oc env s1 (REVERSE es) (s2, Rerr err))
==>
evaluate ck oc env s1 (App op es) (s2, Rerr err))

/\ (! ck oc env op e1 e2 v e' bv s1 s2.
(evaluate ck oc env s1 e1 (s2, Rval v) /\
(do_log op v e2 = SOME (Exp e')) /\
evaluate ck oc env s2 e' bv)
==>
evaluate ck oc env s1 (Log op e1 e2) bv)

/\ (! ck oc env op e1 e2 v bv s1 s2.
(evaluate ck oc env s1 e1 (s2, Rval v) /\
(do_log op v e2 = SOME (Val bv)))
==>
evaluate ck oc env s1 (Log op e1 e2) (s2, Rval bv))

/\ (! ck oc env op e1 e2 v s1 s2.
(evaluate ck oc env s1 e1 (s2, Rval v) /\
(do_log op v e2 = NONE))
==>
evaluate ck oc env s1 (Log op e1 e2) (s2, Rerr (Rabort Rtype_error)))

/\ (! ck oc env op e1 e2 err s s'.
(evaluate ck oc env s e1 (s', Rerr err))
==>
evaluate ck oc env s (Log op e1 e2) (s', Rerr err))

/\ (! ck oc env e1 e2 e3 v e' bv s1 s2.
(evaluate ck oc env s1 e1 (s2, Rval v) /\
(do_if v e2 e3 = SOME e') /\
evaluate ck oc env s2 e' bv)
==>
evaluate ck oc env s1 (If e1 e2 e3) bv)

/\ (! ck oc env e1 e2 e3 v s1 s2.
(evaluate ck oc env s1 e1 (s2, Rval v) /\
(do_if v e2 e3 = NONE))
==>
evaluate ck oc env s1 (If e1 e2 e3) (s2, Rerr (Rabort Rtype_error)))

/\ (! ck oc env e1 e2 e3 err s s'.
(evaluate ck oc env s e1 (s', Rerr err))
==>
evaluate ck oc env s (If e1 e2 e3) (s', Rerr err))

/\ (! ck oc env e pes v bv s1 s2.
(evaluate ck oc env s1 e (s2, Rval v) /\
evaluate_match ck oc env s2 v pes (Conv (SOME ("Bind", TypeExn (Short "Bind"))) []) bv)
==>
evaluate ck oc env s1 (Mat e pes) bv)

/\ (! ck oc env e pes err s s'.
(evaluate ck oc env s e (s', Rerr err))
==>
evaluate ck oc env s (Mat e pes) (s', Rerr err))

/\ (! ck oc env n e1 e2 v bv s1 s2.
(evaluate ck oc env s1 e1 (s2, Rval v) /\
evaluate ck oc ( env with<| v := opt_bind n v env.v |>) s2 e2 bv)
==>
evaluate ck oc env s1 (Let n e1 e2) bv)

/\ (! ck oc env n e1 e2 err s s'.
(evaluate ck oc env s e1 (s', Rerr err))
==>
evaluate ck oc env s (Let n e1 e2) (s', Rerr err))

/\ (! ck oc env funs e bv s.
(ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs) /\
evaluate ck oc ( env with<| v := build_rec_env funs env env.v |>) s e bv)
==>
evaluate ck oc env s (Letrec funs e) bv)

/\ (! ck oc env funs e s.
(~ (ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs)))
==>
evaluate ck oc env s (Letrec funs e) (s, Rerr (Rabort Rtype_error)))

/\ (! ck oc env s.
T
==>
evaluate_list ck oc env s [] (s, Rval []))

/\ (! ck oc env e es v vs s1 s2 s3.
(evaluate ck oc env s1 e (s2, Rval v) /\
evaluate_list ck oc env s2 es (s3, Rval vs))
==>
evaluate_list ck oc env s1 (e::es) (s3, Rval (v::vs)))

/\ (! ck oc env e es err s s'.
(evaluate ck oc env s e (s', Rerr err))
==>
evaluate_list ck oc env s (e::es) (s', Rerr err))

/\ (! ck oc env e es v err s1 s2 s3.
(evaluate ck oc env s1 e (s2, Rval v) /\
evaluate_list ck oc env s2 es (s3, Rerr err))
==>
evaluate_list ck oc env s1 (e::es) (s3, Rerr err))

/\ (! ck oc env v err_v s.
T
==>
evaluate_match ck oc env s v [] err_v (s, Rerr (Rraise err_v)))

/\ (! ck oc env env' v p pes e bv err_v s.
(ALL_DISTINCT (pat_bindings p []) /\
(pmatch env.c s.refs p v env.v = Match env') /\
evaluate ck oc ( env with<| v := env' |>) s e bv)
==>
evaluate_match ck oc env s v ((p,e)::pes) err_v bv)

/\ (! ck oc env v p e pes bv s err_v.
(ALL_DISTINCT (pat_bindings p []) /\
(pmatch env.c s.refs p v env.v = No_match) /\
evaluate_match ck oc env s v pes err_v bv)
==>
evaluate_match ck oc env s v ((p,e)::pes) err_v bv)

/\ (! ck oc env v p e pes s err_v.
(pmatch env.c s.refs p v env.v = Match_type_error)
==>
evaluate_match ck oc env s v ((p,e)::pes) err_v (s, Rerr (Rabort Rtype_error)))

/\ (! ck oc env v p e pes s err_v.
(~ (ALL_DISTINCT (pat_bindings p [])))
==>
evaluate_match ck oc env s v ((p,e)::pes) err_v (s, Rerr (Rabort Rtype_error)))`;

(* The set tid_or_exn part of the state tracks all of the types and exceptions
 * that have been declared *)
val _ = Hol_reln ` (! ck oc mn env p e v env' s1 s2.
(evaluate ck oc env s1 e (s2, Rval v) /\
ALL_DISTINCT (pat_bindings p []) /\
(pmatch env.c s2.refs p v [] = Match env'))
==>
evaluate_dec ck oc mn env s1 (Dlet p e) (s2, Rval ([], env')))

/\ (! ck oc mn env p e v s1 s2.
(evaluate ck oc env s1 e (s2, Rval v) /\
ALL_DISTINCT (pat_bindings p []) /\
(pmatch env.c s2.refs p v [] = No_match))
==>
evaluate_dec ck oc mn env s1 (Dlet p e) (s2, Rerr (Rraise Bindv)))

/\ (! ck oc mn env p e v s1 s2.
(evaluate ck oc env s1 e (s2, Rval v) /\
ALL_DISTINCT (pat_bindings p []) /\
(pmatch env.c s2.refs p v [] = Match_type_error))
==>
evaluate_dec ck oc mn env s1 (Dlet p e) (s2, Rerr (Rabort Rtype_error)))

/\ (! ck oc mn env p e s.
(~ (ALL_DISTINCT (pat_bindings p [])))
==>
evaluate_dec ck oc mn env s (Dlet p e) (s, Rerr (Rabort Rtype_error)))

/\ (! ck oc mn env p e err s s'.
(evaluate ck oc env s e (s', Rerr err) /\
ALL_DISTINCT (pat_bindings p []))
==>
evaluate_dec ck oc mn env s (Dlet p e) (s', Rerr err))

/\ (! ck oc mn env funs s.
(ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs))
==>
evaluate_dec ck oc mn env s (Dletrec funs) (s, Rval ([], build_rec_env funs env [])))

/\ (! ck oc mn env funs s.
(~ (ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs)))
==>
evaluate_dec ck oc mn env s (Dletrec funs) (s, Rerr (Rabort Rtype_error)))

/\ (! ck oc mn env tds s new_tdecs.
(check_dup_ctors tds /\
(new_tdecs = type_defs_to_new_tdecs mn tds) /\
DISJOINT new_tdecs s.defined_types /\
ALL_DISTINCT (MAP (\ (tvs,tn,ctors) .  tn) tds))
==>
evaluate_dec ck oc mn env s (Dtype tds) (( s with<| defined_types := new_tdecs UNION s.defined_types |>), Rval (build_tdefs mn tds, [])))

/\ (! ck oc mn env tds s.
(~ (check_dup_ctors tds) \/
(~ (DISJOINT (type_defs_to_new_tdecs mn tds) s.defined_types) \/
~ (ALL_DISTINCT (MAP (\ (tvs,tn,ctors) .  tn) tds))))
==>
evaluate_dec ck oc mn env s (Dtype tds) (s, Rerr (Rabort Rtype_error)))

/\ (! ck oc mn env tvs tn t s.
T
==>
evaluate_dec ck oc mn env s (Dtabbrev tvs tn t) (s, Rval ([], [])))

/\ (! ck oc mn env cn ts s.
(~ (TypeExn (mk_id mn cn) IN s.defined_types))
==>
evaluate_dec ck oc mn env s (Dexn cn ts) (( s with<| defined_types := {TypeExn (mk_id mn cn)} UNION s.defined_types |>), Rval ([(cn, (LENGTH ts, TypeExn (mk_id mn cn)))], [])))

/\ (! ck oc mn env cn ts s.
(TypeExn (mk_id mn cn) IN s.defined_types)
==>
evaluate_dec ck oc mn env s (Dexn cn ts) (s, Rerr (Rabort Rtype_error)))`;

val _ = Hol_reln ` (! ck oc mn env s.
T
==>
evaluate_decs ck oc mn env s [] (s, [], Rval []))

/\ (! ck oc mn s1 s2 env d ds e.
(evaluate_dec ck oc mn env s1 d (s2, Rerr e))
==>
evaluate_decs ck oc mn env s1 (d::ds) (s2, [], Rerr e))

/\ (! ck oc mn s1 s2 s3 env d ds new_tds' new_tds new_env r.
(evaluate_dec ck oc mn env s1 d (s2, Rval (new_tds,new_env)) /\
evaluate_decs ck oc mn (extend_dec_env new_env new_tds env) s2 ds (s3, new_tds', r))
==>
evaluate_decs ck oc mn env s1 (d::ds) (s3, (new_tds' ++ new_tds), combine_dec_result new_env r))`;


val _ = Hol_reln ` (! ck oc s1 s2 env d new_tds new_env.
(evaluate_dec ck oc NONE env s1 d (s2, Rval (new_tds, new_env)))
==>
evaluate_top ck oc env s1 (Tdec d) (s2, ([],new_tds), Rval ([], new_env)))

/\ (! ck oc s1 s2 env d err.
(evaluate_dec ck oc NONE env s1 d (s2, Rerr err))
==>
evaluate_top ck oc env s1 (Tdec d) (s2, ([],[]), Rerr err))

/\ (! ck oc s1 s2 env ds mn specs new_tds new_env.
(~ (mn IN s1.defined_mods) /\
no_dup_types ds /\
evaluate_decs ck oc (SOME mn) env s1 ds (s2, new_tds, Rval new_env))
==>
evaluate_top ck oc env s1 (Tmod mn specs ds) (( s2 with<| defined_mods := {mn} UNION s2.defined_mods |>), ([(mn,new_tds)], []), Rval ([(mn,new_env)], [])))

/\ (! ck oc s1 s2 env ds mn specs new_tds err.
(~ (mn IN s1.defined_mods) /\
no_dup_types ds /\
evaluate_decs ck oc (SOME mn) env s1 ds (s2, new_tds, Rerr err))
==>
evaluate_top ck oc env s1 (Tmod mn specs ds) (( s2 with<| defined_mods := {mn} UNION s2.defined_mods |>), ([(mn,new_tds)], []), Rerr err))

/\ (! ck oc s1 env ds mn specs.
(~ (no_dup_types ds))
==>
evaluate_top ck oc env s1 (Tmod mn specs ds) (s1, ([],[]), Rerr (Rabort Rtype_error)))

/\ (! ck oc env s mn specs ds.
(mn IN s.defined_mods)
==>
evaluate_top ck oc env s (Tmod mn specs ds) (s, ([],[]), Rerr (Rabort Rtype_error)))`;

val _ = Hol_reln ` (! ck oc env s.
T
==>
evaluate_prog ck oc env s [] (s, ([],[]), Rval ([], [])))

/\ (! ck oc s1 s2 s3 env top tops new_mods new_tds new_tds' new_env r.
(evaluate_top ck oc env s1 top (s2, new_tds, Rval (new_mods,new_env)) /\
evaluate_prog ck oc (extend_top_env new_mods new_env new_tds env) s2 tops (s3,new_tds',r))
==>
evaluate_prog ck oc env s1 (top::tops) (s3, merge_alist_mod_env new_tds' new_tds, combine_mod_result new_mods new_env r))

/\ (! ck oc s1 s2 env top tops err new_tds.
(evaluate_top ck oc env s1 top (s2, new_tds, Rerr err))
==>
evaluate_prog ck oc env s1 (top::tops) (s2, new_tds, Rerr err))`;


(*val evaluate_whole_prog : forall 'ffi. Eq 'ffi => bool -> oracle 'ffi -> environment v -> state 'ffi -> prog ->
          state 'ffi * env_ctor * result (env_mod * env_val) v -> bool*)
val _ = Define `
 (evaluate_whole_prog ck oc env s1 tops (s2, new_tds, res) =  
(if no_dup_mods tops s1.defined_mods /\ no_dup_top_types tops s1.defined_types then
    evaluate_prog ck oc env s1 tops (s2, new_tds, res)
  else    
(s1 = s2) /\ (new_tds = ([],[])) /\ (res = Rerr (Rabort Rtype_error))))`;


(*val dec_diverges : forall 'ffi. oracle 'ffi -> environment v -> state 'ffi -> dec -> bool*)
val _ = Define `
 (dec_diverges oc env st d =  
((case d of
      Dlet p e => ALL_DISTINCT (pat_bindings p []) /\ e_diverges oc env (st.refs, st.ffi) e
    | Dletrec funs => F
    | Dtype tds => F
    | Dtabbrev tvs tn t => F
    | Dexn cn ts => F
  )))`;


val _ = Hol_reln ` (! oc mn st env d ds.
(dec_diverges oc env st d)
==>
decs_diverges oc mn env st (d::ds))

/\ (! oc mn s1 s2 env d ds new_tds new_env.
(evaluate_dec F oc mn env s1 d (s2, Rval (new_tds, new_env)) /\
decs_diverges oc mn (extend_dec_env new_env new_tds env) s2 ds)
==>
decs_diverges oc mn env s1 (d::ds))`;

val _ = Hol_reln ` (! oc st env d.
(dec_diverges oc env st d)
==>
top_diverges oc env st (Tdec d))

/\ (! oc env s1 ds mn specs.
(~ (mn IN s1.defined_mods) /\
no_dup_types ds /\
decs_diverges oc (SOME mn) env s1 ds)
==>
top_diverges oc env s1 (Tmod mn specs ds))`;

val _ = Hol_reln ` (! oc st env top tops.
(top_diverges oc env st top)
==>
prog_diverges oc env st (top::tops))

/\ (! oc s1 s2 env top tops new_mods new_tds new_env.
(evaluate_top F oc env s1 top (s2, new_tds, Rval (new_mods, new_env)) /\
prog_diverges oc (extend_top_env new_mods new_env new_tds env) s2 tops)
==>
prog_diverges oc env s1 (top::tops))`;
val _ = export_theory()

