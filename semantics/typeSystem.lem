open import Pervasives_extra
open import Lib
open import Ast

(* Only to get check_dup_ctors *)
open import SemanticPrimitives 

(* Check that the free type variables are in the given list.  Every deBruijn
 * variable must be smaller than the first argument.  So if it is 0, no deBruijn
 * indices are permitted. *)
val check_freevars : nat -> list tvarN -> t -> bool
let rec
check_freevars dbmax tvs (Tvar tv) =
  elem tv tvs
and
check_freevars dbmax tvs (Tapp ts tn) =
  List.all (check_freevars dbmax tvs) ts
and
check_freevars dbmax tvs (Tvar_db n) = n < dbmax

(* Simultaneous substitution of types for type variables in a type *)
val type_subst : env tvarN t -> t -> t
let rec
type_subst s (Tvar tv) =
  match lookup tv s with
    | Nothing -> Tvar tv
    | Just(t) -> t
  end
and
type_subst s (Tapp ts tn) =
  Tapp (List.map (type_subst s) ts) tn
and
type_subst s (Tvar_db n) = Tvar_db n

(* Increment the deBruijn indices in a type by n levels, skipping all levels
 * less than skip. *)
val deBruijn_inc : nat -> nat -> t -> t
let rec
deBruijn_inc skip n (Tvar tv) = Tvar tv
and
deBruijn_inc skip n (Tvar_db m) =
  if m < skip then
    Tvar_db m
  else
    Tvar_db (m + n)
and
deBruijn_inc skip n (Tapp ts tn) = Tapp (List.map (deBruijn_inc skip n) ts) tn

(* skip the lowest given indices and replace the next (LENGTH ts) with the given types and reduce all the higher ones *)
val deBruijn_subst : nat -> list t -> t -> t
let rec
deBruijn_subst skip ts (Tvar tv) = Tvar tv
and
deBruijn_subst skip ts (Tvar_db n) =
  if not (n < skip) && (n < List.length ts + skip) then
    List_extra.nth ts (n - skip)
  else if not (n < skip) then
    Tvar_db (n - List.length ts)
  else
    Tvar_db n
and
deBruijn_subst skip ts (Tapp ts' tn) =
  Tapp (List.map (deBruijn_subst skip ts) ts') tn

(* constructor type environments: each constructor has a type
 * forall tyvars. t list -> (tyvars) typeN *)
type flat_tenvC = env conN (list tvarN * list t * tid_or_exn)
type tenvC = env modN flat_tenvC * flat_tenvC

val merge_tenvC : tenvC -> tenvC -> tenvC
let merge_tenvC (mcenv1,cenv1) (mcenv2,cenv2) = 
  (merge mcenv1 mcenv2, merge cenv1 cenv2)

(* Type environments *)
type tenvE =
  | Empty
  (* Binds several de Bruijn type variables *)
  | Bind_tvar of nat * tenvE
  (* The number is how many de Bruijn type variables the typescheme binds *)
  | Bind_name of varN * nat * t * tenvE

type tenvM = env modN (env varN (nat * t))

let bind_tvar tvs tenv = if tvs = 0 then tenv else Bind_tvar tvs tenv

val lookup_tenv : varN -> nat -> tenvE -> maybe (nat * t) 
let rec
lookup_tenv n inc Empty = Nothing
and
lookup_tenv n inc (Bind_tvar tvs e) = lookup_tenv n (inc + tvs) e
and
lookup_tenv n inc (Bind_name n' tvs t e) =
  if n' = n then
    Just (tvs, deBruijn_inc tvs inc t)
  else
    lookup_tenv n inc e

declare termination_argument lookup_tenv = automatic

val bind_tenv : varN -> nat -> t -> tenvE -> tenvE
let bind_tenv n tvs t e = Bind_name n tvs t e

val opt_bind_tenv : maybe varN -> nat -> t -> tenvE -> tenvE
let opt_bind_tenv n tvs t e = 
  match n with
    | Nothing -> e
    | Just n' -> Bind_name n' tvs t e
  end

val t_lookup_var_id : id varN -> tenvM -> tenvE -> maybe (nat * t)
let t_lookup_var_id id tenvM tenvE =
  match id with
    | Short x -> lookup_tenv x 0 tenvE
    | Long x y ->
        match lookup x tenvM with
          | Nothing -> Nothing
          | Just tenvE' -> lookup y tenvE'
        end
  end

val num_tvs : tenvE -> nat
let rec 
num_tvs Empty = 0
and
num_tvs (Bind_tvar tvs e) = tvs + num_tvs e
and
num_tvs (Bind_name n tvs t e) = num_tvs e

declare termination_argument num_tvs = automatic

val bind_var_list : nat -> list (varN * t) -> tenvE -> tenvE
let rec
bind_var_list tvs [] tenv = tenv
and
bind_var_list tvs ((n,t)::binds) tenv =
  bind_tenv n tvs t (bind_var_list tvs binds tenv)

declare termination_argument bind_var_list = automatic

val bind_var_list2 : env varN (nat * t) -> tenvE -> tenvE
let rec
bind_var_list2 [] tenv = tenv
and
bind_var_list2 ((n,(tvs,t))::binds) tenv =
  bind_tenv n tvs t (bind_var_list2 binds tenv)

declare termination_argument bind_var_list2 = automatic

(* A pattern matches values of a certain type and extends the type environment
 * with the pattern's binders. The number is the maximum deBruijn type variable
 * allowed. *)
val type_p : nat -> tenvC -> pat -> t -> list (varN * t) -> bool

(* An expression has a type *)
val type_e : tenvM -> tenvC -> tenvE -> exp -> t -> bool

(* A list of expressions has a list of types *)
val type_es : tenvM -> tenvC -> tenvE -> list exp -> list t -> bool

(* Type a mutually recursive bundle of functions.  Unlike pattern typing, the
 * resulting environment does not extend the input environment, but just
 * represents the functions *)
val type_funs : tenvM -> tenvC -> tenvE -> list (varN * varN * exp) ->
                list (varN * t) -> bool

type decls = set modN * set (id typeN) * set (id conN)

val empty_decls : decls
let empty_decls = ({},{},{})

val union_decls : decls -> decls -> decls
let union_decls (m1,t1,e1) (m2,t2,e2) =
  (m1 union m2, t1 union t2, e1 union e2)

(* Check a declaration and update the top-level environments
 * The arguments are in order:
 * - the module that the declaration is in
 * - the set of all modules, and types, and exceptions that have been previously declared
 * - the type schemes of bindings in previous modules
 * - the types of each constructor binding
 * - the type schemes of top-level bindings (plus those in the current module)
 * - the declaration
 * - the set of all modules, and types, and exceptions that have been previously declared and are declared here (cumulative)
 * - the types of the new constructors
 * - the type schemes of the new bindings *)

val type_d : maybe modN -> decls -> tenvM -> tenvC -> tenvE -> dec -> decls -> flat_tenvC -> env varN (nat * t) -> bool

val type_ds : maybe modN -> decls -> tenvM -> tenvC -> tenvE -> list dec -> decls -> flat_tenvC -> env varN (nat * t) -> bool
val weakE : env varN (nat * t) -> env varN (nat * t) -> bool
val check_signature : maybe modN -> decls -> flat_tenvC -> env varN (nat * t) -> maybe specs -> decls -> flat_tenvC -> env varN (nat * t) -> bool
val type_specs : maybe modN -> specs -> decls -> flat_tenvC -> env varN (nat * t) -> bool
val type_prog : decls -> tenvM -> tenvC -> tenvE -> list top -> decls -> tenvM -> tenvC -> env varN (nat * t) -> bool

(* Check that the operator can have type (t1 -> t2 -> t3) *)
val type_op : op -> t -> t -> t -> bool
let type_op op t1 t2 t3 =
  match (op,t1,t2) with
    | (Opapp, Tapp [t2'; t3'] TC_fn, _) -> (t2 = t2') && (t3 = t3')
    | (Opn _, Tapp [] TC_int, Tapp [] TC_int) -> (t3 = Tint)
    | (Opb _, Tapp [] TC_int, Tapp [] TC_int) -> (t3 = Tbool)
    | (Equality, t1, t2) -> (t1 = t2) && (t3 = Tbool)
    | (Opassign, Tapp [t1] TC_ref, t2) -> (t1 = t2) && (t3 = Tunit)
    | _ -> false
  end

(* Check that the operator can have type (t1 -> t2) *)
val type_uop : uop -> t -> t -> bool
let type_uop uop t1 t2 =
  match (uop,t1) with
    | (Opref, _) -> t2 = Tref t1
    | (Opderef, Tapp [t1'] TC_ref) -> t2 = t1'
    | _ -> false
  end

(* Check that a type definition defines no already defined types or duplicate
 * constructors, and that the free type variables of each constructor argument
 * type are included in the type's type parameters. *)
val check_ctor_tenv :
   maybe modN -> list (list tvarN * typeN * list (conN * list t)) -> bool
let check_ctor_tenv mn tds =
  check_dup_ctors tds &&  
  List.all
    (fun (tvs,tn,ctors) ->
       List.allDistinct tvs &&
       List.all
         (fun (cn,ts) -> (List.all (check_freevars 0 tvs) ts))
         ctors)
    tds &&  
  List.allDistinct (List.map (fun (_,tn,_) -> tn) tds)

val build_ctor_tenv : maybe modN -> list (list tvarN * typeN * list (conN * list t)) -> flat_tenvC
let build_ctor_tenv mn tds =
  List.reverse
    (concat
      (List.map
         (fun (tvs,tn,ctors) ->
            List.map (fun (cn,ts) -> (cn,(tvs,ts, TypeId (mk_id mn tn)))) ctors)
         tds))

(* Check that an exception definition defines no already defined (or duplicate)
 * constructors, and that the arguments have no free type variables. *)
val check_exn_tenv : maybe modN -> conN -> list t -> bool
let check_exn_tenv mn cn ts =
  List.all (check_freevars 0 []) ts

(* For the value restriction on let-based polymorphism *)
val is_value : exp -> bool
let rec 
is_value (Lit _) = true
and
is_value (Con _ es) = List.all is_value es
and
is_value (Var _) = true
and
is_value (Fun _ _) = true
and
is_value _ = false

val tid_exn_to_tc : tid_or_exn -> tc
let tid_exn_to_tc t =
  match t with
    | TypeId tid -> TC_name tid
    | TypeExn _ -> TC_exn
  end

indreln [type_p : nat -> tenvC -> pat -> t -> list (varN * t) -> bool]
and [type_ps : nat -> tenvC -> list pat -> list t -> list (varN * t) -> bool]

pvar : forall tvs cenv n t.
check_freevars tvs [] t
==>
type_p tvs cenv (Pvar n) t [(n,t)]

and

plit_bool : forall tvs cenv b.
true
==>
type_p tvs cenv (Plit (Bool b)) Tbool []

and

plit_int : forall tvs cenv n.
true
==>
type_p tvs cenv (Plit (IntLit n)) Tint []

and

plit_string : forall tvs cenv s.
true
==>
type_p tvs cenv (Plit (StrLit s)) Tstring []

and

plit_unit : forall tvs cenv.
true
==>
type_p tvs cenv (Plit Unit) Tunit []

and

pcon_some : forall tvs cenv cn ps ts tvs' tn ts' tenv.
List.all (check_freevars tvs []) ts' &&
List.length ts' = List.length tvs' &&
type_ps tvs cenv ps (List.map (type_subst (ZIP tvs' ts')) ts) tenv &&
lookup_con_id cn cenv = Just (tvs', ts, tn)
==>
type_p tvs cenv (Pcon (Just cn) ps) (Tapp ts' (tid_exn_to_tc tn)) tenv

and

pcon_none : forall tvs cenv ps ts tenv.
type_ps tvs cenv ps ts tenv
==>
type_p tvs cenv (Pcon Nothing ps) (Tapp ts TC_tup) tenv

and

pref : forall tvs cenv p t tenv.
type_p tvs cenv p t tenv
==>
type_p tvs cenv (Pref p) (Tref t) tenv

and

empty : forall tvs cenv.
true
==>
type_ps tvs cenv [] [] []

and

cons : forall tvs cenv p ps t ts tenv tenv'.
type_p tvs cenv p t tenv &&
type_ps tvs cenv ps ts tenv'
==>
type_ps tvs cenv (p::ps) (t::ts) (tenv'++tenv)

indreln [type_e : tenvM -> tenvC -> tenvE -> exp -> t -> bool]
and [type_es : tenvM -> tenvC -> tenvE -> list exp -> list t -> bool]
and [type_funs : tenvM -> tenvC -> tenvE -> list (varN * varN * exp) -> list (varN * t) -> bool]


lit_bool : forall menv cenv tenv b.
true
==>
type_e menv cenv tenv (Lit (Bool b)) Tbool

and

lit_int : forall menv cenv tenv n.
true
==>
type_e menv cenv tenv (Lit (IntLit n)) Tint

and

lit_string : forall menv cenv tenv s.
true
==>
type_e menv cenv tenv (Lit (StrLit s)) Tstring

and

lit_unit : forall menv cenv tenv.
true
==>
type_e menv cenv tenv (Lit Unit) Tunit

and

raise : forall menv cenv tenv e t.
check_freevars (num_tvs tenv) [] t &&
type_e menv cenv tenv e Texn 
==>
type_e menv cenv tenv (Raise e) t

and

handle : forall menv cenv tenv e pes t.
type_e menv cenv tenv e t &&
pes <> [] &&
(forall ((p,e) MEM pes). exists tenv'.
   List.allDistinct (pat_bindings p []) &&   
   type_p (num_tvs tenv) cenv p Texn tenv' &&
   type_e menv cenv (bind_var_list 0 tenv' tenv) e t)
==>
type_e menv cenv tenv (Handle e pes) t

and

con_some : forall menv cenv tenv cn es tvs tn ts' ts.
List.all (check_freevars (num_tvs tenv) []) ts' &&
List.length tvs = List.length ts' &&
type_es menv cenv tenv es (List.map (type_subst (ZIP tvs ts')) ts) &&
lookup_con_id cn cenv = Just (tvs, ts, tn)
==>
type_e menv cenv tenv (Con (Just cn) es) (Tapp ts' (tid_exn_to_tc tn))

and

con_none : forall menv cenv tenv es ts.
type_es menv cenv tenv es ts
==>
type_e menv cenv tenv (Con Nothing es) (Tapp ts TC_tup)

and

var : forall menv cenv tenv n t targs tvs.
tvs = List.length targs &&
List.all (check_freevars (num_tvs tenv) []) targs &&
t_lookup_var_id n menv tenv = Just (tvs,t)
==>
type_e menv cenv tenv (Var n) (deBruijn_subst 0 targs t)

and

fn : forall menv cenv tenv n e t1 t2.
check_freevars (num_tvs tenv) [] t1 &&
type_e menv cenv (bind_tenv n 0 t1 tenv) e t2
==>
type_e menv cenv tenv (Fun n e) (Tfn t1 t2)

and

uapp : forall menv cenv tenv uop e t1 t2.
type_e menv cenv tenv e t1 &&
type_uop uop t1 t2
==>
type_e menv cenv tenv (Uapp uop e) t2

and

app : forall menv cenv tenv op e1 e2 t1 t2 t3.
type_e menv cenv tenv e1 t1 &&
type_e menv cenv tenv e2 t2 &&
type_op op t1 t2 t3
==>
type_e menv cenv tenv (App op e1 e2) t3

and

log : forall menv cenv tenv l e1 e2.
type_e menv cenv tenv e1 Tbool &&
type_e menv cenv tenv e2 Tbool
==>
type_e menv cenv tenv (Log l e1 e2) Tbool

and

if' : forall menv cenv tenv e1 e2 e3 t.
type_e menv cenv tenv e1 Tbool &&
(type_e menv cenv tenv e2 t &&
type_e menv cenv tenv e3 t)
==>
type_e menv cenv tenv (If e1 e2 e3) t

and

mat : forall menv cenv tenv e pes t1 t2.
type_e menv cenv tenv e t1 &&
pes <> [] &&
(forall ((p,e) MEM pes) . exists tenv'.
   List.allDistinct (pat_bindings p []) &&   
   type_p (num_tvs tenv) cenv p t1 tenv' &&
   type_e menv cenv (bind_var_list 0 tenv' tenv) e t2)
==>
type_e menv cenv tenv (Mat e pes) t2

and

let_poly : forall menv cenv tenv n e1 e2 t1 t2 tvs.
is_value e1 &&
type_e menv cenv (bind_tvar tvs tenv) e1 t1 &&
type_e menv cenv (opt_bind_tenv n tvs t1 tenv) e2 t2
==>
type_e menv cenv tenv (Let n e1 e2) t2

and

let_mono : forall menv cenv tenv n e1 e2 t1 t2.
type_e menv cenv tenv e1 t1 &&
type_e menv cenv (opt_bind_tenv n 0 t1 tenv) e2 t2
==>
type_e menv cenv tenv (Let n e1 e2) t2

and

letrec : forall menv cenv tenv funs e t tenv' tvs.
type_funs menv cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv' &&
type_e menv cenv (bind_var_list tvs tenv' tenv) e t
==>
type_e menv cenv tenv (Letrec funs e) t

and

empty : forall menv cenv tenv.
true
==>
type_es menv cenv tenv [] []

and

cons : forall menv cenv tenv e es t ts.
type_e menv cenv tenv e t &&
type_es menv cenv tenv es ts
==>
type_es menv cenv tenv (e::es) (t::ts)

and

no_funs : forall menv cenv env.
true
==>
type_funs menv cenv env [] []

and

funs : forall menv cenv env fn n e funs env' t1 t2.
check_freevars (num_tvs env) [] (Tfn t1 t2) &&
type_e menv cenv (bind_tenv n 0 t1 env) e t2 &&
type_funs menv cenv env funs env' &&
lookup fn env' = Nothing
==>
type_funs menv cenv env ((fn, n, e)::funs) ((fn, Tfn t1 t2)::env')

val tenv_add_tvs : nat -> env varN t -> env varN (nat * t)
let tenv_add_tvs tvs tenv =
  List.map (fun (n,t) -> (n,(tvs,t))) tenv

indreln [type_d : maybe modN -> decls -> tenvM -> tenvC -> tenvE -> dec -> decls -> flat_tenvC -> env varN (nat * t) -> bool]

dlet_poly : forall tvs mn menv cenv tenv p e t tenv' decls.
is_value e &&
List.allDistinct (pat_bindings p []) &&
type_p tvs cenv p t tenv' &&
type_e menv cenv (bind_tvar tvs tenv) e t
==>
type_d mn decls menv cenv tenv (Dlet p e) empty_decls emp (tenv_add_tvs tvs tenv')

and

dlet_mono : forall mn menv cenv tenv p e t tenv' decls.
List.allDistinct (pat_bindings p []) &&
type_p 0 cenv p t tenv' &&
type_e menv cenv tenv e t
==>
type_d mn decls menv cenv tenv (Dlet p e) empty_decls emp (tenv_add_tvs 0 tenv')

and

dletrec : forall mn menv cenv tenv funs tenv' tvs decls.
type_funs menv cenv (bind_var_list 0 tenv' (bind_tvar tvs tenv)) funs tenv'
==>
type_d mn decls menv cenv tenv (Dletrec funs) empty_decls emp (tenv_add_tvs tvs tenv')

and

dtype : forall mn menv cenv tenv tdefs mdecls edecls tdecls new_tdecls.
check_ctor_tenv mn tdefs &&
new_tdecls = Set.fromList (List.map (fun (tvs,tn,ctors) -> (mk_id mn tn)) tdefs) &&
disjoint new_tdecls tdecls
==>
type_d mn (mdecls,tdecls,edecls) menv cenv tenv (Dtype tdefs) ({},new_tdecls,{}) (build_ctor_tenv mn tdefs) emp

and

dexn : forall mn menv cenv tenv cn ts mdecls edecls tdecls.
check_exn_tenv mn cn ts &&
not (mk_id mn cn IN edecls)
==>
type_d mn (mdecls,tdecls,edecls) menv cenv tenv (Dexn cn ts) ({},{},{mk_id mn cn}) (bind cn ([], ts, TypeExn (mk_id mn cn)) emp) emp
 
indreln [ type_ds : maybe modN -> decls -> tenvM -> tenvC -> tenvE -> list dec -> decls -> flat_tenvC -> env varN (nat * t) -> bool]

empty : forall mn menv cenv tenv decls.
true
==>
type_ds mn decls menv cenv tenv [] empty_decls emp emp

and

cons : forall mn menv cenv tenv d ds cenv' tenv' cenv'' tenv'' decls decls' decls''.
type_d mn decls menv cenv tenv d decls' cenv' tenv' &&
type_ds mn (union_decls decls' decls) menv (merge_tenvC (emp,cenv') cenv) (bind_var_list2 tenv' tenv) ds decls'' cenv'' tenv''
==>
type_ds mn decls menv cenv tenv (d::ds) (union_decls decls'' decls') (merge cenv'' cenv') (merge tenv'' tenv')

indreln [type_specs : maybe modN -> specs -> decls -> flat_tenvC -> env varN (nat * t) -> bool]

empty : forall mn. 
true
==>
type_specs mn [] empty_decls emp emp

and

sval : forall mn x t specs cenv tenv fvs decls.
check_freevars 0 fvs t &&
type_specs mn specs decls cenv tenv
==>
type_specs mn (Sval x t :: specs) decls cenv (tenv ++ [(x, (List.length fvs, type_subst (ZIP fvs (List.map Tvar_db (genlist (fun x -> x) (List.length fvs)))) t))]) 

and

stype : forall mn cenv tenv td specs new_tdecls decls.
check_ctor_tenv mn td &&
new_tdecls = Set.fromList (List.map (fun (tvs,tn,ctors) -> (mk_id mn tn)) td) &&
type_specs mn specs decls cenv tenv
==>
type_specs mn (Stype td :: specs) (union_decls decls ({},new_tdecls,{})) (merge cenv (build_ctor_tenv mn td)) tenv

and

sexn : forall mn cenv tenv cn ts specs decls.
check_exn_tenv mn cn ts &&
type_specs mn specs decls cenv tenv
==>
type_specs mn (Sexn cn ts :: specs) (union_decls decls ({},{},{mk_id mn cn})) (cenv ++ [(cn,([], ts, TypeExn (mk_id mn cn)))]) tenv

and

stype_opq : forall mn cenv tenv tn specs tvs decls.
List.allDistinct tvs &&
type_specs mn specs decls cenv tenv
==>
type_specs mn (Stype_opq tvs tn :: specs) (union_decls decls ({},{mk_id mn tn},{})) cenv tenv

let weakE tenv_impl tenv_spec =
  forall x.
    match lookup x tenv_spec with
      | Just (tvs_spec, t_spec) ->
          match lookup x tenv_impl with
            | Nothing -> false
            | Just (tvs_impl, t_impl) ->
                exists subst. 
                  List.length subst = tvs_impl &&                  
                  check_freevars tvs_impl [] t_impl &&                  
                  List.all (check_freevars tvs_spec []) subst &&                  
                  deBruijn_subst 0 subst t_impl = t_spec
          end
        | Nothing -> true
    end

val flat_weakC : flat_tenvC -> flat_tenvC -> bool
let flat_weakC cenv_impl cenv_spec =
  forall cn.
    match lookup cn cenv_spec with
      | Just (tvs_spec,ts_spec,tn_spec) ->
          match lookup cn cenv_impl with
            | Nothing -> false
            | Just (tvs_impl, ts_impl, tn_impl) ->
                tn_spec = tn_impl &&                
                (* For simplicity, we reject matches that differ only by renaming of bound type variables *)
                tvs_spec = tvs_impl &&                
                ts_spec = ts_impl
          end
      | Nothing -> true
    end

val weak_decls : decls -> decls -> bool
let weak_decls (mdecs_impl, tdecs_impl, edecs_impl) (mdecs_spec, tdecs_spec, edecs_spec) =  
  mdecs_impl = mdecs_spec &&
  tdecs_spec subset tdecs_impl &&
  edecs_spec subset edecs_impl

indreln [check_signature : maybe modN -> decls -> flat_tenvC -> env varN (nat * t) -> maybe specs -> decls -> flat_tenvC -> env varN (nat * t) -> bool]

none : forall mn cenv tenv decls.
true
==>
check_signature mn decls cenv tenv Nothing decls cenv tenv

and

some : forall mn cenv tenv specs tenv' cenv' decls decls'.
weakE tenv tenv' &&
flat_weakC cenv cenv' &&
weak_decls decls decls' &&
type_specs mn specs decls' cenv' tenv'
==>
check_signature mn decls cenv tenv (Just specs) decls' cenv' tenv'

indreln [type_top : decls -> tenvM -> tenvC -> tenvE -> top -> decls -> tenvM -> tenvC -> (env varN (nat * t)) -> bool]

tdec : forall menv cenv tenv d cenv' tenv' decls decls'.
type_d Nothing decls menv cenv tenv d decls' cenv' tenv'
==>
type_top decls menv cenv tenv (Tdec d) decls' emp (emp,cenv') tenv'

and

tmod : forall menv cenv tenv mn spec ds cenv' tenv' cenv'' tenv'' mdecls tdecls edecls decls' mdecls'' tdecls'' edecls''.
not (mn IN mdecls) &&
type_ds (Just mn) (mdecls,tdecls,edecls) menv cenv tenv ds decls' cenv' tenv' &&
check_signature (Just mn) decls' cenv' tenv' spec (mdecls'',tdecls'',edecls'') cenv'' tenv''
==>
type_top (mdecls,tdecls,edecls) menv cenv tenv (Tmod mn spec ds) ({mn} union mdecls'',tdecls'',edecls'') [(mn,tenv'')] ([(mn,cenv'')], emp) emp

indreln [type_prog : decls -> tenvM -> tenvC -> tenvE -> list top -> decls -> tenvM -> tenvC -> env varN (nat * t) -> bool]

empty : forall menv cenv tenv decls.
true
==>
type_prog decls menv cenv tenv [] empty_decls emp (emp,emp) emp

and

cons : forall menv cenv tenv top tops menv' cenv' tenv' menv'' cenv'' tenv'' decls decls' decls''.
type_top decls menv cenv tenv top decls' menv' cenv' tenv' &&
type_prog (union_decls decls' decls) (merge menv' menv) (merge_tenvC cenv' cenv) (bind_var_list2 tenv' tenv) tops decls'' menv'' cenv'' tenv''
==>
type_prog decls menv cenv tenv (top :: tops) (union_decls decls'' decls') (merge menv'' menv') (merge_tenvC cenv'' cenv') (merge tenv'' tenv')
