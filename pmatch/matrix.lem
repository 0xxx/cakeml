type matrix_row = MatrixRow list Cpat * Cexp

(* semantics of a row MatrixRow ([p0, ..., pn], e) :
 * Match (p0, ..., pn) -> e
 *)

type matrix =
  Matrix of bool * list num * list matrix_row

(* intended semantics:

Matrix b vs rows =
  match vs with 
    | rows 
    | _ -> if b then raise match else ... ?

vs is a list of variables and can therefore
be represented as "list num" 

slightly formalised semantics:
this could later become lem code:

val matrix_sem : matrix -> semantics
val cexp_sem : Cexp -> semantics

let sem_equiv : semantics -> semantics -> bool

*)


(* try to convert a matrix to a Cexp. This only
 * works for simple matrices. Examples are the empty matrix and
 * a matrix that contains only variables in the first row.
 *
 * Guarantee:
 *
 * forall m e. try_matrix_to_Cexp m = Some e -->
 *             (sem_equiv (matrix_sem m) (cexp_sem e))
 *)

val try_matrix_to_Cexp : matrix -> option Cexp

let try_matrix_to_Cexp (Matrix is_exn input rows) =
  match rows with
    | [] -> Some (if is_exn then ... else raise match)
    | (MatrixRow (pats, e) :: _) -> 
       if List.for_all is_Cvar pats then Some (
                      Let input0 
                      Let input1 
                      Let input2 
                      Let input3 
                      e
       )
       else None
 
(* select_column is a heuristic that selects a column of 
 * a matrix. It can be implemented by fancy heuristics, but it
 * only guarentees:
 *
 * if the matrix has at least one row and at least one column,
 * then a number less then the number of columns is returned. 
 *)

val select_column : matrix -> num
let select_column _ = 0


(* [extract_column colNo matrix] extracts column [colNo] from
   Matrix [matrix]. Extracting means essentially removing column no
   [colNo] and putting it at the end of the matrix. The right-hand side
   expressions need to be modified in order to support this change
   without changed semantics.

   extract_column i 
     (Matrix is_exn 
       [v0, ..., vn] 
       [MatrixRow ([p00, ..., p0n], e0), 
        ...
        MatrixRow ([pm0, ..., pmn], em)])
   = (Matrix is_exn 
       [v0, ..., v{i-1}, v{i+1}, ... vn] 
       [MatrixRow ([p00, ..., p0{i-1}, p0{i+1}, ..., p0n], e0'), 
        ...
        MatrixRow ([pm0, ..., pm{i-1}, pm{i+1}, ..., pmn], em')],
      vi,
      [p0i, ... pmi])

  such that 
    
    sem_equiv (matrix_sem     
       (Matrix is_exn 
          [v0, ..., vn] 
          [MatrixRow ([p00, ..., p0n], e0), 
           ...
           MatrixRow ([pm0, ..., pmn], em)]))
       (matrix_sem (Matrix is_exn 
          [v0, ..., v{i-1}, v{i+1}, ..., vn, vi] 
          [MatrixRow ([p00, ..., p0{i-1}, p0{i+1}, ..., p0n, p0i], e0), 
           ...
           MatrixRow ([pm0, ..., pm{i-1}, pm{i+1}, ..., pmn, pmi], em)])))
     
*)     

val extract_column : num -> matrix -> (matrix * num * list Cpat)

(*
let rec
extract_column n [] = []
and
extract_column n ((ps,e),pses) =
  (List.nth n ps)::(extract_column n pses)

let rec
rest _ [] = []
and
rest 0 (p::ps) = ps
and
rest (n+1) (p::ps) = (p::rest n ps)

let rec
elim_var_col n v [] = []
and
elim_var_col n v ((ps,e),pses) =
  ((rest n ps),CLet (CVar(Short v)) )::(elim_var_col n pses)

type column_type =
  VarCol | LitCol | ConCol | RefCol

let rec
column_type [] = VarCol
and
column_type (Pvar::ps) = column_type ps
and
column_type ((Plit _)::_) = LitCol
and
column_type ((Pcon _ _)::_) = ConCol
and
column_type ((Pref _)::_) = RefCol

*)


(* get_distinct_patterns extracts the distinct cases from a given list of patterns.
   Variable patterns are always ignored. Constructors should appear only once.
   I.e. if there are two occurences "C1 p1" and "C1 p2", of the same constructor
   "C1", only one should be in the resulting list. *)
val get_distinct_patterns : list Cpat -> list Cpat

let rec get_distinct_patterns acc ps = match ps with
  | [] -> acc
  | (p :: ps) -> 
      let acc' = if (acc already convers p) then acc else (replace arguments of p with vars)::acc in
      get_distinct_patterns acc' ps


(* [create_top_level_fun input_var [p0, ... pn] should logically create the expression

   fun (e0, ..., en, e_default) -> match input_var with
     | p0 -> e0
     ...
     | pn -> en
     | _ -> e_default
*)     

val create_top_level_fun : num -> list Cpat -> list Cexp -> Cexp


(* [create_submatrix org_matrix input pats specialise_pat] specialises the matrix 
   given by [org_matrix, input, pats] for inputs that match [specialise_pat]. I.e. 

   The semantics of [org_matrix, input, pats] is for extract_column. So given
   that org_matrix uses prefixes p, v and e, input is input and pats are [q0,...qm] we have

       Matrix is_exn 
          [v0, ..., vn, input] 
          [MatrixRow ([p00, ..., p0n, q0], e0), 
           ...
           MatrixRow ([pm0, ..., pmn, qm], em)]

   We then want a matrix m' such that informally the semantics of the input matrix above
   is the same as of this informal expression provided input really matches [specialise_pat]. 

      match input with 
        | specialise_pat ->
           (matrix_sem (Matrix is_exn 
             [v0, ..., vn'] 
              [MatrixRow ([p'00,  ..., p'0n',  q'0 ], e'0), 
               ...
               MatrixRow ([p'm'0, ..., p'm'n', q'm'], e'm')])))

*)   


val match_pattern : Cpat -> Cpat -> option (list Cpat) 

let match_pattern select_pattern p = match (select_pattern, p) with
  | (Plit sl, Plit l) -> 
       (if sl = l then Some [] else None)
  | (Pcon sc _, Pcon c args) -> 
       (if sc = c then Some [args] else None)
  | (Pref _, Pref p) -> Some [p]
  | (_, Pvar) -> Some (List.replicate (arg_num select_pattern) Pvar)
  | (_, _) ->  None

val create_submatrix : matrix -> num -> pat list -> pat -> matrix


let create_submatrix (Matrix is_exn vs rows) input ps sp =
begin
  let arg_num = get_number_of_argments of sp in

  (* add extra input variables for the destructed arguments *)
  let vs' = vs ++ [arg_num-1, ... 0] 
  
  let rec process_row rows ps = match (rows, ps) with 
     | ([], _) -> []
     | (_, []) -> [] (* rows and ps should have the same length, so this case should not fire *)

     | ((MatrixRow row_pats e) :: rows, p :: ps) -> begin
          match (match_pattern sp p) with
           | None -> process_rows rows ps
           | Some extra_pats -> begin
                (* if p is a variable pattern, then do the letbind on rhs and shift. 
                   The problem is that var-patterns get expanded to multiple variable columns, while
                   all other patterns just copy their arguments. *)
                let e' = if isVar_pat p then shift arg_num (Let input e) else e in
                let row_pats' = row_pats ++ extra_pats in
                (MatrixRow row_pats' e')::process_rows rows ps
             end
     end
  end
end


val compile_matrix_step : matrix -> list matrix * (list Cexp -> Cexp)
let compile_matrix_step m =
  (* check whether the matrix is already simple enough or needs further
     decomposition *)
  match try_matrix_to_Cexp m
  | Some e -> (* it's already simple enough, just return an expression *) ([],fun _ -> e)
  | None -> begin
      (* do further decomposition *)
      
      let i = select_column m in
      let (m', input, pats) = extract_column i m in

      let cases = get_distinct_patterns pats in

      let top_level_fun = create_top_level_fun cases in
      let ms = List.map (create_submatrix m' input pats) (cases ++ (* add catchall case *) [Pvar]) in

      (ms, top_level_fun)
   end


let rec
compile_matrix b m =
  let (ms,f) = compile_matrix_step b m in
  match ms with
  | [] -> f []
  | ms -> let es = List.map (compile_matrix b) ms in f es
  end


(* The new plan: 

compile_match : bool -> Cexp -> list (Cpat * Cexp) -> Cexp
  satisfying:
    ∀b menv s env exp pes s' v env' e v'.
      Cevaluate menv s env exp (s', Cval v) ∧
      Cevaluate_match s' v pes env' (SOME e) ∧
      Cevaluate menv s' (env' ++ env) e res
      ⇒
      Cevaluate menv s env (compile_match b exp pes) res
  and
    ∀b menv s env exp pes s' v .
      Cevaluate menv s env exp (s', Cval v) ∧
      Cevaluate_match s' v pes [] NONE
      ⇒
      Cevaluate menv s env (compile_match b exp pes)
        (s', Cexc (Craise (if b then v else CBind_excv)))
  and
    ∀b menv s env exp pes s' v.
      Cevaluate menv s env exp (s', Cexc v)
      ⇒
      Cevaluate menv s env (compile_match b exp pes) (s', Cexc v)
*)

(*
The first plan:

  Write

  compile_match : exp -> list (pat * exp) -> exp

  and prove that it satisfies

  ∀e pes.
    simple_matches_only e ∧
    EVERY simple_matches_only (MAP SND pes)
    ⇒
    simple_matches_only (compile_match e pes)

  and

  ∀ck menv cenv s env res.
    evaluate ck menv cenv s env (Mat e pes) res ⇒
    evaluate ck menv cenv s env (compile_match e pes) res

(* For reference:
Handle e pes
  should be equivalent to:
Mat e (pes++[(Pvar"e", Raise(Var(Short"e")))])
*)

let rec
simple_matches_only (Raise e) = simple_matches_only e
and
simple_matches_only (Handle e pes) =
  simple_matches_only e &&
  simple_matches_only_pes pes &&
and
simple_matches_only (Lit _) = true
and
simple_matches_only (Con n es) =
  simple_matches_only_list es
and
simple_matches_only (Var _) = true
and
simple_matches_only (Fun _ e) = simple_matches_only e
and
simple_matches_only (Uapp _ e) = simple_matches_only e
and
simple_matches_only (App _ e1 e2) =
  simple_matches_only e1 &&
  simple_matches_only e2
and
simple_matches_only (Log _ e1 e2) =
  simple_matches_only e1 &&
  simple_matches_only e2
and
simple_matches_only (If e1 e2 e3) =
  simple_matches_only e1 &&
  simple_matches_only e2 &&
  simple_matches_only e3
and
simple_matches_only (Mat e pes) =
  simple_matches_only e &&
  simple_matches_only_pes pes
and
simple_matches_only (Let _ e1 e2) =
  simple_matches_only e1 &&
  simple_matches_only e2
and
simple_matches_only (Letrec defs e) =
  simple_matches_only_defs defs &&
  simple_matches_only e
and
simple_matches_only_list [] = true
and
simple_matches_only_list (e::es) =
  simple_matches_only e &&
  simple_matches_only_list es
and
simple_matches_only_pes [] = true
and
simple_matches_only_pes ((p,e)::pes) =
  (exists n vs.
    p = Pcon n vs &&
    forall v. List.mem v vs --> exists a. v = Pvar a) &&
  simple_matches_only e &&
  simple_matches_only_pes pes

type match_matrix =
  Matrix of list exp * list (list pat * exp)

*)
