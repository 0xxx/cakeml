(*Generated by Lem from simpleIO.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory lem_pervasives_extraTheory libTheory ffiTheory;

val _ = numLib.prefer_num();



val _ = new_theory "simpleIO"

(*open import Pervasives*)
(*open import Pervasives_extra*)
(*open import Lib*)
(*open import Ffi*)

val _ = Hol_datatype `
 io_state = <| input :  word8 llist; output :  word8 llist |>`;


(*val isEof : io_state -> list (word8 * word8) -> bool*)
val _ = Define `
 (isEof st io =  
((case io of
    [] => F
  | (x,y)::io =>
      EVERY (\ (x,y) .  x = y) io /\
      (((st.input = LNIL) /\ (y =n2w ( 1))) \/
       ((st.input <> LNIL) /\ (y =n2w ( 0))))
  )))`;


(*val getChar : io_state -> list (word8 * word8) -> maybe io_state*)
val _ = Define `
 (getChar st io =  
((case io of
    [] => NONE
  | (x,y)::io =>
      if EVERY (\ (x,y) .  x = y) io /\ (SOME y = LHD st.input) then
        SOME ( st with<| input := THE (LTL st.input) |>)
      else
        NONE
  )))`;


(*val putChar : io_state -> list (word8 * word8) -> maybe io_state*)
val _ = Define `
 (putChar st io =  
((case io of
    [] => NONE
  | (x,y)::io =>
      if (x = y) /\ EVERY (\ (x,y) .  x = y) io then
        SOME ( st with<| output := LCONS x st.output |>)
      else
        NONE
  )))`;


(*val system_step : io_state -> io_trace -> io_state * io_trace*)
val _ = Define `
 (system_step st tr =  
((case tr of
    SOME events =>
      (case LHD events of
        SOME (IO_event n xs) =>
          let rest = (LTL events) in
            if (n = 0) /\ isEof st xs then
              (st, rest)
            else if n = 1 then
              (case getChar st xs of
                SOME st' => (st', rest)
              | NONE => (st, NONE)
              )
            else if n = 2 then
              (case putChar st xs of
                SOME st' => (st', rest)
              | NONE => (st, NONE)
              )
            else
              (st, NONE)
      | NONE => (st, NONE)
      )
  | NONE =>(st, NONE)
  )))`;

val _ = export_theory()

