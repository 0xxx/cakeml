open HolKernel Parse boolLib bossLib miscLib
open listTheory sptreeTheory pred_setTheory pairTheory rich_listTheory alistTheory
open BasicProvers
open word_procTheory word_langTheory word_liveTheory
open reg_allocTheory 
open word_ssaTheory

val _ = new_theory "word_transform"

(*This should describe the full theorems resulting 
  from linking up everything and define the full transform

  The theorems that need to be linked can be divided into
  correctness and conventions

  Correctness
  ---
  1) SSA converted program preserves semantics for all? permutes
  2) Calling register allocation produces correct code
  3) Linking up SSA + register allocation into 1 pass

  Conventions
  ---
  1) SSA program has the special conventions on stack variables
  2) Register allocation produces an is_phy_var colouring

  Everything after allocation should be is_phy_var, and
  the stack variables should be ≥ 2*k

*)

val get_spg_def = Define`
  get_spg prog live =
    let (hd,clash_sets) = get_clash_sets prog live in
      (clash_sets_to_sp_g (hd::clash_sets))`

val irc_alloc_def =  Define`
  irc_alloc G k moves =
  let moves = MAP maybe_flip moves in
  let s = init_ra_state G k moves in
  let s = SND (rpt_do_step s) in
  let coalesced = s.coalesced in
  let pref x y z = aux_move_pref coalesced (resort_moves(moves_to_sp moves LN)) x y z in
  let (col,ls) = alloc_colouring s.graph k pref s.stack in
  let (G,spills,coalesce_map) = full_coalesce s.graph moves ls in
  let s = sec_ra_state G k spills coalesce_map in
  let s = SND (rpt_do_step2 s) in
  let col = spill_colouring G k coalesce_map s.stack col in
  let col = spill_colouring G k LN ls col in
    col`

(*Prove that irc alloc is an instance of the actual algorithm*)
val irc_alloc_reg_alloc_3 = prove(``
  ∀G k moves.
  irc_alloc G k moves = reg_alloc 3 G k moves``,
  fs[irc_alloc_def,reg_alloc_def]>>
  rw[]>>
  `pref = pref'` by 
    (fs[FUN_EQ_THM]>>
    unabbrev_all_tac>>fs[])>>
  unabbrev_all_tac>>
  fs[]>>rfs[]>>
  rpt VAR_EQ_TAC>>
  fs[])

(*Instantiates the register allocator to wordLang liveness analysis*)
val word_alloc_def = Define`
  word_alloc k prog =
  let clash_graph = get_spg prog LN in (*No live after set*)
  let moves = get_prefs prog [] in (*Get the moves in the graph*) 
  let col = irc_alloc clash_graph k moves in 
  (*Get the register allocation function,
    TODO: We can choose the flag based on the size of graph/moves*)
    apply_colour (total_colour col) prog`

(*word_trans is the combination that does SSA/CC then Register Allocation
  n is the number of incoming arguments, k is the number of available registers
*)
val word_trans_def = Define`
  word_trans n k prog =
  word_alloc k (full_ssa_cc_trans n prog)` 

val colouring_satisfactory_colouring_ok_alt = prove(``
  ∀prog f live.
  let spg = get_spg prog live in
  colouring_satisfactory (f:num->num) spg
  ⇒
  colouring_ok_alt f prog live``,
  rpt strip_tac>>
  fs[LET_THM,colouring_ok_alt_def,colouring_satisfactory_def,get_spg_def]>>
  Cases_on`get_clash_sets prog live`>>fs[]>>
  strip_tac>>
  qabbrev_tac `ls = q::r`>>
  qsuff_tac `EVERY (λs. INJ f (domain s) UNIV) ls`
  >-
    fs[Abbr`ls`]
  >>
  rw[EVERY_MEM]>>
  imp_res_tac clash_sets_clique>>
  imp_res_tac colouring_satisfactory_cliques>>
  pop_assum(qspec_then`f`mp_tac)>>
  discharge_hyps
  >- fs[colouring_satisfactory_def,LET_THM]>>
  discharge_hyps
  >- fs[ALL_DISTINCT_MAP_FST_toAList]>>
  fs[INJ_DEF]>>rw[]>>
  fs[domain_lookup]>>
  `MEM x (MAP FST (toAList s)) ∧
   MEM y (MAP FST (toAList s))` by
    (fs[MEM_MAP,EXISTS_PROD]>>
    metis_tac[domain_lookup,MEM_MAP,EXISTS_PROD,MEM_toAList])>>
  `ALL_DISTINCT (MAP FST (toAList s))` by
    metis_tac[ALL_DISTINCT_MAP_FST_toAList]>>
  fs[EL_ALL_DISTINCT_EL_EQ]>>
  fs[MEM_EL]>>rfs[EL_MAP]>>
  metis_tac[])

val is_phy_var_tac = 
    fs[is_phy_var_def]>>
    `0<2:num` by DECIDE_TAC>>
    `∀k.(2:num)*k=k*2` by DECIDE_TAC>>
    metis_tac[arithmeticTheory.MOD_EQ_0];

val call_arg_convention_preservation = prove(``
  ∀prog f.
  every_var (λx. is_phy_var x ⇒ f x = x) prog ∧ 
  call_arg_convention prog ⇒ 
  call_arg_convention (apply_colour f prog)``,
  ho_match_mp_tac call_arg_convention_ind>>
  rw[call_arg_convention_def,every_var_def]>>
  EVERY_CASE_TAC>>unabbrev_all_tac>>
  fs[call_arg_convention_def]>>
  `is_phy_var 2` by is_phy_var_tac>>fs[]>>
  `EVERY is_phy_var args` by
    (qpat_assum`args=A` SUBST_ALL_TAC>>
    fs[EVERY_GENLIST]>>rw[]>>
    is_phy_var_tac)>>
  qpat_assum`args = A` (SUBST_ALL_TAC o SYM)>>
  fs[EVERY_MEM,miscTheory.MAP_EQ_ID]>>
  rfs[])

val pre_post_conventions_word_alloc = prove(``
  ∀prog k.
  pre_alloc_conventions prog ⇒ (*this is generated by ssa form*) 
  post_alloc_conventions k (word_alloc k prog)``,
  fs[pre_alloc_conventions_def,post_alloc_conventions_def,word_alloc_def,get_spg_def,irc_alloc_reg_alloc_3]>>
  rw[]>>
  `undir_graph clash_graph` by
    metis_tac[clash_sets_to_sp_g_undir]>>
  imp_res_tac reg_alloc_conventional>>
  pop_assum(qspecl_then[`moves`,`k`,`3`] assume_tac)>>rfs[LET_THM]>>
  `every_var (in_clash_sets (hd::clash_sets)) prog` by 
     (Q.ISPECL_THEN [`prog`,`LN:num_set`] assume_tac 
       every_var_in_get_clash_set>>
     rfs[LET_THM])>>
  `every_var (λx. x ∈ domain clash_graph) prog` by   
    (match_mp_tac every_var_mono>>
    HINT_EXISTS_TAC>>rw[]>>
    metis_tac[clash_sets_to_sp_g_domain])>>
  fs[colouring_conventional_def,LET_THM]
  >-
    (match_mp_tac every_var_apply_colour>>
    HINT_EXISTS_TAC>>fs[]>>
    rw[]>>
    metis_tac[])
  >-
    (match_mp_tac every_stack_var_apply_colour>>
    imp_res_tac every_var_imp_every_stack_var>>
    qexists_tac `λx. (x ∈ domain clash_graph ∧ is_stack_var x)` >>rw[]
    >-
      metis_tac[every_stack_var_conj]
    >>
    metis_tac[convention_partitions])
  >>
  match_mp_tac call_arg_convention_preservation>>
  rw[]>>match_mp_tac every_var_mono>>
  HINT_EXISTS_TAC>>
  metis_tac[])

(*TODO: Add a version that can take and verify oracle colors*)

(*Actually, it should probably be exactly 0,2,4,6...*)
val even_starting_locals_def = Define`
  even_starting_locals (locs:'a word_loc num_map) ⇔ 
    ∀x. x ∈ domain locs ⇒ is_phy_var x`

fun rm_let tm = tm|> SIMP_RULE std_ss [LET_THM]

(*Prove the full correctness theorem for word_alloc*)
val word_alloc_correct = prove(``
  ∀prog k st.
  even_starting_locals st.locals 
  ⇒
  ∃perm'.
  let (res,rst) = wEval(prog,st with permute:=perm') in
  if (res = SOME Error) then T else
  let (res',rcst) = wEval(word_alloc k prog,st) in
    res = res' ∧
    word_state_eq_rel rst rcst``,
  rw[]>>
  qpat_abbrev_tac`cprog = word_alloc k prog`>>
  fs[word_alloc_def,irc_alloc_reg_alloc_3]>>pop_assum mp_tac>>LET_ELIM_TAC>>
  Q.ISPECL_THEN[`prog`,`st`,`st`,`total_colour col`,`LN:num_set`] mp_tac wEval_apply_colour>>
  discharge_hyps>-
    (rw[]
    >-
      (*Prove that the colors are okay*)
      (match_mp_tac colouring_ok_alt_thm>>
      match_mp_tac (colouring_satisfactory_colouring_ok_alt|>rm_let)>>
      unabbrev_all_tac>>
      match_mp_tac (reg_alloc_total_satisfactory|>rm_let)>>
      rw[get_spg_def]>>
      fs[clash_sets_to_sp_g_undir])
    >-
      fs[word_state_eq_rel_def]
    >>
      fs[strong_locals_rel_def,even_starting_locals_def]>>
      rw[]>>
      fs[domain_lookup]>>
      first_x_assum(qspec_then`n` assume_tac)>>
      rfs[]>>
      Q.ISPECL_THEN[`3:num`,`clash_graph`,`k`,`moves`] mp_tac (reg_alloc_conventional_phy_var|>rm_let)>>
      discharge_hyps>-
        (rw[Abbr`clash_graph`,get_spg_def]>>fs[clash_sets_to_sp_g_undir])
      >>
      rw[colouring_conventional_def,LET_THM])
  >>
  rw[]>>
  qexists_tac`perm'`>>rw[]>>
  fs[LET_THM])

val word_trans_correct = store_thm("word_trans_correct",
``∀prog n k st.
  domain st.locals = set(even_list n)
  ⇒
  ∃perm'.
  let (res,rst) = wEval(prog,st with permute:=perm') in
  if (res = SOME Error) then T else
  let (res',rcst) = wEval(word_trans n k prog,st) in
    res = res' ∧
    word_state_eq_rel rst rcst``,
  rw[word_trans_def]>>
  Q.ISPECL_THEN [`full_ssa_cc_trans n prog`,`k`,`st`] mp_tac word_alloc_correct>>
  discharge_hyps>-
    (fs[even_starting_locals_def,is_phy_var_def,even_list_def,MEM_GENLIST]>>
    rw[]>>is_phy_var_tac)>>rw[]>>
  Q.ISPECL_THEN [`prog`,`st with permute:= perm'`,`n`] assume_tac full_ssa_cc_trans_correct>>
  rfs[LET_THM]>>
  qexists_tac`perm''`>>fs[LET_THM]>>rw[]>>
  qpat_assum `A= (res,rst)` (SUBST_ALL_TAC)>>
  Cases_on`wEval(full_ssa_cc_trans n prog, st with permute:=perm')`>>
  fs[word_state_eq_rel_def])

val word_trans_conventions = store_thm("word_trans_conventions",
``∀prog n k.
  post_alloc_conventions k (word_trans n k prog)``,
  rw[word_trans_def]>>
  assume_tac (SPEC_ALL full_ssa_cc_trans_pre_alloc_conventions)>>
  imp_res_tac pre_post_conventions_word_alloc>>
  metis_tac[])

val _ = export_theory();
