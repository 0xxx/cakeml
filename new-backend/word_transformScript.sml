open HolKernel Parse boolLib bossLib miscLib
open listTheory sptreeTheory pred_setTheory pairTheory rich_listTheory alistTheory
open BasicProvers
open word_procTheory word_langTheory word_liveTheory
open reg_allocTheory 
(*open word_ssaTheory*)

val _ = new_theory "word_transform"

(*This should describe the full theorems resulting 
  from linking up everything and define the full transform

  The theorems that need to be linked can be divided into
  correctness and conventions

  Correctness
  ---
  1) SSA converted program preserves semantics for all? permutes
  2) Calling register allocation produces correct code
  3) Linking up SSA + register allocation into 1 pass

  Conventions
  ---
  1) SSA program has the special conventions on stack variables
  2) Register allocation produces an is_phy_var colouring

  Everything after allocation should be is_phy_var, and
  the stack variables should be ≥ 2*k

*)

val get_spg_def = Define`
  get_spg prog live =
    let (hd,clash_sets) = get_clash_sets prog live in
      (clash_sets_to_sp_g (hd::clash_sets))`

(*Instantiates the register allocator to wordLang liveness analysis*)
val word_alloc_def = Define`
  word_alloc k prog =
  let clash_graph = get_spg prog LN in (*No live after set*)
  let moves = get_prefs prog [] in (*Get the moves in the graph*) 
  let col = reg_alloc 3 clash_graph k moves in 
  (*Get the register allocation function,
    TODO: choose the flag based on the size of graph/moves*)
    apply_colour (total_colour col) prog`

(*
(*word_trans is the combination that does SSA/CC then Register Allocation*)
val word_trans_def = Define`
  word_trans k prog =
  let (ssa_prog,na,ns) = ssa_cc_trans prog LN 101 in (*numbers are placeholders*)
    word_alloc k ssa_prog`
*)

val colouring_satisfactory_colouring_ok_alt = prove(``
  ∀prog f live.
  let spg = get_spg prog live in
  colouring_satisfactory (f:num->num) spg
  ⇒
  colouring_ok_alt f prog live``,
  rpt strip_tac>>
  fs[LET_THM,colouring_ok_alt_def,colouring_satisfactory_def,get_spg_def]>>
  Cases_on`get_clash_sets prog live`>>fs[]>>
  strip_tac>>
  qabbrev_tac `ls = q::r`>>
  qsuff_tac `EVERY (λs. INJ f (domain s) UNIV) ls`
  >-
    fs[Abbr`ls`]
  >>
  rw[EVERY_MEM]>>
  imp_res_tac clash_sets_clique>>
  imp_res_tac colouring_satisfactory_cliques>>
  pop_assum(qspec_then`f`mp_tac)>>
  discharge_hyps
  >- fs[colouring_satisfactory_def,LET_THM]>>
  discharge_hyps
  >- fs[ALL_DISTINCT_MAP_FST_toAList]>>
  fs[INJ_DEF]>>rw[]>>
  fs[domain_lookup]>>
  `MEM x (MAP FST (toAList s)) ∧
   MEM y (MAP FST (toAList s))` by
    (fs[MEM_MAP,EXISTS_PROD]>>
    metis_tac[domain_lookup,MEM_MAP,EXISTS_PROD,MEM_toAList])>>
  `ALL_DISTINCT (MAP FST (toAList s))` by
    metis_tac[ALL_DISTINCT_MAP_FST_toAList]>>
  fs[EL_ALL_DISTINCT_EL_EQ]>>
  fs[MEM_EL]>>rfs[EL_MAP]>>
  metis_tac[])

val is_phy_var_tac = 
    fs[is_phy_var_def]>>
    `0<2:num` by DECIDE_TAC>>
    `∀k.(2:num)*k=k*2` by DECIDE_TAC>>
    metis_tac[arithmeticTheory.MOD_EQ_0];

val call_arg_convention_preservation = prove(``
  ∀prog f.
  every_var (λx. is_phy_var x ⇒ f x = x) prog ∧ 
  call_arg_convention prog ⇒ 
  call_arg_convention (apply_colour f prog)``,
  ho_match_mp_tac call_arg_convention_ind>>
  rw[call_arg_convention_def,every_var_def]>>
  EVERY_CASE_TAC>>unabbrev_all_tac>>
  fs[call_arg_convention_def]>>
  `is_phy_var 2` by is_phy_var_tac>>fs[]>>
  `EVERY is_phy_var args` by
    (qpat_assum`args=A` SUBST_ALL_TAC>>
    fs[EVERY_GENLIST]>>rw[]>>
    is_phy_var_tac)>>
  qpat_assum`args = A` (SUBST_ALL_TAC o SYM)>>
  fs[EVERY_MEM,miscTheory.MAP_EQ_ID]>>
  rfs[])

val pre_post_conventions_word_alloc = prove(``
  ∀prog k.
  pre_alloc_conventions prog ⇒ (*this is generated by ssa form*) 
  post_alloc_conventions k (word_alloc k prog)``,
  fs[pre_alloc_conventions_def,post_alloc_conventions_def,word_alloc_def,get_spg_def]>>
  rw[]>>
  `undir_graph clash_graph` by
    metis_tac[clash_sets_to_sp_g_undir]>>
  imp_res_tac reg_alloc_conventional>>
  pop_assum(qspecl_then[`moves`,`k`,`3`] assume_tac)>>rfs[LET_THM]>>
  `every_var (in_clash_sets (hd::clash_sets)) prog` by 
     (Q.ISPECL_THEN [`prog`,`LN:num_set`] assume_tac 
       every_var_in_get_clash_set>>
     rfs[LET_THM])>>
  `every_var (λx. x ∈ domain clash_graph) prog` by   
    (match_mp_tac every_var_mono>>
    HINT_EXISTS_TAC>>rw[]>>
    metis_tac[clash_sets_to_sp_g_domain])>>
  fs[colouring_conventional_def,LET_THM]
  >-
    (match_mp_tac every_var_apply_colour>>
    HINT_EXISTS_TAC>>fs[]>>
    rw[]>>
    metis_tac[])
  >-
    (match_mp_tac every_stack_var_apply_colour>>
    imp_res_tac every_var_imp_every_stack_var>>
    qexists_tac `λx. (x ∈ domain clash_graph ∧ is_stack_var x)` >>rw[]
    >-
      metis_tac[every_stack_var_conj]
    >>
    metis_tac[convention_partitions])
  >>
  match_mp_tac call_arg_convention_preservation>>
  rw[]>>match_mp_tac every_var_mono>>
  HINT_EXISTS_TAC>>
  metis_tac[])

(*Add a version that can take and verify oracle colors*)


(*Actually, it should probably be exactly 0,2,4,6...*)
val even_starting_locals_def = Define`
  even_starting_locals (locs:'a word_loc num_map) ⇔ 
    ∀x. x ∈ domain locs ⇒ is_phy_var x`

fun rm_let tm = tm|> SIMP_RULE std_ss [LET_THM]

(*Prove the correctness theorem for word_alloc*)
val word_alloc_correct = prove(``
  ∀prog k st.
  even_starting_locals st.locals 
  ⇒
  ∃perm'.
  let (res,rst) = wEval(prog,st with permute:=perm') in
  if (res = SOME Error) then T else
  let (res',rcst) = wEval(word_alloc k prog,st) in
    res = res' ∧
    word_state_eq_rel rst rcst``,
  (*TODO: Do I need to keep the assumptions about the final locals?*)
  rw[]>>
  qpat_abbrev_tac`cprog = word_alloc k prog`>>
  fs[word_alloc_def]>>pop_assum mp_tac>>LET_ELIM_TAC>>
  Q.ISPECL_THEN[`prog`,`st`,`st`,`total_colour col`,`LN:num_set`] mp_tac wEval_apply_colour>>
  discharge_hyps>-
    (rw[]
    >-
      (*Prove that the colors are okay*)
      (match_mp_tac colouring_ok_alt_thm>>
      match_mp_tac (colouring_satisfactory_colouring_ok_alt|>rm_let)>>
      unabbrev_all_tac>>
      match_mp_tac (reg_alloc_total_satisfactory|>rm_let)>>
      rw[get_spg_def]>>
      fs[clash_sets_to_sp_g_undir])
    >-
      fs[word_state_eq_rel_def]
    >>
      fs[strong_locals_rel_def,even_starting_locals_def]>>
      rw[]>>
      fs[domain_lookup]>>
      first_x_assum(qspec_then`n` assume_tac)>>
      rfs[]>>
      Q.ISPECL_THEN[`3:num`,`clash_graph`,`k`,`moves`] mp_tac (reg_alloc_conventional_phy_var|>rm_let)>>
      discharge_hyps>-
        (rw[Abbr`clash_graph`,get_spg_def]>>fs[clash_sets_to_sp_g_undir])
      >>
      rw[colouring_conventional_def,LET_THM])
  >>
  rw[]>>
  qexists_tac`perm'`>>rw[]>>
  fs[LET_THM])

val _ = export_theory();
