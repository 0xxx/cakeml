\documentclass[12pt,a4paper]{book}
\usepackage[scaled]{berasans}
\usepackage[scaled]{berasans}
\usepackage[scaled]{beraserif}

\usepackage{todonotes}

\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{amsmath}

\usepackage{supertabular}

\usepackage{xcolor}
\usepackage{lem}

\newcommand{\TODO}[1]{{\color{red}#1}}

\newcommand{\gramsep}{|}

\title{CakeML Reference Manual}
\author{Scott Owens\\
University of Kent\\
\url{https://cakeml.org}
}
\usepackage[T1]{fontenc}

\begin{document}\sloppy
\maketitle
\frenchspacing

\frontmatter

\chapter{Preface}

This manual is intended to describe the CakeML language, compiler, and associated proof technologies. We hope that it will be useful for anyone who wants to understand  CakeML and its implementation, either with an aim to collaborate with main CakeML team,\footnote{Project ideas are listed at \url{https://cakeml.org/projects.html}.}
or to work with CakeML independently.

We have attempted to make this reference manual self-contained. However, our aim is not to explain the basics of functional programming, programming language semantics, or interactive theorem proving, and so we expect of the reader at least some familiarity with a functional programming language, and with basic discrete mathematics: logic, inductively defined relations, etc.

\mainmatter
\tableofcontents


\part{The CakeML Language}

\chapter{An informal description of CakeML}

CakeML is a functional language in the ML family. Its syntax and semantics
closely resembles Standard ML, and the concepts will also be familiar to OCaml
programmers.

CakeML's syntax has a two-level structure with declarations and expressions. A
program is a sequence of top-level declarations that define variables,
functions, types, and modules. Computations are performed by the expressions in
function bodies and variable initialisation.

Expression are built up from constants, variables, function applications, and
various special forms for conditionals, pattern matching, exception handling,
anonymous functions, and local definitions. Each expression has a type, and
computes a value of that type, unless it infinite loops or raises an exception.

\section{Primitive values}

CakeML has special syntax for boolean, integer, string, and character
constants. Lists, tuples, and functions are also values, as are immutable
vectors and mutable references and arrays (see \S\ref{ch:stdlib}).

\paragraph{Booleans} The boolean constants are written as \texttt{true} and
\texttt{false}. The type of booleans is \texttt{bool}. The conjunction and
disjunction logical operators are written as infix \texttt{andalso} and
\texttt{orelse}. They evaluate the left argument first, and only evaluate the
right one if necessary (short-circuit evaluation).

\paragraph{Integers} Integers values are written in decimal. The
\texttt{\textasciitilde} character acts as the minus sign for writing negative
numbers. So write \texttt{\textasciitilde 1} instead of \texttt{-1}. Hexidecimal and other
non-decimal notations are not currently supported. The type of integers is
\texttt{int}.

CakeML provides the following infix arithmetic operators on integers: \texttt{+},\texttt{-}, \texttt{*}, \texttt{div}, \texttt{mod}. Integers are represented internally as arbitrary precision numbers (\emph{bignums}) so they can never overflow, and there is no maximum or minimum representable integer. The \texttt{div} and \texttt{mod} operations will raise the \texttt{Div} exception if given divisor of 0. \texttt{div} returns the least integer less than the real quotient, so \texttt{\textasciitilde 10 div 3} returns \texttt{\textasciitilde 4}, and not \texttt{\textasciitilde 3}. \texttt{mod} is consistent with this, so that \texttt{\textasciitilde 10 mod 3} returns \texttt{2}, not \texttt{1}.

Integers are compared with \texttt{=}, \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}, each of which returns a \texttt{bool}.

\paragraph{Strings} String constants are enclosed in double quotation marks (\texttt{"}). The type of strings is \texttt{string}.

The escape character is \verb|\|, and it supports the following:
\begin{itemize}
\item
\verb|\n| : a newline character
\item
\verb|\"| : a double quotation (\texttt{"}) character
\item
\verb|\\| : a single backslash (\verb|\|) character, and
\item
\verb|\t| : a tab character.
\end{itemize}

\todo{Operations}

\paragraph{Characters} A character constant is just a string constant of length
1, with a \texttt{\#} prefix, for example \texttt{\#"c"} for the character `c'.
This means that characters use the same escape sequences as strings. The type
of characters is \texttt{char}.

\todo{Operations}

\section{Variables and other names}

There are two kinds of variable names, alphanumeric and symbolic. An alphanumeric variable must start
with a lower case letter and be a sequence of letters, digits and the \texttt{\_} and \texttt{'} characters. A symbolic variable is a sequence of the following characters: \verb)! % & $ # + - / : < = > ? @ \ ~ ^ | ` *).

Names of modules and constructors (from type definitions) are alphanumeric and
start with an upper case letter. Names of types are alphanumeric, and start
with a lower case letter.

No name can be any of the following reserved words:
\begin{verbatim}
and  andalso  before  case  datatype  div  else  end  exception
false  fn  handle  if  in  let  mod  nil  o  of  orelse  raise
ref  sig  struct  structure  then  true  type  val
:=  :>  ::  @  =>  =  :  |  +  *  -  /  <  >  <=  >=  <>
\end{verbatim}

\section{Functions and operators}

\begin{figure}
\centering
\begin{tabular}{l}
 \texttt{*} \texttt{div} \texttt{mod} \texttt{/}\\
 \texttt{+} \texttt{-}\\
 \texttt{@} \texttt{::}\\
 \texttt{<} \texttt{>} \texttt{<=} \texttt{>=} \texttt{<>} \texttt{=}\\
 \texttt{o} \texttt{:=}\\
 \texttt{before}\\
 \texttt{orelse} \texttt{andalso}
 \end{tabular}
\caption{Infix operators from tightest (at the top) to loosest binding}
\label{precedences}
\end{figure}

CakeML supports the limited set of infix operators listed in Figure~\ref{precedences}.

\paragraph{Equality}

The infix equality operator \texttt{=} checks whether two values are equal, returning a boolean. The values must be of the same type. For atomic data (booleans, integers, bytes, and strings), they are equal exactly when they are the same value. For immutable data (tuples, lists, vectors, and user defined datatypes), they are equal if they are made up of equal elements, recursively. For mutable data (references, arrays, and byte arrays), they are equal if they are the same structure, their elements are not inspected.

If the equality function encounters a function value while traversing its arguments, it raises the \texttt{Eq} exception.

\section{Conditionals}
%
\[\texttt{if}\ e_1\ \texttt{then}\ e_2\ \texttt{else}\ e_3\]

A conditional expression (above) evaluates expression $e_1$, and if it is \texttt{true}, then return the value of $e_2$, otherwise return the value of $e_3$. $e_1$ must have type \texttt{bool}, and $e_2$ and $e_3$ must have the same type.

\section{Compound data and pattern matching}

\paragraph{Tuples} A tuple of values is surrounded by parentheses and separated by commas. For example, \texttt{(1,2,true)} is a three element tuple. The empty tuple \texttt{()} is the (only) member of the special type \texttt{unit}. The type of a tuple is formed from the types of its members, separated by \texttt{*}, so the previous tuple has type \texttt{int * int * bool}. There are no operations on tuples.

\paragraph{Lists} A list of values is surrounded by square brackets and separated by commas. Each element of the list must have the same type. For example, the expression \texttt{[1,2,3,4]} is a list of integers containing four elements. Its type is \texttt{int list}. The empty list is written \texttt{[]}, and has a polymorphic type \texttt{'a list}, indicating that it can be used as an empty list of any type of contents. The cons operator (constructing a list with one more element) is written as \texttt{::}, so the above list could also have been written as \texttt{1::2::3::4::[]}. There are no operations for de-structuring lists.

\paragraph{User-defined data}

\section{Exceptions}

\section{Local bindings}

\section{Modules}

\section{Differences from Standard ML}

\subsection{Unsupported features}
Here we only list missing features of the language, and not the basis library.

The CakeML module system is heavily restricted compared to SML's. Structures cannot be nested, and functors are not supported. Structures cannot be given alternate names, or opened. Signatures cannot be named, and must appear directly on the structure that they seal. Only opaque sealing is supported (\texttt{:>}, but not \texttt{:}). Signatures cannot contain \texttt{include}, \texttt{sharing}, \texttt{structure}, \texttt{eqtype} or datatype replication specifications.

In contrast, CakeML's core language is more fully featured, with only the following omissions. The \texttt{local}, \texttt{abstype}, and datatype replication declarations are not supported. Neither are records, type annotations that contain type variables, and \texttt{while} loops. Furthermore, \texttt{let} expressions are restricted to \texttt{val} and \texttt{fun} declarations; they cannot contain type or exception declarations. The pattern language does not support the \texttt{as} form.

CakeML has a fixed set of infix operators, and does not support user defined parsing precedences (\texttt{infix}, \texttt{infixr}, and \texttt{nonfix}). See Figure~\ref{precedences} for the supported infix operators. The infix status of these operators cannot be suppressed (\texttt{op}).

Floating point numbers are not supported, nor are integer constants written in hexadecimal notation (\texttt{0x}). Lastly, only the most basic escape sequences are supported in strings (just \texttt{\textbackslash n}, \texttt{\textbackslash t}, \texttt{\textbackslash "}, and \texttt{\textbackslash\textbackslash}).

Syntactic sugar for functions with pattern parameters is not provided, instead parameters are variables, and must be matched against with \texttt{case} expressions, if desired.

\subsection{Syntactic and semantic differences}

All names must follow the OCaml convention where structure and constructor names start with a capital letter, and type and variable names must either start with a lower case letter, or be symbolic names.

CakeML does not support the limited overloading found in the SML Basis Library.

CakeML does not support the equality types that SML uses to ensure that the \texttt{=} operation never encounters a function value. Instead, the \texttt{=} raises an exception \texttt{Eq} if it does.

The types of bindings in \texttt{let} expressions cannot be generalised. This restriction does not affect top level, or structure top level declarations.

The built-in CakeML functions prefer the curried style over SML's preferred tupled style. For example, we write \texttt{Vector.sub v 12} to get the 12$^\textrm{th}$ element of vector v, rather than \texttt{Vector.sub (v,12)}.

CakeML guarantees right to left evaluation order.

\section{Differences from OCaml}

Because CakeML has a significantly different syntax, we focus here on the major features and semantic differences rather than attempt to catalogue every piece of OCaml syntax that lacks a CakeML analogue. Briefly, CakeML does not have floating point numbers, records, objects, polymorphic variants, labels, nested/local modules, or functors.

Strings are immutable; however, the Word8Array structure provides byte arrays.

CakeML guarantees right to left evaluation order.

The \texttt{=} operator does not traverse mutable data (arrays and references), instead it compares the pointers, SML style.

\chapter{Standard library}
\label{ch:stdlib}

%CakeML supports data of boolean, integer, character, and string types. It also supports compound data of tuple, list, option, vector, reference, array, and byte array types. Additionally, users can define new algebraic data types: these are described in  \S\ref{expressions} on pattern matching, and in \S\ref{declarations} on type definitions.


\section{References}

A reference is a mutable structure that contains exactly one value. The type of a reference containing a value of type $\tau$ is written $\tau$ \texttt{ref}.
References have the following operations.
\begin{itemize}
\item
\texttt{ref : 'a -> 'a ref} Create a new reference with an initial value.
\item
\texttt{! : 'a ref -> 'a} Get the value from a reference.
\item
\texttt{:= : 'a ref -> 'a -> unit} Replace the value in the reference with a new one.
\end{itemize}


\section{Array}

Arrays have a fixed length and support constant-time indexing. Each element of an array must have the same type. The operations on arrays are collected in the \texttt{Array} module. If the elements of an array are of some type $\tau$ then the vector's type is $\tau$\ \texttt{Array.array}.

The following are the supported operations on arrays. If an index is out of bounds (or negative), the \texttt{Subscript} exception is raised.
\begin{itemize}
\item \texttt{Array.array : int -> 'a -> 'a array} Create a new array of given length and default value.
\item \texttt{Array.length : 'a array -> int} Get the array's length.
\item \texttt{Array.sub : 'a array -> int -> 'a} Get the i$^\textrm{th}$ element.
\item \texttt{Array.update : 'a array -> int -> 'a -> unit} Set the i$^\textrm{th}$ element.
\end{itemize}

\section{Char}

\section{Int}

\section{List}

\section{Option} An optional value is either \texttt{NONE}, indicating that no value is present, or \texttt{SOME}\ $v$ for a value $v$. They type of an optional value that might contain a value of type $\tau$ is $\tau$\ \texttt{option}. There are no operations for de-structuring options.

\section{Vector}

Vectors are immutable array-like structures. They have a fixed length and support constant-time indexing. Each element of a vector must have the same type. The operations on vectors are collected in the \texttt{Vector} module. If the elements of a vector are of some type $\tau$ then the vector's type is $\tau$\ \texttt{Vector.vector}.

The following are the supported operations on vectors. If an index is out of bounds (or negative), the \texttt{Subscript} exception is raised.
\begin{itemize}
\item \texttt{Vector.fromList : 'a list -> 'a vector} Convert a list to a vector containing the same elements (in order).
\item \texttt{Vector.length : 'a vector -> int} Get the vector's length.
\item \texttt{Vector.sub : 'a vector -> int -> 'a} Get the i$^\textrm{th}$ element.
\end{itemize}

\section{Word8}

\section{Word8Array}
Byte arrays have a fixed length and support constant-time indexing. Each element of an array must be a byte (\texttt{Word8.word} type). The operations on byte arrays are collected in the \texttt{Word8Array} module. The type of a byte array is \texttt{Word8Array.array}.

The following are the supported operations on byte arrays. If an index is out of bounds (or negative), the \texttt{Subscript} exception is raised.
\begin{itemize}
\item \texttt{Word8Array.array : int -> Word8.word -> Word8Array.array} Create a new array of given length and default value.
\item \texttt{Word8Array.length : Word8Array.array -> int} Get the array's length.
\item \texttt{Word8Array.sub : Word8Array.array -> int -> Word8.word} Get the i$^\textrm{th}$ element.
\item \texttt{Word8Array.update : Word8Array.array -> int -> Word8.word -> unit} Set the i$^\textrm{th}$ element.
\end{itemize}



\chapter{Formal syntax and semantics}

\section{Lexical and context free syntax}

\[
\begin{array}{lcll}
\alpha&=& \mbox{\texttt{'}[\texttt{a}-\texttt{z}\texttt{A}-\texttt{Z}\texttt{'}\texttt{\_}]}^*&\mbox{type variable}\\
i &=& \verb|~|^?\mbox{[\texttt{0}-\texttt{9}]}^+&\mbox{integer constant}\\
\end{array}
\]


\TODO{Lexical syntax for str, tn, v, fqv, C, fqC, S}

\[
\begin{array}{lcll}
t & ::= & &\mbox{types}\\
&&\alpha & \mbox{type variable}\\
& \gramsep& t\ \texttt{*}\ t & \mbox{tuple}\\
 &\gramsep &t\ \texttt{->}\ t&\mbox{function}\\
 &\gramsep& \mathit{tn}&\mbox{type name}\\
 &\gramsep&t\ \mathit{tn}&\mbox{type application}\\
 &\gramsep& \texttt{(}t\texttt{,}t(\texttt{,}t)^*\texttt{)}\ \mathit{tn}&\mbox{type application}\\
 &\gramsep&\texttt{(}t\texttt{)}
 \end{array}
 \]

 \[
\begin{array}{lcll}
l & ::= &&\mbox{literal constants}\\
&& \texttt{true}\\
&\gramsep& \texttt{false}\\
&\gramsep& \texttt{(}\texttt{)}&\mbox{unit}\\
&\gramsep& \texttt{[}\texttt{]}&\mbox{empty list}\\
&\gramsep& \texttt{nil}&\mbox{empty list}\\
&\gramsep& i &\mbox{integer}\\
&\gramsep& \textit{str} &\mbox{string}\\
 \end{array}
\]

\[
\begin{array}{lcll}
p & ::= & &\mbox{patterns}\\
&&\texttt{\_}&\mbox{wildcard}\\
&\gramsep& v &\mbox{variable}\\
&\gramsep& l &\mbox{constant}\\
&\gramsep& \mathit{fqC} & \mbox{constant constructor}\\
&\gramsep& \mathit{fqC}\ p & \mbox{constructor application}\\
&\gramsep& \texttt{(}p\texttt{,}p(\texttt{,}p)^*\texttt{)}&\mbox{tuple}\\
&\gramsep& p \texttt{::} p&\mbox{list (first and rest)}\\
&\gramsep& \texttt{[}p(\texttt{,}p)^*\texttt{]}&\mbox{list (fixed length)}\\
 &\gramsep& \texttt{ref}\ p&\mbox{reference}\\
 &\gramsep& \texttt{(}p\texttt{)}
 \end{array}
\]

\[
\begin{array}{lcll}

e & ::= & &\mbox{expressions}\\
&&l &\mbox{constant}\\
&|& \mathit{fqv}&\mbox{variable}\\
&|&\mathit{fqC}&\mbox{constant constructor}\\
&|&\mathit{fqC}\ e&\mbox{constructor application}\\
&|&\texttt{(}e\texttt{,}e(\texttt{,}e)^*\texttt{)}&\mbox{tuple}\\
&|&\texttt{[}e(\texttt{,}e)^*\texttt{]}&\mbox{list}\\
&|&\texttt{raise}\ e & \mbox{exception raising}\\
&|& e\ \texttt{handle}\ p\ \texttt{=>}\ e\ (\texttt{|}p\ \texttt{=>}\ e)^*&\mbox{exception handling}\\
&|& \texttt{fn}\ v\ \texttt{=>}\ e&\mbox{function}\\
&|& e\ e&\mbox{function application}\\
&|& e\ \mathit{op}\ e&\mbox{binary operator}\\
&|& \texttt{(}(e\texttt{;})^*e\texttt{)}&\mbox{sequencing}\\
&|& \texttt{if}\ e\ \texttt{then}\ e\ \texttt{else}\ e&\mbox{conditional}\\
&|& \texttt{case}\ e\ \texttt{of}\ p\ \texttt{=>}\ e\ (\texttt{|}p\ \texttt{=>}\ e)^*&\mbox{pattern matching}\\
&|& \texttt{let}\ (\mathit{ld}|\texttt{;})^*\ \texttt{in}\ (e\texttt{;})^*e\ \texttt{end}&\mbox{let}\\
&|&\texttt{(}e\texttt{)}\\\\

\mathit{ld} &::=& &\mbox{local definition}\\
&& \texttt{val}\ x\ \texttt{=}\ e&\mbox{value}\\
 &|&\texttt{fun}\ v\ v^+\ \texttt{=}\ e\ (\texttt{and}\ v\ v^+\ \texttt{=}\ e)^*&\mbox{function}\\\\

\mathit{op} &::=& &\mbox{infix operators}\\
&&\texttt{*}\gramsep \texttt{div}\gramsep \texttt{mod}&\mbox{multipicative}\\
&|& \texttt{+}\gramsep \texttt{-}&\mbox{additive} \\
&|&\texttt{@}\gramsep{::} & \mbox{list}\\
&|&\texttt{=} \gramsep \texttt{<}\gramsep \texttt{<=}\gramsep \texttt{>}\gramsep \texttt{>=} \gramsep\texttt{<>}&\mbox{comparison}\\
&|&\texttt{o}\gramsep \texttt{:=}\\
&|&\texttt{before}&\mbox{sequencing}\\
&|&\texttt{andalso} \gramsep \texttt{orelse}&\mbox{logical}
\end{array}
\]


\[
\begin{array}{lcll}
d &::=& &\mbox{declarations}\\
&&\texttt{val}\ p\ \texttt{=}\ e&\mbox{value}\\
&|& \texttt{fun}\ v\ v^+\ \texttt{=}\ e\ (\texttt{and}\ v\ v^+\ \texttt{=}\ e)^*&\mbox{function}\\
&|&  \texttt{datatype}\ \mathit{tyd}\ (\texttt{and}\ \mathit{tyd})^*&\mbox{type}\\
&|& \texttt{exception}\ c&\mbox{exception}\\\\

c & ::= &&\mbox{constructors}\\
&& C&\mbox{constant}\\
& \gramsep &C\ \texttt{of}\ t&\mbox{with arguments}\\\\

\mathit{ptn} &::=& &\mbox{type names w/parameters}\\
&& \texttt{(}\alpha(\texttt{,}\alpha)^*\texttt{)}\ \mathit{tn}\\
&\gramsep& \alpha\ \mathit{tn}\\
&\gramsep& \mathit{tn}\\\\

\mathit{tyd} & ::= & \mathit{ptn}\ \texttt{=}\ c(\texttt{|}c)^* & \mbox{define a single type}
\end{array}
\]

\[
\begin{array}{lcll}
m &::=& \texttt{structure}\ S\ s^?\ \texttt{=}\ \texttt{struct}\ (d|\texttt{;})^*\ \texttt{end}&\mbox{modules}\\\\

s &::=& \texttt{:>}\ \texttt{sig}\ (\mathit{sp}|\texttt{;})^*\ \texttt{end}&\mbox{signatures}\\\\

\mathit{sp}&::=&  &\mbox{specifications}\\
&&\texttt{val}\ v\ \texttt{:}\ t& \mbox{value}\\
&\gramsep& \texttt{type}\ \textit{tyn}&\mbox{opaque type}\\
&|&  \texttt{datatype}\ \mathit{tyd}\ (\texttt{and}\ \mathit{tyd})^*&\mbox{type}\\
&|& \texttt{exception}\ c&\mbox{exception}
\end{array}
\]

\[
\begin{array}{lcll}
\mathit{top} &::=& &\mbox{top-level declaration}\\
&& m &\mbox{module}\\
&& d &\mbox{declaration}\\
\end{array}
\]



\section{Abstract syntax}

The abstract syntax of CakeML is defined in Lem in \texttt{semantics/ast.lem}\footnote{\url{https://github.com/CakeML/cakeml/blob/master/semantics/ast.lem}}. This file is included here.

{\setlength{\parindent}{0pt}
\TODO{Figure out why Lem is omitting leading comments. Possibly change the typesetting}
\include{lem-generated/Ast-inc}

\LEMTypeLit

\LEMTypeOpn

\LEMTypeOpb

\LEMTypeModN

%\LEMTypeId

\LEMTypeVarN

\LEMTypeConN

\LEMTypeTypeN

\LEMTypeTvarN

%\LEMValspecMkId

%\LEMmkId

%\LEMValspecIdToN

%\LEMidToN

\LEMTypeOp

\LEMTypeLop

\LEMTypeTctor

\LEMTypeT

\LEMTint

\LEMTstring

%\LEMTunit

%\LEMTbool

\LEMTref

\LEMTwordEight

\LEMTwordEightarray

\LEMTfn

\LEMTexn

\LEMTypePat

\LEMTypeExp

\LEMTypeTypeDef

\LEMTypeDec

\LEMTypeDecs

\LEMTypeSpec

\LEMTypeSpecs

\LEMTypeTop

\LEMTypeProg

\LEMValspecPatBindings

\LEMconstZero
}

\section{Type system}

\section{Operational semantics}

\chapter{Theorems}


\part{The CakeML compiler and verification tools}

\chapter{Installing and using the compiler}

\chapter{Extracting pure CakeML programs from HOL4}

\chapter{Verifying effectful CakeML programs with characteristic formulae}

\end{document}
