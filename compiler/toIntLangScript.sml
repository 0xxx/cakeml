(*Generated by Lem from toIntLang.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory libTheory compilerLibTheory intLangTheory astTheory miscTheory;

val _ = numLib.prefer_num();



val _ = new_theory "toIntLang"

(* Translation from CakeML to Intermediate Language *)
(*open import Pervasives*)

(*open import Lib*)
(*open import CompilerLib*)
(*open import IntLang*)
(*open import Ast*)
(*import {hol} `miscTheory`*)

(* TODO: Lem's builtin find index has a different type *)
(*val find_index : forall 'a. 'a -> list 'a -> nat -> maybe nat*) (* to pick up the definition in miscTheory *)

 val free_vars_defn = Hol_defn "free_vars" `

(free_vars (CRaise e) = (free_vars e))
/\
(free_vars (CHandle e1 e2) = (lunion (free_vars e1) (lshift( 1) (free_vars e2))))
/\
(free_vars (CVar n) = ([n]))
/\
(free_vars (CGvar _) = ([]))
/\
(free_vars (CLit _) = ([]))
/\
(free_vars (CCon _ es) = (free_vars_list es))
/\
(free_vars (CLet bd e eb) = (lunion (free_vars e) (if bd then lshift( 1) (free_vars eb) else free_vars eb)))
/\
(free_vars (CLetrec defs e) =  
(let n = (LENGTH defs) in
  lunion (free_vars_defs n defs) (lshift n (free_vars e))))
/\
(free_vars (CCall _ e es) = (lunion (free_vars e) (free_vars_list es)))
/\
(free_vars (CPrim1 _ e) = (free_vars e))
/\
(free_vars (CPrim2 _ e1 e2) = (lunion (free_vars e1) (free_vars e2)))
/\
(free_vars (CUpd e1 e2) = (lunion (free_vars e1) (free_vars e2)))
/\
(free_vars (CIf e1 e2 e3) = (lunion (free_vars e1) (lunion (free_vars e2) (free_vars e3))))
/\
(free_vars (CExtG _) = ([]))
/\
(free_vars_list [] = ([]))
/\
(free_vars_list (e::es) = (lunion (free_vars e) (free_vars_list es)))
/\
(free_vars_defs _ [] = ([]))
/\
(free_vars_defs n (d::ds) = (lunion (free_vars_def n d) (free_vars_defs n ds)))
/\
(free_vars_def n (NONE,(k,e)) = (lshift (n+k) (free_vars e)))
/\
(free_vars_def _ (SOME _,_) = ([]))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn free_vars_defn;

 val mkshift_defn = Hol_defn "mkshift" `

(mkshift f k (CRaise e) = (CRaise (mkshift f k e)))
/\
(mkshift f k (CHandle e1 e2) = (CHandle (mkshift f k e1) (mkshift f (k+ 1) e2)))
/\
(mkshift f k (CVar v) = (CVar (if v < k then v else (f (v - k))+k)))
/\
(mkshift _ _ (CGvar v) = (CGvar v))
/\
(mkshift _ _ (CLit l) = (CLit l))
/\
(mkshift f k (CCon cn es) = (CCon cn (MAP (mkshift f k) es)))
/\
(mkshift f k (CLet bd e b) = (CLet bd (mkshift f k e) (mkshift f (if bd then k+ 1 else k) b)))
/\
(mkshift f k (CLetrec defs b) =  
(let ns = (LENGTH defs) in
  let defs = (MAP (\ cb . 
    (case cb of   (SOME _,_) => cb | (NONE,(az,b)) => (NONE,(az,mkshift f ((k+ns)+az) b)) ))
    defs) in
  CLetrec defs (mkshift f (k+ns) b)))
/\
(mkshift f k (CCall ck e es) = (CCall ck (mkshift f k e) (MAP (mkshift f k) es)))
/\
(mkshift f k (CPrim1 p1 e) = (CPrim1 p1 (mkshift f k e)))
/\
(mkshift f k (CPrim2 p2 e1 e2) = (CPrim2 p2 (mkshift f k e1) (mkshift f k e2)))
/\
(mkshift f k (CUpd e1 e2) = (CUpd (mkshift f k e1) (mkshift f k e2)))
/\
(mkshift f k (CIf e1 e2 e3) = (CIf (mkshift f k e1) (mkshift f k e2) (mkshift f k e3)))
/\
(mkshift _ _ (CExtG n) = (CExtG n))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn mkshift_defn;

val _ = Define `
 (shift n = (mkshift (\ v .  v+n)))`;


 val _ = Define `

(opn_to_prim2 Plus = (INL CAdd))
/\
(opn_to_prim2 Minus = (INL CSub))
/\
(opn_to_prim2 Times = (INL CMul))
/\
(opn_to_prim2 Divide = (INR CDiv))
/\
(opn_to_prim2 Modulo = (INR CMod))`;


(*

let rec
exp_to_Cexp m (Handle e pes) =
  let Ce = exp_to_Cexp m e in
  let Cpes = pes_to_Cpes m pes in
  let Cpes = List.map (fun (p,e) -> (p,shift 1 (Cpat_vars p) e)) Cpes in
  CHandle Ce (remove_mat_var true 0 Cpes)
and
exp_to_Cexp m (Raise e) = CRaise (exp_to_Cexp m e)
and
exp_to_Cexp _ (Lit l) = CLit l
and
exp_to_Cexp m (Con cn es) =
  CCon (fapply 0 cn m.cnmap) (exps_to_Cexps m es)
and
exp_to_Cexp m (Var (Short vn)) = CVar (Short (the 0 (find_index vn m.bvars 0)))
and
exp_to_Cexp m (Var (Long mn vn)) = CVar (Long mn (the 0 (find_index vn (fapply [] mn m.mvars) 0)))
and
exp_to_Cexp m (Fun vn e) =
  CLetrec [(Nothing,(1,shift 1 1 (exp_to_Cexp (cbv m vn) e)))] (CVar (Short 0))
and
exp_to_Cexp m (App (Opn opn) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  match opn_to_prim2 opn with
  | Left p2 -> CPrim2 p2 Ce1 Ce2
  | Right p2 ->
    CLet Ce1
      (CLet (shift 1 0 Ce2)
        (CIf (CPrim2 CEq (CVar (Short 0)) (CLit (IntLit 0)))
             (CRaise CDiv_exc)
             (CPrim2 p2 (CVar (Short 1)) (CVar (Short 0)))))
  end
and
exp_to_Cexp m (App (Opb opb) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  match opb with
  | Lt -> CPrim2 CLt Ce1 Ce2
  | Leq -> CPrim2 CLt (CPrim2 CSub Ce1 Ce2) (CLit (IntLit 1))
  | opb ->
      CLet Ce1 (
        CLet (shift 1 0 Ce2) (
          match opb with
          | Gt ->  CPrim2 CLt (CVar (Short 0)) (CVar (Short 1))
          | Geq -> CPrim2 CLt (CPrim2 CSub (CVar (Short 0)) (CVar (Short 1))) (CLit (IntLit 1))
          | _ -> CRaise CBind_exc (* should not happen *)
          end))
  end
and
exp_to_Cexp m (App Equality e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CLet (CPrim2 CEq Ce1 Ce2)
    (CIf (CPrim1 CIsBlock (CVar (Short 0))) (CVar (Short 0)) (CRaise CEq_exc))
and
exp_to_Cexp m (App Opapp e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CCall true Ce1 [Ce2]
and
exp_to_Cexp m (App Opassign e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CUpd Ce1 Ce2
and
exp_to_Cexp m (Uapp uop e) =
  let Ce = exp_to_Cexp m e in
  CPrim1 (match uop with
          | Opref   -> CRef
          | Opderef -> CDer
          end) Ce
and
exp_to_Cexp m (Log log e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  (match log with
   | And -> CIf Ce1 Ce2 (CLit (Bool false))
   | Or  -> CIf Ce1 (CLit (Bool true)) Ce2
   end)
and
exp_to_Cexp m (If e1 e2 e3) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  let Ce3 = exp_to_Cexp m e3 in
  CIf Ce1 Ce2 Ce3
and
exp_to_Cexp m (Mat e pes) =
  let Ce = exp_to_Cexp m e in
  let Cpes = pes_to_Cpes m pes in
  let Cpes = List.map (fun (p,e) -> (p,shift 1 (Cpat_vars p) e)) Cpes in
  CLet Ce (remove_mat_var false 0 Cpes)
and
exp_to_Cexp m (Let vn e b) =
  let Ce = exp_to_Cexp m e in
  let Cb = exp_to_Cexp (cbv m vn) b in
  CLet Ce Cb
and
exp_to_Cexp m (Letrec defs b) =
  let m = <| m with bvars = (List.map (fun (n,_,_) -> n) defs) ++ m.bvars |> in
  CLetrec (defs_to_Cdefs m defs) (exp_to_Cexp m b)
and
defs_to_Cdefs _ [] = []
and
defs_to_Cdefs m ((_,vn,e)::defs) =
  let Ce = exp_to_Cexp (cbv m vn) e in
  let Cdefs = defs_to_Cdefs m defs in
  (Nothing,(1,Ce))::Cdefs
and
pes_to_Cpes _ [] = []
and
pes_to_Cpes m ((p,e)::pes) =
  let Cpes = pes_to_Cpes m pes in
  let (m,Cp) = pat_to_Cpat m p in
  let Ce = exp_to_Cexp m e in
  (Cp,Ce)::Cpes
and
exps_to_Cexps _ [] = []
and
exps_to_Cexps m (e::es) =
  exp_to_Cexp m e :: exps_to_Cexps m es

(* source to intermediate values *)

open SemanticPrimitives

let rec
v_to_Cv _ _ (Litv l) = CLitv l
and
v_to_Cv mv m (Conv cn vs) =
  CConv (fapply 0 cn m) (vs_to_Cvs mv m vs)
and
v_to_Cv mv m (Closure env vn e) =
  let Cenv = env_to_Cenv mv m env in
  let m = <| bvars = List.map fst env ; mvars = mv; cnmap = m |> in
  let Ce = exp_to_Cexp (cbv m vn) e in
  CRecClos Cenv [(Nothing, (1,shift 1 1 Ce))] 0
and
v_to_Cv mv m (Recclosure env defs vn) =
  let Cenv = env_to_Cenv mv m env in
  let m = <| bvars = List.map fst env ; mvars = mv; cnmap = m |> in
  let fns = List.map (fun (n,_,_) -> n) defs in
  let m = <| m with bvars = fns ++ m.bvars |> in
  let Cdefs = defs_to_Cdefs m defs in
  CRecClos Cenv Cdefs (the 0 (find_index vn fns 0))
and
v_to_Cv _ _ (Loc n) = CLoc n
and
vs_to_Cvs _ _ [] = []
and
vs_to_Cvs mv m (v::vs) = v_to_Cv mv m v :: vs_to_Cvs mv m vs
and
env_to_Cenv _ _ [] = []
and
env_to_Cenv mv m ((_,v)::env) =
  (v_to_Cv mv m v)::(env_to_Cenv mv m env)
  *)
val _ = export_theory()

