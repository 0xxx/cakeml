(*Generated by Lem from compiler.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory semanticPrimitivesTheory astTheory compilerLibTheory intLangTheory toIntLangTheory toBytecodeTheory bytecodeTheory;

val _ = numLib.prefer_num();



val _ = new_theory "compiler"

(*open import Pervasives*) 

(*open import SemanticPrimitives*)
(*open import Ast*)
(*open import CompilerLib*)
(*open import IntLang*)
(*open import ToIntLang*)
(*open import ToBytecode*)
(*open import Bytecode*)
(*open String_extra*)

val _ = type_abbrev( "contab" , ``: (( ( conN id)option), num) fmap # (num #  ( conN id)option) list # num``);
(*val cmap : contab -> Map.map (maybe (id conN)) nat*)
 val _ = Define `
 (cmap (m,_,_) = m)`;


val _ = Hol_datatype `
 compiler_state =
  <| contab : contab
   ; renv : (string # num) list
   ; rmenv : (string, ( (string # num)list)) fmap
   ; rsz : num
   ; rnext_label : num
   |>`;


(*val cpam : compiler_state -> list (nat * maybe (id conN))*)
 val _ = Define `
 (cpam s = ((case s.contab of (_,w,_) => w )))`;


val _ = Define `
 (init_compiler_state =  
(<| contab := (((((((FEMPTY |+ (NONE, tuple_cn)) |+ ((SOME(Short"nil")), nil_exc_cn)) |+ ((SOME(Short"::")), cons_exc_cn)) |+ ((SOME(Short"Bind")), bind_exc_cn)) |+ ((SOME(Short"Div")), div_exc_cn)) |+ ((SOME(Short"Eq")), eq_exc_cn))
              ,[(eq_exc_cn,SOME(Short"Eq"))
               ;(div_exc_cn,SOME(Short"Div"))
               ;(bind_exc_cn,SOME(Short"Bind"))
               ;(cons_exc_cn,SOME(Short"::"))
               ;(nil_exc_cn,SOME(Short"nil"))
               ;(tuple_cn,NONE)]
              , 6)
   ; renv := []
   ; rmenv := FEMPTY
   ; rsz :=( 0)
   ; rnext_label :=( 0)
   |>))`;


 val _ = Define `

(number_constructors _ [] ct = ct)
/\
(number_constructors mn ((c,_)::cs) (m,w,n) =  
(number_constructors mn cs (m |+ ((SOME (mk_id mn c)), n), ((n,SOME (mk_id mn c))::w), (n+( 1:num)))))`;


 val _ = Define `

(dec_to_contab mn ct (Dtype ts) =  
(FOLDL (\ct p .  (case (ct ,p ) of ( ct , (_,_,cs) ) => number_constructors mn cs ct )) ct ts))
/\
(dec_to_contab mn ct (Dexn c ts) =  
(number_constructors mn [(c,ts)] ct))
/\
(dec_to_contab _ ct _ = ct)`;


 val decs_to_contab_defn = Hol_defn "decs_to_contab" `

(decs_to_contab _ ct [] = ct)
/\
(decs_to_contab mn ct (d::ds) = (decs_to_contab mn (dec_to_contab mn ct d) ds))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn decs_to_contab_defn;

 val compile_news_defn = Hol_defn "compile_news" `

(compile_news cs _ [] = (emit cs [Stack Pop]))
/\
(compile_news cs i (_::vs) =  
(let cs = (emit cs (MAP Stack [Load( 0); Load( 0); El i])) in
  let cs = (emit cs [Stack (Store( 1))]) in
  compile_news cs (i+ 1) vs))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn compile_news_defn;

val _ = Define `
 (compile_Cexp menv env rsz cs Ce =  
(let (Ce,nl) = (label_closures (LENGTH env) cs.next_label Ce) in
  let cs = (compile_code_env menv ( cs with<| next_label := nl |>) Ce) in
  compile menv env TCNonTail rsz cs Ce))`;


(*
let compile_fake_exp menv m env rsz cs vs e =
  let Ce = exp_to_Cexp m (e (Con Nothing (List.map (fun v -> Var (Short v)) (List.reverse vs)))) in
  compile_Cexp menv env rsz cs Ce

let rec
compile_dec _ _ _ _ cs (Dtype _) = (Nothing, emit cs [Stack (Cons (block_tag+tuple_cn) 0)])
and
compile_dec _ _ _ _ cs (Dexn _ _ ) = (Nothing, emit cs [Stack (Cons (block_tag+tuple_cn) 0)])
and
compile_dec menv m env rsz cs (Dletrec defs) =
  let vs = List.map (fun (n,_,_) -> n) defs in
  (Just vs, compile_fake_exp menv m env rsz cs vs (fun b -> Letrec defs b))
and
compile_dec menv m env rsz cs (Dlet p e) =
  let vs = pat_bindings p [] in
  (Just vs, compile_fake_exp menv m env rsz cs vs (fun b -> Mat e [(p,b)]))

let rec
compile_decs _ _ ct m _ rsz cs [] = (ct,m,rsz,cs)
and
compile_decs mn menv ct m env rsz cs (dec::decs) =
  let (vso,cs) = compile_dec menv m env rsz cs dec in
  let ct = dec_to_contab mn ct dec in
  let vs = match vso with Nothing -> [] | Just vs -> vs end in
  let n = List.length vs in
  let m = <| m with cnmap = cmap ct; bvars = vs++m.bvars |> in
  let env = (genlist(fun i -> CTDec (rsz+n-1-i))n)++env in
  let rsz = rsz+n in
  let cs = compile_news cs 0 vs in
  compile_decs mn menv ct m env rsz cs decs

let compile_decs_wrap mn rs decs =
  let cs = <| out = []; next_label = rs.rnext_label |> in
  let cs = emit cs [PushPtr (Addr 0); PushExc] in
  let menv = Map.map (List.map snd) rs.rmenv in
  let m = <| bvars = List.map fst rs.renv
           ; mvars = Map.map (List.map fst) rs.rmenv
           ; cnmap = cmap rs.contab
           |> in
  let env = List.map (comb CTDec snd) rs.renv in
  let (ct,m,rsz,cs) = compile_decs mn menv rs.contab m env (rs.rsz+2) cs decs in
  let n = rsz-2-rs.rsz in
  let news = List.take n m.bvars in
  let cs = emit cs [Stack (Cons tuple_cn n)] in
  let cs = emit cs [PopExc; Stack(Pops 1)] in
  let cs = compile_news cs 0 news in
  let env = Lib.ZIP news (genlist (fun i -> rs.rsz+n-1-i) n) in
  (ct,env,cs)

let tystr types v =
  match Map.lookup v types with
    | Just t -> t
    | Nothing -> "<unknown>"
  end

let rec
compile_print_vals _ _ [] s = s
and
compile_print_vals types n (v::vs) s =
  let s = emit s (List.map PrintC (EXPLODE (string_concat ["val ";v;":"; tystr types v;" = "]))) in
  let s = emit s [Stack(Load n); Print] in
  let s = emit s (List.map PrintC (EXPLODE "\n")) in
    compile_print_vals types (n+1) vs s

let rec
compile_print_ctors [] s = s
and
compile_print_ctors ((c,_)::cs) s =
  compile_print_ctors cs
    (emit s (List.map PrintC (EXPLODE (string_concat [c;" = <constructor>\n"]))))
declare termination_argument compile_print_ctors = automatic

let rec
compile_print_types [] s = s
and
compile_print_types ((_,_,cs)::ts) s =
  compile_print_types ts (compile_print_ctors cs s)
declare termination_argument compile_print_types = automatic

let rec
compile_print_dec _ (Dtype ts) s = compile_print_types ts s
and
compile_print_dec _ (Dexn c xs) s = compile_print_types [(([]:list tvarN),"exn",[(c,xs)])] s
and
compile_print_dec types (Dlet p _) s =
  compile_print_vals types 0 (pat_bindings p []) s
and
compile_print_dec types (Dletrec defs) s =
  compile_print_vals types 0 (List.map (fun (n,_,_) -> n) defs) s

let rec
compile_top _ rs (Tmod mn _ decs) =
  let (ct,env,cs) = compile_decs_wrap (Just mn) rs decs in
  let str = string_concat["structure ";mn;" = <structure>\n"] in
  (<| rs with
      contab = ct
    ; rnext_label = cs.next_label
    ; rmenv = Map.insert mn env rs.rmenv
    ; rsz = rs.rsz + List.length env |>
  ,<| rs with
      contab = ct
    ; rmenv = Map.insert mn [] rs.rmenv
    ; rnext_label = cs.next_label
    |>
  ,(emit cs (List.map PrintC (EXPLODE str))).out)
and
compile_top types rs (Tdec dec) =
  let (ct,env,cs) = compile_decs_wrap Nothing rs [dec] in
  (<| rs with
      contab = ct
    ; rnext_label = cs.next_label
    ; renv = env++rs.renv
    ; rsz = rs.rsz+List.length env |>
  ,<| rs with
      contab = ct
    ; rnext_label = cs.next_label |>
  ,(compile_print_dec types dec cs).out)
 *)
val _ = export_theory()

