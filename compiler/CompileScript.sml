(*Generated by Lem from compile.lem.*)
open bossLib Theory Parse res_quanTheory
open fixedPointTheory finite_mapTheory listTheory pairTheory pred_setTheory
open integerTheory set_relationTheory sortingTheory stringTheory wordsTheory
open alistTheory

val _ = numLib.prefer_num();



open ToBytecodeTheory ToIntLangTheory IntLangTheory CompilerPrimitivesTheory BytecodeTheory CompilerLibTheory SemanticPrimitivesTheory AstTheory LibTheory

val _ = new_theory "Compile"

(*open SemanticPrimitives*)
(*open Ast*)
(*open CompilerLib*)
(*open IntLang*)
(*open ToIntLang*)
(*open Bytecode*)
(*open ToBytecode*)

 val no_labs_defn = Hol_defn "no_labs" `

(no_labs (CDecl _) = T)
/\
(no_labs (CRaise _) = T)
/\
(no_labs (CHandle e1 e2) = (no_labs e1 /\ no_labs e2))
/\
(no_labs (CVar _) = T)
/\
(no_labs (CLit _) = T)
/\
(no_labs (CCon _ es) = (no_labs_list es))
/\
(no_labs (CTagEq e _) = (no_labs e))
/\
(no_labs (CProj e _) = (no_labs e))
/\
(no_labs (CLet e b) = (no_labs e /\ no_labs b))
/\
(no_labs (CLetrec defs e) = (no_labs_defs defs /\ no_labs e))
/\
(no_labs (CFun def) = (no_labs_def def))
/\
(no_labs (CCall e es) = (no_labs e /\ no_labs_list es))
/\
(no_labs (CPrim2 _ e1 e2) = (no_labs e1 /\ no_labs e2))
/\
(no_labs (CUpd e1 e2) = (no_labs e1 /\ no_labs e2))
/\
(no_labs (CPrim1 _ e) = (no_labs e))
/\
(no_labs (CIf e1 e2 e3) = (no_labs e1 /\ no_labs e2 /\ no_labs e3))
/\
(no_labs_list [] = T)
/\
(no_labs_list (e::es) = (no_labs e /\ no_labs_list es))
/\
(no_labs_defs [] = T)
/\
(no_labs_defs (d::ds) = (no_labs_def d /\ no_labs_defs ds))
/\
(no_labs_def (SOME _,_) = F)
/\
(no_labs_def (NONE,(az,b)) = (no_labs b))`;

val _ = Defn.save_defn no_labs_defn;

 val all_labs_defn = Hol_defn "all_labs" `

(all_labs (CDecl _) = T)
/\
(all_labs (CRaise _) = T)
/\
(all_labs (CHandle e1 e2) = (all_labs e1 /\ all_labs e2))
/\
(all_labs (CVar _) = T)
/\
(all_labs (CLit _) = T)
/\
(all_labs (CCon _ es) = (all_labs_list es))
/\
(all_labs (CTagEq e _) = (all_labs e))
/\
(all_labs (CProj e _) = (all_labs e))
/\
(all_labs (CLet e b) = (all_labs e /\ all_labs b))
/\
(all_labs (CLetrec defs e) = (all_labs_defs defs /\ all_labs e))
/\
(all_labs (CFun def) = (all_labs_def def))
/\
(all_labs (CCall e es) = (all_labs e /\ all_labs_list es))
/\
(all_labs (CPrim2 _ e1 e2) = (all_labs e1 /\ all_labs e2))
/\
(all_labs (CUpd e1 e2) = (all_labs e1 /\ all_labs e2))
/\
(all_labs (CPrim1 _ e) = (all_labs e))
/\
(all_labs (CIf e1 e2 e3) = (all_labs e1 /\ all_labs e2 /\ all_labs e3))
/\
(all_labs_list [] = T)
/\
(all_labs_list (e::es) = (all_labs e /\ all_labs_list es))
/\
(all_labs_defs [] = T)
/\
(all_labs_defs (d::ds) = (all_labs_def d /\ all_labs_defs ds))
/\
(all_labs_def (SOME _,(az,b)) = (all_labs b))
/\
(all_labs_def (NONE,(az,b)) = F)`;

val _ = Defn.save_defn all_labs_defn;

(* repl *)

val _ = type_abbrev( "contab" , ``: (( conN id), num)fmap # (num, ( conN id))fmap # num``);
(*val cmap : contab -> Pmap.map (id conN) num*)
 val cmap_def = Define `
 (cmap (m,_,_) = m)`;


val _ = Hol_datatype `
 repl_state =
  <| contab : contab
   ; rbvars : string list
   ; renv : ctenv
   ; rsz  : num
   ; rnext_label : num
   |>`;


(*val etC : repl_state -> exp_to_Cexp_state*)
val _ = Define `
 (etC rs = (<| bvars := rs.rbvars; cnmap := ( cmap rs.contab) |>))`;


val _ = Define `
 init_repl_state =  
(<| contab := ( FEMPTY, FEMPTY, 0)
   ; rbvars := []
   ; renv := []
   ; rsz  := 0
   ; rnext_label := 0
   |>)`;


val _ = Define `
 (compile_Cexp rs decl Ce =  
(let (Ce,n) = ( label_closures ( LENGTH rs.rbvars) rs.rnext_label Ce) in
  let cs = (<| out := []; next_label := n
            ; decl := (rs.renv,rs.rsz,rs.rbvars) |>) in
  let cs = ( compile_code_env cs Ce) in
  let cs = ( compile rs.renv (TCNonTail decl) rs.rsz cs Ce) in
  let rs = (if decl then (case cs.decl of
      (env,sz,bvars) => ( rs with<| renv := env; rsz := sz; rbvars := bvars |>)
    ) else ( rs with<| rsz := rs.rsz + 1 |>)) in
  let rs = (( rs with<| rnext_label := cs.next_label |>)) in
  (rs, REVERSE cs.out)))`;


 val number_constructors_defn = Hol_defn "number_constructors" `

(number_constructors [] ct = ct)
/\
(number_constructors ((c,_)::cs) (m,w,n) =  
(number_constructors cs ( FUPDATE  m ( (Short c), n), FUPDATE  w ( n, (Short c)), (n +1))))`;

val _ = Defn.save_defn number_constructors_defn;

 val repl_dec_defn = Hol_defn "repl_dec" `

(repl_dec rs (Dtype []) = (rs,[]))
/\
(repl_dec rs (Dtype ((_,_,cs)::ts)) =  
(let ct = ( number_constructors cs rs.contab) in
  repl_dec ( rs with<| contab := ct |>) (Dtype ts)))
/\
(repl_dec rs (Dletrec defs) =  
(let m = ( etC rs) in
  let fns = ( MAP (\p . 
  (case (p ) of ( (n,_,_) ) => n )) defs) in
  let m = (( m with<| bvars := fns ++ m.bvars |>)) in
  let Cdefs = ( defs_to_Cdefs m defs) in
  compile_Cexp rs T (CLetrec Cdefs (CDecl ( ZIP ( ( GENLIST (\ i . i) ( LENGTH fns)), fns))))))
/\
(repl_dec rs (Dlet p e) =  
(let m = ( etC rs) in
  let Ce = ( exp_to_Cexp m e) in
  let (m,Cp) = ( pat_to_Cpat ( m with<| bvars := [] |>) p) in
  let vs = (m.bvars) in
  let Cpes = ([(Cp,CDecl ( ZIP ( ( GENLIST (\ i . i) ( LENGTH vs)), vs)))]) in
  compile_Cexp rs T (CLet Ce (remove_mat_var 0 Cpes))))`;

val _ = Defn.save_defn repl_dec_defn;

val _ = Define `
 (repl_exp s exp = ( compile_Cexp s F (exp_to_Cexp (etC s) exp)))`;


(* Correctness *)

(* observable values *)

val _ = Hol_datatype `
 ov =
    OLit of lit
  | OConv of conN id => ov list
  | OFn
  | OLoc of num`;
 (* machine, not semantic, address *)

 val v_to_ov_defn = Hol_defn "v_to_ov" `

(v_to_ov s (Litv l) = (OLit l))
/\
(v_to_ov s (Conv cn vs) = (OConv cn ( MAP (v_to_ov s) vs)))
/\
(v_to_ov s (Closure _ _ _) = OFn)
/\
(v_to_ov s (Recclosure _ _ _) = OFn)
/\
(v_to_ov s (Loc n) = (OLoc ( EL  n  s)))`;

val _ = Defn.save_defn v_to_ov_defn;

 val Cv_to_ov_defn = Hol_defn "Cv_to_ov" `

(Cv_to_ov m s (CLitv l) = (OLit l))
/\
(Cv_to_ov m s (CConv cn vs) = (OConv ( FAPPLY  m  cn) ( MAP (Cv_to_ov m s) vs)))
/\
(Cv_to_ov m s (CRecClos _ _ _) = OFn)
/\
(Cv_to_ov m s (CLoc n) = (OLoc ( EL  n  s)))`;

val _ = Defn.save_defn Cv_to_ov_defn;

 val bv_to_ov_defn = Hol_defn "bv_to_ov" `

(bv_to_ov m (Number i) = (OLit (IntLit i)))
/\
(bv_to_ov m (Block n vs) =  
(if n = (bool_to_tag F) then OLit (Bool F) else
  if n = (bool_to_tag T) then OLit (Bool T) else
  if n = unit_tag then OLit Unit else
  if n = closure_tag then OFn else
  OConv ( FAPPLY  m  (n - block_tag)) ( MAP (bv_to_ov m) vs)))
/\
(bv_to_ov m (RefPtr n) = (OLoc n))`;

val _ = Defn.save_defn bv_to_ov_defn;

(* source to intermediate values *)

 val v_to_Cv_defn = Hol_defn "v_to_Cv" `

(v_to_Cv m (Litv l) = (CLitv l))
/\
(v_to_Cv m (Conv cn vs) =  
(CConv ( FAPPLY  m  cn) (vs_to_Cvs m vs)))
/\
(v_to_Cv m (Closure env vn e) =  
(let Cenv = (env_to_Cenv m env) in
  let m = (<| bvars := ( MAP FST env) ; cnmap := m |>) in
  let Ce = ( exp_to_Cexp (cbv m vn) e) in
  CRecClos Cenv [(NONE, (1,shift 1 1 Ce))] 0))
/\
(v_to_Cv m (Recclosure env defs vn) =  
(let Cenv = (env_to_Cenv m env) in
  let m = (<| bvars := ( MAP FST env) ; cnmap := m |>) in
  let fns = ( MAP (\p . 
  (case (p ) of ( (n,_,_) ) => n )) defs) in
  let m = (( m with<| bvars := fns ++ m.bvars |>)) in
  let Cdefs = ( defs_to_Cdefs m defs) in
  CRecClos Cenv Cdefs ( THE (find_index vn fns 0))))
/\
(v_to_Cv m (Loc n) = (CLoc n))
/\
(vs_to_Cvs m [] = ([]))
/\
(vs_to_Cvs m (v::vs) = (v_to_Cv m v :: vs_to_Cvs m vs))
/\
(env_to_Cenv m [] = ([]))
/\
(env_to_Cenv m ((_,v)::env) =  
((v_to_Cv m v) ::(env_to_Cenv m env)))`;

val _ = Defn.save_defn v_to_Cv_defn;

(* TODO: compile Raise and Handle properly *)
(* TODO: simple type system and checker? *)
(* TODO: map_Cexp? *)
(* TODO: use Pmap.peek instead of mem when it becomes available *)
(* TODO: collapse nested functions *)
(* TODO: collapse nested lets *)
(* TODO: Letfun introduction and reordering *)
(* TODO: let floating *)
(* TODO: removal of redundant expressions *)
(* TODO: simplification (e.g., constant folding) *)
(* TODO: avoid Shifts when possible *)
(* TODO: registers, register allocation, greedy shuffling? *)
(* TODO: bytecode optimizer: repeated Pops, unreachable code (e.g. after a Jump) *)
(* TODO: more efficient pattern-matching *)
(* TODO: store type information on CMat nodes (for pattern matching compilation)? *)
val _ = export_theory()

