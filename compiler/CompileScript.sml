(* generated by Lem from compile.lem *)
open bossLib Theory Parse res_quanTheory
open finite_mapTheory listTheory pairTheory pred_setTheory integerTheory
open alistTheory state_transformerTheory CexpTypesTheory; val _ = intLib.deprecate_int();
open set_relationTheory sortingTheory stringTheory wordsTheory

val _ = new_theory "Compile"

open BytecodeTheory MiniMLTheory

(* TODO: simple type system and checker *)
(* TODO: map_Cexp? *)
(* TODO: use Pmap.peek instead of mem when it becomes available *)
(* TODO: collapse nested functions *)
(* TODO: collapse nested lets *)
(* TODO: Letfun introduction and reordering *)
(* TODO: let floating *)
(* TODO: removal of redundant expressions *)
(* TODO: simplification (e.g., constant folding) *)
(* TODO: avoid Shifts when possible *)
(* TODO: registers, register allocation, greedy shuffling? *)
(* TODO: bytecode optimizer: repeated Pops, unreachable code (e.g. after a Jump) *)
(* TODO: more efficient pattern-matching method? *)
(* TODO: store type information on CMat nodes (for pattern matching compilation) *)
(* TODO: typechecking *)
(* TODO: printing *)

(* TODO: move to lem *)
(*val fold_left2 : forall 'a 'b 'c. ('a -> 'b -> 'c -> 'a) -> 'a -> list 'b -> list 'c -> 'a*)
(* TODO: lem library should use this for List.for_all2 *)
(*val every2 : forall 'a 'b. ('a -> 'b -> bool) -> list 'a -> list 'b -> bool*)
(*val least : (num -> bool) -> num*)
(*val num_to_string : num -> string*)
(*val int_to_num : int -> num*)
(*val alist_to_fmap : forall 'a 'b. list ('a * 'b) -> Pmap.map 'a 'b*)
(*val optrel : forall 'a 'b 'c 'd. ('a -> 'b -> bool) -> 'c -> 'd -> bool*)
(*val flookup : forall 'a 'b 'c. Pmap.map 'a 'b -> 'a -> 'c*)
(*val domsub : forall 'a 'b. Pmap.map 'a 'b -> 'a -> Pmap.map 'a 'b*)
(*val genlist : forall 'a. (num -> 'a) -> num -> list 'a*)
(*open MiniML*)
(*val return : forall 'a 'b. 'a -> 'b -> 'a * 'b*)
(*val bind : forall 'a 'b 'c. ('a -> 'b * 'a) -> ('b -> 'a -> 'c * 'a) -> 'a -> 'c * 'a*)
(*val ubind : forall 'a 'b 'c. ('a -> 'b * 'a) -> ('a -> 'c * 'a) -> 'a -> 'c * 'a*)

(* TODO: Misc. helpers *)

 val find_index_defn = Hol_defn "find_index" `

(find_index y [] _ = NONE)
/\
(find_index y (x::xs) n = if x = y then SOME n else find_index y xs (n+1))`;

val _ = Defn.save_defn find_index_defn;

val _ = Define `
 (fresh_var s =
  num_to_hex_string ($LEAST (\ n . ~  (num_to_hex_string n IN s))))`;


 val num_fold_defn = Hol_defn "num_fold" `
 (num_fold f a n = if n = 0 then a else num_fold f (f a) (n - 1))`;

val _ = Defn.save_defn num_fold_defn;

 val map_result_defn = Hol_defn "map_result" `

(map_result f (Rval v) = Rval (f v))
/\
(map_result f (Rerr e) = Rerr e)`;

val _ = Defn.save_defn map_result_defn;

 val every_result_defn = Hol_defn "every_result" `

(every_result  P (Rerr _) = T)
/\
(every_result P (Rval v) = P v)`;

val _ = Defn.save_defn every_result_defn;

val _ = Define `
 i0 = int_of_num 0`;

val _ = Define `
 i1 = int_of_num 1`;

val _ = Define `
 i2 = int_of_num 2`;


 val error_to_int_defn = Hol_defn "error_to_int" `

(error_to_int Bind_error = i0)
/\
(error_to_int Div_error = i1)`;

val _ = Defn.save_defn error_to_int_defn;

 val num_to_bool_defn = Hol_defn "num_to_bool" `

(num_to_bool 0 = F)
/\
(num_to_bool 1 = T)`;

val _ = Defn.save_defn num_to_bool_defn;

(* Intermediate language for MiniML compiler *)


 val Cpat_vars_defn = Hol_defn "Cpat_vars" `

(Cpat_vars (CPvar n) = {n})
/\
(Cpat_vars (CPlit _) = {})
/\
(Cpat_vars (CPcon _ ps) = FOLDL (\ s p . s UNION Cpat_vars p) {} ps)`;

val _ = Defn.save_defn Cpat_vars_defn;

 val free_vars_defn = Hol_defn "free_vars" `

(free_vars _ (CDecl xs) = LIST_TO_SET xs)
/\
(free_vars _ (CRaise _) = {})
/\
(free_vars _ (CVar n) = {n})
/\
(free_vars _ (CLit _) = {})
/\
(free_vars c (CCon _ es) =
  FOLDL (\ s e . s UNION free_vars c e) {} es)
/\
(free_vars c (CTagEq e _) = free_vars c e)
/\
(free_vars c (CProj e _) = free_vars c e)
/\
(free_vars c (CLet xs es e) =
  FOLDL (\ s e . s UNION free_vars c e)
  (free_vars c e DIFF LIST_TO_SET xs) es)
/\
(free_vars c (CLetfun T ns defs e) =
  FOLDL (\ s (vs,b) .
    s UNION (cbod_fvs c b DIFF (LIST_TO_SET ns UNION
                             LIST_TO_SET vs)))
  (free_vars c e DIFF LIST_TO_SET ns) defs)
/\
(free_vars c (CLetfun F ns defs e) =
  FOLDL (\ s (vs,b) .
    s UNION (cbod_fvs c b DIFF LIST_TO_SET vs))
  (free_vars c e DIFF LIST_TO_SET ns) defs)
/\
(free_vars c (CFun xs b) = cbod_fvs c b DIFF (LIST_TO_SET xs))
/\
(free_vars c (CCall e es) =
  FOLDL (\ s e . s UNION free_vars c e)
  (free_vars c e) es)
/\
(free_vars c (CPrim2 _ e1 e2) = free_vars c e1 UNION free_vars c e2)
/\
(free_vars c (CIf e1 e2 e3) = free_vars c e1 UNION free_vars c e2 UNION free_vars c e3)
/\
(cbod_fvs c l = (case FLOOKUP c l of
    NONE => {}
  | SOME e => free_vars ($\\ c l) e
  ))`;

val _ = Defn.save_defn free_vars_defn;

 val free_labs_defn = Hol_defn "free_labs" `

(free_labs c (CDecl _) = {})
/\
(free_labs c (CRaise _) = {})
/\
(free_labs c (CVar _) = {})
/\
(free_labs c (CLit _) = {})
/\
(free_labs c (CCon _ es) =
  FOLDL (\ s e . s UNION free_labs c e) {} es)
/\
(free_labs c (CTagEq e _) = free_labs c e)
/\
(free_labs c (CProj e _) = free_labs c e)
/\
(free_labs c (CLet _ es e) =
  FOLDL (\ s e . s UNION free_labs c e) (free_labs c e) es)
/\
(free_labs c (CLetfun _ _ defs e) =
  FOLDL (\ s (vs,b) . s UNION cbod_fls c b) (free_labs c e) defs)
/\
(free_labs c (CFun _ b) = cbod_fls c b)
/\
(free_labs c (CCall e es) =
  FOLDL (\ s e . s UNION free_labs c e) (free_labs c e) es)
/\
(free_labs c (CPrim2 _ e1 e2) = free_labs c e1 UNION free_labs c e2)
/\
(free_labs c (CIf e1 e2 e3) = free_labs c e1 UNION free_labs c e2 UNION free_labs c e3)
/\
(cbod_fls c l = {l} UNION (case FLOOKUP c l of
    NONE => {}
  | SOME e => free_labs ($\\ c l) e
  ))`;

val _ = Defn.save_defn free_labs_defn;

(* Big-step semantics *)

 val no_closures_defn = Hol_defn "no_closures" `

(no_closures (CLitv _) = T)
/\
(no_closures (CConv _ vs) = EVERY no_closures vs)
/\
(no_closures (CRecClos _ _ _ _) = F)`;

val _ = Defn.save_defn no_closures_defn;

 val doPrim2_defn = Hol_defn "doPrim2" `

(doPrim2 b ty op (CLitv (IntLit x)) (CLitv (IntLit y)) =
  if b /\ (y = i0) then (Rerr (Rraise Div_error))
  else Rval (CLitv (ty (op x y))))
/\
(doPrim2 b ty op _ _ = Rerr Rtype_error)`;

val _ = Defn.save_defn doPrim2_defn;

 val CevalPrim2_defn = Hol_defn "CevalPrim2" `

(CevalPrim2 CAdd = doPrim2 F IntLit int_add)
/\
(CevalPrim2 CSub = doPrim2 F IntLit (int_sub))
/\
(CevalPrim2 CMul = doPrim2 F IntLit int_mul)
/\
(CevalPrim2 CDiv = doPrim2 T IntLit int_div)
/\
(CevalPrim2 CMod = doPrim2 T IntLit int_mod)
/\
(CevalPrim2 CLt = doPrim2 F Bool int_lt)
/\
(CevalPrim2 CEq = \ v1 v2 .
  if no_closures v1 /\ no_closures v2
  then Rval (CLitv (Bool (v1 = v2)))
  else Rerr Rtype_error)`;

val _ = Defn.save_defn CevalPrim2_defn;

val _ = Define `
 (extend_rec_env cenv env rs defs ns vs =
  FOLDL2  (\ en n v . FUPDATE  en ( n, v)) 
    (FOLDL
        (\ en n . FUPDATE  en ( n,
          (CRecClos cenv rs defs n)))
        env
        rs) 
    ns  vs)`;


val _ = Hol_reln `
(! c env error.
T
==>
Cevaluate c env (CRaise error) (Rerr (Rraise error)))

/\
(! c env n.
 n IN FDOM  env
==>
Cevaluate c env (CVar n) (Rval (FAPPLY  env  n)))

/\
(! c env l.
T
==>
Cevaluate c env (CLit l) (Rval (CLitv l)))

/\
(! c env n es vs.
Cevaluate_list c env es (Rval vs)
==>
Cevaluate c env (CCon n es) (Rval (CConv n vs)))
/\
(! c env n es err.
Cevaluate_list c env es (Rerr err)
==>
Cevaluate c env (CCon n es) (Rerr err))

/\
(! c env e n m vs.
Cevaluate c env e (Rval (CConv m vs))
==>
Cevaluate c env (CTagEq e n) (Rval (CLitv (Bool (n = m)))))
/\
(! c env e n err.
Cevaluate c env e (Rerr err)
==>
Cevaluate c env (CTagEq e n) (Rerr err))

/\
(! c env e n m vs.
Cevaluate c env e (Rval (CConv m vs)) /\
n < LENGTH vs
==>
Cevaluate c env (CProj e n) (Rval (EL  n  vs)))
/\
(! c env e n err.
Cevaluate c env e (Rerr err)
==>
Cevaluate c env (CProj e n) (Rerr err))

/\
(! c env b r.
Cevaluate c env b r
==>
Cevaluate c env (CLet [] [] b) r)
/\
(! c env n ns e es b v r.
Cevaluate c env e (Rval v) /\
Cevaluate c (FUPDATE  env ( n, v)) (CLet ns es b) r
==>
Cevaluate c env (CLet (n::ns) (e::es) b) r)
/\
(! c env n ns e es b err.
Cevaluate c env e (Rerr err)
==>
Cevaluate c env (CLet (n::ns) (e::es) b) (Rerr err))

/\
(! c env ns defs b r.
(LENGTH ns = LENGTH defs) /\
ALL_DISTINCT ns /\
(! xs l. MEM (xs,l) defs ==>  l IN FDOM  c) /\
Cevaluate c
  (FOLDL2 
    (\ env' n (xs,cb) .
      FUPDATE  env' ( n, (CRecClos env [fresh_var (cbod_fvs c cb)] [(xs,cb)]
                               (fresh_var (cbod_fvs c cb))))) 
    env  ns  defs)
  b r
==>
Cevaluate c env (CLetfun F ns defs b) r)

/\
(! c env ns defs b r.
(LENGTH ns = LENGTH defs) /\
ALL_DISTINCT ns /\
(! xs l. MEM (xs,l) defs ==>  l IN FDOM  c) /\
Cevaluate c
  (FOLDL
     (\ env' n .
       FUPDATE  env' ( n, (CRecClos env ns defs n)))
     env ns)
  b r
==>
Cevaluate c env (CLetfun T ns defs b) r)

/\
(! c env xs l.
 l IN FDOM  c
==>
Cevaluate c env (CFun xs l)
  (Rval (CRecClos env [fresh_var (cbod_fvs c l)] [(xs,l)]
                      (fresh_var (cbod_fvs c l)))))

/\
(! c env e es env' ns' defs n i ns l b vs r.
Cevaluate c env e (Rval (CRecClos env' ns' defs n)) /\
(LENGTH ns' = LENGTH defs) /\
ALL_DISTINCT ns' /\
Cevaluate_list c env es (Rval vs) /\
(find_index n ns' 0 = SOME i) /\
(EL  i  defs = (ns,l)) /\
 l IN FDOM  c /\
(b = FAPPLY  c  l) /\
(LENGTH ns = LENGTH vs) /\
ALL_DISTINCT ns /\
Cevaluate c (extend_rec_env env' env' ns' defs ns vs) b r
==>
Cevaluate c env (CCall e es) r)
/\
(! c env e v es err.
Cevaluate c env e (Rval v) /\
Cevaluate_list c env es (Rerr err)
==>
Cevaluate c env (CCall e es) (Rerr err))

/\
(! c env e es err.
Cevaluate c env e (Rerr err)
==>
Cevaluate c env (CCall e es) (Rerr err))

/\
(! c env p2 e1 e2 v1 v2.
Cevaluate_list c env [e1;e2] (Rval [v1;v2])
==>
Cevaluate c env (CPrim2 p2 e1 e2) (CevalPrim2 p2 v1 v2))
/\
(! c env p2 e1 e2 err.
Cevaluate_list c env [e1;e2] (Rerr err)
==>
Cevaluate c env (CPrim2 p2 e1 e2) (Rerr err))

/\
(! c env e1 e2 e3 b1 r.
Cevaluate c env e1 (Rval (CLitv (Bool b1))) /\
Cevaluate c env (if b1 then e2 else e3) r
==>
Cevaluate c env (CIf e1 e2 e3) r)
/\
(! c env e1 e2 e3 err.
Cevaluate c env e1 (Rerr err)
==>
Cevaluate c env (CIf e1 e2 e3) (Rerr err))

/\
(! c env.
T
==>
Cevaluate_list c env [] (Rval []))
/\
(! c env e es v vs.
Cevaluate c env e (Rval v) /\
Cevaluate_list c env es (Rval vs)
==>
Cevaluate_list c env (e::es) (Rval (v::vs)))
/\
(! c env e es err.
Cevaluate c env e (Rerr err)
==>
Cevaluate_list c env (e::es) (Rerr err))
/\
(! c env e es v err.
Cevaluate c env e (Rval v) /\
Cevaluate_list c env es (Rerr err)
==>
Cevaluate_list c env (e::es) (Rerr err))`;

(* equivalence relations on intermediate language *)

val _ = Hol_reln `
(! c l.
T
==>
syneq c (CLitv l) (CLitv l))
/\
(! c cn vs1 vs2.
EVERY2 (syneq c) vs1 vs2
==>
syneq c (CConv cn vs1) (CConv cn vs2))
/\
(! c env1 env2 ns defs d.
EVERY
  (\ (xs,b) .
    (! v. v IN (cbod_fvs c b DIFF (LIST_TO_SET ns UNION
                                     LIST_TO_SET xs))
      ==> (OPTREL (syneq c)) (FLOOKUP env1 v) (FLOOKUP env2 v)))
  defs
==>
syneq c (CRecClos env1 ns defs d) (CRecClos env2 ns defs d))`;

(* Compiler *)

(* source to intermediate expressions *)

(* remove pattern-matching using continuations *)

 val pat_to_Cpat_defn = Hol_defn "pat_to_Cpat" `

(pat_to_Cpat m pvs (Pvar vn) = (vn::pvs, CPvar vn))
/\
(pat_to_Cpat m pvs (Plit l) = (pvs, CPlit l))
/\
(pat_to_Cpat m pvs (Pcon cn ps) =
  let (pvs,Cps) = pats_to_Cpats m pvs ps in
  (pvs,CPcon (FAPPLY  m  cn) Cps))
/\
(pats_to_Cpats m pvs [] = (pvs,[]))
/\
(pats_to_Cpats m pvs (p::ps) =
  let (pvs,Cps) = pats_to_Cpats m pvs ps in
  let (pvs,Cp) = pat_to_Cpat m pvs p in
  (pvs,Cp::Cps))`;

val _ = Defn.save_defn pat_to_Cpat_defn;

 val remove_mat_vp_defn = Hol_defn "remove_mat_vp" `

(remove_mat_vp c fk sk v (CPvar pv) =
  CLet [pv] [CVar v] sk)
/\
(remove_mat_vp c fk sk v (CPlit l) =
  CIf (CPrim2 CEq (CVar v) (CLit l))
    sk (CCall (CVar fk) []))
/\
(remove_mat_vp c fk sk v (CPcon cn ps) =
  CIf (CTagEq (CVar v) cn)
    (remove_mat_con c fk sk v 0 ps)
    (CCall (CVar fk) []))
/\
(remove_mat_con c fk sk v n [] = sk)
/\
(remove_mat_con c fk sk v n (p::ps) =
  let v' = fresh_var ({v;fk} UNION (free_vars c sk) UNION (Cpat_vars p)) in
  CLet [v'] [CProj (CVar v) n]
    (remove_mat_vp c fk (remove_mat_con c fk sk v (n+1) ps) v' p))`;

val _ = Defn.save_defn remove_mat_vp_defn;

val _ = Hol_datatype `
 e2c_state =
  <| e2c_next_label : num
   ; e2c_code_env : (num, Cexp) fmap
   (* not modified on return *)
   ; e2c_cmap : (conN, num) fmap
   |>`;


 val e2c_bump_defn = Hol_defn "e2c_bump" `
 (e2c_bump s =
  (s.e2c_next_label,  s with<| e2c_next_label := s.e2c_next_label + 1 |>))`;

val _ = Defn.save_defn e2c_bump_defn;
 val e2c_add_defn = Hol_defn "e2c_add" `
 (e2c_add l b s =
  ((),  s with<| e2c_code_env := FUPDATE  s.e2c_code_env ( l, b) |>))`;

val _ = Defn.save_defn e2c_add_defn;

 val remove_mat_var_defn = Hol_defn "remove_mat_var" `

(remove_mat_var v [] = UNIT (CRaise Bind_error))
/\
(remove_mat_var v ((p,sk)::pes) = BIND
  (\ s . UNIT s.e2c_code_env s) (\ c .
  let fk = fresh_var ({v} UNION (free_vars c sk) UNION (Cpat_vars p)) in BIND
  (e2c_bump) (\ n . BIND
  (remove_mat_var v pes) (\ pes . IGNORE_BIND
  (e2c_add n pes)
  (UNIT (CLetfun F [fk] [([],n)] (remove_mat_vp c fk sk v p)))))))`;

val _ = Defn.save_defn remove_mat_var_defn;

 val Cpes_vars_defn = Hol_defn "Cpes_vars" `
 (Cpes_vars c =
  FOLDL (\ s (p,e) . s UNION Cpat_vars p UNION free_vars c e) {})`;

val _ = Defn.save_defn Cpes_vars_defn;

 val exp_to_Cexp_defn = Hol_defn "exp_to_Cexp" `

(exp_to_Cexp (Raise err) = UNIT (CRaise err))
/\
(exp_to_Cexp (Lit l) = UNIT (CLit l))
/\
(exp_to_Cexp (Con cn es) = BIND
  (exps_to_Cexps es) (\ Ces . BIND
  (\ s . UNIT s.e2c_cmap s) (\ cmap . UNIT
  (CCon (FAPPLY  cmap  cn) Ces))))
/\
(exp_to_Cexp (Var vn) = UNIT (CVar vn))
/\
(exp_to_Cexp (Fun vn e) = BIND
  (e2c_bump) (\ n . BIND
  (exp_to_Cexp e) (\ e . IGNORE_BIND
  (e2c_add n e)
  (UNIT (CFun [vn] n)))))
/\
(exp_to_Cexp (App (Opn opn) e1 e2) = BIND
  (exp_to_Cexp e1) (\ Ce1 . BIND
  (exp_to_Cexp e2) (\ Ce2 . UNIT
  (CPrim2 ((case opn of
            Plus   => CAdd
          | Minus  => CSub
          | Times  => CMul
          | Divide => CDiv
          | Modulo => CMod
          ))
  Ce1 Ce2))))
/\
(exp_to_Cexp (App (Opb opb) e1 e2) = BIND
  (exp_to_Cexp e1) (\ Ce1 . BIND
  (exp_to_Cexp e2) (\ Ce2 . BIND
  (\ s . UNIT s.e2c_code_env s) (\ c . UNIT
  ((case opb of
    Lt => CPrim2 CLt Ce1 Ce2
  | Leq => CPrim2 CLt (CPrim2 CSub Ce1 Ce2) (CLit (IntLit i1))
  | opb =>
      let x1 = fresh_var (free_vars c Ce2) in
      let x2 = fresh_var {x1} in
      CLet [x1;x2] [Ce1;Ce2]
        (case opb of
          Gt =>  CPrim2 CLt (CVar x2) (CVar x1)
        | Geq => CPrim2 CLt (CPrim2 CSub (CVar x2) (CVar x1)) (CLit (IntLit i1))
        )
  ))))))
/\
(exp_to_Cexp (App Equality e1 e2) = BIND
  (exp_to_Cexp e1) (\ Ce1 . BIND
  (exp_to_Cexp e2) (\ Ce2 . UNIT
  (CPrim2 CEq Ce1 Ce2))))
/\
(exp_to_Cexp (App Opapp e1 e2) = BIND
  (exp_to_Cexp e1) (\ Ce1 . BIND
  (exp_to_Cexp e2) (\ Ce2 . UNIT
  (CCall Ce1 [Ce2]))))
/\
(exp_to_Cexp (Log log e1 e2) = BIND
  (exp_to_Cexp e1) (\ Ce1 . BIND
  (exp_to_Cexp e2) (\ Ce2 . UNIT
  ((case log of
     And => CIf Ce1 Ce2 (CLit (Bool F))
   | Or  => CIf Ce1 (CLit (Bool T)) Ce2
   )))))
/\
(exp_to_Cexp (If e1 e2 e3) = BIND
  (exp_to_Cexp e1) (\ Ce1 . BIND
  (exp_to_Cexp e2) (\ Ce2 . BIND
  (exp_to_Cexp e3) (\ Ce3 . UNIT
  (CIf Ce1 Ce2 Ce3)))))
/\
(exp_to_Cexp (Mat e pes) = BIND
  (exp_to_Cexp e) (\ Ce . BIND
  (pes_to_Cpes pes) (\ Cpes . BIND
  (\ s . UNIT s.e2c_code_env s) (\ c .
  let v = fresh_var (Cpes_vars c Cpes) in BIND
  (remove_mat_var v Cpes) (\ Cpes . UNIT
  (CLet [v] [Ce] Cpes))))))
/\
(exp_to_Cexp (Let vn e b) = BIND
   (exp_to_Cexp e) (\ Ce . BIND
   (exp_to_Cexp b) (\ Cb . UNIT
   (CLet [vn] [Ce] Cb))))
/\
(exp_to_Cexp (Letrec defs b) = BIND
  (defs_to_Cdefs defs) (\ (fns,Cdefs) . BIND
  (exp_to_Cexp b) (\ Cb . UNIT
  (CLetfun T fns Cdefs Cb))))
/\
(defs_to_Cdefs [] = UNIT ([],[]))
/\
(defs_to_Cdefs ((d,vn,e)::defs) = BIND
  (e2c_bump) (\ n . BIND
  (exp_to_Cexp e) (\ Ce . IGNORE_BIND
  (e2c_add n Ce) (BIND
  (defs_to_Cdefs defs) (\ (fns,Cdefs) . UNIT
  (d::fns,([vn],n)::Cdefs))))))
/\
(pes_to_Cpes [] = UNIT [])
/\
(pes_to_Cpes ((p,e)::pes) = BIND
  (\ s . UNIT s.e2c_cmap s) (\ cmap .
  let (_pvs,Cp) = pat_to_Cpat cmap [] p in BIND
  (exp_to_Cexp e) (\ Ce . BIND
  (pes_to_Cpes pes) (\ Cpes . UNIT
  ((Cp,Ce)::Cpes)))))
/\
(exps_to_Cexps [] = UNIT [])
/\
(exps_to_Cexps (e::es) = BIND
  (exp_to_Cexp e) (\ e . BIND
  (exps_to_Cexps es) (\ es . UNIT
  (e::es))))`;

val _ = Defn.save_defn exp_to_Cexp_defn;

(* extract syntactic defs, to assist code_env construction *)

 val calculate_ldefs_defn = Hol_defn "calculate_ldefs" `
 (* including many uneta because Hol_defn sucks *)
(calculate_ldefs c ls (CDecl _) = ls)
/\
(calculate_ldefs c ls (CRaise _) = ls)
/\
(calculate_ldefs c ls (CVar _) = ls)
/\
(calculate_ldefs c ls (CLit _) = ls)
/\
(calculate_ldefs c ls (CCon _ es) =
  FOLDL (\ ls e . calculate_ldefs c ls e) ls es)
/\
(calculate_ldefs c ls (CTagEq e _) = calculate_ldefs c ls e)
/\
(calculate_ldefs c ls (CProj e _) = calculate_ldefs c ls e)
/\
(calculate_ldefs c ls (CLet _ es e) =
  FOLDL (\ ls e . calculate_ldefs c ls e) (calculate_ldefs c ls e) es)
/\
(calculate_ldefs c ls (CLetfun p ns defs e) =
  FOLDL
    (\ ls . \x . (case x of (_,l) =>
      (case FLOOKUP c l of NONE => [] (* should not happen *)
      | SOME e => calculate_ldefs ($\\ c l) ls e
      )))
    ((if p then ns else [],defs)
     ::calculate_ldefs c ls e)
    defs)
/\
(calculate_ldefs c ls (CFun xs l) =
  (case FLOOKUP c l of NONE => [] (* should not happen *)
  | SOME e => calculate_ldefs ($\\ c l) (([],[(xs,l)])::ls) e
  ))
/\
(calculate_ldefs c ls (CCall e es) =
  FOLDL (\ ls e . calculate_ldefs c ls e) (calculate_ldefs c ls e) es)
/\
(calculate_ldefs c ls (CPrim2 _ e1 e2) =
  calculate_ldefs c (calculate_ldefs c ls e1) e2)
/\
(calculate_ldefs c ls (CIf e1 e2 e3) =
  calculate_ldefs c (calculate_ldefs c (calculate_ldefs c ls e1) e2) e3)`;

val _ = Defn.save_defn calculate_ldefs_defn;

(* intermediate expressions to bytecode *)

(*open Bytecode*)

(* values in compile-time environment *)
val _ = Hol_datatype `
 ctbind = CTLet of num | CTArg of num | CTEnv of num | CTRef of num`;

(* CTLet n means stack[sz - n]
   CTArg n means stack[sz + n]
   CTEnv n means El n of the environment, which is at stack[sz]
   CTRef n means El n of the environment, but it's a ref pointer *)

val _ = Hol_datatype `
 call_context = TCNonTail | TCTail of num => num`;


val _ = type_abbrev( "ctenv" , ``: (string, ctbind) fmap``);

(* helper for reconstructing closure environments *)
val _ = Hol_datatype `
 cebind = CEEnv of string | CERef of num`;


val _ = type_abbrev( "ecs" , ``: num # cebind list``);

val _ = Hol_datatype `
 compiler_state =
  <| env: ctenv
   ; sz: num
   ; ecs: (num, ecs) fmap
   ; env_azs: (num, (ctenv # num)) fmap
   ; out: bc_inst list (* reversed code *)
   ; next_label: num
   ; tail: call_context
   (* not modified on return: *)
   ; decl: (ctenv # num)option
   |>`;


 val prim2_to_bc_defn = Hol_defn "prim2_to_bc" `

(prim2_to_bc CAdd = Add)
/\
(prim2_to_bc CSub = Sub)
/\
(prim2_to_bc CMul = Mult)
/\
(prim2_to_bc CDiv = Div)
/\
(prim2_to_bc CMod = Mod)
/\
(prim2_to_bc CLt = Less)
/\
(prim2_to_bc CEq = Equal)`;

val _ = Defn.save_defn prim2_to_bc_defn;

val _ = Define `
 emit = FOLDL (\ s i .  s with<| out := i :: s.out |>)`;


 val get_labels_defn = Hol_defn "get_labels" `

(get_labels n s = ( s with<| next_label := s.next_label + n |>,
                  GENLIST (\ i . s.next_label + i) n))`;

val _ = Defn.save_defn get_labels_defn;

 val compile_varref_defn = Hol_defn "compile_varref" `

(compile_varref s (CTLet n) = emit s [Stack (Load (s.sz - n))])
/\
(compile_varref s (CTArg n) = emit s [Stack (Load (s.sz + n))])
/\
(compile_varref s (CTEnv n) = emit s [Stack (Load s.sz); Stack (El n)])
/\
(compile_varref s (CTRef n) = emit (compile_varref s (CTEnv n)) [Deref])`;

val _ = Defn.save_defn compile_varref_defn;

val _ = Define `
 (incsz s =  s with<| sz := s.sz + 1 |>)`;

val _ = Define `
 (decsz s =  s with<| sz := s.sz - 1 |>)`;

val _ = Define `
 (sdt s = ( s with<| decl := NONE; tail := TCNonTail |>, (s.decl,s.tail)))`;

val _ = Define `
 (ldt (d,t) s =  s with<| decl := d; tail := t |>)`;


 val emit_ec_defn = Hol_defn "emit_ec" `

(emit_ec z s (CEEnv fv) = incsz (compile_varref s (FAPPLY  s.env  fv)))
/\
(emit_ec z s (CERef j) = incsz (emit s [Stack (Load (s.sz - z - j))]))`;

val _ = Defn.save_defn emit_ec_defn;

 val compile_closures_defn = Hol_defn "compile_closures" `

(compile_closures nz s defs =
  let sz0 = s.sz in
  let s = num_fold (\ s . incsz (emit s [Stack (PushInt i0); Ref])) s nz in
  let s = emit s [Stack (PushInt i0)] in
  let nk = LENGTH defs in
  let (s,labs) = get_labels nk s in
  let (s,k,ecs) = FOLDL
    (\ (s,k,ecs) (xs,l) .
      let lab = EL  k  labs in
      let s = incsz (
        emit s [Call (Lab lab);
                Jump (Lab l);
                Label lab]) in
      (s,k+1,(FAPPLY  s.ecs  l)::ecs))
    (s,0,[]) defs in
  let s = emit s [Stack Pop] in
  let (s,k) = FOLDL
    (\ (s,k) (j,ec) .
      let s = incsz (emit s [Stack (Load (nk - k))]) in
      let s = FOLDL (emit_ec sz0) s (REVERSE ec) in
      let s = emit s [Stack (if j = 0 then PushInt i0 else Cons 0 j)] in
      let s = emit s [Stack (Cons 0 2)] in
      let s = decsz (emit s [Stack (Store (nk - k))]) in
      let s =  s with<| sz := s.sz - j |> in
      (s,k+1))
    (s,1) (REVERSE ecs) in
  let (s,k) = num_fold
    (\ (s,k) .
      let s = emit s [Stack (Load (nk + nk - k))] in
      let s = emit s [Stack (Load (nk + 1 - k))] in
      let s = emit s [Update] in
      (s,k+1))
    (s,1) nz in
  let k = nk - 1 in
  num_fold
    (\ s . decsz (emit s [Stack (Store k)]))
         s nz)`;

val _ = Defn.save_defn compile_closures_defn;

  (* calling convention:
   * before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
   * thus, since env = stack[sz], argk should be CTArg (2 + n - k)
   * after:  retval,

this is out of date:
       PushInt 0, Ref
       ...            (* create RefPtrs for recursive closures *)
       PushInt 0, Ref                       RefPtr 0, ..., RefPtr 0, rest
       PushInt 0                            0, RefPtr 0, ..., RefPtr 0, rest
       Call L1                              0, CodePtr f1, RefPtr 0, ..., RefPtr 0, rest
       ?
       ...      (* function 1 body *)
       Pops ?   (* delete local variables and env *)
       Load 1
       Store n+2(* replace closure with return pointer *)
       Pops n+1 (* delete arguments *)
       Return
   L1: Call L2                              0, CodePtr f2, CodePtr f1, RefPtrs, rest
       ?
       ...      (* function 2 body *)
       Return
   L2: Call L3
       ?
       ...      (* more function bodies *)
   ...
       Return
   LK: Call L
       ...
       Return   (* end of last function *)
   L:  Pop                                  CodePtr fk, ..., CodePtr f1, RefPtrs, rest
       Load ?   (* copy code pointer for function 1 *)
       Load ?   (* copy free mutrec vars for function 1 *)
       Load ?   (* copy free vars for function 1 *)
       ...                                  vm1, ..., v1, RefPtr 0, ..., RefPtr 0, CodePtr f1, CodePtr fk, ..., CodePtr f1, RefPtrs, rest
       Cons 0 (m1 + n1)
       Cons 0 2                             Block 0 [CodePtr f1; Block 0 Env], CodePtr fk, ..., CodePtr f1, RefPtrs, rest
       Store ?                              CodePtr fk, ..., CodePtr f2, f1, RefPtrs, rest
       Load ?   (* copy code pointer for function 2 *)
       Load ?   (* copy free mutrec vars for function k-1 *)
       Load ?   (* copy free vars for function k-1 *)
       ...
       Cons 0 (m2 + n2)
       Cons 0 2                             
       Store ?                              CodePtr fk, ..., CodePtr f3, f2, f1, RefPtrs, rest
       ...                                  fk, ..., f2, f1, RefPtrs, rest
       Load ?
       Load 1                               fk, RefPtr 0, fk, f(k-1), ..., RefPtrs, rest
       Update                               fk, f(k-1), ..., f1, RefPtrs, rest
       Load ?
       Load 2
       Update
       ...      (* update RefPtrs with closures *)
       Store ?  (* pop RefPtrs *)           fk, f(k-1), ..., f1, rest
       ...
  *)
  (*
   * - push refptrs and leading 0
   * - for each function (in order), push a Call 0, remember the next label,
   *   calculate its environment, remember the environment, compile its body in
   *   that environment
   * - update Calls
   * - for each environment emit code to load that
   *   environment and build the closure
   * - update refptrs, etc.
   *)

 val compile_defn = Hol_defn "compile" `

(compile s (CDecl vs) =
  (case s.decl of SOME (env0,sz0) =>
  let sz1 = s.sz in
  let k = sz1 - sz0 in
  let (s,i,env) = FOLDL
    (\ (s,i,env) v .
      if  v IN FDOM  env0 then
        ((case FAPPLY  env0  v of
           CTLet x => emit (compile_varref s (FAPPLY  s.env  v))
                           [Stack (Store (s.sz - x))]
         | _ => emit s [Stack (PushInt i2); Exception] (* should not happen *)
         ), i, env)
      else
        (incsz (compile_varref s (FAPPLY  s.env  v)),
         i+1,
         FUPDATE  env ( v, (CTLet i))))
         (s,sz0+1,env0) vs in
  let s = emit s [Stack (Shift (i -(sz0+1)) k)] in
   s with<| sz := sz1+1; decl := SOME (env,s.sz - k) |>
  | NONE => emit s [Stack (PushInt i2); Exception] (* should not happen *)
  ))
/\
(compile s (CRaise err) =
  incsz (emit s [Stack (PushInt (error_to_int err)); Exception]))
/\
(compile s (CLit (IntLit i)) =
  incsz (emit s [Stack (PushInt i)]))
/\
(compile s (CLit (Bool b)) =
  incsz (emit s [Stack (PushInt (bool_to_int b))]))
/\
(compile s (CVar vn) = incsz (compile_varref s (FAPPLY  s.env  vn)))
/\
(compile s (CCon n es) =
  let z = s.sz + 1 in
  let (s,dt) = sdt s in
  let s = FOLDL (\ s e . compile s e) s es in (* uneta because Hol_defn sucks *)
  let s = emit (ldt dt s) [Stack (Cons n (LENGTH es))] in
   s with<| sz := z |>)
/\
(compile s (CTagEq e n) =
  let (s,dt) = sdt s in
  ldt dt (emit (compile s e) [Stack (TagEq n)]))
/\
(compile s (CProj e n) =
  let (s,dt) = sdt s in
  ldt dt (emit (compile s e) [Stack (El n)]))
/\
(compile s (CLet xs es e) =
  let z = s.sz + 1 in
  let (s,dt) = sdt s in
  let s = FOLDL (\ s e . compile s e) s es in (* uneta because Hol_defn sucks *)
  compile_bindings s.env z e 0 (ldt dt s) xs)
/\
(compile s (CLetfun recp ns defs e) =
  let z = s.sz + 1 in
  let s = compile_closures (if recp then LENGTH ns else 0) s defs in
  compile_bindings s.env z e 0 s ns)
/\
(compile s (CFun xs cb) =
  compile_closures 0 s [(xs,cb)])
/\
(compile s (CCall e es) =
  let n = LENGTH es in
  let t = s.tail in
  let (s,dt) = sdt s in
  let s = (case t of
    TCNonTail =>
    let s = compile s e in
    let s = FOLDL (\ s e . compile s e) s es in (* uneta because Hol_defn sucks *)
    (* argn, ..., arg2, arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [Stack (Load n); Stack (El 1)] in
    (* env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [Stack (Load (n+1)); Stack (El 0)] in
    (* CodePtr c, env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    emit s [CallPtr]
    (* before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    (* after:  retval, *)
(* does it make sense to distinguish this case?
  | TCTop sz0 ->
    let k = match s.decl with None -> s.sz - sz0 | Some _ -> 0 end in
    let n1 = 1+1+n+1 in
    let (i,s) = pad k n1 s in
    let s = compile s e in
    let s = List.fold_left (fun s e -> compile s e) s es in (* uneta because Hol_defn sucks *)
    (* argn, ..., arg1, Block 0 [CodePtr c; env], 0i, ..., 01, vk, ..., v1, *)
    let s = emit s [Stack (Load n); Stack (El 1)] in
    (* env, argn, ..., arg1, Block 0 [CodePtr c; env], 0i, ..., 01, vk, ..., v1, *)
    let s = emit s [Stack (Load (n+1)); Stack (El 0)] in
    (* CodePtr c, env, argn, ..., arg1, Block 0 [CodePtr c; env], 0i, ..., 01, vk, ..., v1, *)
    let s = mv (k+i) n1 s in
    (* CodePtr c, env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    emit s [CallPtr]
*)
  | TCTail j k =>
    let s = compile s e in
    let s = FOLDL (\ s e . compile s e) s es in (* uneta because Hol_defn sucks *)
    (* argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+1+k+1))] in
    (* CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+1)); Stack (El 1)] in
    (* env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+2)); Stack (El 0)] in
    (* CodePtr c, env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Shift (1+1+1+n+1) (k+1+1+j+1))] in
    emit s [JumpPtr]
  ) in
  ldt dt  s with<| sz := s.sz - n |>)
/\
(compile s (CPrim2 op e1 e2) =
  let (s,dt) = sdt s in
  let s = compile s e1 in
  let s = compile s e2 in (* TODO: need to detect div by zero *)
  decsz (ldt dt (emit s [Stack (prim2_to_bc op)])))
/\
(compile s (CIf e1 e2 e3) =
  let (s,dt) = sdt s in
  let s = ldt dt (compile s e1) in
  let (s,labs) = get_labels 3 s in
  let n0 = EL  0  labs in
  let n1 = EL  1  labs in
  let n2 = EL  2  labs in
  let s = emit s [(JumpNil (Lab n0)); (Jump (Lab n1)); Label n0] in
  let s = compile (decsz s) e2 in
  let s = emit s [(Jump (Lab n2)); Label n1] in
  let s = compile (decsz s) e3 in
  emit s [Label n2])
/\
(compile_bindings env0 sz1 e n s [] =
  let s = (case s.tail of
    TCTail j k => compile ( s with<| tail := TCTail j (k+n) |>) e
  | TCNonTail => (case s.decl of
      NONE => emit (compile s e) [Stack (Pops n)]
    | SOME _ => compile s e
    )
  ) in
   s with<| env := env0 ; sz := sz1 |>)
/\
(compile_bindings env0 sz1 e n s (x::xs) =
  compile_bindings env0 sz1 e
    (n+1) (* parentheses below because Lem sucks *)
    ( s with<| env := FUPDATE  s.env ( x, (CTLet (sz1 + n))) |>)
    xs)`;

val _ = Defn.save_defn compile_defn;

(* code env to bytecode *)

 val bind_fv_defn = Hol_defn "bind_fv" `

(bind_fv ns xs az k fv (n,env,(ecl,ec)) =
  (case find_index fv xs 1 of
    SOME j => (n, FUPDATE  env ( fv, (CTArg (2 + az - j))), (ecl,ec))
  | NONE => (case find_index fv ns 0 of
      NONE => (n+1, FUPDATE  env ( fv, (CTEnv n)), (ecl+1,CEEnv fv::ec))
    | SOME j => if j = k
                then (n, FUPDATE  env ( fv, (CTArg (2 + az))), (ecl,ec))
                else (n+1, FUPDATE  env ( fv, (CTRef n)), (ecl+1,(CERef (j+1))::ec))
    )
  ))`;

val _ = Defn.save_defn bind_fv_defn;

 val calculate_ecs_defn = Hol_defn "calculate_ecs" `

(calculate_ecs c =
  FOLDL
    (\ s (ns,defs) .
      let (s,k) = FOLDL
        (\ (s,k) (xs,l) .
          let az = LENGTH xs in
          let (n,env,(ecl,ec)) =
            ITSET (bind_fv ns xs az k) (free_vars c (FAPPLY  c  l)) (0,FEMPTY,(0,[])) in
          let s =  s with<|
                     env_azs := FUPDATE  s.env_azs ( l, (env,az))
                   ; ecs := FUPDATE  s.ecs ( l, (ecl,ec))
                   |> in
          (s,k+1))
        (s,0) defs in
      s))`;

val _ = Defn.save_defn calculate_ecs_defn;

 val cce_aux_defn = Hol_defn "cce_aux" `

(cce_aux c s (ns,defs) =
  let (s,k) = FOLDL
    (\ (s,k) (xs,l) .
      let (env,az) = FAPPLY  s.env_azs  l in
      let s = emit s [Label l] in
      let s' =  s with<| env := env; sz := 0; tail := TCTail az 0 |> in
      let s' = compile s' (FAPPLY  c  l) in
      let n = (case s'.tail of TCNonTail => 1 | TCTail j k => k+1 ) in
      let s' = emit s' [Stack (Pops n);
                        Stack (Load 1);
                        Stack (Store (az+2));
                        Stack (Pops (az+1));
                        Return] in
      let s =  s' with<| env := s.env; sz := s.sz; tail := s.tail |> in
      (s,k+1))
    (s,0) defs in
  s)`;

val _ = Defn.save_defn cce_aux_defn;

 val compile_code_env_defn = Hol_defn "compile_code_env" `

(compile_code_env c s ldefs =
  let (s,ls) = get_labels 1 s in
  let l = EL  0  ls in
  let s = emit s [Jump (Lab l)] in
  let s = FOLDL (cce_aux c) s ldefs in
  emit s [Label l])`;

val _ = Defn.save_defn compile_code_env_defn;

(* replace labels in bytecode with addresses *)

(* runtime type information, for repl *)

val _ = Hol_datatype `
 nt =
    NTvar of num
  | NTapp of nt list => typeN
  | NTfn
  | NTnum
  | NTbool`;


 val t_to_nt_defn = Hol_defn "t_to_nt" `

(t_to_nt a (Tvar x) = (case find_index x a 0 of SOME n => NTvar n ))
/\
(t_to_nt a (Tapp ts tn) = NTapp (MAP (t_to_nt a) ts) tn)
/\
(t_to_nt a (Tfn _ _) = NTfn)
/\
(t_to_nt a Tnum = NTnum)
/\
(t_to_nt a Tbool = NTbool)`;

val _ = Defn.save_defn t_to_nt_defn;

val _ = Hol_datatype `
 repl_state =
  <| cmap : (conN, num) fmap
   ; cpam : (typeN, ( (num, (conN # nt list))fmap)) fmap
   ; code : bc_inst list
   ; renv : ctenv
   ; rsz  : num
   ; next_addr : num
   ; inst_length : bc_inst -> num
   |>`;


 val calculate_labels_defn = Hol_defn "calculate_labels" `

(calculate_labels il m n a [] = (m,n,a))
/\
(calculate_labels il m n a (Label l::lbc) =
  calculate_labels il (FUPDATE  m ( l, n)) n a lbc)
/\
(calculate_labels il m n a (i::lbc) =
  calculate_labels il m (n + il i + 1) (i::a) lbc)`;

val _ = Defn.save_defn calculate_labels_defn;

 val replace_labels_defn = Hol_defn "replace_labels" `

(replace_labels m a [] = a)
/\
(replace_labels m a (Jump (Lab l)::bc) =
  replace_labels m (Jump (Addr (FAPPLY  m  l))::a) bc)
/\
(replace_labels m a (JumpNil (Lab l)::bc) =
  replace_labels m (JumpNil (Addr (FAPPLY  m  l))::a) bc)
/\
(replace_labels m a (Call (Lab l)::bc) =
  replace_labels m (Call (Addr (FAPPLY  m  l))::a) bc)
/\
(replace_labels m a (i::bc) =
  replace_labels m (i::a) bc)`;

val _ = Defn.save_defn replace_labels_defn;

 val compile_labels_defn = Hol_defn "compile_labels" `

(compile_labels rs lbc =
  let (m,n,bc) = calculate_labels rs.inst_length FEMPTY rs.next_addr [] lbc in
   rs with<| code := replace_labels m [] bc ; next_addr := n |>)`;

val _ = Defn.save_defn compile_labels_defn;

(* repl *)

val _ = Define `
 init_repl_state =
  <| cmap := FEMPTY
   ; cpam := FEMPTY
   ; code := []
   ; renv := FEMPTY
   ; rsz  := 0
   ; next_addr := 0
   ; inst_length := \ i . 0
   |>`;


val _ = Define `
 (compile_Cexp rs decl s Ce =
  let c = s.e2c_code_env in
  let ldefs = calculate_ldefs c [] Ce in
  let cs = <| env := rs.renv; sz := rs.rsz
            ; ecs := FEMPTY; env_azs := FEMPTY
            ; out := []; next_label := s.e2c_next_label
            ; tail := TCNonTail; decl := decl |> in
  let cs = calculate_ecs c cs ldefs in
  let cs = compile_code_env c cs ldefs in
  let cs =  cs with<| env_azs := FEMPTY |> in
  let cs = compile cs Ce in
  let rs = (case cs.decl of
      NONE => rs
    | SOME (env,sz) =>  rs with<| renv := env ; rsz := sz |>
    ) in
  compile_labels rs (REVERSE cs.out))`;


 val number_constructors_defn = Hol_defn "number_constructors" `

(number_constructors a (cm,cw) n [] = (cm,cw))
/\
(number_constructors a (cm,cw) n ((c,tys)::cs) =
  let cm' = FUPDATE  cm ( c, n) in
  let cw' = FUPDATE  cw ( n, (c, MAP (t_to_nt a) tys)) in
  number_constructors a (cm',cw') (n+1) cs)`;

val _ = Defn.save_defn number_constructors_defn;

val _ = Define `
 (mk_e2c_state rs =
  <| e2c_next_label := 0
   ; e2c_code_env := FEMPTY
   ; e2c_cmap := rs.cmap
   |>)`;


 val repl_dec_defn = Hol_defn "repl_dec" `

(repl_dec rs (Dtype []) =  rs with<| code := [] |>)
/\
(repl_dec rs (Dtype ((a,ty,cs)::ts)) =
  let (cm,cw) = number_constructors a (rs.cmap,FEMPTY) 0 cs in
  repl_dec ( rs with<| cmap := cm; cpam := FUPDATE  rs.cpam ( ty, cw) |>) (Dtype ts)) (* parens: Lem sucks *)
/\
(repl_dec rs (Dletrec defs) =
  let s = mk_e2c_state rs in
  let ((fns,Cdefs),s) = defs_to_Cdefs defs s in
  let decl = SOME(rs.renv,rs.rsz) in
  compile_Cexp rs decl s (CLetfun T fns Cdefs (CDecl fns)))
/\
(repl_dec rs (Dlet p e) =
  let (pvs,Cp) = pat_to_Cpat rs.cmap [] p in
  let Cpes = [(Cp,CDecl pvs)] in
  let vn = fresh_var (Cpes_vars FEMPTY Cpes) in
  let s = mk_e2c_state rs in
  let (Ce,s) = exp_to_Cexp e s in
  let (Cpes,s) = remove_mat_var vn Cpes s in
  let decl = SOME(rs.renv,rs.rsz) in
  compile_Cexp rs decl s (CLet [vn] [Ce] Cpes))`;

val _ = Defn.save_defn repl_dec_defn;

val _ = Define `
 (repl_exp rs exp =
  let s = mk_e2c_state rs in
  let (Ce,s) = exp_to_Cexp exp s in
  compile_Cexp rs NONE s Ce)`;


(* Correctness *)

(* observable values *)

val _ = Hol_datatype `
 ov =
    OLit of lit
  | OConv of conN => ov list
  | OFn`;


 val v_to_ov_defn = Hol_defn "v_to_ov" `

(v_to_ov (Litv l) = OLit l)
/\
(v_to_ov (Conv cn vs) = OConv cn (MAP v_to_ov vs))
/\
(v_to_ov (Closure _ _ _) = OFn)
/\
(v_to_ov (Recclosure _ _ _) = OFn)`;

val _ = Defn.save_defn v_to_ov_defn;

 val Cv_to_ov_defn = Hol_defn "Cv_to_ov" `

(Cv_to_ov m (CLitv l) = OLit l)
/\
(Cv_to_ov m (CConv cn vs) = OConv (FAPPLY  m  cn) (MAP (Cv_to_ov m) vs))
/\
(Cv_to_ov m (CRecClos _ _ _ _) = OFn)`;

val _ = Defn.save_defn Cv_to_ov_defn;

val _ = Define `
 (lookup_conv_ty m ty n = FAPPLY  (FAPPLY  m  ty)  n)`;


 val inst_arg_defn = Hol_defn "inst_arg" `

(inst_arg tvs (NTvar n) = EL  n  tvs)
/\
(inst_arg tvs (NTapp ts tn) = NTapp (MAP (inst_arg tvs) ts) tn)
/\
(inst_arg tvs tt = tt)`;

val _ = Defn.save_defn inst_arg_defn;

 val bv_to_ov_defn = Hol_defn "bv_to_ov" `

(bv_to_ov m NTnum (Number i) = OLit (IntLit i))
/\
(bv_to_ov m NTbool (Number i) = OLit (Bool (num_to_bool (Num i))))
/\
(bv_to_ov m (NTapp _ ty) (Number i) =
  OConv (FST (lookup_conv_ty m ty (Num i))) [])
/\
(bv_to_ov m (NTapp tvs ty) (Block n vs) =
  let (tag, args) = lookup_conv_ty m ty n in
  let args = MAP (inst_arg tvs) args in
  OConv tag (MAP2 (\ ty v . bv_to_ov m ty v) args vs)) (* uneta: Hol_defn sucks *)
/\
(bv_to_ov m NTfn (Block 0 _) = OFn)`;

val _ = Defn.save_defn bv_to_ov_defn;

(* source to intermediate values *)

 val v_to_Cv_defn = Hol_defn "v_to_Cv" `

(v_to_Cv (Litv l) = UNIT (CLitv l))
/\
(v_to_Cv (Conv cn vs) = BIND
  (vs_to_Cvs vs) (\ Cvs . BIND
  (\ s . UNIT s.e2c_cmap s) (\ cmap . UNIT
  (CConv (FAPPLY  cmap  cn) Cvs))))
/\
(v_to_Cv (Closure env vn e) = BIND
  (env_to_Cenv env) (\ Cenv . BIND
  (e2c_bump) (\ n . BIND
  (exp_to_Cexp e) (\ Ce . IGNORE_BIND
  (e2c_add n Ce) (BIND
  (\ s . UNIT s.e2c_code_env s) (\ c .
  let fn = fresh_var (free_vars c Ce) in UNIT
  (CRecClos (alist_to_fmap Cenv) [fn] [([vn],n)] fn)))))))
/\
(v_to_Cv (Recclosure env defs fn) = BIND
  (env_to_Cenv env) (\ Cenv . BIND
  (defs_to_Cdefs defs) (\ (fns,Cdefs) . UNIT
  (CRecClos (alist_to_fmap Cenv) fns Cdefs fn))))
/\
(vs_to_Cvs [] = UNIT [])
/\
(vs_to_Cvs (v::vs) = BIND
  (v_to_Cv v) (\ Cv . BIND
  (vs_to_Cvs vs) (\ Cvs . UNIT
  (Cv::Cvs))))
/\
(env_to_Cenv [] = UNIT [])
/\
(env_to_Cenv ((x,v)::env) = BIND
  (v_to_Cv v) (\ Cv . BIND
  (env_to_Cenv env) (\ Cenv . UNIT
  ((x,Cv)::Cenv))))`;

val _ = Defn.save_defn v_to_Cv_defn;

(* intermediate to target values *)

(*
let rec
Cv_to_bv (CLitv (IntLit i)) = Number i
and
Cv_to_bv (CLitv (Bool b)) = Number (bool_to_int b)
and
Cv_to_bv (CConv n vs) = Block n (Cvs_to_bvs vs)
and
Cv_to_bv (CClosure env vs b) = Block 0 [CodePtr ?, ?]
and
Cv_to_bv (CRecClos env ns defs n) = Block 0 [CodePtr ?, ?]
and
Cvs_to_bvs [] = []
and
Cvs_to_bvs (v::vs) = Cv_to_bv v :: Cvs_to_bvs vs
*)

(*
indreln
forall il c cc.
true
==>
bc_code_prefix il (List.append c cc) 0 c
and
forall il p i c cc.
bc_code_prefix il cc p c
==>
bc_code_prefix il (i::cc) (p + il i) c

let rec
body_cs env xs =
  <| env = env; sz = 0; out = []; next_label = 0;
     tail = TCTail (List.length xs) 0; decl = None |>

let rec
body_env ns xs j fvs =
  let (n,env,(nec,ec)) =
    Set.fold (bind_fv ns xs (List.length xs) j) fvs (0,Pmap.empty,(0,[])) in
  (env,ec)

indreln
forall il c i.
true
==>
bceqv il c (CLitv (IntLit i)) (Number i)
and
forall il c b.
true
==>
bceqv il c (CLitv (Bool b)) (Number (bool_to_int b))
and
forall il c n vs bvs.
every2 (bceqv il c) vs bvs
==>
bceqv il c (CConv n vs) (Block n bvs)
and
forall il c env ns defs n j xs e cenv ec f bvs.
find_index n ns 0 = Some j &&
List.nth defs j = (xs,e) &&
(cenv,ec) = body_env ns xs j (free_vars Pmap.empty e) &&
List.length bvs = List.length ec &&
(forall i. i < List.length ec -->
    (exists fv. List.nth ec i = CEEnv fv &&
                bceqv il c (Pmap.find fv env) (List.nth bvs i)) ||
    (exists k kxs ke kenv kec g.
        List.nth ec i = CERef k &&
        List.nth defs k = (kxs,ke) &&
        (kenv,kec) = body_env ns xs k (free_vars ke) &&
        bc_code_prefix il c g
          (List.rev (compile (body_cs kenv kxs) ke).out))) &&
bc_code_prefix il c f (List.rev (compile (body_cs cenv xs) e).out)
==>
bceqv il c (CRecClos env ns defs n)
  (Block 0 [CodePtr f; if bvs = [] then Number i0 else Block 0 bvs])
*)


(* relating source to intermediate language *)

(*
indreln
forall m c l.
true
==>
v_Cv m c (Litv l) (CLitv l)
and
forall m c cn vs Cvs.
every2 (v_Cv m c) vs Cvs
==>
v_Cv m c (Conv cn vs) (CConv (Pmap.find cn m) Cvs)
and
forall m c env vn e fn l.
env_Cenv m c env Cenv &&

==>
v_Cv m c (Closure env vn e) (CRecClos Cenv [fn] [([vn],l)] fn)
and
==>
v_Cv m c (Recclosure env defs fn) (CRecClos Cenv fns Cdefs fn)
and
forall c env1 env2 ns defs d.
List.for_all
  (fun (xs,b) ->
    (forall v. v IN (cbod_fvs c b \ (Set.from_list ns union
                                     Set.from_list xs))
      --> (optrel (syneq c)) (flookup env1 v) (flookup env2 v)))
  defs
==>
v_Cv m c (CRecClos env1 ns defs d) (CRecClos env2 ns defs d)
*)

(*
indreln
forall G cm env Cenv err.
true
==>
exp_Cexp G cm env Cenv (Raise err) (CRaise err)
and
forall G cm env Cenv l.
true
==>
exp_Cexp G cm env Cenv (Lit l) (CLit l)
and
forall G cm env Cenv cn es Ces.
Pmap.mem cn cm &&
every2 (exp_Cexp G cm env Cenv) es Ces
==>
exp_Cexp G cm env Cenv (Con cn es) (CCon (Pmap.find cn cm) Ces)
and
forall G cm env Cenv vn v Cvn.
lookup vn env = Some v &&
Pmap.mem Cvn Cenv &&
G cm v (Pmap.find Cvn Cenv)
==>
exp_Cexp G cm env Cenv (Var vn) (CVar Cvn)
and
forall G cm env Cenv vn e n Ce.
(forall v Cv. G cm v Cv -->
  exp_Cexp G cm (bind vn v env) (Pmap.add n Cv Cenv) e Ce)
==>
exp_Cexp G cm env Cenv (Fun vn e) (CFun [n] Ce)

indreln
forall G cm l.
true
==>
v_Cv G cm (Litv l) (CLitv l)
and
forall G cm cn vs Cvs.
Pmap.mem cn cm &&
every2 (v_Cv G cm) vs Cvs
==>
v_Cv G cm (Conv cn vs) (CConv (Pmap.find cn cm) Cvs)
*)

(*
indreln
forall cm env Cenv err.
true
==>
exp_Cexp cm env Cenv (Raise err) (CRaise err)
and
forall cm env Cenv v Cv.
v_Cv cm v Cv
==>
exp_Cexp cm env Cenv (Val v) (CVal Cv)
and
forall cm env Cenv cn es Ces.
every2 (exp_Cexp cm env Cenv) es Ces
==>
exp_Cexp cm env Cenv (Con cn es) (CCon (Pmap.find cn cm) Ces)
and
forall cm env Cenv vn v Cvn Cv.
lookup vn env = Some v &&
Pmap.mem Cvn Cenv && Pmap.find Cvn Cenv = Cv && (* TODO: lookup *)
v_Cv cm v Cv
==>
exp_Cexp cm env Cenv (Var vn) (CVar Cvn)
and
forall cm env Cenv vn e n Ce.
(* but what to do here without a context of equal variables? *)
(* (see comments in v_Cv below) *)
==>
exp_Cexp cm env Cenv (Fun vn e) (CFun n Ce)
and
forall cm l.
true
==>
v_Cv cm (Lit l) (CLit l)
and
forall cm cn vs Cvs.
every2 (v_Cv cm) vs Cvs
==>
v_Cv cm (Conv cn vs) (CConv (Pmap.find cn cm) Cvs)
and
forall cm env vn e Cenv n Ce.
(* can't do this because it's a negative occurrence of v_Cv,
 * leading to a non-monotonic rule
(forall v Cv. v_Cv cm v Cv -->
 exp_Cexp cm (bind vn v env) (Pmap.add n Cv (alist_to_fmap Cenv)) e Ce)
*)
(* obviously this is incorrect (requires the functions to be equivalent on
 * arbitrary pairs of arguments)
 * options for extension include:
   * normal form (open): use the same free variable as the argument
     * but does this distinguish too many pairs of terms?
   * carry around a context of equal values/variables
     * but how does this relate with the environments in closures?
     * probably just have to have both independently
   * parameterise by a "global knowledge" relation of equal values *)
(forall v Cv. exp_Cexp cm (bind vn v env) (Pmap.add n Cv (alist_to_fmap Cenv)) e Ce)
==>
v_Cv cm (Closure env vn e) (CClosure Cenv [n] Ce)
*)

(*
let rec
Cv_to_bv (CLitv (IntLit i)) = Number i
and
Cv_to_bv (CLitv (Bool b)) = Number (bool_to_int b)
and
Cv_to_bv (CConv n vs) = Block n (Cvs_to_bvs vs)
and
Cv_to_bv (CClosure env vs b) = Block 0 [CodePtr ?, ?]
and
Cv_to_bv (CRecClos env ns defs n) = Block 0 [CodePtr ?, ?]
and
Cvs_to_bvs [] = []
and
Cvs_to_bvs (v::vs) = Cv_to_bv v :: Cvs_to_bvs vs
*)
val _ = export_theory()

