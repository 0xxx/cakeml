(*Generated by Lem from compile.lem.*)
open bossLib Theory Parse res_quanTheory
open fixedPointTheory finite_mapTheory listTheory pairTheory pred_setTheory
open integerTheory set_relationTheory sortingTheory stringTheory wordsTheory

val _ = numLib.prefer_num();



open BytecodeTheory MiniMLTheory

val _ = new_theory "Compile"

(* TODO: compile Raise and Handle properly; requires changes to bytecode *)
(* TODO: simple type system and checker *)
(* TODO: map_Cexp? *)
(* TODO: use Pmap.peek instead of mem when it becomes available *)
(* TODO: collapse nested functions *)
(* TODO: collapse nested lets *)
(* TODO: Letfun introduction and reordering *)
(* TODO: let floating *)
(* TODO: removal of redundant expressions *)
(* TODO: simplification (e.g., constant folding) *)
(* TODO: avoid Shifts when possible *)
(* TODO: registers, register allocation, greedy shuffling? *)
(* TODO: bytecode optimizer: repeated Pops, unreachable code (e.g. after a Jump) *)
(* TODO: more efficient pattern-matching method? *)
(* TODO: store type information on CMat nodes (for pattern matching compilation) *)
(* TODO: typechecking *)
(* TODO: printing *)

(* TODO: move to lem *)
(*val fold_left2 : forall 'a 'b 'c. ('a -> 'b -> 'c -> 'a) -> 'a -> list 'b -> list 'c -> 'a*)
(* TODO: lem library should use this for List.for_all2 *)
(*val every2 : forall 'a 'b. ('a -> 'b -> bool) -> list 'a -> list 'b -> bool*)
(*val least : (num -> bool) -> num*)
(*val num_to_string : num -> string*)
(*val int_to_num : int -> num*)
(*val alist_to_fmap : forall 'a 'b. list ('a * 'b) -> Pmap.map 'a 'b*)
(*val optrel : forall 'a 'b 'c 'd. ('a -> 'b -> bool) -> 'c -> 'd -> bool*)
(*val flookup : forall 'a 'b 'c. Pmap.map 'a 'b -> 'a -> 'c*)
(*val fdom : forall 'a 'b. Pmap.map 'a 'b -> set 'a*)
(*val domsub : forall 'a 'b. Pmap.map 'a 'b -> 'a -> Pmap.map 'a 'b*)
(*val genlist : forall 'a. (num -> 'a) -> num -> list 'a*)
(*open MiniML*)
(*val return : forall 'a 'b. 'a -> 'b -> 'a * 'b*)
(*val bind : forall 'a 'b 'c. ('a -> 'b * 'a) -> ('b -> 'a -> 'c * 'a) -> 'a -> 'c * 'a*)
(*val ubind : forall 'a 'b 'c. ('a -> 'b * 'a) -> ('a -> 'c * 'a) -> 'a -> 'c * 'a*)

(* TODO: Misc. helpers *)

 val find_index_defn = Hol_defn "find_index" `

(find_index y [] _ = NONE)
/\
(find_index y (x::xs) n = if x = y then SOME n else find_index y xs (n +1))`;

val _ = Defn.save_defn find_index_defn;

val _ = Define `
 (fresh_var s = num_to_hex_string ( LEAST (\ n . ~  ( num_to_hex_string n IN s))))`;


 val num_fold_defn = Hol_defn "num_fold" `
 (num_fold f a n = if n = 0 then a else num_fold f (f a) (n - 1))`;

val _ = Defn.save_defn num_fold_defn;

 val map_result_def = Define `

(map_result f (Rval v) = Rval (f v))
/\
(map_result f (Rerr e) = Rerr e)`;


 val every_result_def = Define `

(every_result  P (Rerr _) = T)
/\
(every_result P (Rval v) = P v)`;


val _ = Define `
 i0 = int_of_num 0`;

val _ = Define `
 i1 = int_of_num 1`;

val _ = Define `
 i2 = int_of_num 2`;


 val error_to_int_def = Define `

(error_to_int Bind_error = i0)
/\
(error_to_int Div_error = i1)
/\
(error_to_int (Int_error n) = int_add i2 n)`;


 val num_to_bool_def = Define `

(num_to_bool 0 = F)
/\
(num_to_bool (SUC 0) = T)`;


(* Intermediate language for MiniML compiler *)

(* Syntax *)
(* (real definitions in CexpTypesTheory) *)
val _ = Hol_datatype `
 (+0) = INL0 of 'a | INR0 of 'b`;
 (* TODO: move to lem *)

(* pure applicative primitives with bytecode counterparts *)
val _ = Hol_datatype `
 Cprim1 = CRef | CDer`;

val _ = Hol_datatype `
 Cprim2 = CAdd | CSub | CMul | CDiv | CMod | CLt | CEq`;


val _ = Hol_datatype `
 Cpat =
    CPvar of string
  | CPlit of lit
  | CPcon of num => Cpat list
  | CPref of Cpat`;


val _ = Hol_datatype `
 Cexp =
    CDecl of string list
  | CRaise of error
  | CHandle of Cexp => string => Cexp
  | CVar of string
  | CLit of lit
  | CCon of num => Cexp list
  | CTagEq of Cexp => num
  | CProj of Cexp => num
  | CLet of string => Cexp => Cexp
  | CLetrec of string list => ( string list # ( (Cexp, num)+0)) list => Cexp
  | CFun of string list => ( (Cexp, num)+0)
  | CCall of Cexp => Cexp list
  | CPrim1 of Cprim1 => Cexp
  | CPrim2 of Cprim2 => Cexp => Cexp
  | CUpd of Cexp => Cexp
  | CIf of Cexp => Cexp => Cexp`;


val _ = type_abbrev( "def" , ``: string list # ( (Cexp, num)+0)``);

val _ = Hol_datatype `
 Cv =
    CLitv of lit
  | CConv of num => Cv list
  | CRecClos of (string, Cv)fmap => string list => def list => string
  | CLoc of num`;


(* Semantics *)

 val Cpat_vars_defn = Hol_defn "Cpat_vars" `

(Cpat_vars (CPvar n) = {n})
/\
(Cpat_vars (CPlit _) = {})
/\
(Cpat_vars (CPcon _ ps) = FOLDL (\ s p . s UNION Cpat_vars p) {} ps)
/\
(Cpat_vars (CPref p) = Cpat_vars p)`;

val _ = Defn.save_defn Cpat_vars_defn;

 val free_vars_defn = Hol_defn "free_vars" `

(free_vars _ (CDecl xs) = LIST_TO_SET xs)
/\
(free_vars _ (CRaise _) = {})
/\
(free_vars c (CHandle e1 x e2) = free_vars c e1 UNION (free_vars c e2 DIFF {x}))
/\
(free_vars _ (CVar n) = {n})
/\
(free_vars _ (CLit _) = {})
/\
(free_vars c (CCon _ es) = FOLDL (\ s e . s UNION free_vars c e) {} es)
/\
(free_vars c (CTagEq e _) = free_vars c e)
/\
(free_vars c (CProj e _) = free_vars c e)
/\
(free_vars c (CLet x e eb) =
  free_vars c e UNION (free_vars c eb DIFF {x}))
/\
(free_vars c (CLetrec ns defs e) = FOLDL (\ s (vs,b) .
    s UNION (cbod_fvs c b DIFF ( LIST_TO_SET ns UNION LIST_TO_SET vs)))
  (free_vars c e DIFF LIST_TO_SET ns) defs)
/\
(free_vars c (CFun xs b) = cbod_fvs c b DIFF ( LIST_TO_SET xs))
/\
(free_vars c (CCall e es) = FOLDL (\ s e . s UNION free_vars c e)
  (free_vars c e) es)
/\
(free_vars c (CPrim1 _ e) = free_vars c e)
/\
(free_vars c (CPrim2 _ e1 e2) = free_vars c e1 UNION free_vars c e2)
/\
(free_vars c (CUpd e1 e2) = free_vars c e1 UNION free_vars c e2)
/\
(free_vars c (CIf e1 e2 e3) = free_vars c e1 UNION free_vars c e2 UNION free_vars c e3)
/\
(cbod_fvs c (INL0 e) = free_vars c e)
/\
(cbod_fvs c (INR0 l) = (case FLOOKUP c l of
    NONE => {}
  | SOME e => free_vars ( DOMSUB c l) e
  ))`;

val _ = Defn.save_defn free_vars_defn;

(* Big-step semantics *)

 val no_closures_defn = Hol_defn "no_closures" `

(no_closures (CLitv _) = T)
/\
(no_closures (CConv _ vs) = EVERY no_closures vs)
/\
(no_closures (CRecClos _ _ _ _) = F)`;

val _ = Defn.save_defn no_closures_defn;

 val doPrim2_def = Define `

(doPrim2 b ty op (CLitv (IntLit x)) (CLitv (IntLit y)) =
  if b /\ (y = i0) then Rerr (Rraise Div_error)
  else Rval (CLitv (ty (op x y))))
/\
(doPrim2 b ty op _ _ = Rerr Rtype_error)`;


 val CevalPrim2_def = Define `

(CevalPrim2 CAdd = doPrim2 F IntLit int_add)
/\
(CevalPrim2 CSub = doPrim2 F IntLit (int_sub))
/\
(CevalPrim2 CMul = doPrim2 F IntLit int_mul)
/\
(CevalPrim2 CDiv = doPrim2 T IntLit int_div)
/\
(CevalPrim2 CMod = doPrim2 T IntLit int_mod)
/\
(CevalPrim2 CLt = doPrim2 F Bool int_lt)
/\
(CevalPrim2 CEq = \ v1 v2 .
  if no_closures v1 /\ no_closures v2
  then Rval (CLitv (Bool (v1 = v2)))
  else Rerr Rtype_error)`;


 val CevalUpd_def = Define `

(CevalUpd s (CLoc n) (v:Cv) =
  if  n IN FDOM  s
  then ( FUPDATE  s ( n, v), Rval (CLitv Unit))
  else (s, Rerr Rtype_error))
/\
(CevalUpd s _ _ = (s, Rerr Rtype_error))`;


 val CevalPrim1_def = Define `

(CevalPrim1 CRef s v =
  let n = LEAST (\ n . ~  ( n IN FDOM  s)) in
  ( FUPDATE  s ( n, v), Rval (CLoc n)))
/\
(CevalPrim1 CDer s (CLoc n) =
  (s, (case FLOOKUP s n of
        NONE => Rerr Rtype_error
      | SOME v => Rval v
      )))
/\
(CevalPrim1 _ s _ = (s, Rerr Rtype_error))`;


val _ = Define `
 (extend_rec_env cenv env rs defs ns vs =
  (* TODO: LEM internal error:
  List.fold_left (fun a -> Hol.UNCURRY (f a)) a (List.combine lb lc)
  *)
  (* TODO: LEM internal error:
  List.fold_left (fun a (b,c) -> f a b c) a (List.combine lb lc)
  *)
  FOLDL2  (\ en n v . FUPDATE  en ( n, v)) 
    ( FOLDL
        (\ en n . FUPDATE  en ( n,
          (CRecClos cenv rs defs n)))
        env
        rs) 
    ns  vs)`;


val _ = Hol_reln `
(! c d s env error.
T
==>
Cevaluate c d s env (CRaise error) (s, Rerr (Rraise error)))

/\
(! c d s1 env e1 x e2 s2 v.
Cevaluate c d s1 env e1 (s2, Rval v)
==>
Cevaluate c d s1 env (CHandle e1 x e2) (s2, Rval v))
/\
(! c d s1 env e1 x e2 s2 n res.
Cevaluate c d s1 env e1 (s2, Rerr (Rraise (Int_error n))) /\
Cevaluate c d s2 ( FUPDATE  env ( x, (CLitv (IntLit n)))) e2 res
==>
Cevaluate c d s1 env (CHandle e1 x e2) res)
/\
(! c d s1 env e1 x e2 s2 err.
Cevaluate c d s1 env e1 (s2, Rerr err) /\
(! n. ~  (err = Rraise (Int_error n)))
==>
Cevaluate c d s1 env (CHandle e1 x e2) (s2, Rerr err))

/\
(! c d s env n.
 n IN FDOM  env
==>
Cevaluate c d s env (CVar n) (s, Rval ( FAPPLY  env  n)))

/\
(! c d s env l.
T
==>
Cevaluate c d s env (CLit l) (s, Rval (CLitv l)))

/\
(! c d s env n es s' vs.
Cevaluate_list c d s env es (s', Rval vs)
==>
Cevaluate c d s env (CCon n es) (s', Rval (CConv n vs)))
/\
(! c d s env n es s' err.
Cevaluate_list c d s env es (s', Rerr err)
==>
Cevaluate c d s env (CCon n es) (s', Rerr err))

/\
(! c d s env e n m s' vs.
Cevaluate c d s env e (s', Rval (CConv m vs))
==>
Cevaluate c d s env (CTagEq e n) (s', Rval (CLitv (Bool (n = m)))))
/\
(! c d s env e n s' err.
Cevaluate c d s env e (s', Rerr err)
==>
Cevaluate c d s env (CTagEq e n) (s', Rerr err))

/\
(! c d s env e n m s' vs.
Cevaluate c d s env e (s', Rval (CConv m vs)) /\
n < LENGTH vs
==>
Cevaluate c d s env (CProj e n) (s', Rval ( EL  n  vs)))
/\
(! c d s env e n s' err.
Cevaluate c d s env e (s', Rerr err)
==>
Cevaluate c d s env (CProj e n) (s', Rerr err))

/\
(! c d s env n e b s' v r.
Cevaluate c d s env e (s', Rval v) /\
Cevaluate c d s' ( FUPDATE  env ( n, v)) b r
==>
Cevaluate c d s env (CLet n e b) r)
/\
(! c d s env n e b s' err.
Cevaluate c d s env e (s', Rerr err)
==>
Cevaluate c d s env (CLet n e b) (s', Rerr err))

/\
(! c d s env ns defs b r. ( LENGTH ns = LENGTH defs) /\ ALL_DISTINCT ns /\
(! xs l k. k < LENGTH defs /\ ( EL  k  defs = (xs,INR0 l)) ==>
   l IN FDOM  c /\ ( FLOOKUP d l = SOME (free_vars c ( FAPPLY  c  l),xs,ns,k))) /\
Cevaluate c d s
  ( FOLDL
     (\ env' n . FUPDATE  env' ( n, (CRecClos env ns defs n)))
     env ns)
  b r
==>
Cevaluate c d s env (CLetrec ns defs b) r)

/\
(! c d s env xs cb.
(! l. (cb =INR0 l) ==>  l IN FDOM  c /\ ( FLOOKUP d l = SOME (cbod_fvs c cb,xs,[],0)))
==>
Cevaluate c d s env (CFun xs cb) (s, Rval (CRecClos env [] [(xs,cb)] "")))

/\
(! c d s env e es s' env' ns defs n i xs cb b s'' vs r fvs.
Cevaluate c d s env e (s', Rval (CRecClos env' ns defs n)) /\
(if ns = [] then (defs = [(xs,cb)]) /\ (i = 0) else ( LENGTH ns = LENGTH defs) /\ ALL_DISTINCT ns /\
 (
 find_index n ns 0 = SOME i)) /\ ( EL  i  defs = (xs,cb)) /\
Cevaluate_list c d s' env es (s'', Rval vs) /\
(fvs = cbod_fvs c cb) /\
((b,(fvs,xs,ns,i)) = (case cb of INL0 b => (b,(fvs,xs,ns,i))
                                 |INR0 l => ( FAPPLY  c  l, FAPPLY  d  l) )) /\ ( LENGTH xs = LENGTH vs) /\ ALL_DISTINCT xs /\
Cevaluate c d s'' (extend_rec_env env' env' ns defs xs vs) b r
==>
Cevaluate c d s env (CCall e es) r)
/\
(! c d s env e s' v es s'' err.
Cevaluate c d s env e (s', Rval v) /\
Cevaluate_list c d s' env es (s'', Rerr err)
==>
Cevaluate c d s env (CCall e es) (s'', Rerr err))

/\
(! c d s env e es s' err.
Cevaluate c d s env e (s', Rerr err)
==>
Cevaluate c d s env (CCall e es) (s', Rerr err))

/\
(! c d s env uop e s' v.
Cevaluate c d s env e (s', Rval v)
==>
Cevaluate c d s env (CPrim1 uop e) (CevalPrim1 uop s' v))
/\
(! c d s env uop e s' err.
Cevaluate c d s env e (s', Rerr err)
==>
Cevaluate c d s env (CPrim1 uop e) (s', Rerr err))

/\
(! c d s env p2 e1 e2 s' v1 v2.
Cevaluate_list c d s env [e1;e2] (s', Rval [v1;v2])
==>
Cevaluate c d s env (CPrim2 p2 e1 e2) (s', CevalPrim2 p2 v1 v2))
/\
(! c d s env p2 e1 e2 s' err.
Cevaluate_list c d s env [e1;e2] (s', Rerr err)
==>
Cevaluate c d s env (CPrim2 p2 e1 e2) (s', Rerr err))

/\
(! c d s env e1 e2 s' v1 v2.
Cevaluate_list c d s env [e1;e2] (s', Rval [v1;v2])
==>
Cevaluate c d s env (CUpd e1 e2) (CevalUpd s' v1 v2))
/\
(! c d s env e1 e2 s' err.
Cevaluate_list c d s env [e1;e2] (s', Rerr err)
==>
Cevaluate c d s env (CUpd e1 e2) (s', Rerr err))

/\
(! c d s env e1 e2 e3 s' b1 r.
Cevaluate c d s env e1 (s', Rval (CLitv (Bool b1))) /\
Cevaluate c d s' env (if b1 then e2 else e3) r
==>
Cevaluate c d s env (CIf e1 e2 e3) r)
/\
(! c d s env e1 e2 e3 s' err.
Cevaluate c d s env e1 (s', Rerr err)
==>
Cevaluate c d s env (CIf e1 e2 e3) (s', Rerr err))

/\
(! c d s env.
T
==>
Cevaluate_list c d s env [] (s, Rval []))
/\
(! c d s env e es s' v s'' vs.
Cevaluate c d s env e (s', Rval v) /\
Cevaluate_list c d s' env es (s'', Rval vs)
==>
Cevaluate_list c d s env (e ::es) (s'', Rval (v ::vs)))
/\
(! c d s env e es s' err.
Cevaluate c d s env e (s', Rerr err)
==>
Cevaluate_list c d s env (e ::es) (s', Rerr err))
/\
(! c d s env e es s' v s'' err.
Cevaluate c d s env e (s', Rval v) /\
Cevaluate_list c d s' env es (s'', Rerr err)
==>
Cevaluate_list c d s env (e ::es) (s'', Rerr err))`;

(* equivalence relations on intermediate language *)

val _ = Hol_reln `
(! c l.
T
==>
syneq c (CLitv l) (CLitv l))
/\
(! c cn vs1 vs2. EVERY2 (syneq c) vs1 vs2
==>
syneq c (CConv cn vs1) (CConv cn vs2))
/\
(! c env1 env2 ns defs d. EVERY
  (\ (xs,b) .
    (! v. v IN (cbod_fvs c b DIFF ( LIST_TO_SET ns UNION LIST_TO_SET xs)) ==> ( OPTREL (syneq c)) ( FLOOKUP env1 v) ( FLOOKUP env2 v)))
  defs
==>
syneq c (CRecClos env1 ns defs d) (CRecClos env2 ns defs d))
/\
(! c n.
T
==>
syneq c (CLoc n) (CLoc n))`;

(* Compiler *)

(* source to intermediate expressions *)

(* remove pattern-matching using continuations *)

 val pat_to_Cpat_defn = Hol_defn "pat_to_Cpat" `

(pat_to_Cpat m pvs (Pvar vn) = ((vn ::pvs), CPvar vn))
/\
(pat_to_Cpat m pvs (Plit l) = (pvs, CPlit l))
/\
(pat_to_Cpat m pvs (Pcon (Short cn) ps) =
  let (pvs,Cps) = pats_to_Cpats m pvs ps in
  (pvs,CPcon ( FAPPLY  m  cn) Cps))
/\
(pat_to_Cpat m pvs (Pref p) =
  let (pvs,Cp) = pat_to_Cpat m pvs p in
  (pvs,CPref Cp))
/\
(pats_to_Cpats m pvs [] = (pvs,[]))
/\
(pats_to_Cpats m pvs (p::ps) =
  let (pvs,Cps) = pats_to_Cpats m pvs ps in
  let (pvs,Cp) = pat_to_Cpat m pvs p in
  (pvs,(Cp ::Cps)))`;

val _ = Defn.save_defn pat_to_Cpat_defn;

 val remove_mat_vp_defn = Hol_defn "remove_mat_vp" `

(remove_mat_vp fk sk v (CPvar pv) =
  CLet pv (CVar v) sk)
/\
(remove_mat_vp fk sk v (CPlit l) =
  CIf (CPrim2 CEq (CVar v) (CLit l))
    sk (CCall (CVar fk) []))
/\
(remove_mat_vp fk sk v (CPcon cn ps) =
  CIf (CTagEq (CVar v) cn)
    (remove_mat_con fk sk v 0 ps)
    (CCall (CVar fk) []))
/\
(remove_mat_vp fk sk v (CPref p) =
  let v' = fresh_var ({v;fk} UNION (free_vars FEMPTY sk) UNION (Cpat_vars p)) in
  CLet v' (CPrim1 CDer (CVar v))
    (remove_mat_vp fk sk v' p))
/\
(remove_mat_con fk sk v n [] = sk)
/\
(remove_mat_con fk sk v n (p::ps) =
  let v' = fresh_var ({v;fk} UNION (free_vars FEMPTY sk) UNION (Cpat_vars p)) in
  CLet v' (CProj (CVar v) n)
    (remove_mat_vp fk (remove_mat_con fk sk v (n +1) ps) v' p))`;

val _ = Defn.save_defn remove_mat_vp_defn;

 val remove_mat_var_defn = Hol_defn "remove_mat_var" `

(remove_mat_var v [] = CRaise Bind_error)
/\
(remove_mat_var v ((p,sk)::pes) =
  let fk = fresh_var ({v} UNION (free_vars FEMPTY sk) UNION (Cpat_vars p)) in
  CLet fk (CFun [] (INL0 (remove_mat_var v pes)))
    (remove_mat_vp fk sk v p))`;

val _ = Defn.save_defn remove_mat_var_defn;

val _ = Define `
 Cpes_vars = FOLDL (\ s (p,e) . s UNION Cpat_vars p UNION free_vars FEMPTY e) {}`;


 val exp_to_Cexp_defn = Hol_defn "exp_to_Cexp" `

(exp_to_Cexp m (Handle e x b) =
  CHandle (exp_to_Cexp m e) x (exp_to_Cexp m b))
/\
(exp_to_Cexp m (Raise err) = CRaise err)
/\
(exp_to_Cexp m (Lit l) = CLit l)
/\
(exp_to_Cexp m (Con (Short cn) es) =
  CCon ( FAPPLY  m  cn) (exps_to_Cexps m es))
/\
(exp_to_Cexp m (Var (Short vn)) = CVar vn)
/\
(exp_to_Cexp m (Fun vn e) =
  CFun [vn] (INL0 (exp_to_Cexp m e)))
/\
(exp_to_Cexp m (App (Opn opn) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CPrim2 ((case opn of
            Plus   => CAdd
          | Minus  => CSub
          | Times  => CMul
          | Divide => CDiv
          | Modulo => CMod
          ))
  Ce1 Ce2)
/\
(exp_to_Cexp m (App (Opb opb) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  (case opb of
    Lt => CPrim2 CLt Ce1 Ce2
  | Leq => CPrim2 CLt (CPrim2 CSub Ce1 Ce2) (CLit (IntLit i1))
  | opb =>
      let x1 = fresh_var (free_vars FEMPTY Ce2) in
      let x2 = fresh_var {x1} in
      CLet x1 Ce1 (
        CLet x2 Ce2 (
          (case opb of
            Gt =>  CPrim2 CLt (CVar x2) (CVar x1)
          | Geq => CPrim2 CLt (CPrim2 CSub (CVar x2) (CVar x1)) (CLit (IntLit i1))
          )))
  ))
/\
(exp_to_Cexp m (App Equality e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CPrim2 CEq Ce1 Ce2)
/\
(exp_to_Cexp m (App Opapp e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CCall Ce1 [Ce2])
/\
(exp_to_Cexp m (App Opassign e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CUpd Ce1 Ce2)
/\
(exp_to_Cexp m (Uapp uop e) =
  let Ce = exp_to_Cexp m e in
  CPrim1 ((case uop of
            Opref   => CRef
          | Opderef => CDer
          )) Ce)
/\
(exp_to_Cexp m (Log log e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  ((case log of
     And => CIf Ce1 Ce2 (CLit (Bool F))
   | Or  => CIf Ce1 (CLit (Bool T)) Ce2
   )))
/\
(exp_to_Cexp m (If e1 e2 e3) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  let Ce3 = exp_to_Cexp m e3 in
  CIf Ce1 Ce2 Ce3)
/\
(exp_to_Cexp m (Mat e pes) =
  let Cpes = pes_to_Cpes m pes in
  let v = fresh_var (Cpes_vars Cpes) in
  let Ce = exp_to_Cexp m e in
  CLet v Ce (remove_mat_var v Cpes))
/\
(exp_to_Cexp m (Let vn e b) =
  let Ce = exp_to_Cexp m e in
  let Cb = exp_to_Cexp m b in
  CLet vn Ce Cb)
/\
(exp_to_Cexp m (Letrec defs b) =
  let (fns,Cdefs) = defs_to_Cdefs m defs in
  let Cb = exp_to_Cexp m b in
  CLetrec fns Cdefs Cb)
/\
(defs_to_Cdefs m [] = ([],[]))
/\
(defs_to_Cdefs m ((d,vn,e)::defs) =
  let Ce = exp_to_Cexp m e in
  let (fns,Cdefs) = defs_to_Cdefs m defs in
  ((d ::fns),(([vn],INL0 Ce) ::Cdefs)))
/\
(pes_to_Cpes m [] = [])
/\
(pes_to_Cpes m ((p,e)::pes) =
  let (pvs,Cp) = pat_to_Cpat m [] p in
  let Ce = exp_to_Cexp m e in
  let Cpes = pes_to_Cpes m pes in
  (Cp,Ce) ::Cpes)
/\
(exps_to_Cexps s [] = [])
/\
(exps_to_Cexps m (e::es) =
  exp_to_Cexp m e :: exps_to_Cexps m es)`;

val _ = Defn.save_defn exp_to_Cexp_defn;

(* pull closure bodies into code environment *)

val _ = Hol_datatype `
 label_closures_state =
  <| lnext_label: num
   ; lcode_env: (num # Cexp) list
   |>`;


 val label_defs_defn = Hol_defn "label_defs" `

(label_defs (ds: def list) ([]: def list) = UNIT ds)
/\
(label_defs ds ((xs,INR0 a)::defs) =
  label_defs ((xs,INR0 a) ::ds) defs)
/\
(label_defs ds ((xs,INL0 b)::defs) = BIND
  (\ s . UNIT s.lnext_label
    (( s with<| (* parens: Lem sucks *)
      lnext_label := s.lnext_label +1 ;
      lcode_env := (s.lnext_label,b) ::s.lcode_env
     |>)) ) (\ n .
  (label_defs ((xs,INR0 n) ::ds) defs)))`;

val _ = Defn.save_defn label_defs_defn;

 val label_closures_defn = Hol_defn "label_closures" `

(label_closures (CDecl xs) = UNIT (CDecl xs))
/\
(label_closures (CRaise err) = UNIT (CRaise err))
/\
(label_closures (CHandle e1 x e2) = BIND
  (label_closures e1) (\ e1 . BIND
  (label_closures e2) (\ e2 . UNIT
  (CHandle e1 x e2))))
/\
(label_closures (CVar x) = UNIT (CVar x))
/\
(label_closures (CLit l) = UNIT (CLit l))
/\
(label_closures (CCon cn es) = BIND
  (label_closures_list es) (\ es . UNIT
  (CCon cn es)))
/\
(label_closures (CTagEq e n) = BIND
  (label_closures e) (\ e . UNIT
  (CTagEq e n)))
/\
(label_closures (CProj e n) = BIND
  (label_closures e) (\ e . UNIT
  (CProj e n)))
/\
(label_closures (CLet x e b) = BIND
  (label_closures e) (\ e . BIND
  (label_closures b) (\ b . UNIT
  (CLet x e b))))
/\
(label_closures (CLetrec ns defs e) = BIND
  (label_defs [] defs) (\ defs . BIND
  (label_closures e) (\ e . UNIT
  (CLetrec ns ( REVERSE defs) e))))
/\
(label_closures (CFun xs cb) = BIND
  (label_defs [] [(xs,cb)]) (\ defs .
  let (xs,cb) = EL  0  defs in UNIT
  (CFun xs cb)))
/\
(label_closures (CCall e es) = BIND
  (label_closures e) (\ e . BIND
  (label_closures_list es) (\ es . UNIT
  (CCall e es))))
/\
(label_closures (CPrim1 uop e) = BIND
  (label_closures e) (\ e . UNIT
    (CPrim1 uop e)))
/\
(label_closures (CPrim2 op e1 e2) = BIND
  (label_closures e1) (\ e1 . BIND
  (label_closures e2) (\ e2 . UNIT
  (CPrim2 op e1 e2))))
/\
(label_closures (CUpd e1 e2) = BIND
  (label_closures e1) (\ e1 . BIND
  (label_closures e2) (\ e2 . UNIT
  (CUpd e1 e2))))
/\
(label_closures (CIf e1 e2 e3) = BIND
  (label_closures e1) (\ e1 . BIND
  (label_closures e2) (\ e2 . BIND
  (label_closures e3) (\ e3 . UNIT
  (CIf e1 e2 e3)))))
/\
(label_closures_list [] = UNIT [])
/\
(label_closures_list (e::es) = BIND
  (label_closures e) (\ e . BIND
  (label_closures_list es) (\ es . UNIT
  (e ::es))))`;

val _ = Defn.save_defn label_closures_defn;

 val count_unlab_defn = Hol_defn "count_unlab" `

(count_unlab [] = 0)
/\
(count_unlab ((_,INL0 _)::ls) = 1 + count_unlab ls)
/\
(count_unlab ((_,INR0 _)::ls) = count_unlab ls)`;

val _ = Defn.save_defn count_unlab_defn;

(* imm_unlab e = number of unlabeled (INL) bodies, without looking
 * recursively at any of the bodies *)
 val imm_unlab_defn = Hol_defn "imm_unlab" `

(imm_unlab (CDecl xs) = 0)
/\
(imm_unlab (CRaise err) = 0)
/\
(imm_unlab (CHandle e1 x e2) = imm_unlab e1 + imm_unlab e2)
/\
(imm_unlab (CVar x) = 0)
/\
(imm_unlab (CLit l) = 0)
/\
(imm_unlab (CCon cn es) = imm_unlab_list es)
/\
(imm_unlab (CTagEq e n) = imm_unlab e)
/\
(imm_unlab (CProj e n) = imm_unlab e)
/\
(imm_unlab (CLet x e b) = imm_unlab e + imm_unlab b)
/\
(imm_unlab (CLetrec ns defs e) = count_unlab defs + imm_unlab e)
/\
(imm_unlab (CFun xs cb) = count_unlab [(xs,cb)])
/\
(imm_unlab (CCall e es) = imm_unlab e + imm_unlab_list es)
/\
(imm_unlab (CPrim2 op e1 e2) = imm_unlab e1 + imm_unlab e2)
/\
(imm_unlab (CUpd e1 e2) = imm_unlab e1 + imm_unlab e2)
/\
(imm_unlab (CPrim1 uop e) = imm_unlab e)
/\
(imm_unlab (CIf e1 e2 e3) = imm_unlab e1 + imm_unlab e2 + imm_unlab e3)
/\
(imm_unlab_list [] = 0)
/\
(imm_unlab_list (e::es) = imm_unlab e + imm_unlab_list es)`;

val _ = Defn.save_defn imm_unlab_defn;

 val repeat_label_closures_defn = Hol_defn "repeat_label_closures" `

(repeat_label_closures e n ac =
  if imm_unlab e = 0 then (e,n,ac) else
  let s = <| lnext_label := n; lcode_env := [] |> in
  let (e,s) = label_closures e s in
  let (n,ac) = label_code_env s.lnext_label ac s.lcode_env in
  (e,n,ac))
/\
(label_code_env n ac [] = (n,ac))
/\
(label_code_env n ac ((l,e)::ls) =
  let (e,n,ac) = repeat_label_closures e n ac in
  label_code_env n ((l,e) ::ac) ls)`;

val _ = Defn.save_defn repeat_label_closures_defn;

(* extract syntactic defs, to assist code_env construction *)

 val defs_to_ldefs_defn = Hol_defn "defs_to_ldefs" `

(defs_to_ldefs [] = [])
/\
(defs_to_ldefs ((xs,INR0 l)::defs) = (xs,l) ::(defs_to_ldefs defs))
/\
(defs_to_ldefs _ = [])`;

val _ = Defn.save_defn defs_to_ldefs_defn; (* should not happen *)

 val calculate_ldefs_defn = Hol_defn "calculate_ldefs" `
 (* including many uneta because Hol_defn sucks *)
(calculate_ldefs c ls (CDecl _) = ls)
/\
(calculate_ldefs c ls (CRaise _) = ls)
/\
(calculate_ldefs c ls (CVar _) = ls)
/\
(calculate_ldefs c ls (CLit _) = ls)
/\
(calculate_ldefs c ls (CCon _ es) = FOLDL (\ ls e . calculate_ldefs c ls e) ls es)
/\
(calculate_ldefs c ls (CTagEq e _) = calculate_ldefs c ls e)
/\
(calculate_ldefs c ls (CProj e _) = calculate_ldefs c ls e)
/\
(calculate_ldefs c ls (CLet _ e b) =
  calculate_ldefs c (calculate_ldefs c ls b) e)
/\
(calculate_ldefs c ls (CLetrec ns defs e) = FOLDL
    (\ls p . (case (ls ,p ) of
     ( ls , (_,cb) ) =>
 (case cb of
     INR0 l =>
 (case FLOOKUP c l of
     NONE => [] (* should not happen *)
   | SOME e => calculate_ldefs ( DOMSUB c l) ls e
 )
   | _ => [] (* should not happen *)
 )
 ))
    ((ns,
      defs_to_ldefs defs) ::calculate_ldefs c ls e)
    defs)
/\
(calculate_ldefs c ls (CFun xs cb) =
  (case cb of INR0 l =>
    (case FLOOKUP c l of NONE => [] (* should not happen *)
    | SOME e => calculate_ldefs ( DOMSUB c l) (([],[(xs,l)]) ::ls) e
    )
  | _ => [] (* should not happen *)
  ))
/\
(calculate_ldefs c ls (CCall e es) = FOLDL (\ ls e . calculate_ldefs c ls e) (calculate_ldefs c ls e) es)
/\
(calculate_ldefs c ls (CPrim2 _ e1 e2) =
  calculate_ldefs c (calculate_ldefs c ls e1) e2)
/\
(calculate_ldefs c ls (CUpd e1 e2) =
  calculate_ldefs c (calculate_ldefs c ls e1) e2)
/\
(calculate_ldefs c ls (CIf e1 e2 e3) =
  calculate_ldefs c (calculate_ldefs c (calculate_ldefs c ls e1) e2) e3)`;

val _ = Defn.save_defn calculate_ldefs_defn;

(* intermediate expressions to bytecode *)

(*open Bytecode*)

(* values in compile-time environment *)
val _ = Hol_datatype `
 ctbind = CTLet of num | CTArg of num | CTEnv of num | CTRef of num`;

(* CTLet n means stack[sz - n]
   CTArg n means stack[sz + n]
   CTEnv n means El n of the environment, which is at stack[sz]
   CTRef n means El n of the environment, but it's a ref pointer *)

val _ = type_abbrev( "ctenv" , ``: (string, ctbind)fmap``);

val _ = Hol_datatype `
 call_context = TCNonTail of bool | TCTail of num => num`;

(* TCTail j k = in tail position,
   * the called function has j arguments, and
   * k let variables have been bound *)
(* TCNonTail b = if b then in tail position, but called from top-level,
 * else not in tail position. *)

(* helper for reconstructing closure environments *)
val _ = Hol_datatype `
 cebind = CEEnv of string | CERef of num`;


val _ = type_abbrev( "ecs" , ``: num # cebind list``); (* num is the length of the list *)

val _ = Hol_datatype `
 compiler_result =
  <| out: bc_inst list (* reversed code *)
   ; next_label: num
   ; decl: ctenv # num
   |>`;


val _ = Hol_datatype `
 closure_data =
  <| ecs: (num, ecs)fmap
   ; env_azs: (num, (ctenv # num))fmap
   |>`;


 val prim1_to_bc_def = Define `

(prim1_to_bc CRef = Ref)
/\
(prim1_to_bc CDer = Deref)`;


 val prim2_to_bc_def = Define `

(prim2_to_bc CAdd = Add)
/\
(prim2_to_bc CSub = Sub)
/\
(prim2_to_bc CMul = Mult)
/\
(prim2_to_bc CDiv = Div)
/\
(prim2_to_bc CMod = Mod)
/\
(prim2_to_bc CLt = Less)
/\
(prim2_to_bc CEq = Equal)`;


val _ = Define `
 emit = FOLDL (\ s i . ( s with<| out := i :: s.out |>))`;


 val get_labels_def = Define `

(get_labels n s = (( s with<| next_label := s.next_label + n |>), GENLIST (\ i . s.next_label + i) n))`;


 val compile_varref_defn = Hol_defn "compile_varref" `

(compile_varref sz s (CTLet n) = emit s [Stack (Load (sz - n))])
/\
(compile_varref sz s (CTArg n) = emit s [Stack (Load (sz + n))])
/\
(compile_varref sz s (CTEnv n) = emit s [Stack (Load sz); Stack (El n)])
/\
(compile_varref sz s (CTRef n) = emit (compile_varref sz s (CTEnv n)) [Deref])`;

val _ = Defn.save_defn compile_varref_defn;

(* calling convention:
 * before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
 * thus, since env = stack[sz], argk should be CTArg (2 + n - k)
 * after:  retval,
 *)

(* closure representation:
 * Block 3 [CodePtr f; Env]
 * where Env = Number 0 for empty, or else
 * Block 3 [v1,...,vk]
 * with a value for each free variable
 * (some values may be RefPtrs to other (mutrec) closures)
 *)

(* closure construction, for a bundle of nz names, nk defs:
 * - push nz refptrs
 * - push nk CodePtrs, each pointing to the appropriate body
 * - for each def, load its CodePtr, load its environment, cons them up, and
     store them where its CodePtr was
   - for each name, load the refptr and update it with the closure
   - for each name, store the refptr back where it was
 *)

 val emit_ec_def = Define `

(emit_ec env z (sz,s) (CEEnv fv) = ((sz +1),compile_varref sz s ( FAPPLY  env  fv)))
/\
(* sz                                                                                         z *)
(* e, ..., e, CodePtr_k, CodePtr nk, ..., CodePtr k, ..., cl_1, RefPtr_nz 0, ..., RefPtr_1 0,   *)
(emit_ec env z (sz,s) (CERef j) = ((sz +1),emit s [Stack (Load (sz - z - j))]))`;


 val push_lab_def = Define `

(push_lab d (s,ecs) (xs,INL0 _) = (s,((0,[]) ::ecs))) (* should not happen *)
/\
(push_lab d (s,ecs) (xs,INR0 l) =
  (emit s [PushPtr (Lab l)],(( FAPPLY  d.ecs  l) ::ecs)))`;


 val cons_closure_def = Define `

(cons_closure env0 sz0 sz1 nk (s,k) (j,ec) =
  (* sz1                                                                  sz0 *)
  (* CodePtr nk, ..., CodePtr k, ..., cl_1, RefPtr_nz 0, ..., RefPtr_1 0,     *)
  let s = emit s [Stack (Load (nk - k))] in
  (* CodePtr_k, CodePtr nk, ..., CodePtr k, ..., cl_1, RefPtr_nz 0, ..., RefPtr_1 0, *)
  let (z,s) = FOLDL (emit_ec env0 sz0) ((sz1 +1),s) ( REVERSE ec) in
  (* e_kj, ..., e_k1, CodePtr_k, CodePtr nk, ..., CodePtr k, ..., cl_1, RefPtr_nz 0, ..., RefPtr_1 0, *)
  let s = emit s [Stack (Cons 0 j)] in
  (* env_k, CodePtr_k, CodePtr nk, ..., CodePtr k, ..., cl_1, RefPtr_nz 0, ..., RefPtr_1 0, *)
  let s = emit s [Stack (Cons closure_tag 2)] in
  (* cl_k, CodePtr nk, ..., CodePtr k, ..., cl_1, RefPtr_nz 0, ..., RefPtr_1 0, *)
  let s = emit s [Stack (Store (nk - k))] in
  (* CodePtr nk, ..., cl_k, ..., cl_1, RefPtr_nz 0, ..., RefPtr_1 0, *)
  (s,(k +1)))`;


 val update_refptr_def = Define `

(update_refptr nk (s,k) =
  (* nk = nz *)
  (* cl_nk, ..., cl_1, RefPtr_nz 0, ..., RefPtr_k 0, ..., RefPtr_1 cl_1, *)
  let s = emit s [Stack (Load (nk + nk - k))] in
  (* RefPtr_k 0, cl_nk, ..., cl_1, RefPtr_nz 0, ..., RefPtr_k 0, ..., RefPtr_1 cl_1, *)
  let s = emit s [Stack (Load (1 + nk - k))] in
  (* cl_k, RefPtr_k 0, cl_nk, ..., cl_1, RefPtr_nz 0, ..., RefPtr_k 0, ..., RefPtr_1 cl_1, *)
  let s = emit s [Update] in
  (* cl_nk, ..., cl_1, RefPtr_nz 0, ..., RefPtr_k cl_k, ..., RefPtr_1 cl_1, *)
  (s,(k +1)))`;


 val compile_closures_def = Define `

(compile_closures d env sz nz s defs =
  let s = num_fold (\ s . emit s [Stack (PushInt i0); Ref]) s nz in
  (* RefPtr_nz 0, ..., RefPtr_2 0, RefPtr_1 0, *)
  let nk = LENGTH defs in
  let (s,ecs) = FOLDL (push_lab d) (s,[]) defs in
  (* CodePtr nk, ..., CodePtr 2, CodePtr 1, RefPtr_nz 0, ..., RefPtr_1 0, *)
  let (s,k) = FOLDL (cons_closure env sz (sz +nz +nk) nk) (s,1) ( REVERSE ecs) in
  (* Block 3 [CodePtr nk, env_nk], ..., Block 3 [CodePtr 1, env_1], RefPtr_nz 0, ..., RefPtr_1 0, *)
  let (s,k) = num_fold (update_refptr nk) (s,1) nz in
  (* cl_nk, ..., cl_1, RefPtr_nz cl_nz, ..., RefPtr_1 cl_1, *)
  let k = nk - 1 in
  num_fold (\ s . emit s [Stack (Store k)]) s nz)`;

  (* cl_nk, ..., cl_1, *)

 val compile_decl_def = Define `

(compile_decl env1 env0 = FOLDL
    (\ (s,sz,i,env) v .
      if  v IN FDOM  env0 then
        ((case FAPPLY  env0  v of
           CTLet x => emit (compile_varref sz s ( FAPPLY  env1  v))
                           [Stack (Store (sz - x))]
         | _ => emit s [Stack (PushInt i2); PopExc] (* should not happen *)
         ), sz, i, env)
      else
        (compile_varref sz s ( FAPPLY  env1  v),
         (sz +1),
         (i +1), FUPDATE  env ( v, (CTLet i)))))`;


 val pushret_def = Define `

(pushret (TCNonTail _) s = s)
/\
(pushret (TCTail j k) s =
 (* val, vk, ..., v1, env, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c; env], *)
  emit s [Stack (Pops (k +1));
 (* val, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c; env], *)
          Stack (Load 1);
 (* CodePtr ret, val, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c; env], *)
          Stack (Store (j +2));
 (* val, CodePtr ret, argj, ..., arg1, CodePtr ret, *)
          Stack (Pops (j +1));
 (* val, CodePtr ret, *)
          Return])`;



 val compile_defn = Hol_defn "compile" `

(compile _ env t sz s (CDecl vs) =
  (case t of TCNonTail T =>
  (case s.decl of (env0,sz0) =>
  let k = sz - sz0 in
  let (s,sz,i,env) = (compile_decl env) env0 (s,sz,(sz0 +1),env0) vs in
  let s = emit s [Stack (Shift (i -(sz0 +1)) k)] in
  ( s with<| decl := (env,(sz - k)) |>)
  ) | _ => pushret t (emit s [Stack (PushInt i2); PopExc]) (* should not happen *) ))
/\
(compile _ _ t _ s (CRaise err) =
  pushret t (emit s [Stack (PushInt (error_to_int err)); PopExc]))
/\
(compile d env t sz s (CHandle e1 x e2) = compile d env t sz s e1)
/\
(compile _ _ t _ s (CLit (IntLit i)) =
  pushret t (emit s [Stack (PushInt i)]))
/\
(compile _ _ t _ s (CLit (Bool b)) =
  pushret t (emit s [Stack (Cons (bool_to_tag b) 0)]))
/\
(compile _ _ t _ s (CLit Unit) =
  pushret t (emit s [Stack (Cons unit_tag 0)]))
/\
(compile _ env t sz s (CVar vn) = pushret t (compile_varref sz s ( FAPPLY  env  vn)))
/\
(compile d env t sz s (CCon n es) =
  pushret t (emit (compile_nts d env sz s es) [Stack (Cons (n +block_tag) ( LENGTH es))]))
/\
(compile d env t sz s (CTagEq e n) =
  pushret t (emit (compile d env (TCNonTail F) sz s e) [Stack (TagEq (n +block_tag))]))
/\
(compile d env t sz s (CProj e n) =
  pushret t (emit (compile d env (TCNonTail F) sz s e) [Stack (El n)]))
/\
(compile d env t sz s (CLet x e eb) =
  compile_bindings d env t sz eb 0 (compile d env (TCNonTail F) sz s e) [x])
/\
(compile d env t sz s (CLetrec ns defs eb) =
  let s = compile_closures d env sz ( LENGTH ns) s defs in
  compile_bindings d env t sz eb 0 s ns)
/\
(compile d env t sz s (CFun xs cb) =
  pushret t (compile_closures d env sz 0 s [(xs,cb)]))
/\
(compile d env t sz s (CCall e es) =
  let n = LENGTH es in
  let s = compile_nts d env sz s (e ::es) in
  (case t of
    TCNonTail _ =>
    (* argn, ..., arg2, arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [Stack (Load n); Stack (El 1)] in
    (* env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [Stack (Load (n +1)); Stack (El 0)] in
    (* CodePtr c, env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    emit s [CallPtr]
    (* before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    (* after:  retval, *)
  | TCTail j k =>
    (* argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n +1 +k +1))] in
    (* CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n +1)); Stack (El 1)] in
    (* env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n +2)); Stack (El 0)] in
    (* CodePtr c, env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Shift (1 +1 +1 +n +1) (k +1 +1 +j +1))] in
    emit s [JumpPtr]
  ))
/\
(compile d env t sz s (CPrim1 uop e) =
  pushret t (emit (compile d env (TCNonTail F) sz s e) [prim1_to_bc uop]))
/\
(compile d env t sz s (CPrim2 op e1 e2) = (* TODO: need to detect div by zero? *)
  pushret t (emit (compile_nts d env sz s [e1;e2]) [Stack (prim2_to_bc op)]))
/\
(compile d env t sz s (CUpd e1 e2) =
  pushret t (emit (compile_nts d env sz s [e1;e2]) [Update; Stack (Cons unit_tag 0)]))
/\
(compile d env t sz s (CIf e1 e2 e3) =
  let s = compile d env (TCNonTail F) sz s e1 in
  let (s,labs) = get_labels 2 s in
  let n0 = EL  0  labs in
  let n1 = EL  1  labs in
  (case t of
    TCNonTail _ =>
    let (s,labs) = get_labels 1 s in
    let n2 = EL  0  labs in
    let s = emit s [(JumpIf (Lab n0)); (Jump (Lab n1)); Label n0] in
    let s = compile d env t sz s e2 in
    let s = emit s [Jump (Lab n2); Label n1] in
    let s = compile d env t sz s e3 in
    emit s [Label n2]
  | TCTail _ _ =>
    let s = emit s [(JumpIf (Lab n0)); (Jump (Lab n1)); Label n0] in
    let s = compile d env t sz s e2 in
    let s = emit s [Label n1] in
    compile d env t sz s e3
  ))
/\
(compile_bindings d env t sz e n s [] =
  (case t of
    TCTail j k => compile d env (TCTail j (k +n)) (sz +n) s e
  | TCNonTail F =>
    emit (compile d env t (sz +n) s e) [Stack (Pops n)]
  | TCNonTail T =>
    compile d env t (sz +n) s e
  ))
/\
(compile_bindings d env t sz e n s (x::xs) =
  compile_bindings d
  ( FUPDATE  env ( x, (CTLet (sz +(n +1)))))
  t sz e (n +1) s xs)
/\
(compile_nts d env sz s [] = s)
/\
(compile_nts d env sz s (e::es) =
  compile_nts d env (sz +1) (compile d env (TCNonTail F) sz s e) es)`;

val _ = Defn.save_defn compile_defn;

(* code env to bytecode *)

 val bind_fv_def = Define `

(bind_fv ns xs az k fv (env,(ecl,ec)) =
  (case find_index fv xs 1 of
    SOME j => ( FUPDATE  env ( fv, (CTArg (2 + az - j))), (ecl,ec))
  | NONE => (case find_index fv ns 0 of
      NONE => ( FUPDATE  env ( fv, (CTEnv ecl)), ((ecl +1),(CEEnv fv ::ec)))
    | SOME j => if j = k
                then ( FUPDATE  env ( fv, (CTArg (2 + az))), (ecl,ec))
                else ( FUPDATE  env ( fv, (CTRef ecl)), ((ecl +1),((CERef (j +1)) ::ec)))
    )
  ))`;


 val calculate_ecs_def = Define `

(calculate_ecs c = FOLDL
    (\ s (ns,defs) .
      let (s,k) = FOLDL
        (\ (s,k) (xs,l) .
          let az = LENGTH xs in
          let (env,(ecl,ec)) = ITSET (bind_fv ns xs az k) (free_vars c ( FAPPLY  c  l)) ( FEMPTY,(0,[])) in
          let s = ( s with<|
                     env_azs := FUPDATE  s.env_azs ( l, (env,az))
                   ; ecs := FUPDATE  s.ecs ( l, (ecl,ec))
                   |>) in
          (s,(k +1)))
        (s,0) defs in
      s))`;


 val cce_aux_def = Define `

(cce_aux c d s (ns,defs) = FOLDL
    (\ s (xs,l) .
      let (env,az) = FAPPLY  d.env_azs  l in
      let s = emit s [Label l] in
      compile d env (TCTail az 0) 0 s ( FAPPLY  c  l))
    s defs)`;


 val compile_code_env_def = Define `

(compile_code_env c d s ldefs =
  let (s,ls) = get_labels 1 s in
  let l = EL  0  ls in
  let s = emit s [Jump (Lab l)] in
  let s = FOLDL (cce_aux c d) s ldefs in
  emit s [Label l])`;


(* replace labels in bytecode with addresses *)

 val calculate_labels_defn = Hol_defn "calculate_labels" `

(calculate_labels il m n a [] = (m,n,a))
/\
(calculate_labels il m n a (Label l::lbc) =
  calculate_labels il ( FUPDATE  m ( l, n)) n a lbc)
/\
(calculate_labels il m n a (i::lbc) =
  calculate_labels il m (n + il i + 1) (i ::a) lbc)`;

val _ = Defn.save_defn calculate_labels_defn;

 val replace_labels_defn = Hol_defn "replace_labels" `

(replace_labels m a [] = a)
/\
(replace_labels m a (Jump (Lab l)::bc) =
  replace_labels m (Jump (Addr ( FAPPLY  m  l)) ::a) bc)
/\
(replace_labels m a (JumpIf (Lab l)::bc) =
  replace_labels m (JumpIf (Addr ( FAPPLY  m  l)) ::a) bc)
/\
(replace_labels m a (Call (Lab l)::bc) =
  replace_labels m (Call (Addr ( FAPPLY  m  l)) ::a) bc)
/\
(replace_labels m a (PushPtr (Lab l)::bc) =
  replace_labels m (PushPtr (Addr ( FAPPLY  m  l)) ::a) bc)
/\
(replace_labels m a (i::bc) =
  replace_labels m (i ::a) bc)`;

val _ = Defn.save_defn replace_labels_defn;

 val compile_labels_def = Define `

(compile_labels il lbc =
  let (m,n,bc) = calculate_labels il FEMPTY 0 [] lbc in
    replace_labels m [] bc)`;


(* repl *)

val _ = type_abbrev( "contab" , ``: (conN, num)fmap # (num, conN)fmap # num``);
(*val cmap : contab -> Pmap.map conN num*)
 val cmap_def = Define `
 (cmap (m,_,_) = m)`;


val _ = Hol_datatype `
 repl_state =
  <| contab : contab
   ; renv : ctenv
   ; rsz  : num
   ; rnext_label : num
   |>`;


val _ = Define `
 init_repl_state =
  <| contab := ( FEMPTY, FEMPTY, 0)
   ; renv := FEMPTY
   ; rsz  := 0
   ; rnext_label := 0
   |>`;


val _ = Define `
 (compile_Cexp rs decl Ce =
  let (Ce,n,c) = repeat_label_closures Ce rs.rnext_label [] in
  let c = alist_to_fmap c in
  let ldefs = calculate_ldefs c [] Ce in
  let d = calculate_ecs c <| ecs := FEMPTY; env_azs := FEMPTY |> ldefs in
  let cs = <| out := []; next_label := n
            ; decl := (rs.renv,rs.rsz) |> in
  let cs = compile_code_env c d cs ldefs in
  let cs = compile d rs.renv (TCNonTail decl) rs.rsz cs Ce in
  let rs = if decl then (case cs.decl of
      (env,sz) => ( rs with<| renv := env ; rsz := sz |>)
    ) else rs in
  let rs = ( rs with<| rnext_label := cs.next_label |>) in
  (rs, REVERSE cs.out))`;


 val number_constructors_defn = Hol_defn "number_constructors" `

(number_constructors [] ct = ct)
/\
(number_constructors ((c,_)::cs) (m,w,n) =
  number_constructors cs ( FUPDATE  m ( c, n), FUPDATE  w ( n, c), (n +1)))`;

val _ = Defn.save_defn number_constructors_defn;

 val repl_dec_defn = Hol_defn "repl_dec" `

(repl_dec rs (Dtype []) = (rs,[]))
/\
(repl_dec rs (Dtype ((_,_,cs)::ts)) =
  let ct = number_constructors cs rs.contab in
  repl_dec (( rs with<| contab := ct |>)) (Dtype ts)) (* parens: Lem sucks *)
/\
(repl_dec rs (Dletrec defs) =
  let (fns,Cdefs) = defs_to_Cdefs (cmap rs.contab) defs in
  compile_Cexp rs T (CLetrec fns Cdefs (CDecl fns)))
/\
(repl_dec rs (Dlet p e) =
  let m = cmap rs.contab in
  let (pvs,Cp) = pat_to_Cpat m [] p in
  let Cpes = [(Cp,CDecl pvs)] in
  let vn = fresh_var (Cpes_vars Cpes) in
  let Ce = exp_to_Cexp m e in
  compile_Cexp rs T (CLet vn Ce (remove_mat_var vn Cpes)))`;

val _ = Defn.save_defn repl_dec_defn;

val _ = Define `
 (repl_exp s exp = compile_Cexp s F (exp_to_Cexp (cmap s.contab) exp))`;


(* Correctness *)

(* observable values *)

val _ = Hol_datatype `
 ov =
    OLit of lit
  | OConv of conN => ov list
  | OFn
  | OLoc of num`;
 (* machine, not semantic, address *)

 val v_to_ov_defn = Hol_defn "v_to_ov" `

(v_to_ov s (Litv l) = OLit l)
/\
(v_to_ov s (Conv (Short cn) vs) = OConv cn ( MAP (v_to_ov s) vs))
/\
(v_to_ov s (Closure _ _ _) = OFn)
/\
(v_to_ov s (Recclosure _ _ _) = OFn)
/\
(v_to_ov s (Loc n) = OLoc ( FAPPLY  s  n))`;

val _ = Defn.save_defn v_to_ov_defn;

 val Cv_to_ov_defn = Hol_defn "Cv_to_ov" `

(Cv_to_ov m s (CLitv l) = OLit l)
/\
(Cv_to_ov m s (CConv cn vs) = OConv ( FAPPLY  m  cn) ( MAP (Cv_to_ov m s) vs))
/\
(Cv_to_ov m s (CRecClos _ _ _ _) = OFn)
/\
(Cv_to_ov m s (CLoc n) = OLoc ( FAPPLY  s  n))`;

val _ = Defn.save_defn Cv_to_ov_defn;

 val bv_to_ov_defn = Hol_defn "bv_to_ov" `

(bv_to_ov m (Number i) = OLit (IntLit i))
/\
(bv_to_ov m (Block n vs) =
  if n = (bool_to_tag F) then OLit (Bool F) else
  if n = (bool_to_tag T) then OLit (Bool T) else
  if n = unit_tag then OLit Unit else
  if n = closure_tag then OFn else
  OConv ( FAPPLY  m  (n - block_tag)) ( MAP (bv_to_ov m) vs))
/\
(bv_to_ov m (RefPtr n) = OLoc n)`;

val _ = Defn.save_defn bv_to_ov_defn;

(* source to intermediate values *)

 val v_to_Cv_defn = Hol_defn "v_to_Cv" `

(v_to_Cv m (Litv l) = CLitv l)
/\
(v_to_Cv m (Conv (Short cn) vs) =
  CConv ( FAPPLY  m  cn) (vs_to_Cvs m vs))
/\
(v_to_Cv m (Closure env vn e) =
  let Cenv = alist_to_fmap (env_to_Cenv m env) in
  let Ce = exp_to_Cexp m e in
  CRecClos Cenv [] [([vn],INL0 Ce)] "")
/\
(v_to_Cv m (Recclosure env defs vn) =
  let Cenv = alist_to_fmap (env_to_Cenv m env) in
  let (fns,Cdefs) = defs_to_Cdefs m defs in
  CRecClos Cenv fns Cdefs vn)
/\
(v_to_Cv m (Loc n) = CLoc n)
/\
(vs_to_Cvs m [] = [])
/\
(vs_to_Cvs m (v::vs) = v_to_Cv m v :: vs_to_Cvs m vs)
/\
(env_to_Cenv m [] = [])
/\
(env_to_Cenv m ((x,v)::env) =
  (x, v_to_Cv m v) ::(env_to_Cenv m env))`;

val _ = Defn.save_defn v_to_Cv_defn;

(* intermediate to target values *)

(*
let rec
Cv_to_bv (CLitv (IntLit i)) = Number i
and
Cv_to_bv (CLitv (Bool b)) = Number (bool_to_int b)
and
Cv_to_bv (CConv n vs) = Block n (Cvs_to_bvs vs)
and
Cv_to_bv (CRecClos env ns defs n) = Block 0 [CodePtr ?, ?]
and
Cvs_to_bvs [] = []
and
Cvs_to_bvs (v::vs) = Cv_to_bv v :: Cvs_to_bvs vs
*)

(*
indreln
forall il c cc.
true
==>
bc_code_prefix il (List.append c cc) 0 c
and
forall il p i c cc.
bc_code_prefix il cc p c
==>
bc_code_prefix il (i::cc) (p + il i) c

let rec
body_cs env xs =
  <| env = env; sz = 0; out = []; next_label = 0;
     tail = TCTail (List.length xs) 0; decl = None |>

let rec
body_env ns xs j fvs =
  let (n,env,(nec,ec)) =
    Set.fold (bind_fv ns xs (List.length xs) j) fvs (0,Pmap.empty,(0,[])) in
  (env,ec)

indreln
forall il c i.
true
==>
bceqv il c (CLitv (IntLit i)) (Number i)
and
forall il c b.
true
==>
bceqv il c (CLitv (Bool b)) (Number (bool_to_int b))
and
forall il c n vs bvs.
every2 (bceqv il c) vs bvs
==>
bceqv il c (CConv n vs) (Block n bvs)
and
forall il c env ns defs n j xs e cenv ec f bvs.
find_index n ns 0 = Some j &&
List.nth defs j = (xs,e) &&
(cenv,ec) = body_env ns xs j (free_vars Pmap.empty e) &&
List.length bvs = List.length ec &&
(forall i. i < List.length ec -->
    (exists fv. List.nth ec i = CEEnv fv &&
                bceqv il c (Pmap.find fv env) (List.nth bvs i)) ||
    (exists k kxs ke kenv kec g.
        List.nth ec i = CERef k &&
        List.nth defs k = (kxs,ke) &&
        (kenv,kec) = body_env ns xs k (free_vars ke) &&
        bc_code_prefix il c g
          (List.rev (compile (body_cs kenv kxs) ke).out))) &&
bc_code_prefix il c f (List.rev (compile (body_cs cenv xs) e).out)
==>
bceqv il c (CRecClos env ns defs n)
  (Block 0 [CodePtr f; if bvs = [] then Number i0 else Block 0 bvs])
*)


(* relating source to intermediate language *)

(*
indreln
forall m c l.
true
==>
v_Cv m c (Litv l) (CLitv l)
and
forall m c cn vs Cvs.
every2 (v_Cv m c) vs Cvs
==>
v_Cv m c (Conv cn vs) (CConv (Pmap.find cn m) Cvs)
and
forall m c env vn e fn l.
env_Cenv m c env Cenv &&

==>
v_Cv m c (Closure env vn e) (CRecClos Cenv [fn] [([vn],l)] fn)
and
==>
v_Cv m c (Recclosure env defs fn) (CRecClos Cenv fns Cdefs fn)
and
forall c env1 env2 ns defs d.
List.for_all
  (fun (xs,b) ->
    (forall v. v IN (cbod_fvs c b \ (Set.from_list ns union
                                     Set.from_list xs))
      --> (optrel (syneq c)) (flookup env1 v) (flookup env2 v)))
  defs
==>
v_Cv m c (CRecClos env1 ns defs d) (CRecClos env2 ns defs d)
*)

(*
indreln
forall G cm env Cenv err.
true
==>
exp_Cexp G cm env Cenv (Raise err) (CRaise err)
and
forall G cm env Cenv l.
true
==>
exp_Cexp G cm env Cenv (Lit l) (CLit l)
and
forall G cm env Cenv cn es Ces.
Pmap.mem cn cm &&
every2 (exp_Cexp G cm env Cenv) es Ces
==>
exp_Cexp G cm env Cenv (Con cn es) (CCon (Pmap.find cn cm) Ces)
and
forall G cm env Cenv vn v Cvn.
lookup vn env = Some v &&
Pmap.mem Cvn Cenv &&
G cm v (Pmap.find Cvn Cenv)
==>
exp_Cexp G cm env Cenv (Var vn) (CVar Cvn)
and
forall G cm env Cenv vn e n Ce.
(forall v Cv. G cm v Cv -->
  exp_Cexp G cm (bind vn v env) (Pmap.add n Cv Cenv) e Ce)
==>
exp_Cexp G cm env Cenv (Fun vn e) (CFun [n] Ce)

indreln
forall G cm l.
true
==>
v_Cv G cm (Litv l) (CLitv l)
and
forall G cm cn vs Cvs.
Pmap.mem cn cm &&
every2 (v_Cv G cm) vs Cvs
==>
v_Cv G cm (Conv cn vs) (CConv (Pmap.find cn cm) Cvs)
*)

(*
indreln
forall cm env Cenv err.
true
==>
exp_Cexp cm env Cenv (Raise err) (CRaise err)
and
forall cm env Cenv v Cv.
v_Cv cm v Cv
==>
exp_Cexp cm env Cenv (Val v) (CVal Cv)
and
forall cm env Cenv cn es Ces.
every2 (exp_Cexp cm env Cenv) es Ces
==>
exp_Cexp cm env Cenv (Con cn es) (CCon (Pmap.find cn cm) Ces)
and
forall cm env Cenv vn v Cvn Cv.
lookup vn env = Some v &&
Pmap.mem Cvn Cenv && Pmap.find Cvn Cenv = Cv && (* TODO: lookup *)
v_Cv cm v Cv
==>
exp_Cexp cm env Cenv (Var vn) (CVar Cvn)
and
forall cm env Cenv vn e n Ce.
(* but what to do here without a context of equal variables? *)
(* (see comments in v_Cv below) *)
==>
exp_Cexp cm env Cenv (Fun vn e) (CFun n Ce)
and
forall cm l.
true
==>
v_Cv cm (Lit l) (CLit l)
and
forall cm cn vs Cvs.
every2 (v_Cv cm) vs Cvs
==>
v_Cv cm (Conv cn vs) (CConv (Pmap.find cn cm) Cvs)
and
forall cm env vn e Cenv n Ce.
(* can't do this because it's a negative occurrence of v_Cv,
 * leading to a non-monotonic rule
(forall v Cv. v_Cv cm v Cv -->
 exp_Cexp cm (bind vn v env) (Pmap.add n Cv (alist_to_fmap Cenv)) e Ce)
*)
(* obviously this is incorrect (requires the functions to be equivalent on
 * arbitrary pairs of arguments)
 * options for extension include:
   * normal form (open): use the same free variable as the argument
     * but does this distinguish too many pairs of terms?
   * carry around a context of equal values/variables
     * but how does this relate with the environments in closures?
     * probably just have to have both independently
   * parameterise by a "global knowledge" relation of equal values *)
(forall v Cv. exp_Cexp cm (bind vn v env) (Pmap.add n Cv (alist_to_fmap Cenv)) e Ce)
==>
v_Cv cm (Closure env vn e) (CClosure Cenv [n] Ce)
*)

(*
let rec
Cv_to_bv (CLitv (IntLit i)) = Number i
and
Cv_to_bv (CLitv (Bool b)) = Number (bool_to_int b)
and
Cv_to_bv (CConv n vs) = Block n (Cvs_to_bvs vs)
and
Cv_to_bv (CClosure env vs b) = Block 0 [CodePtr ?, ?]
and
Cv_to_bv (CRecClos env ns defs n) = Block 0 [CodePtr ?, ?]
and
Cvs_to_bvs [] = []
and
Cvs_to_bvs (v::vs) = Cv_to_bv v :: Cvs_to_bvs vs
*)
val _ = export_theory()

