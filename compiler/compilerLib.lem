open import Pervasives
import List_extra


(* TODO: these should be in the lem library *)
val all2 : forall 'a 'b. ('a -> 'b -> bool) -> list 'a -> list 'b -> bool
declare hol target_rep function all2 = `EVERY2`

val num_fold : forall 'a. ('a -> 'a) -> 'a -> nat -> 'a
let rec num_fold f a n = if n = 0 then a else num_fold f (f a) (n-1)
declare termination_argument num_fold = automatic

(* TODO: move? *)
open import {hol} `sptreeTheory`
type nat_set
declare hol target_rep type nat_set = `spt` unit
val nat_set_empty : nat_set
val nat_set_insert : nat_set -> nat -> nat_set
val nat_set_to_set : nat_set -> set nat
val nat_set_elem : nat_set -> nat -> bool
val nat_set_from_list : list nat -> nat_set
declare hol target_rep function nat_set_empty = `LN`
declare hol target_rep function nat_set_insert s n = `insert` n () s
declare hol target_rep function nat_set_to_set s = `domain` s
declare hol target_rep function nat_set_elem s n = n IN (nat_set_to_set s)
declare hol target_rep function nat_set_from_list = List.foldl nat_set_insert nat_set_empty

let rec
intersperse _ [] = []
and
intersperse _ [x] = [x]
and
intersperse a (x::xs) = x::a::intersperse a xs

let rec
lunion [] s = s
and
lunion (x::xs) s =
  if List.elem x s
  then lunion xs s
  else x::(lunion xs s)

let rec
lshift (n : nat) ls =
  List.map (fun v -> v - n) (List.filter (fun v -> n <= v) ls)

let rec the _ (Just x) = x and the x Nothing = x

val fapply : forall 'a 'b. MapKeyType 'b => 'a -> 'b -> Map.map 'b 'a -> 'a
let fapply d x f = match Map.lookup x f with Just d -> d | Nothing -> d end
