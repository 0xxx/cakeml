(* The third intermediate language (IL3). Removes declarations.
 *
 * The AST of IL3 differs from IL2 in that there is no declarations level, the
 * program is represented by a sequence of expressions.
 *
 * The values of IL3 are the same as IL2.
 *
 * The semantics of IL3 differ in that the global environment is now store-like
 * rather than environment-like. The expressions for extending and initialising
 * it modify the global environment (instread of just rasing a type error).
 *
 * The translator to IL3 maps a declaration to an expression that sets of the
 * global environment in the right way. If evaluating the expression results in
 * an exception, then the exception is handled, and a SOME containing the
 * exception is returned. Otherwise, a NONE is returned.
 *
 *)

open import Pervasives
open import Lib
open import Ast
open import SemanticPrimitives
open import List_extra
open import BigStep
open import ConLang

type pat_exh =
  | Pvar_exh of varN
  | Plit_exh of lit
  | Pcon_exh of nat * list pat_exh
  | Pref_exh of pat_exh

type exp_exh =
  | Raise_exh of exp_exh
  | Handle_exh of exp_exh * list (pat_exh * exp_exh)
  | Lit_exh of lit
  | Con_exh of nat * list exp_exh
  | Var_local_exh of varN
  | Var_global_exh of nat
  | Fun_exh of varN * exp_exh
  | Uapp_exh of uop_i2 * exp_exh
  | App_exh of op * exp_exh * exp_exh
  | If_exh of exp_exh * exp_exh * exp_exh
  | Mat_exh of exp_exh * list (pat_exh * exp_exh)
  | Let_exh of maybe varN * exp_exh * exp_exh
  | Letrec_exh of list (varN * varN * exp_exh) * exp_exh
  | Extend_global_exh of nat

type v_exh =
  | Litv_exh of lit
  | Conv_exh of nat * list v_exh 
  | Closure_exh of env varN v_exh * varN * exp_exh
  | Recclosure_exh of env varN v_exh * list (varN * varN * exp_exh) * varN
  | Loc_exh of nat

val pat_bindings_exh : pat_exh -> list varN -> list varN
let rec
pat_bindings_exh (Pvar_exh n) already_bound =
  n::already_bound
and
pat_bindings_exh (Plit_exh l) already_bound =
  already_bound
and
pat_bindings_exh (Pcon_exh _ ps) already_bound =
  pats_bindings_exh ps already_bound
and
pat_bindings_exh (Pref_exh p) already_bound =
  pat_bindings_exh p already_bound
and
pats_bindings_exh [] already_bound =
  already_bound
and
pats_bindings_exh (p::ps) already_bound =
  pats_bindings_exh ps (pat_bindings_exh p already_bound)

val pmatch_exh : store v_exh -> pat_exh -> v_exh -> env varN v_exh -> match_result (env varN v_exh)
let rec
pmatch_exh s (Pvar_exh x) v' env = Match (bind x v' env)
and
pmatch_exh s (Plit_exh l) (Litv_exh l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error
and
pmatch_exh s (Pcon_exh n ps) (Conv_exh n' vs) env =
  if n = n' then
    if List.length ps = List.length vs then
      pmatch_list_exh s ps vs env
    else
      Match_type_error
  else
    No_match
and
pmatch_exh s (Pref_exh p) (Loc_exh lnum) env =
  match store_lookup lnum s with
    | Just v -> pmatch_exh s p v env
    | Nothing -> Match_type_error
  end
and
pmatch_exh _ _ _ env = Match_type_error
and
pmatch_list_exh s [] [] env = Match env
and
pmatch_list_exh s (p::ps) (v::vs) env =
  match pmatch_exh s p v env with
    | No_match -> No_match
    | Match_type_error -> Match_type_error
    | Match env' -> pmatch_list_exh s ps vs env'
  end
and
pmatch_list_exh s _ _ env = Match_type_error

val do_uapp_exh : store v_exh * list (maybe v_exh) -> uop_i2 -> v_exh -> maybe ((store v_exh * list (maybe v_exh)) * v_exh)
let do_uapp_exh (s,genv) uop v =
  match uop with
    | Opderef_i2 ->
        match v with
          | Loc_exh n ->
              match store_lookup n s with
                | Just v -> Just ((s,genv),v)
                | Nothing -> Nothing
              end
          | _ -> Nothing
        end
    | Opref_i2 ->
        let (s',n) = store_alloc v s in
          Just ((s',genv), Loc_exh n)
    | Init_global_var_i2 idx ->
        if idx < List.length genv then
          match List_extra.nth genv idx with
            | Nothing -> Just ((s, List.update genv idx (Just v)), Litv_exh Unit)
            | Just x -> Nothing
          end
        else
          Nothing
  end

val build_rec_env_exh : list (varN * varN * exp_exh) -> env varN v_exh -> env varN v_exh -> env varN v_exh
let build_rec_env_exh funs cl_env add_to_env =
  foldr 
    (fun (f,x,e) env' -> bind f (Recclosure_exh cl_env funs f) env') 
    add_to_env 
    funs

val do_eq_exh : v_exh -> v_exh -> eq_result
let rec 
do_eq_exh (Litv_exh l1) (Litv_exh l2) = 
  Eq_val (l1 = l2)
and
do_eq_exh (Loc_exh l1) (Loc_exh l2) = Eq_val (l1 = l2)
and
do_eq_exh (Conv_exh tag1 vs1) (Conv_exh tag2 vs2) =
  if tag1 = tag2 && (List.length vs1 = List.length vs2) then
    do_eq_list_exh vs1 vs2
  else
    Eq_val false
and
do_eq_exh (Closure_exh _ _ _) (Closure_exh _ _ _) = Eq_closure
and
do_eq_exh (Closure_exh _ _ _) (Recclosure_exh _ _ _) = Eq_closure
and
do_eq_exh (Recclosure_exh _ _ _) (Closure_exh _ _ _) = Eq_closure
and
do_eq_exh (Recclosure_exh _ _ _) (Recclosure_exh _ _ _) = Eq_closure
and
do_eq_exh _ _ = Eq_type_error
and
do_eq_list_exh [] [] = Eq_val true
and
do_eq_list_exh (v1::vs1) (v2::vs2) = 
  match do_eq_exh v1 v2 with
    | Eq_closure -> Eq_closure
    | Eq_type_error -> Eq_type_error
    | Eq_val r -> 
        if not r then
          Eq_val false
        else
          do_eq_list_exh vs1 vs2
  end
and
do_eq_list_exh _ _ = Eq_val false


val do_app_exh : env varN v_exh -> store v_exh -> op -> v_exh -> v_exh -> maybe (env varN v_exh * store v_exh * exp_exh)
let do_app_exh env' s op v1 v2 =
  match (op, v1, v2) with
    | (Opapp, Closure_exh env n e, v) ->
        Just (bind n v env, s, e)
    | (Opapp, Recclosure_exh env funs n, v) ->
        match find_recfun n funs with
          | Just (n,e) -> Just (bind n v (build_rec_env_exh funs env env), s, e)
          | Nothing -> Nothing
        end
    | (Opn op, Litv_exh (IntLit n1), Litv_exh (IntLit n2)) ->
        if (op = Divide || (op = Modulo)) && (n2 = 0) then
          Just (emp, s, Raise_exh (Con_exh div_tag []))
        else
          Just (env', s, Lit_exh (IntLit (opn_lookup op n1 n2)))
    | (Opb op, Litv_exh (IntLit n1), Litv_exh (IntLit n2)) ->
        Just (env', s, Lit_exh (Bool (opb_lookup op n1 n2)))
    | (Equality, v1, v2) ->
        match do_eq_exh v1 v2 with
          | Eq_type_error -> Nothing
          | Eq_closure -> Just (emp, s, Raise_exh (Con_exh eq_tag []))
          | Eq_val b -> Just (env', s, Lit_exh (Bool b))
        end
    | (Opassign, (Loc_exh lnum), v) ->
        match store_assign lnum v s with
        | Just st -> Just (env', st, Lit_exh Unit)
        | Nothing -> Nothing
        end
    | _ -> Nothing
  end

val do_if_exh : v_exh -> exp_exh -> exp_exh -> maybe exp_exh
let do_if_exh v e1 e2 =
  if v = Litv_exh (Bool true) then
    Just e1
  else if v = Litv_exh (Bool false) then
    Just e2
  else
    Nothing

type count_store_genv 'a = count_store 'a * list (maybe 'a)

indreln [evaluate_exh : bool -> env varN v_exh -> count_store_genv v_exh -> exp_exh -> count_store_genv v_exh * result v_exh v_exh -> bool]
and [evaluate_list_exh : bool -> env varN v_exh -> count_store_genv v_exh -> list exp_exh -> count_store_genv v_exh * result (list v_exh) v_exh -> bool]
and [evaluate_match_exh : bool -> env varN v_exh -> count_store_genv v_exh -> v_exh -> list (pat_exh * exp_exh) -> count_store_genv v_exh * result v_exh v_exh -> bool]

lit : forall ck env l s.
true
==>
evaluate_exh ck env s (Lit_exh l) (s, Rval (Litv_exh l))

and

raise1 : forall ck env e s1 s2 v.
evaluate_exh ck s1 env e (s2, Rval v)
==>
evaluate_exh ck s1 env (Raise_exh e) (s2, Rerr (Rraise v))

and

raise2 : forall ck env e s1 s2 err.
evaluate_exh ck s1 env e (s2, Rerr err)
==>
evaluate_exh ck s1 env (Raise_exh e) (s2, Rerr err)

and

handle1 : forall ck s1 s2 env e v pes.
evaluate_exh ck s1 env e (s2, Rval v)
==>
evaluate_exh ck s1 env (Handle_exh e pes) (s2, Rval v)

and

handle2 : forall ck s1 s2 env e pes v bv.
evaluate_exh ck env s1 e (s2, Rerr (Rraise v)) &&
evaluate_match_exh ck env s2 v pes bv
==>
evaluate_exh ck env s1 (Handle_exh e pes) bv

and

handle3 : forall ck s1 s2 env e pes err.
evaluate_exh ck env s1 e (s2, Rerr err) &&
(err = Rtimeout_error || (err = Rtype_error))
==>
evaluate_exh ck env s1 (Handle_exh e pes) (s2, Rerr err)

and

con1 : forall ck env tag es vs s s'.
evaluate_list_exh ck env s es (s', Rval vs)
==>
evaluate_exh ck env s (Con_exh tag es) (s', Rval (Conv_exh tag vs))

and

con3 : forall ck env tag es err s s'.
evaluate_list_exh ck env s es (s', Rerr err)
==>
evaluate_exh ck env s (Con_exh tag es) (s', Rerr err)

and

var1 : forall ck env n v s.
(lookup n env = Just v)
==>
evaluate_exh ck env s (Var_local_exh n) (s, Rval v)

and

var2 : forall ck env n s.
(lookup n env = Nothing)
==>
evaluate_exh ck env s (Var_local_exh n) (s, Rerr Rtype_error)

and

var3 : forall ck env n v s genv.
(List.length genv > n) &&
(List_extra.nth genv n = Just v)
==>
evaluate_exh ck env (s,genv) (Var_global_exh n) ((s,genv), Rval v)

and

var4 : forall ck env n s genv.
(List.length genv > n) &&
(List_extra.nth genv n = Nothing)
==>
evaluate_exh ck env (s,genv) (Var_global_exh n) ((s,genv), Rerr Rtype_error)

and

var5 : forall ck env n s genv.
not (List.length genv > n)
==>
evaluate_exh ck env (s,genv) (Var_global_exh n) ((s,genv), Rerr Rtype_error)

and

fn : forall ck env n e s.
true
==>
evaluate_exh ck env s (Fun_exh n e) (s, Rval (Closure_exh env n e))

and

uapp1 : forall ck env uop e v v' s1 s2 count s3 genv2 genv3.
evaluate_exh ck env s1 e (((count,s2),genv2), Rval v) &&
do_uapp_exh (s2,genv2) uop v = Just ((s3,genv3),v')
==>
evaluate_exh ck env s1 (Uapp_exh uop e) (((count,s3),genv3), Rval v')

and

uapp2 : forall ck env uop e v s1 s2 count genv2.
evaluate_exh ck env s1 e (((count,s2),genv2), Rval v) &&
(do_uapp_exh (s2,genv2) uop v = Nothing)
==>
evaluate_exh ck env s1 (Uapp_exh uop e) (((count,s2),genv2), Rerr Rtype_error)

and

uapp3 : forall ck env uop e err s s'.
evaluate_exh ck env s e (s', Rerr err)
==>
evaluate_exh ck env s (Uapp_exh uop e) (s', Rerr err)

and

app1 : forall ck env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 count s4 genv3.
evaluate_exh ck env s1 e1 (s2, Rval v1) &&
evaluate_exh ck env s2 e2 (((count,s3),genv3), Rval v2) &&
do_app_exh env s3 op v1 v2 = Just (env', s4, e3) &&
((ck && (op = Opapp)) --> count <> 0) &&
evaluate_exh ck env' (((if ck then dec_count op count else count),s4),genv3) e3 bv
==>
evaluate_exh ck env s1 (App_exh op e1 e2) bv

and

app2 : forall ck env op e1 e2 v1 v2 env' e3 s1 s2 s3 count s4 genv3.
evaluate_exh ck env s1 e1 (s2, Rval v1) &&
evaluate_exh ck env s2 e2 (((count,s3),genv3), Rval v2) &&
do_app_exh env s3 op v1 v2 = Just (env', s4, e3) &&
count = 0 &&
op = Opapp &&
ck
==>
evaluate_exh ck env s1 (App_exh op e1 e2) (((0,s4),genv3),Rerr Rtimeout_error)

and

app3 : forall ck env op e1 e2 v1 v2 s1 s2 s3 count genv3.
evaluate_exh ck env s1 e1 (s2, Rval v1) &&
evaluate_exh ck env s2 e2 (((count,s3),genv3),Rval v2) &&
do_app_exh env s3 op v1 v2 = Nothing
==>
evaluate_exh ck env s1 (App_exh op e1 e2) (((count,s3),genv3), Rerr Rtype_error)

and

app4 : forall ck env op e1 e2 v1 err s1 s2 s3.
evaluate_exh ck env s1 e1 (s2, Rval v1) &&
evaluate_exh ck env s2 e2 (s3, Rerr err)
==>
evaluate_exh ck env s1 (App_exh op e1 e2) (s3, Rerr err)

and

app5 : forall ck env op e1 e2 err s s'.
evaluate_exh ck env s e1 (s', Rerr err)
==>
evaluate_exh ck env s (App_exh op e1 e2) (s', Rerr err)

and

if1 : forall ck env e1 e2 e3 v e' bv s1 s2.
evaluate_exh ck env s1 e1 (s2, Rval v) &&
do_if_exh v e2 e3 = Just e' &&
evaluate_exh ck env s2 e' bv
==>
evaluate_exh ck env s1 (If_exh e1 e2 e3) bv

and

if2 : forall ck env e1 e2 e3 v s1 s2.
evaluate_exh ck env s1 e1 (s2, Rval v) &&
do_if_exh v e2 e3 = Nothing
==>
evaluate_exh ck env s1 (If_exh e1 e2 e3) (s2, Rerr Rtype_error)

and

if3 : forall ck env e1 e2 e3 err s s'.
evaluate_exh ck env s e1 (s', Rerr err)
==>
evaluate_exh ck env s (If_exh e1 e2 e3) (s', Rerr err)

and

mat1 : forall ck env e pes v bv s1 s2.
evaluate_exh ck env s1 e (s2, Rval v) &&
evaluate_match_exh ck env s2 v pes bv
==>
evaluate_exh ck env s1 (Mat_exh e pes) bv

and

mat2 : forall ck env e pes err s s'.
evaluate_exh ck env s e (s', Rerr err)
==>
evaluate_exh ck env s (Mat_exh e pes) (s', Rerr err)

and

let1 : forall ck env n e1 e2 v bv s1 s2.
evaluate_exh ck env s1 e1 (s2, Rval v) &&
evaluate_exh ck (opt_bind n v env) s2 e2 bv
==>
evaluate_exh ck env s1 (Let_exh n e1 e2) bv

and

let2 : forall ck env n e1 e2 err s s'.
evaluate_exh ck env s e1 (s', Rerr err)
==>
evaluate_exh ck env s (Let_exh n e1 e2) (s', Rerr err)

and

letrec1 : forall ck env funs e bv s.
List.allDistinct (List.map (fun (x,y,z) -> x) funs) &&
evaluate_exh ck (build_rec_env_exh funs env env) s e bv
==>
evaluate_exh ck env s (Letrec_exh funs e) bv

and

letrec2 : forall ck env funs e s.
not (List.allDistinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate_exh ck env s (Letrec_exh funs e) (s, Rerr Rtype_error)

and

extend : forall ck env n s genv.
true
==>
evaluate_exh ck env (s,genv) (Extend_global_exh n) ((s,genv++List.genlist (fun x -> Nothing) n), Rval (Litv_exh Unit))

and

empty : forall ck env s.
true
==>
evaluate_list_exh ck env s [] (s, Rval [])

and

cons1 : forall ck env e es v vs s1 s2 s3.
evaluate_exh ck env s1 e (s2, Rval v) &&
evaluate_list_exh ck env s2 es (s3, Rval vs)
==>
evaluate_list_exh ck env s1 (e::es) (s3, Rval (v::vs))

and

cons2 : forall ck env e es err s s'.
evaluate_exh ck env s e (s', Rerr err)
==>
evaluate_list_exh ck env s (e::es) (s', Rerr err)

and

cons3 : forall ck env e es v err s1 s2 s3.
evaluate_exh ck env s1 e (s2, Rval v) &&
evaluate_list_exh ck env s2 es (s3, Rerr err)
==>
evaluate_list_exh ck env s1 (e::es) (s3, Rerr err)

and

mat_empty : forall ck env v s.
true
==>
evaluate_match_exh ck env s v [] (s, Rerr Rtype_error)

and

mat_cons1 : forall ck env env' v p pes e bv s count genv.
List.allDistinct (pat_bindings_exh p []) &&
pmatch_exh s p v env = Match env' &&
evaluate_exh ck env' ((count,s),genv) e bv
==>
evaluate_match_exh ck env ((count,s),genv) v ((p,e)::pes) bv

and

mat_cons2 : forall ck genv env v p e pes bv s count.
List.allDistinct (pat_bindings_exh p []) &&
pmatch_exh s p v env = No_match &&
evaluate_match_exh ck env ((count,s),genv) v pes bv
==>
evaluate_match_exh ck env ((count,s),genv) v ((p,e)::pes) bv

and

mat_cons3 : forall ck genv env v p e pes s count.
pmatch_exh s p v env = Match_type_error
==>
evaluate_match_exh ck env ((count,s),genv) v ((p,e)::pes) (((count,s),genv), Rerr Rtype_error)

and

mat_cons4 : forall ck env v p e pes s.
not (List.allDistinct (pat_bindings_exh p []))
==>
evaluate_match_exh ck env s v ((p,e)::pes) (s, Rerr Rtype_error)
