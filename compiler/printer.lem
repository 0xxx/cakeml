(* observable values *)

open Ast
open SemanticPrimitives
open CompilerLib
open IntLang
open Bytecode

type ov =
  | OLit of lit
  | OConv of string * list ov
  | OFn
  | OLoc of num (* machine, not semantic, address *)
  | OError (* internal machine value (pointer) that should not appear *)

let rec
id_to_string (Short s) = s
and
id_to_string (Long x y) = x^"."^y

let rec
v_to_ov _ (Litv l) = OLit l
and
v_to_ov s (Conv cn vs) = OConv (id_to_string cn) (List.map (v_to_ov s) vs)
and
v_to_ov _ (Closure _ _ _) = OFn
and
v_to_ov _ (Recclosure _ _ _) = OFn
and
v_to_ov s (Loc n) = OLoc (List.nth s n)

let rec
Cv_to_ov _ _ (CLitv l) = OLit l
and
Cv_to_ov m s (CConv cn vs) = OConv (the "?" (Lib.lookup cn m)) (List.map (Cv_to_ov m s) vs)
and
Cv_to_ov _ _ (CRecClos _ _ _) = OFn
and
Cv_to_ov _ s (CLoc n) = OLoc (List.nth s n)

let rec
bv_to_ov _ (Number i) = OLit (IntLit i)
and
bv_to_ov m (Block n vs) =
  if n = (bool_to_tag false) then OLit (Bool false) else
  if n = (bool_to_tag true) then OLit (Bool true) else
  if n = unit_tag then OLit Unit else
  if n = closure_tag then OFn else
  OConv (the "?" (Lib.lookup (n-block_tag) m)) (List.map (bv_to_ov m) vs)
and
bv_to_ov _ (RefPtr n) = OLoc n
and
bv_to_ov _ _ = OError

let rec
ov_to_string (OLit (IntLit (i:int))) =
  if Int.(<) i i0 then "-"^(string_of_num (num_of_int (neg i)))
  else string_of_num (num_of_int i)
and
ov_to_string (OLit (Bool true)) = "true"
and
ov_to_string (OLit (Bool false)) = "false"
and
ov_to_string (OLit Unit) = "()"
and
ov_to_string (OConv cn vs) =
  cn^" "^
  match intersperse ", " (List.map ov_to_string vs) with
  | [s] -> s
  | ls -> "("^Hol.FLAT ls^")"
  end
and
ov_to_string (OLoc _) = "<ref>"
and
ov_to_string OFn = "<fn>"
and
ov_to_string OError = "<error>"

open Compiler

(* TODO: these two don't belong here *)

let rec
lookup_cc sz st rs (CCArg n) = el_check (sz + n) st
and
lookup_cc sz st rs (CCEnv n) =
  Hol.OPTION_BIND (el_check sz st)
  (fun v -> match v with Block 0 vs -> el_check n vs | _ -> None end)
and
lookup_cc sz st rs (CCRef n) =
  Hol.OPTION_BIND (el_check sz st)
  (fun v -> match v with Block 0 vs ->
     Hol.OPTION_BIND (el_check n vs)
     (fun v -> match v with RefPtr p -> Hol.FLOOKUP rs p | _ -> None end)
   | _ -> None end)

let rec
lookup_ct sz st rs (CTLet n) = if sz < n then None else el_check (sz - n) st
and
lookup_ct sz st rs (CTEnv cc) = lookup_cc sz st rs cc

let stack_index cs v =
  cs.rsz - (List.nth cs.renv (the 0 (find_index v cs.rbvars 0)))

let rec
preprint_dec _ (Dtype _) = []
and
preprint_dec cs (Dlet p _) =
  List.map (fun v -> (stack_index cs v,v)) (pat_bindings p [])
and
preprint_dec cs (Dletrec defs) =
  List.map (fun (v,_,_) -> (stack_index cs v,v)) defs

let simple_printer ds cs stack =
  Hol.FLAT
    (List.map
       (fun (n,v) ->
         "val "^v^" = "^
         (ov_to_string
           (bv_to_ov cs
             (List.nth stack n)))^"\n")
       ds)
