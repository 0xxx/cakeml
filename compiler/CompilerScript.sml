(*Generated by Lem from compiler.lem.*)
open bossLib Theory Parse res_quanTheory
open fixedPointTheory finite_mapTheory listTheory pairTheory pred_setTheory
open integerTheory set_relationTheory sortingTheory stringTheory wordsTheory

val _ = numLib.prefer_num();



open ToBytecodeTheory ToIntLangTheory IntLangTheory CompilerPrimitivesTheory BytecodeTheory CompilerLibTheory SemanticPrimitivesTheory AstTheory LibTheory

val _ = new_theory "Compiler"

(*open Ast*)
(*open CompilerLib*)
(*open IntLang*)
(*open ToIntLang*)
(*open ToBytecode*)

val _ = type_abbrev( "contab" , ``: (( conN id), num)fmap # (num, ( conN id))fmap # num``);
(*val cmap : contab -> Pmap.map (id conN) num*)
 val cmap_def = Define `
 (cmap (m,_,_) = m)`;


val _ = Hol_datatype `
 compiler_state =
  <| contab : contab
   ; rbvars : string list
   ; renv : ctenv
   ; rsz  : num
   ; rnext_label : num
   |>`;


(*val etC : compiler_state -> exp_to_Cexp_state*)
val _ = Define `
 (etC rs = (<| bvars := rs.rbvars; cnmap := ( cmap rs.contab) |>))`;


val _ = Define `
 init_compiler_state =  
(<| contab := ( FEMPTY, FEMPTY, 0)
   ; rbvars := []
   ; renv := []
   ; rsz  := 0
   ; rnext_label := 0
   |>)`;


val _ = Define `
 (compile_Cexp rs decl Ce =  
(let (Ce,n) = ( label_closures ( LENGTH rs.rbvars) rs.rnext_label Ce) in
  let cs = (<| out := []; next_label := n
            ; decl := (rs.renv,rs.rsz,rs.rbvars) |>) in
  let cs = ( compile_code_env cs Ce) in
  let cs = ( compile rs.renv (TCNonTail decl) rs.rsz cs Ce) in
  let rs = (if decl then (case cs.decl of
      (env,sz,bvars) => ( rs with<| renv := env; rsz := sz; rbvars := bvars |>)
    ) else ( rs with<| rsz := rs.rsz + 1 |>)) in
  let rs = (( rs with<| rnext_label := cs.next_label |>)) in
  (rs, REVERSE cs.out)))`;


 val number_constructors_defn = Hol_defn "number_constructors" `

(number_constructors [] ct = ct)
/\
(number_constructors ((c,_)::cs) (m,w,n) =  
(number_constructors cs ( FUPDATE  m ( (Short c), n), FUPDATE  w ( n, (Short c)), (n +1))))`;

val _ = Defn.save_defn number_constructors_defn;

 val compile_dec_defn = Hol_defn "compile_dec" `

(compile_dec rs (Dtype []) = (rs,[]))
/\
(compile_dec rs (Dtype ((_,_,cs)::ts)) =  
(let ct = ( number_constructors cs rs.contab) in
  compile_dec ( rs with<| contab := ct |>) (Dtype ts)))
/\
(compile_dec rs (Dletrec defs) =  
(let m = ( etC rs) in
  let fns = ( MAP (\p . 
  (case (p ) of ( (n,_,_) ) => n )) defs) in
  let m = (( m with<| bvars := fns ++ m.bvars |>)) in
  let Cdefs = ( defs_to_Cdefs m defs) in
  compile_Cexp rs T (CLetrec Cdefs (CDecl ( ZIP ( ( GENLIST (\ i . i) ( LENGTH fns)), fns))))))
/\
(compile_dec rs (Dlet p e) =  
(let m = ( etC rs) in
  let Ce = ( exp_to_Cexp m e) in
  let (m,Cp) = ( pat_to_Cpat ( m with<| bvars := [] |>) p) in
  let vs = (m.bvars) in
  let Cpes = ([(Cp,CDecl ( ZIP ( ( GENLIST (\ i . i) ( LENGTH vs)), vs)))]) in
  compile_Cexp rs T (CLet Ce (remove_mat_var 0 Cpes))))`;

val _ = Defn.save_defn compile_dec_defn;

val _ = Define `
 (compile_exp s exp = ( compile_Cexp s F (exp_to_Cexp (etC s) exp)))`;

val _ = export_theory()

