(*Generated by Lem from compiler.lem.*)
open bossLib Theory Parse res_quanTheory
open fixedPointTheory finite_mapTheory listTheory pairTheory pred_setTheory
open integerTheory set_relationTheory sortingTheory stringTheory wordsTheory

val _ = numLib.prefer_num();



open ToBytecodeTheory ToIntLangTheory IntLangTheory CompilerPrimitivesTheory BytecodeTheory CompilerLibTheory SemanticPrimitivesTheory AstTheory LibTheory

val _ = new_theory "Compiler"

(*open Ast*)
(*open CompilerLib*)
(*open IntLang*)
(*open ToIntLang*)
(*open ToBytecode*)
(*open Bytecode*)

val _ = type_abbrev( "contab" , ``: (( conN id), num)fmap # (num # conN id) list # num``);
(*val cmap : contab -> Pmap.map (id conN) num*)
 val cmap_def = Define `
 (cmap (m,_,_) = m)`;


val _ = Hol_datatype `
 compiler_state =
  <| contab : contab
   ; renv : (string # num) list
   ; rmenv : (string, ( (string # num)list))fmap
   ; rsz : num
   ; rnext_label : num
   |>`;


(*val cpam : compiler_state -> list (num * id conN)*)
 val cpam_def = Define `
 (cpam s = ((case s.contab of (_,w,_) => w )))`;


val _ = Define `
 init_compiler_state =  
(<| contab := ( FUPDATE 
               ( FUPDATE 
                ( FUPDATE FEMPTY ( (Short ""), tuple_cn)) ( (Short "Bind"), bind_exc_cn)) ( (Short "Div"), div_exc_cn)
              (* TODO: don't need to store n, use length of list? *)
              ,[(tuple_cn,Short "");(bind_exc_cn,Short "Bind");(div_exc_cn,Short "Div")]
              ,3)
   ; renv := []
   ; rmenv := FEMPTY
   ; rsz := 0
   ; rnext_label := 0
   |>)`;


val _ = Define `
 (compile_Cexp rsz menv env nl Ce =  
(let (Ce,n) = ( label_closures ( LENGTH env) nl Ce) in
  let cs = (<| out := []; next_label := n |>) in
  let cs = ( emit cs [PushPtr (Addr 0); PushExc]) in
  let cs = ( compile_code_env menv cs Ce) in
  compile menv env TCNonTail (rsz +2) cs Ce))`;


 val number_constructors_defn = Hol_defn "number_constructors" `

(number_constructors _ [] ct = ct)
/\
(number_constructors mn ((c,_)::cs) (m,w,n) =  
(number_constructors mn cs ( FUPDATE  m ( (mk_id mn c), n), ((n,mk_id mn c) ::w), (n +1))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn number_constructors_defn;

 val compile_news_defn = Hol_defn "compile_news" `

(compile_news cs i [] = cs)
/\
(compile_news cs i (_::vs) =  
(let cs = ( emit cs ( MAP Stack [Load 0; Load 0; El i; Store 1])) in
  compile_news cs (i +1) vs))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn compile_news_defn;

val _ = Define `
 (compile_fake_exp rs vs e =  
(let m = (<| bvars := ( MAP FST rs.renv)
           ; mvars := ( (o_f) ( MAP FST) rs.rmenv)
           ; cnmap := ( cmap rs.contab)
           |>) in
  let Ce = ( exp_to_Cexp m (e (Con (Short "") ( MAP (\ v . Var (Short v)) vs)))) in
  let menv = ( (o_f) ( MAP SND) rs.rmenv) in
  let env = ( MAP ((o) CTDec SND) rs.renv) in
  let cs = ( compile_Cexp rs.rsz menv env rs.rnext_label Ce) in
  let cs = ( emit cs [PopExc; Stack (Pops 1)]) in
  let cs = ( compile_news cs 0 vs) in
  let cs = ( emit cs [Stack Pop]) in
  (rs.contab
  , GENLIST (\ i . ( EL  i  vs, (rs.rsz +i))) ( LENGTH vs)
  ,cs.next_label
  ,cs.out
  )))`;


 val compile_dec_def = Define `

(compile_dec mn rs (Dtype ts) =  
(let ct = ( FOLDL
      (\ct p . (case (ct ,p ) of ( ct , (_,_,cs) ) => number_constructors mn cs ct ))
      rs.contab ts) in
  (ct,[],rs.rnext_label,[])))
/\
(compile_dec _ rs (Dletrec defs) =  
(let vs = ( MAP (\p . 
  (case (p ) of ( (n,_,_) ) => n )) defs) in
  compile_fake_exp rs vs (\ b . Letrec defs b)))
/\
(compile_dec _ rs (Dlet p e) =  
(let vs = ( pat_bindings p []) in
  compile_fake_exp rs vs (\ b . Mat e [(p,b)])))`;


 val compile_decs_defn = Hol_defn "compile_decs" `

(compile_decs _ [] ac = ac)
/\
(compile_decs mn (dec::decs) (rs,code) =  
(let (ct,env,nl,code) = ( compile_dec (SOME mn) rs dec) in
  compile_decs mn decs
    (( rs with<|
        contab := ct
      ; renv := env ++rs.renv
      ; rsz := rs.rsz + LENGTH env
      ; rnext_label := nl |>)
    ,code)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn compile_decs_defn;

 val compile_top_def = Define `

(compile_top rs (Tmod mn _ decs) =  
(let (mrs,code) = ( compile_decs mn decs (rs,[])) in
  let env = ( BUTLASTN ( LENGTH rs.renv) rs.renv) in
  (( mrs with<|
      renv := rs.renv
    ; rmenv := FUPDATE  rs.rmenv ( mn, env)
    ; rsz := rs.rsz + LENGTH env |>)
  ,( rs with<| rnext_label := mrs.rnext_label |>)
  , REVERSE (Stop ::code))))
/\
(compile_top rs (Tdec dec) =  
(let (ct,env,nl,code) = ( compile_dec NONE rs dec) in
  (( rs with<|
      contab := ct
    ; renv := env ++rs.renv
    ; rsz := rs.rsz + LENGTH env
    ; rnext_label := nl |>)
  ,( rs with<| rnext_label := nl |>)
  , REVERSE (Stop ::code))))`;

val _ = export_theory()

