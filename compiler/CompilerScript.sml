(*Generated by Lem from compiler.lem.*)
open bossLib Theory Parse res_quanTheory
open fixedPointTheory finite_mapTheory listTheory pairTheory pred_setTheory
open integerTheory set_relationTheory sortingTheory stringTheory wordsTheory

val _ = numLib.prefer_num();



open ToBytecodeTheory ToIntLangTheory IntLangTheory CompilerPrimitivesTheory BytecodeTheory CompilerLibTheory SemanticPrimitivesTheory AstTheory LibTheory

val _ = new_theory "Compiler"

(*open Ast*)
(*open CompilerLib*)
(*open IntLang*)
(*open ToIntLang*)
(*open ToBytecode*)
(*open Bytecode*)

val _ = type_abbrev( "contab" , ``: (( conN id), num)fmap # (num # string) list # num``);
(*val cmap : contab -> Pmap.map (id conN) num*)
 val cmap_def = Define `
 (cmap (m,_,_) = m)`;


val _ = Hol_datatype `
 compiler_state =
  <| contab : contab
   ; rbvars : string list
   ; rnext_label : num
   |>`;


(*val cpam : compiler_state -> list (num * string)*)
 val cpam_def = Define `
 (cpam s = ((case s.contab of (_,w,_) => w )))`;


(*val etC : compiler_state -> exp_to_Cexp_state*)
val _ = Define `
 (etC rs = (<| bvars := rs.rbvars; cnmap := ( cmap rs.contab) |>))`;


val _ = Define `
 init_compiler_state =  
(<| contab := ( FEMPTY, [], 0)
   ; rbvars := []
   ; rnext_label := 0
   |>)`;


val _ = Define `
 (compile_Cexp rs Ce =  
(let rsz = ( LENGTH rs.rbvars) in
  let (Ce,n) = ( label_closures rsz rs.rnext_label Ce) in
  let cs = (<| out := []; next_label := n |>) in
  let cs = ( compile_code_env cs Ce) in
  compile ( GENLIST (\ i . CTLet (rsz - i)) rsz) TCNonTail rsz cs Ce))`;


 val number_constructors_defn = Hol_defn "number_constructors" `

(number_constructors [] ct = ct)
/\
(number_constructors ((c,_)::cs) (m,w,n) =  
(number_constructors cs ( FUPDATE  m ( (Short c), n), ((n,c) ::w), (n +1))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn number_constructors_defn;

 val compile_shadows_defn = Hol_defn "compile_shadows" `

(compile_shadows bvs cs i [] = cs)
/\
(compile_shadows bvs cs i (v::vs) =  
(let j = ( the 0 (find_index v bvs 1)) in
  let cs = ( emit cs ( MAP Stack [Load 0; El i; Store j])) in
  compile_shadows bvs cs (i +1) vs))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn compile_shadows_defn;

 val compile_news_defn = Hol_defn "compile_news" `

(compile_news cs i [] = cs)
/\
(compile_news cs i (v::vs) =  
(let cs = ( emit cs ( MAP Stack [Load 0; Load 0; El i; Store 1])) in
  compile_news cs (i +1) vs))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn compile_news_defn;

val _ = Define `
 (compile_fake_exp rs vs e =  
(let m = ( etC rs) in
  let cn = (Short "") in
  let (shadows,news) = ( PARTITION (\ v . MEM v rs.rbvars) vs) in
  let Ce = ( exp_to_Cexp ( m with<| cnmap := FUPDATE  m.cnmap ( cn, 0) |>)
           (e (Con cn ( MAP (\ v . Var (Short v)) (shadows ++news))))) in
  let cs = ( compile_Cexp rs Ce) in
  let cs = ( compile_shadows rs.rbvars cs 0 shadows) in
  let cs = ( compile_news cs ( LENGTH shadows) news) in
  let cs = ( emit cs [Stack Pop; Stack (PushInt i0)]) in
  (( rs with<| rbvars := ( REVERSE news) ++rs.rbvars
    ; rnext_label := cs.next_label |>)
  , REVERSE cs.out)))`;


 val compile_dec_def = Define `

(compile_dec rs (Dtype ts) =
  (( rs with<| contab := FOLDL
        (\ct p . (case (ct ,p ) of ( ct , (_,_,cs) ) => number_constructors cs ct ))
        rs.contab ts |>)
  ,[Stack (PushInt i0)]))
/\
(compile_dec rs (Dletrec defs) =  
(let vs = ( MAP (\p . 
  (case (p ) of ( (n,_,_) ) => n )) defs) in
  compile_fake_exp rs vs (\ b . Letrec defs b)))
/\
(compile_dec rs (Dlet p e) =  
(let vs = ( pat_bindings p []) in
  compile_fake_exp rs vs (\ b . Mat e [(p,b)])))`;

val _ = export_theory()

