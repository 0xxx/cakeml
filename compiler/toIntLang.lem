(* Translation from IL4 to Intermediate Language *)
open import Pervasives

open import Lib
open import CompilerLib
open import IntLang
open import Ast
open import ConLang
open import PatLang

let rec
free_vars (CRaise e) = free_vars e
and
free_vars (CHandle e1 e2) = lunion (free_vars e1) (lshift 1 (free_vars e2))
and
free_vars (CVar n) = [n]
and
free_vars (CGvar _) = []
and
free_vars (CLit _) = []
and
free_vars (CCon _ es) = free_vars_list es
and
free_vars (CLet bd e eb) = lunion (free_vars e) (if bd then lshift 1 (free_vars eb) else free_vars eb)
and
free_vars (CLetrec defs e) =
  let n = List.length defs in
  lunion (free_vars_defs n defs) (lshift n (free_vars e))
and
free_vars (CCall _ e es) = lunion (free_vars e) (free_vars_list es)
and
free_vars (CPrim1 _ e) = free_vars e
and
free_vars (CPrim2 _ e1 e2) = lunion (free_vars e1) (free_vars e2)
and
free_vars (CUpd e1 e2) = lunion (free_vars e1) (free_vars e2)
and
free_vars (CIf e1 e2 e3) = lunion (free_vars e1) (lunion (free_vars e2) (free_vars e3))
and
free_vars (CExtG _) = []
and
free_vars_list [] = []
and
free_vars_list (e::es) = lunion (free_vars e) (free_vars_list es)
and
free_vars_defs _ [] = []
and
free_vars_defs n (d::ds) = lunion (free_vars_def n d) (free_vars_defs n ds)
and
free_vars_def n (Nothing,(k,e)) = lshift (n+k) (free_vars e)
and
free_vars_def _ (Just _,_) = []

let rec
mkshift f k (CRaise e) = CRaise (mkshift f k e)
and
mkshift f k (CHandle e1 e2) = CHandle (mkshift f k e1) (mkshift f (k+1) e2)
and
mkshift f k (CVar v) = CVar (if v < k then v else (f (v-k))+k)
and
mkshift _ _ (CGvar v) = CGvar v
and
mkshift _ _ (CLit l) = CLit l
and
mkshift f k (CCon cn es) = CCon cn (List.map (mkshift f k) es)
and
mkshift f k (CLet bd e b) = CLet bd (mkshift f k e) (mkshift f (if bd then k+1 else k) b)
and
mkshift f k (CLetrec defs b) =
  let ns = List.length defs in
  let defs = List.map (fun cb ->
    match cb with | (Just _,_) -> cb | (Nothing,(az,b)) -> (Nothing,(az,mkshift f (k+ns+az) b)) end)
    defs in
  CLetrec defs (mkshift f (k+ns) b)
and
mkshift f k (CCall ck e es) = CCall ck (mkshift f k e) (List.map (mkshift f k) es)
and
mkshift f k (CPrim1 p1 e) = CPrim1 p1 (mkshift f k e)
and
mkshift f k (CPrim2 p2 e1 e2) = CPrim2 p2 (mkshift f k e1) (mkshift f k e2)
and
mkshift f k (CUpd e1 e2) = CUpd (mkshift f k e1) (mkshift f k e2)
and
mkshift f k (CIf e1 e2 e3) = CIf (mkshift f k e1) (mkshift f k e2) (mkshift f k e3)
and
mkshift _ _ (CExtG n) = CExtG n

let shift n = mkshift (fun v -> v+n)

let rec
opn_to_prim2 Plus = Left CAdd
and
opn_to_prim2 Minus = Left CSub
and
opn_to_prim2 Times = Left CMul
and
opn_to_prim2 Divide = Right CDiv
and
opn_to_prim2 Modulo = Right CMod

let rec
exp_to_Cexp (Handle_pat e1 e2) =
  CHandle (exp_to_Cexp e1) (exp_to_Cexp e2)
and
exp_to_Cexp (Raise_pat e) = CRaise (exp_to_Cexp e)
and
exp_to_Cexp (Lit_pat l) = CLit l
and
exp_to_Cexp (Con_pat cn es) =
  CCon cn (exps_to_Cexps es)
and
exp_to_Cexp (Var_local_pat vn) = CVar vn
and
exp_to_Cexp (Var_global_pat vn) = CGvar vn
and
exp_to_Cexp (Fun_pat e) =
  CLetrec [(Nothing,(1,shift 1 1 (exp_to_Cexp e)))] (CVar 0)
and
exp_to_Cexp (App_pat op es) =
  match (op,exps_to_Cexps es) with
  | (Op_pat (Op_i2 (Opn opn)), [Ce1; Ce2]) ->
    match opn_to_prim2 opn with
    | Left p2 -> CPrim2 p2 Ce1 Ce2
    | Right p2 ->
      CLet true Ce1
        (CLet true (shift 1 0 Ce2)
          (CIf (CPrim2 CEq (CVar 0) (CLit (IntLit 0)))
               (CRaise (CCon div_tag []))
               (CPrim2 p2 (CVar 1) (CVar 0))))
    end
  | (Op_pat (Op_i2 (Opb opb)), [Ce1; Ce2]) ->
    match opb with
    | Lt -> CPrim2 CLt Ce1 Ce2
    | Leq -> CPrim2 CLt (CPrim2 CSub Ce1 Ce2) (CLit (IntLit 1))
    | opb ->
        CLet true Ce1 (
          CLet true (shift 1 0 Ce2) (
            match opb with
            | Gt ->  CPrim2 CLt (CVar 0) (CVar 1)
            | Geq -> CPrim2 CLt (CPrim2 CSub (CVar 0) (CVar 1)) (CLit (IntLit 1))
            | _ -> CLit (IntLit 0) (* should not happen *)
            end))
    end
  | (Op_pat (Op_i2 Equality), [Ce1; Ce2]) ->
    CLet true (CPrim2 CEq Ce1 Ce2)
      (CIf (CPrim1 CIsBlock (CVar 0)) (CVar 0) (CRaise (CCon eq_tag [])))
  | (Op_pat (Op_i2 Opapp), [Ce1; Ce2]) ->
    CCall true Ce1 [Ce2]
  | (Op_pat (Op_i2 Opassign), [Ce1; Ce2]) ->
    CUpd Ce1 Ce2
  | (Op_pat (Op_i2 op), [Ce]) ->
    CPrim1
    (match op with
     | Opref -> CRef
     | Opderef -> CDer
     | _ -> CDer (* should not happen *)
     end) Ce
   | (Op_pat (Init_global_var_i2 n), [Ce]) ->
     CPrim1 (CInitG n) Ce
   | (op, [Ce]) ->
     CPrim1
     (match op with
      | Tag_eq_pat n -> CTagEq n
      | El_pat n -> CProj n
      end) Ce
   | _ -> CLit (IntLit 0) (* should not happen *)
   end
and
exp_to_Cexp (If_pat e1 e2 e3) =
  let Ce1 = exp_to_Cexp e1 in
  let Ce2 = exp_to_Cexp e2 in
  let Ce3 = exp_to_Cexp e3 in
  CIf Ce1 Ce2 Ce3
and
exp_to_Cexp (Let_pat e b) =
  let Ce = exp_to_Cexp e in
  let Cb = exp_to_Cexp b in
  CLet true Ce Cb
and
exp_to_Cexp (Seq_pat e b) =
  let Ce = exp_to_Cexp e in
  let Cb = exp_to_Cexp b in
  CLet false Ce Cb
and
exp_to_Cexp (Letrec_pat defs b) =
  CLetrec (List.map (fun e -> (Nothing,(1,e))) (exps_to_Cexps defs)) (exp_to_Cexp b)
and
exp_to_Cexp (Extend_global_pat n) = CExtG n
and
exps_to_Cexps [] = []
and
exps_to_Cexps (e::es) =
  exp_to_Cexp e :: exps_to_Cexps es

(* source to intermediate values *)

let rec
v_to_Cv (Litv_pat l) = CLitv l
and
v_to_Cv (Conv_pat cn vs) =
  CConv cn (vs_to_Cvs vs)
and
v_to_Cv (Closure_pat env e) =
  let Cenv = vs_to_Cvs env in
  let Ce = exp_to_Cexp e in
  CRecClos Cenv [(Nothing, (1,shift 1 1 Ce))] 0
and
v_to_Cv (Recclosure_pat env defs vn) =
  let Cenv = vs_to_Cvs env in
  let Cdefs = (List.map (fun e -> (Nothing,(1,e))) (exps_to_Cexps defs)) in
  CRecClos Cenv Cdefs vn
and
v_to_Cv (Loc_pat n) = CLoc n
and
vs_to_Cvs [] = []
and
vs_to_Cvs (v::vs) = v_to_Cv v :: vs_to_Cvs vs
