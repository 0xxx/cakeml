(* Translation from CakeML to Intermediate Language *)
open import Pervasives

open import Lib
open import CompilerLib
open import IntLang
open import Ast
import {hol} `miscTheory`

(* TODO: Lem's builtin find index has a different type *)
val find_index : forall 'a. 'a -> list 'a -> nat -> maybe nat
declare hol target_rep function find_index = `misc$find_index` (* to pick up the definition in miscTheory *)

let rec
free_vars (CRaise e) = free_vars e
and
free_vars (CHandle e1 e2) = lunion (free_vars e1) (lshift 1 (free_vars e2))
and
free_vars (CVar n) = [n]
and
free_vars (CGvar _) = []
and
free_vars (CLit _) = []
and
free_vars (CCon _ es) = free_vars_list es
and
free_vars (CLet bd e eb) = lunion (free_vars e) (if bd then lshift 1 (free_vars eb) else free_vars eb)
and
free_vars (CLetrec defs e) =
  let n = List.length defs in
  lunion (free_vars_defs n defs) (lshift n (free_vars e))
and
free_vars (CCall _ e es) = lunion (free_vars e) (free_vars_list es)
and
free_vars (CPrim1 _ e) = free_vars e
and
free_vars (CPrim2 _ e1 e2) = lunion (free_vars e1) (free_vars e2)
and
free_vars (CUpd e1 e2) = lunion (free_vars e1) (free_vars e2)
and
free_vars (CIf e1 e2 e3) = lunion (free_vars e1) (lunion (free_vars e2) (free_vars e3))
and
free_vars (CExtG _) = []
and
free_vars_list [] = []
and
free_vars_list (e::es) = lunion (free_vars e) (free_vars_list es)
and
free_vars_defs _ [] = []
and
free_vars_defs n (d::ds) = lunion (free_vars_def n d) (free_vars_defs n ds)
and
free_vars_def n (Nothing,(k,e)) = lshift (n+k) (free_vars e)
and
free_vars_def _ (Just _,_) = []

let rec
mkshift f k (CRaise e) = CRaise (mkshift f k e)
and
mkshift f k (CHandle e1 e2) = CHandle (mkshift f k e1) (mkshift f (k+1) e2)
and
mkshift f k (CVar v) = CVar (if v < k then v else (f (v-k))+k)
and
mkshift _ _ (CGvar v) = CGvar v
and
mkshift _ _ (CLit l) = CLit l
and
mkshift f k (CCon cn es) = CCon cn (List.map (mkshift f k) es)
and
mkshift f k (CLet bd e b) = CLet bd (mkshift f k e) (mkshift f (if bd then k+1 else k) b)
and
mkshift f k (CLetrec defs b) =
  let ns = List.length defs in
  let defs = List.map (fun cb ->
    match cb with | (Just _,_) -> cb | (Nothing,(az,b)) -> (Nothing,(az,mkshift f (k+ns+az) b)) end)
    defs in
  CLetrec defs (mkshift f (k+ns) b)
and
mkshift f k (CCall ck e es) = CCall ck (mkshift f k e) (List.map (mkshift f k) es)
and
mkshift f k (CPrim1 p1 e) = CPrim1 p1 (mkshift f k e)
and
mkshift f k (CPrim2 p2 e1 e2) = CPrim2 p2 (mkshift f k e1) (mkshift f k e2)
and
mkshift f k (CUpd e1 e2) = CUpd (mkshift f k e1) (mkshift f k e2)
and
mkshift f k (CIf e1 e2 e3) = CIf (mkshift f k e1) (mkshift f k e2) (mkshift f k e3)
and
mkshift _ _ (CExtG n) = CExtG n

let shift n = mkshift (fun v -> v+n)

let rec
opn_to_prim2 Plus = Left CAdd
and
opn_to_prim2 Minus = Left CSub
and
opn_to_prim2 Times = Left CMul
and
opn_to_prim2 Divide = Right CDiv
and
opn_to_prim2 Modulo = Right CMod

(*

let rec
exp_to_Cexp m (Handle e pes) =
  let Ce = exp_to_Cexp m e in
  let Cpes = pes_to_Cpes m pes in
  let Cpes = List.map (fun (p,e) -> (p,shift 1 (Cpat_vars p) e)) Cpes in
  CHandle Ce (remove_mat_var true 0 Cpes)
and
exp_to_Cexp m (Raise e) = CRaise (exp_to_Cexp m e)
and
exp_to_Cexp _ (Lit l) = CLit l
and
exp_to_Cexp m (Con cn es) =
  CCon (fapply 0 cn m.cnmap) (exps_to_Cexps m es)
and
exp_to_Cexp m (Var (Short vn)) = CVar (Short (the 0 (find_index vn m.bvars 0)))
and
exp_to_Cexp m (Var (Long mn vn)) = CVar (Long mn (the 0 (find_index vn (fapply [] mn m.mvars) 0)))
and
exp_to_Cexp m (Fun vn e) =
  CLetrec [(Nothing,(1,shift 1 1 (exp_to_Cexp (cbv m vn) e)))] (CVar (Short 0))
and
exp_to_Cexp m (App (Opn opn) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  match opn_to_prim2 opn with
  | Left p2 -> CPrim2 p2 Ce1 Ce2
  | Right p2 ->
    CLet Ce1
      (CLet (shift 1 0 Ce2)
        (CIf (CPrim2 CEq (CVar (Short 0)) (CLit (IntLit 0)))
             (CRaise CDiv_exc)
             (CPrim2 p2 (CVar (Short 1)) (CVar (Short 0)))))
  end
and
exp_to_Cexp m (App (Opb opb) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  match opb with
  | Lt -> CPrim2 CLt Ce1 Ce2
  | Leq -> CPrim2 CLt (CPrim2 CSub Ce1 Ce2) (CLit (IntLit 1))
  | opb ->
      CLet Ce1 (
        CLet (shift 1 0 Ce2) (
          match opb with
          | Gt ->  CPrim2 CLt (CVar (Short 0)) (CVar (Short 1))
          | Geq -> CPrim2 CLt (CPrim2 CSub (CVar (Short 0)) (CVar (Short 1))) (CLit (IntLit 1))
          | _ -> CRaise CBind_exc (* should not happen *)
          end))
  end
and
exp_to_Cexp m (App Equality e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CLet (CPrim2 CEq Ce1 Ce2)
    (CIf (CPrim1 CIsBlock (CVar (Short 0))) (CVar (Short 0)) (CRaise CEq_exc))
and
exp_to_Cexp m (App Opapp e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CCall true Ce1 [Ce2]
and
exp_to_Cexp m (App Opassign e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CUpd Ce1 Ce2
and
exp_to_Cexp m (Uapp uop e) =
  let Ce = exp_to_Cexp m e in
  CPrim1 (match uop with
          | Opref   -> CRef
          | Opderef -> CDer
          end) Ce
and
exp_to_Cexp m (Log log e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  (match log with
   | And -> CIf Ce1 Ce2 (CLit (Bool false))
   | Or  -> CIf Ce1 (CLit (Bool true)) Ce2
   end)
and
exp_to_Cexp m (If e1 e2 e3) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  let Ce3 = exp_to_Cexp m e3 in
  CIf Ce1 Ce2 Ce3
and
exp_to_Cexp m (Mat e pes) =
  let Ce = exp_to_Cexp m e in
  let Cpes = pes_to_Cpes m pes in
  let Cpes = List.map (fun (p,e) -> (p,shift 1 (Cpat_vars p) e)) Cpes in
  CLet Ce (remove_mat_var false 0 Cpes)
and
exp_to_Cexp m (Let vn e b) =
  let Ce = exp_to_Cexp m e in
  let Cb = exp_to_Cexp (cbv m vn) b in
  CLet Ce Cb
and
exp_to_Cexp m (Letrec defs b) =
  let m = <| m with bvars = (List.map (fun (n,_,_) -> n) defs) ++ m.bvars |> in
  CLetrec (defs_to_Cdefs m defs) (exp_to_Cexp m b)
and
defs_to_Cdefs _ [] = []
and
defs_to_Cdefs m ((_,vn,e)::defs) =
  let Ce = exp_to_Cexp (cbv m vn) e in
  let Cdefs = defs_to_Cdefs m defs in
  (Nothing,(1,Ce))::Cdefs
and
pes_to_Cpes _ [] = []
and
pes_to_Cpes m ((p,e)::pes) =
  let Cpes = pes_to_Cpes m pes in
  let (m,Cp) = pat_to_Cpat m p in
  let Ce = exp_to_Cexp m e in
  (Cp,Ce)::Cpes
and
exps_to_Cexps _ [] = []
and
exps_to_Cexps m (e::es) =
  exp_to_Cexp m e :: exps_to_Cexps m es

(* source to intermediate values *)

open SemanticPrimitives

let rec
v_to_Cv _ _ (Litv l) = CLitv l
and
v_to_Cv mv m (Conv cn vs) =
  CConv (fapply 0 cn m) (vs_to_Cvs mv m vs)
and
v_to_Cv mv m (Closure env vn e) =
  let Cenv = env_to_Cenv mv m env in
  let m = <| bvars = List.map fst env ; mvars = mv; cnmap = m |> in
  let Ce = exp_to_Cexp (cbv m vn) e in
  CRecClos Cenv [(Nothing, (1,shift 1 1 Ce))] 0
and
v_to_Cv mv m (Recclosure env defs vn) =
  let Cenv = env_to_Cenv mv m env in
  let m = <| bvars = List.map fst env ; mvars = mv; cnmap = m |> in
  let fns = List.map (fun (n,_,_) -> n) defs in
  let m = <| m with bvars = fns ++ m.bvars |> in
  let Cdefs = defs_to_Cdefs m defs in
  CRecClos Cenv Cdefs (the 0 (find_index vn fns 0))
and
v_to_Cv _ _ (Loc n) = CLoc n
and
vs_to_Cvs _ _ [] = []
and
vs_to_Cvs mv m (v::vs) = v_to_Cv mv m v :: vs_to_Cvs mv m vs
and
env_to_Cenv _ _ [] = []
and
env_to_Cenv mv m ((_,v)::env) =
  (v_to_Cv mv m v)::(env_to_Cenv mv m env)
  *)
