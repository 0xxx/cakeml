(* The third intermediate language (IL3). Removes declarations.
 *
 * The AST of IL3 differs from IL2 in that there is no declarations level, the
 * program is represented by a sequence of expressions.
 *
 * The values of IL3 are the same as IL2.
 *
 * The semantics of IL3 differ in that the global environment is now store-like
 * rather than environment-like. The expressions for extending and initialising
 * it modify the global environment (instread of just rasing a type error).
 *
 * The translator to IL3 maps a declaration to an expression that sets of the
 * global environment in the right way.
 *
 *)

open import Pervasives
open import Lib
open import Ast
open import SemanticPrimitives
open import List_extra
open import BigStep
open import IntLang2

val init_globals : nat -> nat -> list (pat_i2 * exp_i2)
let rec init_globals next 0 = []
and init_globals next num =
  let var = "x" ^ String_extra.show num in
    (Pvar_i2 var, Uapp_i2 (Init_global_var_i2 (next+num)) (Var_local_i2 var)) :: init_globals next (num - 1)

declare termination_argument init_globals = automatic

val init_global_funs : nat -> list (varN * varN * exp_i2) -> exp_i2
let rec init_global_funs next [] = Lit_i2 Unit
and init_global_funs next ((f,x,e)::funs) =
  Let_i2 Nothing (Uapp_i2 (Init_global_var_i2 next) (Fun_i2 x e)) (init_global_funs (next+1) funs)

declare termination_argument init_global_funs = automatic

val decs_to_i3 : nat -> list dec_i2 -> exp_i2
let rec decs_to_i3 next [] = Lit_i2 Unit
and decs_to_i3 next (d::ds) =
  match d with
    | Dlet_i2 n e ->
        Let_i2 Nothing (Mat_i2 e (init_globals next n)) (decs_to_i3 (next+n) ds)
    | Dletrec_i2 funs ->
        let n = List.length funs in
          Let_i2 Nothing (init_global_funs next funs) (decs_to_i3 (next+n) ds)
  end

declare termination_argument decs_to_i3 = automatic

val num_defs : list dec_i2 -> nat
let rec num_defs [] = 0
and num_defs (d::ds) =
  match d with
    | Dlet_i2 n e -> n + num_defs ds
    | Dletrec_i2 funs -> List.length funs + num_defs ds
  end

declare termination_argument num_defs = automatic

val prompt_to_i3 : nat -> prompt_i2 -> nat * exp_i2
let prompt_to_i3 next prompt =
  match prompt with
    | Prompt_i2 ds ->
        let n = num_defs ds in
          (next+n, Let_i2 Nothing (Extend_global_i2 n) (Handle_i2 (decs_to_i3 next ds) [(Pvar_i2 "x", Var_local_i2 "x")]))
  end

val prog_to_i3 : nat -> list prompt_i2 -> nat * exp_i2
let rec 
prog_to_i3 next [] = (next, Lit_i2 Unit)
and 
prog_to_i3 next (p::ps) = 
  let (next',p') = prompt_to_i3 next p in
  let (next'',ps') = prog_to_i3 next' ps in
    (next'',Let_i2 Nothing p' ps')

declare termination_argument prog_to_i2 = automatic

val do_uapp_i3 : store v_i2 * list (maybe v_i2) -> uop_i2 -> v_i2 -> maybe ((store v_i2 * list (maybe v_i2)) * v_i2)
let do_uapp_i3 (s,genv) uop v =
  match uop with
    | Opderef_i2 ->
        match v with
          | Loc_i2 n ->
              match store_lookup n s with
                | Just v -> Just ((s,genv),v)
                | Nothing -> Nothing
              end
          | _ -> Nothing
        end
    | Opref_i2 ->
        let (s',n) = store_alloc v s in
          Just ((s',genv), Loc_i2 n)
    | Init_global_var_i2 idx ->
        if idx < List.length genv then
          match List_extra.nth genv idx with
            | Nothing -> Just ((s, List.update genv idx (Just v)), Litv_i2 Unit)
            | Just x -> Nothing
          end
        else
          Nothing
  end

type count_store_genv 'a = count_store 'a * list (maybe 'a)

indreln [evaluate_i3 : bool -> env varN v_i2 -> count_store_genv v_i2 -> exp_i2 -> count_store_genv v_i2 * result v_i2 v_i2 -> bool]
and [evaluate_list_i3 : bool -> env varN v_i2 -> count_store_genv v_i2 -> list exp_i2 -> count_store_genv v_i2 * result (list v_i2) v_i2 -> bool]
and [evaluate_match_i3 : bool -> env varN v_i2 -> count_store_genv v_i2 -> v_i2 -> list (pat_i2 * exp_i2) -> count_store_genv v_i2 * result v_i2 v_i2 -> bool]

lit : forall ck env l s.
true
==>
evaluate_i3 ck env s (Lit_i2 l) (s, Rval (Litv_i2 l))

and

raise1 : forall ck env e s1 s2 v.
evaluate_i3 ck s1 env e (s2, Rval v)
==>
evaluate_i3 ck s1 env (Raise_i2 e) (s2, Rerr (Rraise v))

and

raise2 : forall ck env e s1 s2 err.
evaluate_i3 ck s1 env e (s2, Rerr err)
==>
evaluate_i3 ck s1 env (Raise_i2 e) (s2, Rerr err)

and

handle1 : forall ck s1 s2 env e v pes.
evaluate_i3 ck s1 env e (s2, Rval v)
==>
evaluate_i3 ck s1 env (Handle_i2 e pes) (s2, Rval v)

and

handle2 : forall ck s1 s2 env e pes v bv.
evaluate_i3 ck env s1 e (s2, Rerr (Rraise v)) &&
evaluate_match_i3 ck env s2 v pes bv
==>
evaluate_i3 ck env s1 (Handle_i2 e pes) bv

and

handle3 : forall ck s1 s2 env e pes err.
evaluate_i3 ck env s1 e (s2, Rerr err) &&
(err = Rtimeout_error || (err = Rtype_error))
==>
evaluate_i3 ck env s1 (Handle_i2 e pes) (s2, Rerr err)

and

con1 : forall ck env tag es vs s s'.
evaluate_list_i3 ck env s es (s', Rval vs)
==>
evaluate_i3 ck env s (Con_i2 tag es) (s', Rval (Conv_i2 tag vs))

and

con3 : forall ck env tag es err s s'.
evaluate_list_i3 ck env s es (s', Rerr err)
==>
evaluate_i3 ck env s (Con_i2 tag es) (s', Rerr err)

and

var1 : forall ck env n v s.
(lookup n env = Just v)
==>
evaluate_i3 ck env s (Var_local_i2 n) (s, Rval v)

and

var2 : forall ck env n s.
(lookup n env = Nothing)
==>
evaluate_i3 ck env s (Var_local_i2 n) (s, Rerr Rtype_error)

and

var3 : forall ck env n v s genv.
(List.length genv > n) &&
(List_extra.nth genv n = Just v)
==>
evaluate_i3 ck env (s,genv) (Var_global_i2 n) ((s,genv), Rval v)

and

var4 : forall ck env n s genv.
(List.length genv > n) &&
(List_extra.nth genv n = Nothing)
==>
evaluate_i3 ck env (s,genv) (Var_global_i2 n) ((s,genv), Rerr Rtype_error)

and

var5 : forall ck env n s genv.
not (List.length genv > n)
==>
evaluate_i3 ck env (s,genv) (Var_global_i2 n) ((s,genv), Rerr Rtype_error)

and

fn : forall ck env n e s.
true
==>
evaluate_i3 ck env s (Fun_i2 n e) (s, Rval (Closure_i2 env n e))

and

uapp1 : forall ck env uop e v v' s1 s2 count s3 genv2 genv3.
evaluate_i3 ck env s1 e (((count,s2),genv2), Rval v) &&
(do_uapp_i3 (s2,genv2) uop v = Just ((s3,genv3),v'))
==>
evaluate_i3 ck env s1 (Uapp_i2 uop e) (((count,s3),genv3), Rval v')

and

uapp2 : forall ck env uop e v s1 s2 count genv2.
evaluate_i3 ck env s1 e (((count,s2),genv2), Rval v) &&
(do_uapp_i3 (s2,genv2) uop v = Nothing)
==>
evaluate_i3 ck env s1 (Uapp_i2 uop e) (((count,s2),genv2), Rerr Rtype_error)

and

uapp3 : forall ck env uop e err s s'.
evaluate_i3 ck env s e (s', Rerr err)
==>
evaluate_i3 ck env s (Uapp_i2 uop e) (s', Rerr err)

and

app1 : forall ck env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 count s4 genv3.
evaluate_i3 ck env s1 e1 (s2, Rval v1) &&
evaluate_i3 ck env s2 e2 (((count,s3),genv3), Rval v2) &&
do_app_i2 env s3 op v1 v2 = Just (env', s4, e3) &&
((ck && (op = Opapp)) --> count <> 0) &&
evaluate_i3 ck env' (((if ck then dec_count op count else count),s4),genv3) e3 bv
==>
evaluate_i3 ck env s1 (App_i2 op e1 e2) bv

and

app2 : forall ck env op e1 e2 v1 v2 env' e3 s1 s2 s3 count s4 genv3.
evaluate_i3 ck env s1 e1 (s2, Rval v1) &&
evaluate_i3 ck env s2 e2 (((count,s3),genv3), Rval v2) &&
do_app_i2 env s3 op v1 v2 = Just (env', s4, e3) &&
count = 0 &&
op = Opapp &&
ck
==>
evaluate_i3 ck env s1 (App_i2 op e1 e2) (((0,s4),genv3),Rerr Rtimeout_error)

and

app3 : forall ck env op e1 e2 v1 v2 s1 s2 s3 count genv3.
evaluate_i3 ck env s1 e1 (s2, Rval v1) &&
evaluate_i3 ck env s2 e2 (((count,s3),genv3),Rval v2) &&
do_app_i2 env s3 op v1 v2 = Nothing
==>
evaluate_i3 ck env s1 (App_i2 op e1 e2) (((count,s3),genv3), Rerr Rtype_error)

and

app4 : forall ck env op e1 e2 v1 err s1 s2 s3.
evaluate_i3 ck env s1 e1 (s2, Rval v1) &&
evaluate_i3 ck env s2 e2 (s3, Rerr err)
==>
evaluate_i3 ck env s1 (App_i2 op e1 e2) (s3, Rerr err)

and

app5 : forall ck env op e1 e2 err s s'.
evaluate_i3 ck env s e1 (s', Rerr err)
==>
evaluate_i3 ck env s (App_i2 op e1 e2) (s', Rerr err)

and

if1 : forall ck env e1 e2 e3 v e' bv s1 s2.
evaluate_i3 ck env s1 e1 (s2, Rval v) &&
do_if_i2 v e2 e3 = Just e' &&
evaluate_i3 ck env s2 e' bv
==>
evaluate_i3 ck env s1 (If_i2 e1 e2 e3) bv

and

if2 : forall ck env e1 e2 e3 v s1 s2.
evaluate_i3 ck env s1 e1 (s2, Rval v) &&
do_if_i2 v e2 e3 = Nothing
==>
evaluate_i3 ck env s1 (If_i2 e1 e2 e3) (s2, Rerr Rtype_error)

and

if3 : forall ck env e1 e2 e3 err s s'.
evaluate_i3 ck env s e1 (s', Rerr err)
==>
evaluate_i3 ck env s (If_i2 e1 e2 e3) (s', Rerr err)

and

mat1 : forall ck env e pes v bv s1 s2.
evaluate_i3 ck env s1 e (s2, Rval v) &&
evaluate_match_i3 ck env s2 v pes bv
==>
evaluate_i3 ck env s1 (Mat_i2 e pes) bv

and

mat2 : forall ck env e pes err s s'.
evaluate_i3 ck env s e (s', Rerr err)
==>
evaluate_i3 ck env s (Mat_i2 e pes) (s', Rerr err)

and

let1 : forall ck env n e1 e2 v bv s1 s2.
evaluate_i3 ck env s1 e1 (s2, Rval v) &&
evaluate_i3 ck (opt_bind n v env) s2 e2 bv
==>
evaluate_i3 ck env s1 (Let_i2 n e1 e2) bv

and

let2 : forall ck env n e1 e2 err s s'.
evaluate_i3 ck env s e1 (s', Rerr err)
==>
evaluate_i3 ck env s (Let_i2 n e1 e2) (s', Rerr err)

and

letrec1 : forall ck env funs e bv s.
List.allDistinct (List.map (fun (x,y,z) -> x) funs) &&
evaluate_i3 ck (build_rec_env_i2 funs env env) s e bv
==>
evaluate_i3 ck env s (Letrec_i2 funs e) bv

and

letrec2 : forall ck env funs e s.
not (List.allDistinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate_i3 ck env s (Letrec_i2 funs e) (s, Rerr Rtype_error)

and

extend : forall ck env n s genv.
true
==>
evaluate_i3 ck env (s,genv) (Extend_global_i2 n) ((s,genv++List.genlist (fun x -> Nothing) n), Rval (Litv_i2 Unit))

and

empty : forall ck env s.
true
==>
evaluate_list_i3 ck env s [] (s, Rval [])

and

cons1 : forall ck env e es v vs s1 s2 s3.
evaluate_i3 ck env s1 e (s2, Rval v) &&
evaluate_list_i3 ck env s2 es (s3, Rval vs)
==>
evaluate_list_i3 ck env s1 (e::es) (s3, Rval (v::vs))

and

cons2 : forall ck env e es err s s'.
evaluate_i3 ck env s e (s', Rerr err)
==>
evaluate_list_i3 ck env s (e::es) (s', Rerr err)

and

cons3 : forall ck env e es v err s1 s2 s3.
evaluate_i3 ck env s1 e (s2, Rval v) &&
evaluate_list_i3 ck env s2 es (s3, Rerr err)
==>
evaluate_list_i3 ck env s1 (e::es) (s3, Rerr err)

and

mat_empty : forall ck env v s.
true
==>
evaluate_match_i3 ck env s v [] (s, Rerr Rtype_error)

and

mat_cons1 : forall ck env env' v p pes e bv s count genv.
List.allDistinct (pat_bindings_i2 p []) &&
(pmatch_i2 s p v env = Match env') &&
evaluate_i3 ck env' ((count,s),genv) e bv
==>
evaluate_match_i3 ck env ((count,s),genv) v ((p,e)::pes) bv

and

mat_cons2 : forall ck genv env v p e pes bv s count.
List.allDistinct (pat_bindings_i2 p []) &&
(pmatch_i2 s p v env = No_match) &&
evaluate_match_i3 ck env ((count,s),genv) v pes bv
==>
evaluate_match_i3 ck env ((count,s),genv) v ((p,e)::pes) bv

and

mat_cons3 : forall ck genv env v p e pes s count.
(pmatch_i2 s p v env = Match_type_error)
==>
evaluate_match_i3 ck env ((count,s),genv) v ((p,e)::pes) (((count,s),genv), Rerr Rtype_error)

and

mat_cons4 : forall ck env v p e pes s.
not (List.allDistinct (pat_bindings_i2 p []))
==>
evaluate_match_i3 ck env s v ((p,e)::pes) (s, Rerr Rtype_error)
