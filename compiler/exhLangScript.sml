(*Generated by Lem from exhLang.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory libTheory astTheory semanticPrimitivesTheory lem_list_extraTheory bigStepTheory conLangTheory;

val _ = numLib.prefer_num();



val _ = new_theory "exhLang"

(* The third intermediate language (IL3). Removes declarations.
 *
 * The AST of IL3 differs from IL2 in that there is no declarations level, the
 * program is represented by a sequence of expressions.
 *
 * The values of IL3 are the same as IL2.
 *
 * The semantics of IL3 differ in that the global environment is now store-like
 * rather than environment-like. The expressions for extending and initialising
 * it modify the global environment (instread of just rasing a type error).
 *
 * The translator to IL3 maps a declaration to an expression that sets of the
 * global environment in the right way. If evaluating the expression results in
 * an exception, then the exception is handled, and a SOME containing the
 * exception is returned. Otherwise, a NONE is returned.
 *
 *)

(*open import Pervasives*)
(*open import Lib*)
(*open import Ast*)
(*open import SemanticPrimitives*)
(*open import List_extra*)
(*open import BigStep*)
(*open import ConLang*)

val _ = Hol_datatype `
 pat_exh =
    Pvar_exh of varN
  | Plit_exh of lit
  | Pcon_exh of num => pat_exh list
  | Pref_exh of pat_exh`;


val _ = Hol_datatype `
 exp_exh =
    Raise_exh of exp_exh
  | Handle_exh of exp_exh => (pat_exh # exp_exh) list
  | Lit_exh of lit
  | Con_exh of num => exp_exh list
  | Var_local_exh of varN
  | Var_global_exh of num
  | Fun_exh of varN => exp_exh
  | Uapp_exh of uop_i2 => exp_exh
  | App_exh of op => exp_exh => exp_exh
  | If_exh of exp_exh => exp_exh => exp_exh
  | Mat_exh of exp_exh => (pat_exh # exp_exh) list
  | Let_exh of  varN option => exp_exh => exp_exh
  | Letrec_exh of (varN # varN # exp_exh) list => exp_exh
  | Extend_global_exh of num`;


val _ = Hol_datatype `
 v_exh =
    Litv_exh of lit
  | Conv_exh of num => v_exh list 
  | Closure_exh of (varN, v_exh) env => varN => exp_exh
  | Recclosure_exh of (varN, v_exh) env => (varN # varN # exp_exh) list => varN
  | Loc_exh of num`;


(*val pat_bindings_exh : pat_exh -> list varN -> list varN*)
 val pat_bindings_exh_defn = Hol_defn "pat_bindings_exh" `

(pat_bindings_exh (Pvar_exh n) already_bound =  
(n::already_bound))
/\
(pat_bindings_exh (Plit_exh l) already_bound =
  already_bound)
/\
(pat_bindings_exh (Pcon_exh _ ps) already_bound =  
(pats_bindings_exh ps already_bound))
/\
(pat_bindings_exh (Pref_exh p) already_bound =  
(pat_bindings_exh p already_bound))
/\
(pats_bindings_exh [] already_bound =
  already_bound)
/\
(pats_bindings_exh (p::ps) already_bound =  
(pats_bindings_exh ps (pat_bindings_exh p already_bound)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn pat_bindings_exh_defn;

(*val pmatch_exh : store v_exh -> pat_exh -> v_exh -> env varN v_exh -> match_result (env varN v_exh)*)
 val pmatch_exh_defn = Hol_defn "pmatch_exh" `

(pmatch_exh s (Pvar_exh x) v' env = (Match (bind x v' env)))
/\
(pmatch_exh s (Plit_exh l) (Litv_exh l') env =  
(if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error))
/\
(pmatch_exh s (Pcon_exh n ps) (Conv_exh n' vs) env =  
(if LENGTH ps = LENGTH vs then
    if n = n' then
      pmatch_list_exh s ps vs env
    else
      No_match
  else
    Match_type_error))
/\
(pmatch_exh s (Pref_exh p) (Loc_exh lnum) env =  
((case store_lookup lnum s of
      SOME v => pmatch_exh s p v env
    | NONE => Match_type_error
  )))
/\
(pmatch_exh _ _ _ env = Match_type_error)
/\
(pmatch_list_exh s [] [] env = (Match env))
/\
(pmatch_list_exh s (p::ps) (v::vs) env =  
((case pmatch_exh s p v env of
      No_match => No_match
    | Match_type_error => Match_type_error
    | Match env' => pmatch_list_exh s ps vs env'
  )))
/\
(pmatch_list_exh s _ _ env = Match_type_error)`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn pmatch_exh_defn;

(*val do_uapp_exh : store v_exh * list (maybe v_exh) -> uop_i2 -> v_exh -> maybe ((store v_exh * list (maybe v_exh)) * v_exh)*)
val _ = Define `
 (do_uapp_exh (s,genv) uop v =  
((case uop of
      Opderef_i2 =>
        (case v of
            Loc_exh n =>
              (case store_lookup n s of
                  SOME v => SOME ((s,genv),v)
                | NONE => NONE
              )
          | _ => NONE
        )
    | Opref_i2 =>
        let (s',n) = (store_alloc v s) in
          SOME ((s',genv), Loc_exh n)
    | Init_global_var_i2 idx =>
        if idx < LENGTH genv then
          (case EL idx genv of
              NONE => SOME ((s, LUPDATE (SOME v) idx genv), Litv_exh Unit)
            | SOME x => NONE
          )
        else
          NONE
  )))`;


(*val build_rec_env_exh : list (varN * varN * exp_exh) -> env varN v_exh -> env varN v_exh -> env varN v_exh*)
val _ = Define `
 (build_rec_env_exh funs cl_env add_to_env =  
(FOLDR 
    (\ (f,x,e) env' .  bind f (Recclosure_exh cl_env funs f) env') 
    add_to_env 
    funs))`;


(*val do_eq_exh : v_exh -> v_exh -> eq_result*)
 val do_eq_exh_defn = Hol_defn "do_eq_exh" `
 
(do_eq_exh (Litv_exh l1) (Litv_exh l2) =  
 (Eq_val (l1 = l2)))
/\
(do_eq_exh (Loc_exh l1) (Loc_exh l2) = (Eq_val (l1 = l2)))
/\
(do_eq_exh (Conv_exh tag1 vs1) (Conv_exh tag2 vs2) =  
(if (tag1 = tag2) /\ (LENGTH vs1 = LENGTH vs2) then
    do_eq_list_exh vs1 vs2
  else
    Eq_val F))
/\
(do_eq_exh (Closure_exh _ _ _) (Closure_exh _ _ _) = Eq_closure)
/\
(do_eq_exh (Closure_exh _ _ _) (Recclosure_exh _ _ _) = Eq_closure)
/\
(do_eq_exh (Recclosure_exh _ _ _) (Closure_exh _ _ _) = Eq_closure)
/\
(do_eq_exh (Recclosure_exh _ _ _) (Recclosure_exh _ _ _) = Eq_closure)
/\
(do_eq_exh _ _ = Eq_type_error)
/\
(do_eq_list_exh [] [] = (Eq_val T))
/\
(do_eq_list_exh (v1::vs1) (v2::vs2) =  
 ((case do_eq_exh v1 v2 of
      Eq_closure => Eq_closure
    | Eq_type_error => Eq_type_error
    | Eq_val r => 
        if ~ r then
          Eq_val F
        else
          do_eq_list_exh vs1 vs2
  )))
/\
(do_eq_list_exh _ _ = (Eq_val F))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn do_eq_exh_defn;


(*val do_app_exh : env varN v_exh -> store v_exh -> op -> v_exh -> v_exh -> maybe (env varN v_exh * store v_exh * exp_exh)*)
val _ = Define `
 (do_app_exh env' s op v1 v2 =  
((case (op, v1, v2) of
      (Opapp, Closure_exh env n e, v) =>
        SOME (bind n v env, s, e)
    | (Opapp, Recclosure_exh env funs n, v) =>
        (case find_recfun n funs of
            SOME (n,e) => SOME (bind n v (build_rec_env_exh funs env env), s, e)
          | NONE => NONE
        )
    | (Opn op, Litv_exh (IntLit n1), Litv_exh (IntLit n2)) =>
        if ((op = Divide) \/ (op = Modulo)) /\ (n2 =( 0 : int)) then
          SOME (emp, s, Raise_exh (Con_exh div_tag []))
        else
          SOME (env', s, Lit_exh (IntLit (opn_lookup op n1 n2)))
    | (Opb op, Litv_exh (IntLit n1), Litv_exh (IntLit n2)) =>
        SOME (env', s, Lit_exh (Bool (opb_lookup op n1 n2)))
    | (Equality, v1, v2) =>
        (case do_eq_exh v1 v2 of
            Eq_type_error => NONE
          | Eq_closure => SOME (emp, s, Raise_exh (Con_exh eq_tag []))
          | Eq_val b => SOME (env', s, Lit_exh (Bool b))
        )
    | (Opassign, (Loc_exh lnum), v) =>
        (case store_assign lnum v s of
          SOME st => SOME (env', st, Lit_exh Unit)
        | NONE => NONE
        )
    | _ => NONE
  )))`;


(*val do_if_exh : v_exh -> exp_exh -> exp_exh -> maybe exp_exh*)
val _ = Define `
 (do_if_exh v e1 e2 =  
(if v = Litv_exh (Bool T) then
    SOME e1
  else if v = Litv_exh (Bool F) then
    SOME e2
  else
    NONE))`;


val _ = type_abbrev((*  'a *) "count_store_genv0" , ``: 'a count_store # ( 'a option) list``);

val _ = Hol_reln ` (! ck env l s.
T
==>
evaluate_exh ck env s (Lit_exh l) (s, Rval (Litv_exh l)))

/\ (! ck env e s1 s2 v.
(evaluate_exh ck s1 env e (s2, Rval v))
==>
evaluate_exh ck s1 env (Raise_exh e) (s2, Rerr (Rraise v)))

/\ (! ck env e s1 s2 err.
(evaluate_exh ck s1 env e (s2, Rerr err))
==>
evaluate_exh ck s1 env (Raise_exh e) (s2, Rerr err))

/\ (! ck s1 s2 env e v pes.
(evaluate_exh ck s1 env e (s2, Rval v))
==>
evaluate_exh ck s1 env (Handle_exh e pes) (s2, Rval v))

/\ (! ck s1 s2 env e pes v bv.
(evaluate_exh ck env s1 e (s2, Rerr (Rraise v)) /\
evaluate_match_exh ck env s2 v pes bv)
==>
evaluate_exh ck env s1 (Handle_exh e pes) bv)

/\ (! ck s1 s2 env e pes err.
(evaluate_exh ck env s1 e (s2, Rerr err) /\
((err = Rtimeout_error) \/ (err = Rtype_error)))
==>
evaluate_exh ck env s1 (Handle_exh e pes) (s2, Rerr err))

/\ (! ck env tag es vs s s'.
(evaluate_list_exh ck env s es (s', Rval vs))
==>
evaluate_exh ck env s (Con_exh tag es) (s', Rval (Conv_exh tag vs)))

/\ (! ck env tag es err s s'.
(evaluate_list_exh ck env s es (s', Rerr err))
==>
evaluate_exh ck env s (Con_exh tag es) (s', Rerr err))

/\ (! ck env n v s.
(lookup n env = SOME v)
==>
evaluate_exh ck env s (Var_local_exh n) (s, Rval v))

/\ (! ck env n s.
(lookup n env = NONE)
==>
evaluate_exh ck env s (Var_local_exh n) (s, Rerr Rtype_error))

/\ (! ck env n v s genv.
((LENGTH genv > n) /\
(EL n genv = SOME v))
==>
evaluate_exh ck env (s,genv) (Var_global_exh n) ((s,genv), Rval v))

/\ (! ck env n s genv.
((LENGTH genv > n) /\
(EL n genv = NONE))
==>
evaluate_exh ck env (s,genv) (Var_global_exh n) ((s,genv), Rerr Rtype_error))

/\ (! ck env n s genv.
(~ (LENGTH genv > n))
==>
evaluate_exh ck env (s,genv) (Var_global_exh n) ((s,genv), Rerr Rtype_error))

/\ (! ck env n e s.
T
==>
evaluate_exh ck env s (Fun_exh n e) (s, Rval (Closure_exh env n e)))

/\ (! ck env uop e v v' s1 s2 count s3 genv2 genv3.
(evaluate_exh ck env s1 e (((count,s2),genv2), Rval v) /\
(do_uapp_exh (s2,genv2) uop v = SOME ((s3,genv3),v')))
==>
evaluate_exh ck env s1 (Uapp_exh uop e) (((count,s3),genv3), Rval v'))

/\ (! ck env uop e v s1 s2 count genv2.
(evaluate_exh ck env s1 e (((count,s2),genv2), Rval v) /\
(do_uapp_exh (s2,genv2) uop v = NONE))
==>
evaluate_exh ck env s1 (Uapp_exh uop e) (((count,s2),genv2), Rerr Rtype_error))

/\ (! ck env uop e err s s'.
(evaluate_exh ck env s e (s', Rerr err))
==>
evaluate_exh ck env s (Uapp_exh uop e) (s', Rerr err))

/\ (! ck env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 count s4 genv3.
(evaluate_exh ck env s1 e1 (s2, Rval v1) /\
(evaluate_exh ck env s2 e2 (((count,s3),genv3), Rval v2) /\
((do_app_exh env s3 op v1 v2 = SOME (env', s4, e3)) /\
(((ck /\ (op = Opapp)) ==> ~ (count =( 0))) /\
evaluate_exh ck env' (((if ck then dec_count op count else count),s4),genv3) e3 bv))))
==>
evaluate_exh ck env s1 (App_exh op e1 e2) bv)

/\ (! ck env op e1 e2 v1 v2 env' e3 s1 s2 s3 count s4 genv3.
(evaluate_exh ck env s1 e1 (s2, Rval v1) /\
(evaluate_exh ck env s2 e2 (((count,s3),genv3), Rval v2) /\
((do_app_exh env s3 op v1 v2 = SOME (env', s4, e3)) /\
((count = 0) /\
((op = Opapp) /\
ck)))))
==>
evaluate_exh ck env s1 (App_exh op e1 e2) ((( 0,s4),genv3),Rerr Rtimeout_error))

/\ (! ck env op e1 e2 v1 v2 s1 s2 s3 count genv3.
(evaluate_exh ck env s1 e1 (s2, Rval v1) /\
(evaluate_exh ck env s2 e2 (((count,s3),genv3),Rval v2) /\
(do_app_exh env s3 op v1 v2 = NONE)))
==>
evaluate_exh ck env s1 (App_exh op e1 e2) (((count,s3),genv3), Rerr Rtype_error))

/\ (! ck env op e1 e2 v1 err s1 s2 s3.
(evaluate_exh ck env s1 e1 (s2, Rval v1) /\
evaluate_exh ck env s2 e2 (s3, Rerr err))
==>
evaluate_exh ck env s1 (App_exh op e1 e2) (s3, Rerr err))

/\ (! ck env op e1 e2 err s s'.
(evaluate_exh ck env s e1 (s', Rerr err))
==>
evaluate_exh ck env s (App_exh op e1 e2) (s', Rerr err))

/\ (! ck env e1 e2 e3 v e' bv s1 s2.
(evaluate_exh ck env s1 e1 (s2, Rval v) /\
((do_if_exh v e2 e3 = SOME e') /\
evaluate_exh ck env s2 e' bv))
==>
evaluate_exh ck env s1 (If_exh e1 e2 e3) bv)

/\ (! ck env e1 e2 e3 v s1 s2.
(evaluate_exh ck env s1 e1 (s2, Rval v) /\
(do_if_exh v e2 e3 = NONE))
==>
evaluate_exh ck env s1 (If_exh e1 e2 e3) (s2, Rerr Rtype_error))

/\ (! ck env e1 e2 e3 err s s'.
(evaluate_exh ck env s e1 (s', Rerr err))
==>
evaluate_exh ck env s (If_exh e1 e2 e3) (s', Rerr err))

/\ (! ck env e pes v bv s1 s2.
(evaluate_exh ck env s1 e (s2, Rval v) /\
evaluate_match_exh ck env s2 v pes bv)
==>
evaluate_exh ck env s1 (Mat_exh e pes) bv)

/\ (! ck env e pes err s s'.
(evaluate_exh ck env s e (s', Rerr err))
==>
evaluate_exh ck env s (Mat_exh e pes) (s', Rerr err))

/\ (! ck env n e1 e2 v bv s1 s2.
(evaluate_exh ck env s1 e1 (s2, Rval v) /\
evaluate_exh ck (opt_bind n v env) s2 e2 bv)
==>
evaluate_exh ck env s1 (Let_exh n e1 e2) bv)

/\ (! ck env n e1 e2 err s s'.
(evaluate_exh ck env s e1 (s', Rerr err))
==>
evaluate_exh ck env s (Let_exh n e1 e2) (s', Rerr err))

/\ (! ck env funs e bv s.
(ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs) /\
evaluate_exh ck (build_rec_env_exh funs env env) s e bv)
==>
evaluate_exh ck env s (Letrec_exh funs e) bv)

/\ (! ck env funs e s.
(~ (ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs)))
==>
evaluate_exh ck env s (Letrec_exh funs e) (s, Rerr Rtype_error))

/\ (! ck env n s genv.
T
==>
evaluate_exh ck env (s,genv) (Extend_global_exh n) ((s,(genv++GENLIST (\ x .  NONE) n)), Rval (Litv_exh Unit)))

/\ (! ck env s.
T
==>
evaluate_list_exh ck env s [] (s, Rval []))

/\ (! ck env e es v vs s1 s2 s3.
(evaluate_exh ck env s1 e (s2, Rval v) /\
evaluate_list_exh ck env s2 es (s3, Rval vs))
==>
evaluate_list_exh ck env s1 (e::es) (s3, Rval (v::vs)))

/\ (! ck env e es err s s'.
(evaluate_exh ck env s e (s', Rerr err))
==>
evaluate_list_exh ck env s (e::es) (s', Rerr err))

/\ (! ck env e es v err s1 s2 s3.
(evaluate_exh ck env s1 e (s2, Rval v) /\
evaluate_list_exh ck env s2 es (s3, Rerr err))
==>
evaluate_list_exh ck env s1 (e::es) (s3, Rerr err))

/\ (! ck env v s.
T
==>
evaluate_match_exh ck env s v [] (s, Rerr Rtype_error))

/\ (! ck env env' v p pes e bv s count genv.
(ALL_DISTINCT (pat_bindings_exh p []) /\
((pmatch_exh s p v env = Match env') /\
evaluate_exh ck env' ((count,s),genv) e bv))
==>
evaluate_match_exh ck env ((count,s),genv) v ((p,e)::pes) bv)

/\ (! ck genv env v p e pes bv s count.
(ALL_DISTINCT (pat_bindings_exh p []) /\
((pmatch_exh s p v env = No_match) /\
evaluate_match_exh ck env ((count,s),genv) v pes bv))
==>
evaluate_match_exh ck env ((count,s),genv) v ((p,e)::pes) bv)

/\ (! ck genv env v p e pes s count.
(pmatch_exh s p v env = Match_type_error)
==>
evaluate_match_exh ck env ((count,s),genv) v ((p,e)::pes) (((count,s),genv), Rerr Rtype_error))

/\ (! ck env v p e pes s.
(~ (ALL_DISTINCT (pat_bindings_exh p [])))
==>
evaluate_match_exh ck env s v ((p,e)::pes) (s, Rerr Rtype_error))`;
val _ = export_theory()

