(*Generated by Lem from exhLang.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory libTheory astTheory semanticPrimitivesTheory lem_list_extraTheory bigStepTheory conLangTheory decLangTheory;

val _ = numLib.prefer_num();



val _ = new_theory "exhLang"

(* Adds a default case to non-exhaustive patterns. Follows decLang.
 *
 * The AST of exhLang differs from decLang by removing the type annotation from
 * constructors.
 *
 * The values of exhLang differ from decLang in the same way as the
 * expressions.
 *
 * The semantics of exhLang differ in that pattern matches that fall off the end
 * raise a type error, and the mapping from types to constructor tags is
 * ommitted.
 *
 * The translation only detects the following patterns:
 *   - A single variable, (), or ref variable
 *   - A list of patterns, each of which is a constructor applied to variables.
 *
 *)

(*open import Pervasives*)
(*open import Lib*)
(*open import Ast*)
(*open import SemanticPrimitives*)
(*open import List_extra*)
(*open import BigStep*)
(*open import ConLang*)
(*open import DecLang*)

val _ = Hol_datatype `
 pat_exh =
    Pvar_exh of varN
  | Plit_exh of lit
  | Pcon_exh of num => pat_exh list
  | Pref_exh of pat_exh`;


val _ = Hol_datatype `
 exp_exh =
    Raise_exh of exp_exh
  | Handle_exh of exp_exh => (pat_exh # exp_exh) list
  | Lit_exh of lit
  | Con_exh of num => exp_exh list
  | Var_local_exh of varN
  | Var_global_exh of num
  | Fun_exh of varN => exp_exh
  | App_exh of op_i2 => exp_exh list
  | If_exh of exp_exh => exp_exh => exp_exh
  | Mat_exh of exp_exh => (pat_exh # exp_exh) list
  | Let_exh of  varN option => exp_exh => exp_exh
  | Letrec_exh of (varN # varN # exp_exh) list => exp_exh
  | Extend_global_exh of num`;


val _ = Hol_datatype `
 v_exh =
    Litv_exh of lit
  | Conv_exh of num => v_exh list 
  | Closure_exh of (varN, v_exh) env => varN => exp_exh
  | Recclosure_exh of (varN, v_exh) env => (varN # varN # exp_exh) list => varN
  | Loc_exh of num
  | Vectorv_exh of v_exh list`;


(*val is_unconditional : pat_i2 -> bool*)
 val is_unconditional_defn = Hol_defn "is_unconditional" `

  (is_unconditional p =    
((case p of
        Pvar_i2 _ => T
      | (Plit_i2 Unit) => T
      | (Pcon_i2 (_,NONE) ps) => EVERY is_unconditional ps
      | (Pref_i2 p) => is_unconditional p
      | _ => F
    )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn is_unconditional_defn;

(*val get_tags : list pat_i2 -> nat_set -> maybe(nat_set)*)
 val _ = Define `
 (get_tags [] acc = (SOME acc))
/\ (get_tags (p::ps) acc =  
((case p of
      Pcon_i2 (tag,t) ps' =>
        if EVERY is_unconditional ps' then get_tags ps (sptree$insert tag ()  acc)
        else NONE
    | _ => NONE
  )))`;


(*val exhaustive_match : exh_ctors_env -> list pat_i2 -> bool*)
val _ = Define `
 (exhaustive_match exh ps =  
(EXISTS is_unconditional ps \/
  (case ps of
      Pcon_i2 (tag,SOME (TypeId t)) ps'::ps =>
        (EVERY is_unconditional ps' /\
          (case get_tags ps sptree$LN of
              NONE => F
            | SOME tags =>
                (case FLOOKUP exh t of
                    NONE => F
                  | SOME tags' =>
                    (sptree$insert tag ()  tags) = tags'
                )
          ))
    | _ => F
  )))`;


(*val add_default : bool -> bool -> list (pat_i2 * exp_i2) -> list (pat_i2 * exp_i2)*)
val _ = Define `
 (add_default is_handle is_exh pes =  
(if is_exh then
    pes
  else if is_handle then
    pes ++ [(Pvar_i2 "x", Raise_i2 (Var_local_i2 "x"))]
  else
    pes ++ [(Pvar_i2 "x", Raise_i2 (Con_i2 (bind_tag, SOME (TypeId (Short "option"))) []))]))`;


(*val pat_to_exh : pat_i2 -> pat_exh*)
 val pat_to_exh_defn = Hol_defn "pat_to_exh" `

(pat_to_exh (Pvar_i2 x) = (Pvar_exh x))
/\ 
(pat_to_exh (Plit_i2 l) = (Plit_exh l))
/\ 
(pat_to_exh (Pcon_i2 (tag,t) ps) =  
 (Pcon_exh tag (MAP pat_to_exh ps)))
/\ 
(pat_to_exh (Pref_i2 p) = (Pref_exh (pat_to_exh p)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn pat_to_exh_defn;

(*val exp_to_exh : exh_ctors_env -> exp_i2 -> exp_exh*)
(*val exps_to_exh : exh_ctors_env -> list exp_i2 -> list exp_exh*)
(*val pat_exp_to_exh : exh_ctors_env -> list (pat_i2 * exp_i2) -> list (pat_exh * exp_exh)*)
(*val funs_to_exh : exh_ctors_env -> list (varN * varN * exp_i2) -> list (varN * varN * exp_exh)*)
 val exp_to_exh_defn = Hol_defn "exp_to_exh" `
 
(exp_to_exh exh (Raise_i2 e) =  
 (Raise_exh (exp_to_exh exh e)))
/\
(exp_to_exh exh (Handle_i2 e pes) =  
 (Handle_exh (exp_to_exh exh e) (pat_exp_to_exh exh (add_default T (exhaustive_match exh (MAP FST pes)) pes))))
/\
(exp_to_exh exh (Lit_i2 l) =  
 (Lit_exh l)) 
/\
(exp_to_exh exh (Con_i2 t es) =  
 (Con_exh (FST t) (exps_to_exh exh es)))
/\
(exp_to_exh exh (Var_local_i2 x) = (Var_local_exh x))
/\
(exp_to_exh exh (Var_global_i2 x) = (Var_global_exh x))
/\
(exp_to_exh exh (Fun_i2 x e) =  
(Fun_exh x (exp_to_exh exh e))) 
/\
(exp_to_exh exh (App_i2 op es) =  
(App_exh op (exps_to_exh exh es)))
/\
(exp_to_exh exh (If_i2 e1 e2 e3) =  
(If_exh (exp_to_exh exh e1) (exp_to_exh exh e2) (exp_to_exh exh e3)))
/\
(exp_to_exh exh (Mat_i2 e pes) =  
(Mat_exh (exp_to_exh exh e) (pat_exp_to_exh exh (add_default F (exhaustive_match exh (MAP FST pes)) pes))))
/\
(exp_to_exh exh (Let_i2 x e1 e2) =  
(Let_exh x (exp_to_exh exh e1) (exp_to_exh exh e2)))
/\
(exp_to_exh exh (Letrec_i2 funs e) =  
(Letrec_exh (funs_to_exh exh funs) 
            (exp_to_exh exh e)))
/\
(exp_to_exh exh (Extend_global_i2 n) =  
(Extend_global_exh n))
/\
(exps_to_exh exh [] = ([]))
/\
(exps_to_exh exh (e::es) =  
(exp_to_exh exh e :: exps_to_exh exh es))
/\
(pat_exp_to_exh exh [] = ([]))
/\
(pat_exp_to_exh exh ((p,e)::pes) =  
((pat_to_exh p, exp_to_exh exh e) :: pat_exp_to_exh exh pes))
/\
(funs_to_exh exh [] = ([]))
/\
(funs_to_exh exh ((f,x,e)::funs) =  
((f,x,exp_to_exh exh e) :: funs_to_exh exh funs))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn exp_to_exh_defn;

(*val pat_bindings_exh : pat_exh -> list varN -> list varN*)
 val pat_bindings_exh_defn = Hol_defn "pat_bindings_exh" `

(pat_bindings_exh (Pvar_exh n) already_bound =  
(n::already_bound))
/\
(pat_bindings_exh (Plit_exh l) already_bound =
  already_bound)
/\
(pat_bindings_exh (Pcon_exh _ ps) already_bound =  
(pats_bindings_exh ps already_bound))
/\
(pat_bindings_exh (Pref_exh p) already_bound =  
(pat_bindings_exh p already_bound))
/\
(pats_bindings_exh [] already_bound =
  already_bound)
/\
(pats_bindings_exh (p::ps) already_bound =  
(pats_bindings_exh ps (pat_bindings_exh p already_bound)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn pat_bindings_exh_defn;

(*val pmatch_exh : store v_exh -> pat_exh -> v_exh -> env varN v_exh -> match_result (env varN v_exh)*)
 val pmatch_exh_defn = Hol_defn "pmatch_exh" `

(pmatch_exh s (Pvar_exh x) v' env = (Match (bind x v' env)))
/\
(pmatch_exh s (Plit_exh l) (Litv_exh l') env =  
(if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error))
/\
(pmatch_exh s (Pcon_exh n ps) (Conv_exh n' vs) env =  
(if n = n' then
    if LENGTH ps = LENGTH vs then
      pmatch_list_exh s ps vs env
    else
      Match_type_error
  else
    No_match))
/\
(pmatch_exh s (Pref_exh p) (Loc_exh lnum) env =  
((case store_lookup lnum s of
      SOME (Refv v) => pmatch_exh s p v env
    | _ => Match_type_error
  )))
/\
(pmatch_exh _ _ _ env = Match_type_error)
/\
(pmatch_list_exh s [] [] env = (Match env))
/\
(pmatch_list_exh s (p::ps) (v::vs) env =  
((case pmatch_exh s p v env of
      No_match => No_match
    | Match_type_error => Match_type_error
    | Match env' => pmatch_list_exh s ps vs env'
  )))
/\
(pmatch_list_exh s _ _ env = Match_type_error)`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn pmatch_exh_defn;

(*val build_rec_env_exh : list (varN * varN * exp_exh) -> env varN v_exh -> env varN v_exh -> env varN v_exh*)
val _ = Define `
 (build_rec_env_exh funs cl_env add_to_env =  
(FOLDR 
    (\ (f,x,e) env' .  bind f (Recclosure_exh cl_env funs f) env') 
    add_to_env 
    funs))`;


(*val do_eq_exh : v_exh -> v_exh -> eq_result*)
 val do_eq_exh_defn = Hol_defn "do_eq_exh" `

(do_eq_exh (Litv_exh l1) (Litv_exh l2) =  
(if lit_same_type l1 l2 then Eq_val (l1 = l2)
  else Eq_type_error))
/\
(do_eq_exh (Loc_exh l1) (Loc_exh l2) = (Eq_val (l1 = l2)))
/\
(do_eq_exh (Conv_exh tag1 vs1) (Conv_exh tag2 vs2) =  
(if (tag1 = tag2) /\ (LENGTH vs1 = LENGTH vs2) then
    do_eq_list_exh vs1 vs2
  else
    Eq_val F))
/\
(do_eq_exh (Vectorv_exh vs1) (Vectorv_exh vs2) =  
(if LENGTH vs1 = LENGTH vs2 then
    do_eq_list_exh vs1 vs2
  else
    Eq_val F))
/\
(do_eq_exh (Closure_exh _ _ _) (Closure_exh _ _ _) = Eq_closure)
/\
(do_eq_exh (Closure_exh _ _ _) (Recclosure_exh _ _ _) = Eq_closure)
/\
(do_eq_exh (Recclosure_exh _ _ _) (Closure_exh _ _ _) = Eq_closure)
/\
(do_eq_exh (Recclosure_exh _ _ _) (Recclosure_exh _ _ _) = Eq_closure)
/\
(do_eq_exh _ _ = Eq_type_error)
/\
(do_eq_list_exh [] [] = (Eq_val T))
/\
(do_eq_list_exh (v1::vs1) (v2::vs2) =  
 ((case do_eq_exh v1 v2 of
      Eq_closure => Eq_closure
    | Eq_type_error => Eq_type_error
    | Eq_val r => 
        if ~ r then
          Eq_val F
        else
          do_eq_list_exh vs1 vs2
  )))
/\
(do_eq_list_exh _ _ = (Eq_val F))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn do_eq_exh_defn;

(*val do_opapp_exh : list v_exh -> maybe (env varN v_exh * exp_exh)*)
val _ = Define `
 (do_opapp_exh vs =  
((case vs of
      [Closure_exh env n e; v] =>
        SOME (bind n v env, e)
    | [Recclosure_exh env funs n; v] =>
        if ALL_DISTINCT (MAP (\ (f,x,e) .  f) funs) then
          (case find_recfun n funs of
              SOME (n,e) => SOME (bind n v (build_rec_env_exh funs env env), e)
            | NONE => NONE
          )
        else
          NONE
    | _ => NONE
  )))`;


(*val prim_exn_exh : nat -> v_exh*)
val _ = Define `
 (prim_exn_exh tag = (Conv_exh tag []))`;


(*val v_to_list_exh : v_exh -> maybe (list v_exh)*)
 val _ = Define `
 (v_to_list_exh (Conv_exh tag []) =  
 (if tag = nil_tag then
    SOME []
  else
    NONE))
/\ (v_to_list_exh (Conv_exh tag [v1;v2]) =  
(if tag = cons_tag  then
    (case v_to_list_exh v2 of
        SOME vs => SOME (v1::vs)
      | NONE => NONE
    )
  else
    NONE))
/\ (v_to_list_exh _ = NONE)`;



(*val do_app_exh : count_store_genv v_exh -> op_i2 -> list v_exh -> maybe (count_store_genv v_exh * result v_exh v_exh)*)
val _ = Define `
 (do_app_exh ((count,s),genv) op vs =  
((case (op, vs) of
      (Op_i2 (Opn op), [Litv_exh (IntLit n1); Litv_exh (IntLit n2)]) =>
        if ((op = Divide) \/ (op = Modulo)) /\ (n2 =( 0 : int)) then
          SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh div_tag)))
        else
          SOME (((count,s),genv), Rval (Litv_exh (IntLit (opn_lookup op n1 n2))))
    | (Op_i2 (Opb op), [Litv_exh (IntLit n1); Litv_exh (IntLit n2)]) =>
        SOME (((count,s),genv), Rval (Litv_exh (Bool (opb_lookup op n1 n2))))
    | (Op_i2 Equality, [v1; v2]) =>
        (case do_eq_exh v1 v2 of
            Eq_type_error => NONE
          | Eq_closure => SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh eq_tag)))
          | Eq_val b => SOME (((count,s),genv), Rval (Litv_exh (Bool b)))
        )
    | (Op_i2 Opassign, [Loc_exh lnum; v]) =>
        (case store_assign lnum (Refv v) s of
            SOME st => SOME (((count,st),genv), Rval (Litv_exh Unit))
          | NONE => NONE
        )
    | (Op_i2 Opref, [v]) =>
        let (s',n) = (store_alloc (Refv v) s) in
          SOME (((count,s'),genv), Rval (Loc_exh n))
    | (Op_i2 Opderef, [Loc_exh n]) =>
        (case store_lookup n s of
            SOME (Refv v) => SOME (((count,s),genv),Rval v)
          | _ => NONE
        )
    | (Init_global_var_i2 idx, [v]) =>
        if idx < LENGTH genv then
          (case EL idx genv of
              NONE => SOME (((count,s), LUPDATE (SOME v) idx genv), (Rval (Litv_exh Unit)))
            | SOME x => NONE
          )
        else
          NONE
    | (Op_i2 W8fromInt, [Litv_exh (IntLit n)]) =>
        SOME (((count,s),genv), Rval (Litv_exh (Word8 (i2w n))))
    | (Op_i2 W8toInt, [Litv_exh (Word8 w)]) =>
        SOME (((count,s),genv), Rval (Litv_exh (IntLit (int_of_num (w2n w)))))
    | (Op_i2 Aw8alloc, [Litv_exh (IntLit n); Litv_exh (Word8 w)]) =>
        if n <( 0 : int) then
          SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh subscript_tag)))
        else
          let (s',lnum) =            
(store_alloc (W8array (REPLICATE (Num (ABS ( n))) w)) s)
          in 
            SOME (((count,s'),genv), Rval (Loc_exh lnum))
    | (Op_i2 Aw8sub, [Loc_exh lnum; Litv_exh (IntLit i)]) =>
        (case store_lookup lnum s of
            SOME (W8array ws) =>
              if i <( 0 : int) then
                SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh subscript_tag)))
              else
                let n = (Num (ABS ( i))) in
                  if n >= LENGTH ws then
                    SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh subscript_tag)))
                  else 
                    SOME (((count,s),genv), Rval (Litv_exh (Word8 (EL n ws))))
          | _ => NONE
        )
    | (Op_i2 Aw8length, [Loc_exh n]) =>
        (case store_lookup n s of
            SOME (W8array ws) =>
              SOME (((count,s),genv),Rval (Litv_exh(IntLit(int_of_num(LENGTH ws)))))
          | _ => NONE
         )
    | (Op_i2 Aw8update, [Loc_exh lnum; Litv_exh(IntLit i); Litv_exh(Word8 w)]) =>
        (case store_lookup lnum s of
          SOME (W8array ws) =>
            if i <( 0 : int) then
              SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh subscript_tag)))
            else 
              let n = (Num (ABS ( i))) in
                if n >= LENGTH ws then
                  SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh subscript_tag)))
                else
                  (case store_assign lnum (W8array (LUPDATE w n ws)) s of
                      NONE => NONE
                    | SOME s' => SOME (((count,s'),genv), Rval (Litv_exh Unit))
                  )
        | _ => NONE
      )
    | (Op_i2 VfromList, [v]) =>
          (case v_to_list_exh v of
              SOME vs =>
                SOME (((count,s),genv), Rval (Vectorv_exh vs))
            | NONE => NONE
          )
    | (Op_i2 Vsub, [Vectorv_exh vs; Litv_exh (IntLit i)]) =>
        if i <( 0 : int) then
          SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh subscript_tag)))
        else
          let n = (Num (ABS ( i))) in
            if n >= LENGTH vs then
              SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh subscript_tag)))
            else 
              SOME (((count,s),genv), Rval (EL n vs))
    | (Op_i2 Vlength, [Vectorv_exh vs]) =>
        SOME (((count,s),genv), Rval (Litv_exh (IntLit (int_of_num (LENGTH vs)))))
    | (Op_i2 Aalloc, [Litv_exh (IntLit n); v]) =>
        if n <( 0 : int) then
          SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh subscript_tag)))
        else
          let (s',lnum) =            
(store_alloc (Varray (REPLICATE (Num (ABS ( n))) v)) s)
          in 
            SOME (((count,s'),genv), Rval (Loc_exh lnum))
    | (Op_i2 Asub, [Loc_exh lnum; Litv_exh (IntLit i)]) =>
        (case store_lookup lnum s of
            SOME (Varray vs) =>
              if i <( 0 : int) then
                SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh subscript_tag)))
              else
                let n = (Num (ABS ( i))) in
                  if n >= LENGTH vs then
                    SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh subscript_tag)))
                  else 
                    SOME (((count,s),genv), Rval (EL n vs))
          | _ => NONE
        )
    | (Op_i2 Alength, [Loc_exh n]) =>
        (case store_lookup n s of
            SOME (Varray ws) =>
              SOME (((count,s),genv),Rval (Litv_exh (IntLit(int_of_num(LENGTH ws)))))
          | _ => NONE
         )
    | (Op_i2 Aupdate, [Loc_exh lnum; Litv_exh (IntLit i); v]) =>
        (case store_lookup lnum s of
          SOME (Varray vs) =>
            if i <( 0 : int) then
              SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh subscript_tag)))
            else 
              let n = (Num (ABS ( i))) in
                if n >= LENGTH vs then
                  SOME (((count,s),genv), Rerr (Rraise (prim_exn_exh subscript_tag)))
                else
                  (case store_assign lnum (Varray (LUPDATE v n vs)) s of
                      NONE => NONE
                    | SOME s' => SOME (((count,s'),genv), Rval (Litv_exh Unit))
                  )
        | _ => NONE
      )
    | _ => NONE
  )))`;


(*val do_if_exh : v_exh -> exp_exh -> exp_exh -> maybe exp_exh*)
val _ = Define `
 (do_if_exh v e1 e2 =  
(if v = Litv_exh (Bool T) then
    SOME e1
  else if v = Litv_exh (Bool F) then
    SOME e2
  else
    NONE))`;


val _ = Hol_reln ` (! ck env l s.
T
==>
evaluate_exh ck env s (Lit_exh l) (s, Rval (Litv_exh l)))

/\ (! ck env e s1 s2 v.
(evaluate_exh ck s1 env e (s2, Rval v))
==>
evaluate_exh ck s1 env (Raise_exh e) (s2, Rerr (Rraise v)))

/\ (! ck env e s1 s2 err.
(evaluate_exh ck s1 env e (s2, Rerr err))
==>
evaluate_exh ck s1 env (Raise_exh e) (s2, Rerr err))

/\ (! ck s1 s2 env e v pes.
(evaluate_exh ck s1 env e (s2, Rval v))
==>
evaluate_exh ck s1 env (Handle_exh e pes) (s2, Rval v))

/\ (! ck s1 s2 env e pes v bv.
(evaluate_exh ck env s1 e (s2, Rerr (Rraise v)) /\
evaluate_match_exh ck env s2 v pes bv)
==>
evaluate_exh ck env s1 (Handle_exh e pes) bv)

/\ (! ck s1 s2 env e pes err.
(evaluate_exh ck env s1 e (s2, Rerr err) /\
((err = Rtimeout_error) \/ (err = Rtype_error)))
==>
evaluate_exh ck env s1 (Handle_exh e pes) (s2, Rerr err))

/\ (! ck env tag es vs s s'.
(evaluate_list_exh ck env s es (s', Rval vs))
==>
evaluate_exh ck env s (Con_exh tag es) (s', Rval (Conv_exh tag vs)))

/\ (! ck env tag es err s s'.
(evaluate_list_exh ck env s es (s', Rerr err))
==>
evaluate_exh ck env s (Con_exh tag es) (s', Rerr err))

/\ (! ck env n v s.
(lookup n env = SOME v)
==>
evaluate_exh ck env s (Var_local_exh n) (s, Rval v))

/\ (! ck env n s.
(lookup n env = NONE)
==>
evaluate_exh ck env s (Var_local_exh n) (s, Rerr Rtype_error))

/\ (! ck env n v s genv.
((LENGTH genv > n) /\
(EL n genv = SOME v))
==>
evaluate_exh ck env (s,genv) (Var_global_exh n) ((s,genv), Rval v))

/\ (! ck env n s genv.
((LENGTH genv > n) /\
(EL n genv = NONE))
==>
evaluate_exh ck env (s,genv) (Var_global_exh n) ((s,genv), Rerr Rtype_error))

/\ (! ck env n s genv.
(~ (LENGTH genv > n))
==>
evaluate_exh ck env (s,genv) (Var_global_exh n) ((s,genv), Rerr Rtype_error))

/\ (! ck env n e s.
T
==>
evaluate_exh ck env s (Fun_exh n e) (s, Rval (Closure_exh env n e)))

/\ (! ck genv env es vs env' e bv s1 s2 count genv'.
(evaluate_list_exh ck env (s1,genv) es (((count,s2),genv'), Rval vs) /\
(do_opapp_exh vs = SOME (env', e)) /\
(ck ==> ~ (count =( 0))) /\
evaluate_exh ck env' (((if ck then count -  1 else count),s2),genv') e bv)
==>
evaluate_exh ck env (s1,genv) (App_exh (Op_i2 Opapp) es) bv)

/\ (! ck env es vs env' e s1 s2 count genv.
(evaluate_list_exh ck env s1 es (((count,s2), genv), Rval vs) /\
(do_opapp_exh vs = SOME (env', e)) /\
(count = 0) /\
ck)
==>
evaluate_exh ck env s1 (App_exh (Op_i2 Opapp) es) ((( 0,s2),genv), Rerr Rtimeout_error))

/\ (! ck env es vs s1 s2.
(evaluate_list_exh ck env s1 es (s2, Rval vs) /\
(do_opapp_exh vs = NONE))
==>
evaluate_exh ck env s1 (App_exh (Op_i2 Opapp) es) (s2, Rerr Rtype_error))

/\ (! ck env s1 op es s2 vs s3 res.
(evaluate_list_exh ck env s1 es (s2, Rval vs) /\
(do_app_exh s2 op vs = SOME (s3, res)) /\
(op <> Op_i2 Opapp))
==>
evaluate_exh ck env s1 (App_exh op es) (s3, res))

/\ (! ck env s1 op es s2 vs.
(evaluate_list_exh ck env s1 es (s2, Rval vs) /\
(do_app_exh s2 op vs = NONE) /\
(op <> Op_i2 Opapp))
==>
evaluate_exh ck env s1 (App_exh op es) (s2, Rerr Rtype_error))

/\ (! ck env s1 op es s2 err.
(evaluate_list_exh ck env s1 es (s2, Rerr err))
==>
evaluate_exh ck env s1 (App_exh op es) (s2, Rerr err))

/\ (! ck env e1 e2 e3 v e' bv s1 s2.
(evaluate_exh ck env s1 e1 (s2, Rval v) /\
(do_if_exh v e2 e3 = SOME e') /\
evaluate_exh ck env s2 e' bv)
==>
evaluate_exh ck env s1 (If_exh e1 e2 e3) bv)

/\ (! ck env e1 e2 e3 v s1 s2.
(evaluate_exh ck env s1 e1 (s2, Rval v) /\
(do_if_exh v e2 e3 = NONE))
==>
evaluate_exh ck env s1 (If_exh e1 e2 e3) (s2, Rerr Rtype_error))

/\ (! ck env e1 e2 e3 err s s'.
(evaluate_exh ck env s e1 (s', Rerr err))
==>
evaluate_exh ck env s (If_exh e1 e2 e3) (s', Rerr err))

/\ (! ck env e pes v bv s1 s2.
(evaluate_exh ck env s1 e (s2, Rval v) /\
evaluate_match_exh ck env s2 v pes bv)
==>
evaluate_exh ck env s1 (Mat_exh e pes) bv)

/\ (! ck env e pes err s s'.
(evaluate_exh ck env s e (s', Rerr err))
==>
evaluate_exh ck env s (Mat_exh e pes) (s', Rerr err))

/\ (! ck env n e1 e2 v bv s1 s2.
(evaluate_exh ck env s1 e1 (s2, Rval v) /\
evaluate_exh ck (opt_bind n v env) s2 e2 bv)
==>
evaluate_exh ck env s1 (Let_exh n e1 e2) bv)

/\ (! ck env n e1 e2 err s s'.
(evaluate_exh ck env s e1 (s', Rerr err))
==>
evaluate_exh ck env s (Let_exh n e1 e2) (s', Rerr err))

/\ (! ck env funs e bv s.
(ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs) /\
evaluate_exh ck (build_rec_env_exh funs env env) s e bv)
==>
evaluate_exh ck env s (Letrec_exh funs e) bv)

/\ (! ck env funs e s.
(~ (ALL_DISTINCT (MAP (\ (x,y,z) .  x) funs)))
==>
evaluate_exh ck env s (Letrec_exh funs e) (s, Rerr Rtype_error))

/\ (! ck env n s genv.
T
==>
evaluate_exh ck env (s,genv) (Extend_global_exh n) ((s,(genv++GENLIST (\ x .  NONE) n)), Rval (Litv_exh Unit)))

/\ (! ck env s.
T
==>
evaluate_list_exh ck env s [] (s, Rval []))

/\ (! ck env e es v vs s1 s2 s3.
(evaluate_exh ck env s1 e (s2, Rval v) /\
evaluate_list_exh ck env s2 es (s3, Rval vs))
==>
evaluate_list_exh ck env s1 (e::es) (s3, Rval (v::vs)))

/\ (! ck env e es err s s'.
(evaluate_exh ck env s e (s', Rerr err))
==>
evaluate_list_exh ck env s (e::es) (s', Rerr err))

/\ (! ck env e es v err s1 s2 s3.
(evaluate_exh ck env s1 e (s2, Rval v) /\
evaluate_list_exh ck env s2 es (s3, Rerr err))
==>
evaluate_list_exh ck env s1 (e::es) (s3, Rerr err))

/\ (! ck env v s.
T
==>
evaluate_match_exh ck env s v [] (s, Rerr Rtype_error))

/\ (! ck env env' v p pes e bv s count genv.
(ALL_DISTINCT (pat_bindings_exh p []) /\
(pmatch_exh s p v env = Match env') /\
evaluate_exh ck env' ((count,s),genv) e bv)
==>
evaluate_match_exh ck env ((count,s),genv) v ((p,e)::pes) bv)

/\ (! ck genv env v p e pes bv s count.
(ALL_DISTINCT (pat_bindings_exh p []) /\
(pmatch_exh s p v env = No_match) /\
evaluate_match_exh ck env ((count,s),genv) v pes bv)
==>
evaluate_match_exh ck env ((count,s),genv) v ((p,e)::pes) bv)

/\ (! ck genv env v p e pes s count.
(pmatch_exh s p v env = Match_type_error)
==>
evaluate_match_exh ck env ((count,s),genv) v ((p,e)::pes) (((count,s),genv), Rerr Rtype_error))

/\ (! ck env v p e pes s.
(~ (ALL_DISTINCT (pat_bindings_exh p [])))
==>
evaluate_match_exh ck env s v ((p,e)::pes) (s, Rerr Rtype_error))`;
val _ = export_theory()

