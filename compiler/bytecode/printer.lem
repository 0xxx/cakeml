(* observable values *)

open Ast
open SemanticPrimitives
open CompilerLib

type ov =
  | OLit of lit
  | OConv of id conN * list ov
  | OFn
  | OLoc of num (* machine, not semantic, address *)
  | OError (* internal machine value (pointer) that should not appear *)

let string_of_int i =
  if Int.(<) i i0 then "~"^(string_of_num (num_of_int (neg i)))
  else string_of_num (num_of_int i)

let rec
v_to_ov _ (Litv l) = OLit l
and
v_to_ov s (Conv cn vs) = OConv cn (List.map (v_to_ov s) vs)
and
v_to_ov _ (Closure _ _ _) = OFn
and
v_to_ov _ (Recclosure _ _ _) = OFn
and
v_to_ov s (Loc n) = OLoc (List.nth s n)

let rec
ov_to_string (OLit (IntLit (i:int))) = string_of_int i
and
ov_to_string (OLit (Bool true)) = "true"
and
ov_to_string (OLit (Bool false)) = "false"
and
ov_to_string (OLit Unit) = "()"
and
ov_to_string (OConv _ _) = "<constructor>"
(*
ov_to_string (OConv cn vs) =
  (id_to_string cn)^" "^
  match intersperse ", " (List.map ov_to_string vs) with
  | [s] -> s
  | ls -> "("^Hol.FLAT ls^")"
  end
*)
and
ov_to_string (OLoc _) = "<ref>"
and
ov_to_string OFn = "<fn>"
and
ov_to_string OError = "<error>"

(*
open Compiler

let stack_index cs v = cs.rsz - (the 0 (Lib.lookup v cs.renv)) - 1

let rec
preprint_dec _ (Dtype _) = []
and
preprint_dec cs (Dlet p _) =
  List.map (fun v -> (stack_index cs v,v)) (pat_bindings p [])
and
preprint_dec cs (Dletrec defs) =
  List.map (fun (v,_,_) -> (stack_index cs v,v)) defs

let simple_printer ds cs stack =
  Hol.FLAT
    (List.map
       (fun (n,v) ->
         "val "^v^" = "^
         (ov_to_string
           (bv_to_ov cs
             (List.nth stack n)))^"\n")
       ds)
*)
