(* TODO: these should be in the lem library *)

val genlist : forall 'a. (num -> 'a) -> num -> list 'a
let inline {hol} genlist = Hol.GENLIST

val pre : num -> num
let inline {hol} pre = Hol.PRE

val drop : forall 'a. num -> list 'a -> list 'a
let inline {hol} drop = Hol.DROP

val least : (num -> bool) -> num
let inline {hol} least = Hol.LEAST

val int_of_num : num -> int
let inline {hol} int_of_num = Hol.int_of_num

val num_of_int : int -> num
let inline {hol} num_of_int = Hol.Num

val string_of_num : num -> string
let inline {hol} string_of_num = Hol.num_to_dec_string

val neg : int -> int
let inline {hol} neg = Hol.int_neg

let i0 = int_of_num 0
let i1 = int_of_num 1
let i2 = int_of_num 2

let rec
find_index _ [] _ = None
and
find_index y (x::xs) n = if x = y then Some n else find_index y xs (n+1)

let rec el_check n ls = if n < List.length ls then Some (List.nth ls n) else None

let rec num_fold f a n = if n = 0 then a else num_fold f (f a) (n-1)

let rec
intersperse _ [] = []
and
intersperse _ [x] = [x]
and
intersperse a (x::xs) = x::a::intersperse a xs

let rec
lunion [] s = s
and
lunion (x::xs) s =
  if List.mem x s
  then lunion xs s
  else x::(lunion xs s)

let rec
lshift n ls =
  List.map (fun v -> v - n) (List.filter (fun v -> n <= v) ls)

let rec the _ (Some x) = x and the x None = x

let fapply d x f = match Hol.FLOOKUP f x with Some d -> d | None -> d end
