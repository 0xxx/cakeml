(* TODO: compile Raise and Handle properly; requires changes to bytecode *)
(* TODO: simple type system and checker *)
(* TODO: map_Cexp? *)
(* TODO: use Pmap.peek instead of mem when it becomes available *)
(* TODO: collapse nested functions *)
(* TODO: collapse nested lets *)
(* TODO: Letfun introduction and reordering *)
(* TODO: let floating *)
(* TODO: removal of redundant expressions *)
(* TODO: simplification (e.g., constant folding) *)
(* TODO: avoid Shifts when possible *)
(* TODO: registers, register allocation, greedy shuffling? *)
(* TODO: bytecode optimizer: repeated Pops, unreachable code (e.g. after a Jump) *)
(* TODO: more efficient pattern-matching method? *)
(* TODO: store type information on CMat nodes (for pattern matching compilation) *)
(* TODO: typechecking *)
(* TODO: printing *)

(* TODO: move to lem *)
val alist_to_fmap : forall 'a 'b. list ('a * 'b) -> Pmap.map 'a 'b
let inline {hol} alist_to_fmap = Hol.alist_to_fmap
val optrel : forall 'a 'b 'c 'd. ('a -> 'b -> bool) -> 'c -> 'd -> bool
let inline {hol} optrel = Hol.OPTREL
val flookup : forall 'a 'b 'c. Pmap.map 'a 'b -> 'a -> 'c
let inline {hol} flookup = Hol.FLOOKUP
val genlist : forall 'a. (num -> 'a) -> num -> list 'a
let inline {hol} genlist = Hol.GENLIST
open MiniML
val return : forall 'a 'b. 'a -> 'b -> 'a * 'b
let inline {hol} return = Hol.UNIT
val bind : forall 'a 'b 'c. ('a -> 'b * 'a) -> ('b -> 'a -> 'c * 'a) -> 'a -> 'c * 'a
let inline {hol} bind = Hol.BIND
val ubind : forall 'a 'b 'c. ('a -> 'b * 'a) -> ('a -> 'c * 'a) -> 'a -> 'c * 'a
let inline {hol} ubind = Hol.IGNORE_BIND
val image : forall 'a 'b. ('a -> 'b) -> set 'a -> set 'b
let inline {hol} image = Hol.IMAGE
val pre : num -> num
let inline {hol} pre = Hol.PRE
val count : num -> set num
let inline {hol} count = Hol.count
val the : forall 'a 'b. 'a -> 'b
let inline {hol} the = Hol.THE
val qsort : forall 'a. ('a -> 'a -> bool) -> list 'a -> list 'a
let inline {hol} qsort = Hol.QSORT
val lupdate : forall 'a. 'a -> num -> list 'a -> list 'a
let inline {hol} lupdate = Hol.LUPDATE
val some : forall 'a 'b. ('a -> bool) -> 'b
let inline {hol} some = Hol.some
val all_distinct : forall 'a. list 'a -> bool
let inline {hol} all_distinct = Hol.ALL_DISTINCT

(* TODO: Misc. helpers *)

let rec
find_index y [] _ = None
and
find_index y (x::xs) n = if x = y then Some n else find_index y xs (n+1)

let rec el_check n ls = if n < List.length ls then Some (List.nth ls n) else None

let rec num_fold f a n = if n = 0 then a else num_fold f (f a) (n-1)

let rec
map_result f (Rval v) = Rval (f v)
and
map_result f (Rerr e) = Rerr e

let rec
every_result  P (Rerr _) = true
and
every_result P (Rval v) = P v

let i0 = Bytecode.int_of_num 0
let i1 = Bytecode.int_of_num 1
let i2 = Bytecode.int_of_num 2

let rec
error_to_int Bind_error = i0
and
error_to_int Div_error = i1
and
error_to_int (Int_error n) = Int.(+) i2 n

let rec
num_to_bool 0 = false
and
num_to_bool 1 = true

(* Intermediate language for MiniML compiler *)

(* Syntax *)
(* (real definitions in CexpTypesTheory) *)

(* pure applicative primitives with bytecode counterparts *)
type Cprim1 = CRef | CDer
type Cprim2 = CAdd | CSub | CMul | CDiv | CMod | CLt | CEq

type Cpat =
  | CPvar
  | CPlit of lit
  | CPcon of num * list Cpat
  | CPref of Cpat

type Cexp =
  | CDecl of list (num * string)
  | CRaise of error
  | CHandle of Cexp * Cexp
  | CVar of num
  | CLit of lit
  | CCon of num * list Cexp
  | CTagEq of Cexp * num
  | CProj of Cexp * num
  | CLet of Cexp * Cexp
  | CLetrec of list (sum (num * Cexp) num) * Cexp
  | CFun of sum (num * Cexp) num
  | CCall of Cexp * list Cexp
  | CPrim1 of Cprim1 * Cexp
  | CPrim2 of Cprim2 * Cexp * Cexp
  | CUpd of Cexp * Cexp
  | CIf of Cexp * Cexp * Cexp

type def = sum (num * Cexp) num

type Cv =
  | CLitv of lit
  | CConv of num * list Cv
  | CRecClos of list Cv * list def * num
  | CLoc of num

(* Semantics *)

(* values in compile-time environment *)
type ccbind = CCArg of num | CCRef of num | CCEnv of num
type ctbind = CTLet of num | CTEnv of ccbind
(* CTLet n means stack[sz - n]
   CCArg n means stack[sz + n]
   CCEnv n means El n of the environment, which is at stack[sz]
   CCRef n means El n of the environment, but it's a ref pointer *)
type ccenv = list ccbind
type ceenv = list num * list num (* indices of recursive closures, free variables *)
type ctenv = list ctbind

type closure_data =
  <| ccenv :ccenv
   ; ceenv :ceenv (* to construct ccenv from creation-site environment *)
   ; az    :num   (* number of arguments *)
   ; body  :Cexp  (* adjusted for ccenv *)
   |>

type closure_extra_data =
  <| cd :closure_data
   ; nz :num (* size of recursive bundle *)
   ; ez :num (* size of creation-site environment *)
   ; ix :num (* position in recursive bundle *)
   |>

let rec
free_vars (CDecl xs) = Set.from_list (List.map (fun (n,m) -> n) xs)
and
free_vars (CRaise _) = {}
and
free_vars (CHandle e1 e2) = free_vars e1 union (image pre (free_vars e2 \ {0}))
and
free_vars (CVar n) = {n}
and
free_vars (CLit _) = {}
and
free_vars (CCon _ es) =
  List.fold_left (fun s e -> s union free_vars e) {} es
and
free_vars (CTagEq e _) = free_vars e
and
free_vars (CProj e _) = free_vars e
and
free_vars (CLet e eb) =
  free_vars e union (image pre (free_vars eb \ {0}))
and
free_vars (CLetrec defs e) =
  let n = List.length defs in
  List.fold_left (fun s cb ->
    s union (image (fun m -> m - n) (cbod_fvs cb \ count n)))
  (image (fun m -> m - n) (free_vars e \ count n)) defs
and
free_vars (CFun cb) = image pre (cbod_fvs cb \ {0})
and
free_vars (CCall e es) =
  List.fold_left (fun s e -> s union free_vars e)
  (free_vars e) es
and
free_vars (CPrim1 _ e) = free_vars e
and
free_vars (CPrim2 _ e1 e2) = free_vars e1 union free_vars e2
and
free_vars (CUpd e1 e2) = free_vars e1 union free_vars e2
and
free_vars (CIf e1 e2 e3) = free_vars e1 union free_vars e2 union free_vars e3
and
cbod_fvs (Inl (k,e)) = image (fun m -> m - k) (free_vars e \ (count k))
and
cbod_fvs (Inr l) = {}

(* Big-step semantics *)

let rec
no_closures (CLitv _) = true
and
no_closures (CConv _ vs) = List.for_all no_closures vs
and
no_closures (CRecClos _ _ _) = false

let rec
doPrim2 b ty op (CLitv (IntLit x)) (CLitv (IntLit y)) =
  if b && y = i0 then Rerr (Rraise Div_error)
  else Rval (CLitv (ty (op x y)))
and
doPrim2 b ty op _ _ = Rerr Rtype_error

let rec
CevalPrim2 CAdd = doPrim2 false IntLit Int.(+)
and
CevalPrim2 CSub = doPrim2 false IntLit Int.(-)
and
CevalPrim2 CMul = doPrim2 false IntLit Int.( * )
and
CevalPrim2 CDiv = doPrim2 true IntLit Int.(/)
and
CevalPrim2 CMod = doPrim2 true IntLit Int.(%)
and
CevalPrim2 CLt = doPrim2 false Bool Int.(<)
and
CevalPrim2 CEq = fun v1 v2 ->
  if no_closures v1 && no_closures v2
  then Rval (CLitv (Bool (v1 = v2)))
  else Rerr Rtype_error

let rec
CevalUpd s (CLoc n) (v:Cv) =
  if n < List.length s
  then (lupdate v n s, Rval (CLitv Unit))
  else (s, Rerr Rtype_error)
and
CevalUpd s _ _ = (s, Rerr Rtype_error)

let rec
CevalPrim1 CRef s v = (s@[v], Rval (CLoc (List.length s)))
and
CevalPrim1 CDer s (CLoc n) =
  (s, match el_check n s with
      | None -> Rerr Rtype_error
      | Some v -> Rval v
      end)
and
CevalPrim1 _ s _ = (s, Rerr Rtype_error)

indreln
forall c s env error.
true
==>
Cevaluate c s env (CRaise error) (s, Rerr (Rraise error))

and
forall c s1 env e1 e2 s2 v.
Cevaluate c s1 env e1 (s2, Rval v)
==>
Cevaluate c s1 env (CHandle e1 e2) (s2, Rval v)
and
forall c s1 env e1 e2 s2 n res.
Cevaluate c s1 env e1 (s2, Rerr (Rraise (Int_error n))) &&
Cevaluate c s2 ((CLitv (IntLit n))::env) e2 res
==>
Cevaluate c s1 env (CHandle e1 e2) res
and
forall c s1 env e1 e2 s2 err.
Cevaluate c s1 env e1 (s2, Rerr err) &&
(forall n. not (err = Rraise (Int_error n)))
==>
Cevaluate c s1 env (CHandle e1 e2) (s2, Rerr err)

and
forall c s env n.
n < List.length env
==>
Cevaluate c s env (CVar n) (s, Rval (List.nth env n))

and
forall c s env l.
true
==>
Cevaluate c s env (CLit l) (s, Rval (CLitv l))

and
forall c s env n es s' vs.
Cevaluate_list c s env es (s', Rval vs)
==>
Cevaluate c s env (CCon n es) (s', Rval (CConv n vs))
and
forall c s env n es s' err.
Cevaluate_list c s env es (s', Rerr err)
==>
Cevaluate c s env (CCon n es) (s', Rerr err)

and
forall c s env e n m s' vs.
Cevaluate c s env e (s', Rval (CConv m vs))
==>
Cevaluate c s env (CTagEq e n) (s', Rval (CLitv (Bool (n = m))))
and
forall c s env e n s' err.
Cevaluate c s env e (s', Rerr err)
==>
Cevaluate c s env (CTagEq e n) (s', Rerr err)

and
forall c s env e n m s' vs.
Cevaluate c s env e (s', Rval (CConv m vs)) &&
n < List.length vs
==>
Cevaluate c s env (CProj e n) (s', Rval (List.nth vs n))
and
forall c s env e n s' err.
Cevaluate c s env e (s', Rerr err)
==>
Cevaluate c s env (CProj e n) (s', Rerr err)

and
forall c s env e b s' v r.
Cevaluate c s env e (s', Rval v) &&
Cevaluate c s' (v::env) b r
==>
Cevaluate c s env (CLet e b) r
and
forall c s env e b s' err.
Cevaluate c s env e (s', Rerr err)
==>
Cevaluate c s env (CLet e b) (s', Rerr err)

and
forall c s env defs b r.
List.for_all (fun cb -> forall l. cb = Inr l --> Pmap.mem l c
  && (Pmap.find l c).nz = List.length defs
  && (Pmap.find l c).ez = List.length env) defs &&
Cevaluate c s
  (List.append (List.rev (genlist (CRecClos env defs) (List.length defs))) env)
  b r
==>
Cevaluate c s env (CLetrec defs b) r

and
forall c s env cb.
(forall l. cb = Inr l --> Pmap.mem l c
  && (Pmap.find l c).nz = 1
  && (Pmap.find l c).ez = List.length env)
==>
Cevaluate c s env (CFun cb) (s, Rval (CRecClos env [cb] 0))

and
forall c s env e es s' cenv defs n cb b env'' s'' vs r.
Cevaluate c s env e (s', Rval (CRecClos cenv defs n)) &&
n < List.length defs && List.nth defs n = cb &&
Cevaluate_list c s' env es (s'', Rval vs) &&
(true,List.length vs,List.length defs,List.length cenv,env'',b) =
  match cb with
  | Inl (k,b) ->
    (true
    ,k
    ,List.length defs
    ,List.length cenv
    ,(List.rev vs)@(List.rev (genlist (CRecClos cenv defs) (List.length defs)))@cenv
    ,b)
  | Inr l -> let d = Pmap.find l c in
             let (recs,envs) = d.cd.ceenv in
    (Pmap.mem l c
     && List.for_all (fun n -> n < List.length cenv) envs
     && List.for_all (fun n -> n < List.length defs) recs
    ,d.cd.az
    ,d.nz
    ,d.ez
    ,List.rev vs
    @((CRecClos cenv defs n)::List.map (CRecClos cenv defs) recs)
    @List.map (List.nth cenv) envs
    ,d.cd.body)
  end &&
Cevaluate c s'' env'' b r
==>
Cevaluate c s env (CCall e es) r
and
forall c s env e s' v es s'' err.
Cevaluate c s env e (s', Rval v) &&
Cevaluate_list c s' env es (s'', Rerr err)
==>
Cevaluate c s env (CCall e es) (s'', Rerr err)

and
forall c s env e es s' err.
Cevaluate c s env e (s', Rerr err)
==>
Cevaluate c s env (CCall e es) (s', Rerr err)

and
forall c s env uop e s' v.
Cevaluate c s env e (s', Rval v)
==>
Cevaluate c s env (CPrim1 uop e) (CevalPrim1 uop s' v)
and
forall c s env uop e s' err.
Cevaluate c s env e (s', Rerr err)
==>
Cevaluate c s env (CPrim1 uop e) (s', Rerr err)

and
forall c s env p2 e1 e2 s' v1 v2.
Cevaluate_list c s env [e1;e2] (s', Rval [v1;v2])
==>
Cevaluate c s env (CPrim2 p2 e1 e2) (s', CevalPrim2 p2 v1 v2)
and
forall c s env p2 e1 e2 s' err.
Cevaluate_list c s env [e1;e2] (s', Rerr err)
==>
Cevaluate c s env (CPrim2 p2 e1 e2) (s', Rerr err)

and
forall c s env e1 e2 s' v1 v2.
Cevaluate_list c s env [e1;e2] (s', Rval [v1;v2])
==>
Cevaluate c s env (CUpd e1 e2) (CevalUpd s' v1 v2)
and
forall c s env e1 e2 s' err.
Cevaluate_list c s env [e1;e2] (s', Rerr err)
==>
Cevaluate c s env (CUpd e1 e2) (s', Rerr err)

and
forall c s env e1 e2 e3 s' b1 r.
Cevaluate c s env e1 (s', Rval (CLitv (Bool b1))) &&
Cevaluate c s' env (if b1 then e2 else e3) r
==>
Cevaluate c s env (CIf e1 e2 e3) r
and
forall c s env e1 e2 e3 s' err.
Cevaluate c s env e1 (s', Rerr err)
==>
Cevaluate c s env (CIf e1 e2 e3) (s', Rerr err)

and
forall c s env.
true
==>
Cevaluate_list c s env [] (s, Rval [])
and
forall c s env e es s' v s'' vs.
Cevaluate c s env e (s', Rval v) &&
Cevaluate_list c s' env es (s'', Rval vs)
==>
Cevaluate_list c s env (e::es) (s'', Rval (v::vs))
and
forall c s env e es s' err.
Cevaluate c s env e (s', Rerr err)
==>
Cevaluate_list c s env (e::es) (s', Rerr err)
and
forall c s env e es s' v s'' err.
Cevaluate c s env e (s', Rval v) &&
Cevaluate_list c s' env es (s'', Rerr err)
==>
Cevaluate_list c s env (e::es) (s'', Rerr err)

(* equivalence relations on intermediate language *)

let rec closed_cd cd = forall v. v IN free_vars cd.body -->
  v < cd.az + List.length(fst cd.ceenv) + List.length (snd cd.ceenv) + 1

let rec
syneq_cb_aux c d nz ez (Inl (az,e)) = (d<nz,az,e,nz+ez,
  fun n -> if n < nz then CCRef (nz-n-1) else
           if n < nz+ez then CCEnv (n-nz)
           else CCArg n)
and
syneq_cb_aux c d nz ez (Inr l) =
  let cd = Pmap.find l c in
  let (recs,envs) = cd.cd.ceenv in
  (Pmap.mem l c && cd.nz = nz && cd.ez = ez
   && List.for_all (fun n -> n < nz) recs
   && List.for_all (fun n -> n < ez) envs
   && d < nz
  ,cd.cd.az
  ,cd.cd.body
  ,1+List.length recs+List.length envs
  ,fun n -> if n = 0 then if d < nz then CCRef d else CCArg n else
            if n < 1+List.length recs then
              if (List.nth recs (n-1)) < nz
              then CCRef (List.nth recs (n-1))
              else CCArg n
            else
            if n < 1+List.length recs+List.length envs then
              if (List.nth envs (n-1-List.length recs)) < ez
              then CCEnv (List.nth envs (n-1-List.length recs))
              else CCArg n
            else CCArg n
  )

let rec syneq_cb_V az r1 r2 V V' v1 v2 =
  (v1 < az && v2 = v1) ||
  (az <= v1 && az <= v2 &&
   ((exists j1 j2. (r1 (v1-az) = CCRef j1 && r2 (v2-az) = CCRef j2 && V' j1 j2)) ||
    (exists j1 j2. (r1 (v1-az) = CCEnv j1 && r2 (v2-az) = CCEnv j2 && V  j1 j2)) ||
    (exists j. (r1 (v1-az) = CCArg j) && r2 (v2-az) = CCArg j)))

indreln
forall c1 c2 ez1 ez2 V xs1 xs2.
List.for_all2 (fun v1 v2 -> (v1 < ez1 && v2 < ez2 && V v1 v2) ||
                            (ez1 <= v1 && ez2 <= v2 && v1 = v2))
  (List.map fst xs1) (List.map fst xs2)
==>
syneq_exp c1 c2 ez1 ez2 V (CDecl xs1) (CDecl xs2)
and
forall c1 c2 ez1 ez2 V err.
true
==>
syneq_exp c1 c2 ez1 ez2 V (CRaise err) (CRaise err)
and
forall c1 c2 ez1 ez2 V e1 b1 e2 b2.
syneq_exp c1 c2 ez1 ez2 V e1 e2 &&
syneq_exp c1 c2 (ez1+1) (ez2+1) (fun v1 v2 -> (v1 = 0 && v2 = 0) || 0 < v1 && 0 < v2 && V (v1-1) (v2-1)) b1 b2
==>
syneq_exp c1 c2 ez1 ez2 V (CHandle e1 b1) (CHandle e2 b2)
and
forall c1 c2 ez1 ez2 V v1 v2.
(v1 < ez1 && v2 < ez2 && V v1 v2) ||
(ez1 <= v1 && ez2 <= v2 && v1 = v2)
==>
syneq_exp c1 c2 ez1 ez2 V (CVar v1) (CVar v2)
and
forall c1 c2 ez1 ez2 V lit.
true
==>
syneq_exp c1 c2 ez1 ez2 V (CLit lit) (CLit lit)
and
forall c1 c2 ez1 ez2 V cn es1 es2.
List.for_all2 (syneq_exp c1 c2 ez1 ez2 V) es1 es2
==>
syneq_exp c1 c2 ez1 ez2 V (CCon cn es1) (CCon cn es2)
and
forall c1 c2 ez1 ez2 V n e1 e2.
syneq_exp c1 c2 ez1 ez2 V e1 e2
==>
syneq_exp c1 c2 ez1 ez2 V (CTagEq e1 n) (CTagEq e2 n)
and
forall c1 c2 ez1 ez2 V n e1 e2.
syneq_exp c1 c2 ez1 ez2 V e1 e2
==>
syneq_exp c1 c2 ez1 ez2 V (CProj e1 n) (CProj e2 n)
and
forall c1 c2 ez1 ez2 V e1 b1 e2 b2.
syneq_exp c1 c2 ez1 ez2 V e1 e2 &&
syneq_exp c1 c2 (ez1+1) (ez2+1) (fun v1 v2 -> (v1 = 0 && v2 = 0) || 0 < v1 && 0 < v2 && V (v1-1) (v2-1)) b1 b2
==>
syneq_exp c1 c2 ez1 ez2 V (CLet e1 b1) (CLet e2 b2)
and
forall c1 c2 ez1 ez2 V defs1 defs2 b1 b2 V'.
syneq_defs c1 c2 ez1 ez2 V defs1 defs2 V' &&
syneq_exp c1 c2 (ez1+(List.length defs1)) (ez2+(List.length defs2))
 (fun v1 v2 -> (v1 < List.length defs1 && v2 < List.length defs2
                && V' (List.length defs1-v1-1) (List.length defs2-v2-1)) ||
               (List.length defs1 <= v1 && List.length defs2 <= v2
                && V (v1-List.length defs1) (v2-List.length defs2)))
 b1 b2
==>
syneq_exp c1 c2 ez1 ez2 V (CLetrec defs1 b1) (CLetrec defs2 b2)
and
forall c1 c2 ez1 ez2 V cb1 cb2 V'.
syneq_defs c1 c2 ez1 ez2 V [cb1] [cb2] V' &&
V' 0 0
==>
syneq_exp c1 c2 ez1 ez2 V (CFun cb1) (CFun cb2)
and
forall c1 c2 ez1 ez2 V e1 e2 es1 es2.
syneq_exp c1 c2 ez1 ez2 V e1 e2 &&
List.for_all2 (syneq_exp c1 c2 ez1 ez2 V) es1 es2
==>
syneq_exp c1 c2 ez1 ez2 V (CCall e1 es1) (CCall e2 es2)
and
forall c1 c2 ez1 ez2 V p1 e1 e2.
syneq_exp c1 c2 ez1 ez2 V e1 e2
==>
syneq_exp c1 c2 ez1 ez2 V (CPrim1 p1 e1) (CPrim1 p1 e2)
and
forall c1 c2 ez1 ez2 V p2 e11 e21 e12 e22.
syneq_exp c1 c2 ez1 ez2 V e11 e12 &&
syneq_exp c1 c2 ez1 ez2 V e21 e22
==>
syneq_exp c1 c2 ez1 ez2 V (CPrim2 p2 e11 e21) (CPrim2 p2 e12 e22)
and
forall c1 c2 ez1 ez2 V e11 e21 e12 e22.
syneq_exp c1 c2 ez1 ez2 V e11 e12 &&
syneq_exp c1 c2 ez1 ez2 V e21 e22
==>
syneq_exp c1 c2 ez1 ez2 V (CUpd e11 e21) (CUpd e12 e22)
and
forall c1 c2 ez1 ez2 V e11 e21 e31 e12 e22 e32.
syneq_exp c1 c2 ez1 ez2 V e11 e12 &&
syneq_exp c1 c2 ez1 ez2 V e21 e22 &&
syneq_exp c1 c2 ez1 ez2 V e31 e32
==>
syneq_exp c1 c2 ez1 ez2 V (CIf e11 e21 e31) (CIf e12 e22 e32)
and
forall c1 c2 ez1 ez2 V defs1 defs2 V'.
((List.for_all (fun cb -> forall l. cb = Inr l --> Pmap.mem l c1
  && (Pmap.find l c1).nz = List.length defs1
  && (Pmap.find l c1).ez = ez1) defs1) =
 (List.for_all (fun cb -> forall l. cb = Inr l --> Pmap.mem l c2
   && (Pmap.find l c2).nz = List.length defs2
   && (Pmap.find l c2).ez = ez2) defs2)) &&
(forall n1 n2. V' n1 n2 -->
  n1 < List.length defs1 && n2 < List.length defs2 &&
  exists b az e1 j1 r1 e2 j2 r2.
  (b,az,e1,j1,r1) = syneq_cb_aux c1 n1 (List.length defs1) ez1 (List.nth defs1 n1) &&
  (b,az,e2,j2,r2) = syneq_cb_aux c2 n2 (List.length defs2) ez2 (List.nth defs2 n2) &&
  syneq_exp c1 c2 (az+j1) (az+j2) (syneq_cb_V az r1 r2 V V') e1 e2)
==>
syneq_defs c1 c2 ez1 ez2 V defs1 defs2 V'
and
forall c z V defs V'.
(forall v. v < z --> V v v) &&
(V' = fun v1 v2 -> v1 < List.length defs && v2 = v1)
==>
syneq_defs c c z z V defs defs V'

indreln
forall c1 c2 l.
true
==>
syneq c1 c2 (CLitv l) (CLitv l)
and
forall c1 c2 cn vs1 vs2.
List.for_all2 (syneq c1 c2) vs1 vs2
==>
syneq c1 c2 (CConv cn vs1) (CConv cn vs2)
and
forall c1 c2 V env1 env2 defs1 defs2 d1 d2 V'.
(forall v1 v2. V v1 v2 -->
  (v1 < List.length env1 && v2 < List.length env2 &&
   syneq c1 c2 (List.nth env1 v1) (List.nth env2 v2))) &&
syneq_defs c1 c2 (List.length env1) (List.length env2) V defs1 defs2 V' &&
((d1 < List.length defs1 && d2 < List.length defs2 && V' d1 d2) ||
 (List.length defs1 <= d1 && List.length defs2 <= d2 && d1 = d2))
==>
syneq c1 c2 (CRecClos env1 defs1 d1) (CRecClos env2 defs2 d2)
and
forall c1 c2 n.
true
==>
syneq c1 c2 (CLoc n) (CLoc n)

(*
let rec syneq_cds ez1 ez2 V c1 c2 =
forall l. (Pmap.mem l c1 || Pmap.mem l c2) -->
  exists az nz ix e1 j1 r1 e2 j2 r2.
  (az,e1,j1,r1) = syneq_cb_aux c1 ix nz ez1 (Inr l) &&
  (az,e2,j2,r2) = syneq_cb_aux c2 ix nz ez2 (Inr l) &&
  syneq_exp c1 c2 (az+j1) (az+j2) (syneq_cb_V az r1 r2 V) e1 e2
*)

(* Compiler *)

(* source to intermediate expressions *)

let rec
mkshift f k (CDecl vs) = CDecl (List.map (fun (n,m) -> (if n < k then n else (f (n-k))+k, m)) vs)
and
mkshift f k (CRaise err) = CRaise err
and
mkshift f k (CHandle e1 e2) = CHandle (mkshift f k e1) (mkshift f (k+1) e2)
and
mkshift f k (CVar v) = CVar (if v < k then v else (f (v-k))+k)
and
mkshift f k (CLit l) = CLit l
and
mkshift f k (CCon cn es) = CCon cn (List.map (mkshift f k) es)
and
mkshift f k (CTagEq e m) = CTagEq (mkshift f k e) m
and
mkshift f k (CProj e m) = CProj (mkshift f k e) m
and
mkshift f k (CLet e b) = CLet (mkshift f k e) (mkshift f (k+1) b)
and
mkshift f k (CLetrec defs b) =
  let ns = List.length defs in
  let defs = List.map (fun cb ->
    match cb with | Inr l -> Inr l | Inl (az,b) -> Inl (az,mkshift f (k+ns+az) b) end)
    defs in
  CLetrec defs (mkshift f (k+ns) b)
and
mkshift f k (CFun cb) = CFun
  (match cb with | Inr l -> Inr l | Inl (az,b) -> Inl (az,mkshift f (k+1+az) b) end)
and
mkshift f k (CCall e es) = CCall (mkshift f k e) (List.map (mkshift f k) es)
and
mkshift f k (CPrim1 p1 e) = CPrim1 p1 (mkshift f k e)
and
mkshift f k (CPrim2 p2 e1 e2) = CPrim2 p2 (mkshift f k e1) (mkshift f k e2)
and
mkshift f k (CUpd e1 e2) = CUpd (mkshift f k e1) (mkshift f k e2)
and
mkshift f k (CIf e1 e2 e3) = CIf (mkshift f k e1) (mkshift f k e2) (mkshift f k e3)

let shift n = mkshift (fun v -> v+n)

(* remove pattern-matching using continuations *)

type exp_to_Cexp_state = <| bvars : list string ; cnmap : Pmap.map string num |>
let rec cbv m v = <| m with bvars = v::m.bvars |>

let rec
pat_to_Cpat m (Pvar vn _) = (<|m with bvars = vn::m.bvars|>, CPvar)
and
pat_to_Cpat m (Plit l) = (m, CPlit l)
and
pat_to_Cpat m (Pcon cn ps) =
  let (m,Cps) = pats_to_Cpats m ps in
  (m,CPcon (Pmap.find cn m.cnmap) Cps)
and
pat_to_Cpat m (Pref p) =
  let (m,Cp) = pat_to_Cpat m p in
  (m,CPref Cp)
and
pats_to_Cpats m [] = (m,[])
and
pats_to_Cpats m (p::ps) =
  let (m,Cp) = pat_to_Cpat m p in
  let (m,Cps) = pats_to_Cpats m ps in
  (m,Cp::Cps)

let rec
Cpat_vars CPvar = 1
and
Cpat_vars (CPlit _) = 0
and
Cpat_vars (CPcon _ ps) = Cpat_vars_list ps
and
Cpat_vars (CPref p) = Cpat_vars p
and
Cpat_vars_list [] = 0
and
Cpat_vars_list (p::ps) = (Cpat_vars p)+(Cpat_vars_list ps)

let rec
remove_mat_vp fk sk v CPvar =
  CLet (CVar v) sk
and
remove_mat_vp fk sk v (CPlit l) =
  CIf (CPrim2 CEq (CVar v) (CLit l))
    sk (CCall (CVar fk) [])
and
remove_mat_vp fk sk v (CPcon cn ps) =
  CIf (CTagEq (CVar v) cn)
    (remove_mat_con fk sk v 0 ps)
    (CCall (CVar fk) [])
and
remove_mat_vp fk sk v (CPref p) =
  CLet (CPrim1 CDer (CVar v))
    (remove_mat_vp (fk+1) (shift 1 (Cpat_vars p) sk) 0 p)
and
remove_mat_con fk sk v n [] = sk
and
remove_mat_con fk sk v n (p::ps) =
  let p1 = Cpat_vars p in
  let p2 = Cpat_vars_list ps in
  CLet (CProj (CVar v) n)
    (remove_mat_vp (fk+1)
      (remove_mat_con (fk+1+p1) (shift 1 (p2+p1) sk) (v+1+p1) (n+1) ps)
      0 p)

let rec
remove_mat_var v [] = CRaise Bind_error
and
remove_mat_var v ((p,sk)::pes) =
  CLet (CFun (Inl (0,shift 1 0 (remove_mat_var v pes))))
    (remove_mat_vp 0 (shift 1 (Cpat_vars p) sk) (v+1) p)

let rec
exp_to_Cexp m (Handle e x b) =
  CHandle (exp_to_Cexp m e) (exp_to_Cexp (cbv m x) b)
and
exp_to_Cexp m (Raise err) = CRaise err
and
exp_to_Cexp m (Lit l) = CLit l
and
exp_to_Cexp m (Con cn es) =
  CCon (Pmap.find cn m.cnmap) (exps_to_Cexps m es)
and
exp_to_Cexp m (Var vn _) = CVar (the (find_index vn m.bvars 0))
and
exp_to_Cexp m (Fun vn _ e) =
  CFun (Inl (1,shift 1 1 (exp_to_Cexp (cbv m vn) e)))
and
exp_to_Cexp m (App (Opn opn) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CPrim2 (match opn with
          | Plus   -> CAdd
          | Minus  -> CSub
          | Times  -> CMul
          | Divide -> CDiv
          | Modulo -> CMod
          end)
  Ce1 Ce2
and
exp_to_Cexp m (App (Opb opb) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  match opb with
  | Lt -> CPrim2 CLt Ce1 Ce2
  | Leq -> CPrim2 CLt (CPrim2 CSub Ce1 Ce2) (CLit (IntLit i1))
  | opb ->
      CLet Ce1 (
        CLet Ce2 (
          match opb with
          | Gt ->  CPrim2 CLt (CVar 0) (CVar 1)
          | Geq -> CPrim2 CLt (CPrim2 CSub (CVar 1) (CVar 0)) (CLit (IntLit i1))
          end))
  end
and
exp_to_Cexp m (App Equality e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CPrim2 CEq Ce1 Ce2
and
exp_to_Cexp m (App Opapp e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CCall Ce1 [Ce2]
and
exp_to_Cexp m (App Opassign e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CUpd Ce1 Ce2
and
exp_to_Cexp m (Uapp uop e) =
  let Ce = exp_to_Cexp m e in
  CPrim1 (match uop with
          | Opref   -> CRef
          | Opderef -> CDer
          end) Ce
and
exp_to_Cexp m (Log log e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  (match log with
   | And -> CIf Ce1 Ce2 (CLit (Bool false))
   | Or  -> CIf Ce1 (CLit (Bool true)) Ce2
   end)
and
exp_to_Cexp m (If e1 e2 e3) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  let Ce3 = exp_to_Cexp m e3 in
  CIf Ce1 Ce2 Ce3
and
exp_to_Cexp m (Mat e pes) =
  let Ce = exp_to_Cexp m e in
  let Cpes = pes_to_Cpes m pes in
  let Cpes = List.map (fun (p,e) -> (p,shift 1 (Cpat_vars p) e)) Cpes in
  CLet Ce (remove_mat_var 0 Cpes)
and
exp_to_Cexp m (Let _ vn _ e b) =
  let Ce = exp_to_Cexp m e in
  let Cb = exp_to_Cexp (cbv m vn) b in
  CLet Ce Cb
and
exp_to_Cexp m (Letrec _ defs b) =
  let m = <| m with bvars = (List.map (fun (n,_,_,_,_) -> n) defs) @ m.bvars |> in
  CLetrec (List.rev (defs_to_Cdefs m defs)) (exp_to_Cexp m b)
and
defs_to_Cdefs m [] = []
and
defs_to_Cdefs m ((_,_,vn,_,e)::defs) =
  let Ce = exp_to_Cexp (cbv m vn) e in
  let Cdefs = defs_to_Cdefs m defs in
  (Inl (1,Ce))::Cdefs
and
pes_to_Cpes m [] = []
and
pes_to_Cpes m ((p,e)::pes) =
  let Cpes = pes_to_Cpes m pes in
  let (m,Cp) = pat_to_Cpat m p in
  let Ce = exp_to_Cexp m e in
  (Cp,Ce)::Cpes
and
exps_to_Cexps s [] = []
and
exps_to_Cexps m (e::es) =
  exp_to_Cexp m e :: exps_to_Cexps m es

(* pull closure bodies into code environment *)

type label_closures_state =
  <| lnext_label: num
   ; lcode_env: list (num * closure_data)
   |>

let rec bind_fv e az nz j =
  let j = nz-j-1 in
  let fvs = free_vars e in
  let recs = List.filter (fun v -> az+v IN fvs && not (v=j)) (genlist (fun n -> n) nz) in
  let envs = List.filter (fun v -> az+nz <= v) (qsort (fun x y -> x < y) (Set.to_list fvs)) in
  let envs = List.map (fun v -> v-(az+nz)) envs in
  let rz = List.length recs+1 in
  let e = mkshift (fun v -> if v < nz then the(find_index v (j::recs) 0)
                            else the(find_index (v-nz) envs rz))
                  az e in
  let rz = rz-1 in
  <| ccenv = (genlist (fun i -> CCArg (2+i)) (az+1))
            @(genlist CCRef rz)
            @(genlist (fun i -> CCEnv (rz+i)) (List.length envs))
   ; ceenv = (recs,envs)
   ; az = az ; body = e |>

let rec
label_defs (ds:list def) nz k ([]:list def) = return ds
and
label_defs ds nz k ((Inr a)::defs) =
  label_defs ((Inr a)::ds) nz (k+1) defs
and
label_defs ds nz k ((Inl (xs,b))::defs) = bind
  (fun s -> return s.lnext_label
    <| s with
       lnext_label = s.lnext_label+1 ;
       lcode_env = (s.lnext_label,(bind_fv b xs nz k))::s.lcode_env
     |>) (fun n ->
  (label_defs ((Inr n)::ds) nz (k+1) defs))

let rec
label_closures (CDecl xs) = return (CDecl xs)
and
label_closures (CRaise err) = return (CRaise err)
and
label_closures (CHandle e1 e2) = bind
  (label_closures e1) (fun e1 -> bind
  (label_closures e2) (fun e2 -> return
  (CHandle e1 e2)))
and
label_closures (CVar x) = return (CVar x)
and
label_closures (CLit l) = return (CLit l)
and
label_closures (CCon cn es) = bind
  (label_closures_list es) (fun es -> return
  (CCon cn es))
and
label_closures (CTagEq e n) = bind
  (label_closures e) (fun e -> return
  (CTagEq e n))
and
label_closures (CProj e n) = bind
  (label_closures e) (fun e -> return
  (CProj e n))
and
label_closures (CLet e b) = bind
  (label_closures e) (fun e -> bind
  (label_closures b) (fun b -> return
  (CLet e b)))
and
label_closures (CLetrec defs e) = bind
  (label_defs [] (List.length defs) 0 defs) (fun defs -> bind
  (label_closures e) (fun e -> return
  (CLetrec (List.rev defs) e)))
and
label_closures (CFun cb) = bind
  (label_defs [] 1 0 [cb]) (fun defs ->
  return (CFun (List.nth defs 0)))
and
label_closures (CCall e es) = bind
  (label_closures e) (fun e -> bind
  (label_closures_list es) (fun es -> return
  (CCall e es)))
and
label_closures (CPrim1 uop e) = bind
  (label_closures e) (fun e -> return
    (CPrim1 uop e))
and
label_closures (CPrim2 op e1 e2) = bind
  (label_closures e1) (fun e1 -> bind
  (label_closures e2) (fun e2 -> return
  (CPrim2 op e1 e2)))
and
label_closures (CUpd e1 e2) = bind
  (label_closures e1) (fun e1 -> bind
  (label_closures e2) (fun e2 -> return
  (CUpd e1 e2)))
and
label_closures (CIf e1 e2 e3) = bind
  (label_closures e1) (fun e1 -> bind
  (label_closures e2) (fun e2 -> bind
  (label_closures e3) (fun e3 -> return
  (CIf e1 e2 e3))))
and
label_closures_list [] = return []
and
label_closures_list (e::es) = bind
  (label_closures e) (fun e -> bind
  (label_closures_list es) (fun es -> return
  (e::es)))

let rec (* TODO: replace by SUM o FILTER ISR ? *)
count_unlab [] = 0
and
count_unlab ((Inl _)::ls) = 1 + count_unlab ls
and
count_unlab ((Inr _)::ls) = count_unlab ls

(* imm_unlab e = number of unlabeled (Inl) bodies, without looking
 * recursively at any of the bodies *)
let rec
imm_unlab (CDecl xs) = 0
and
imm_unlab (CRaise err) = 0
and
imm_unlab (CHandle e1 e2) = imm_unlab e1 + imm_unlab e2
and
imm_unlab (CVar x) = 0
and
imm_unlab (CLit l) = 0
and
imm_unlab (CCon cn es) = imm_unlab_list es
and
imm_unlab (CTagEq e n) = imm_unlab e
and
imm_unlab (CProj e n) = imm_unlab e
and
imm_unlab (CLet e b) = imm_unlab e + imm_unlab b
and
imm_unlab (CLetrec defs e) = count_unlab defs + imm_unlab e
and
imm_unlab (CFun cb) = count_unlab [cb]
and
imm_unlab (CCall e es) = imm_unlab e + imm_unlab_list es
and
imm_unlab (CPrim2 op e1 e2) = imm_unlab e1 + imm_unlab e2
and
imm_unlab (CUpd e1 e2) = imm_unlab e1 + imm_unlab e2
and
imm_unlab (CPrim1 uop e) = imm_unlab e
and
imm_unlab (CIf e1 e2 e3) = imm_unlab e1 + imm_unlab e2 + imm_unlab e3
and
imm_unlab_list [] = 0
and
imm_unlab_list (e::es) = imm_unlab e + imm_unlab_list es

let rec
repeat_label_closures e n ac =
  if imm_unlab e = 0 then (e,n,ac) else
  let s = <| lnext_label = n; lcode_env = [] |> in
  let (e,s) = label_closures e s in
  let (n,ac) = label_code_env s.lnext_label ac s.lcode_env in
  (e,n,ac)
and
label_code_env n ac [] = (n,ac)
and
label_code_env n ac ((l,cd)::ls) =
  let (e,n,ac) = repeat_label_closures cd.body n ac in
  label_code_env n ((l,<| cd with body = e |>)::ac) ls

(* intermediate expressions to bytecode *)

open Bytecode

type call_context = TCNonTail of bool | TCTail of num * num
(* TCTail j k = in tail position,
   * the called function has j arguments, and
   * k let variables have been bound *)
(* TCNonTail b = if b then in tail position, but called from top-level,
 * else not in tail position. *)

type compiler_result =
  <| out: list bc_inst (* reversed code *)
   ; next_label: num
   ; decl: ctenv * num * list string
   |>

let rec
prim1_to_bc CRef = Ref
and
prim1_to_bc CDer = Deref

let rec
prim2_to_bc CAdd = Add
and
prim2_to_bc CSub = Sub
and
prim2_to_bc CMul = Mult
and
prim2_to_bc CDiv = Div
and
prim2_to_bc CMod = Mod
and
prim2_to_bc CLt = Less
and
prim2_to_bc CEq = Equal

let emit = List.fold_left (fun s i -> <| s with out = i :: s.out |>)

let rec
get_labels n s = (<| s with next_label = s.next_label + n |>,
                  genlist (fun i -> s.next_label + i) n)

let rec
compile_envref sz s (CCArg n) = emit s [Stack (Load (sz + n))]
and
compile_envref sz s (CCEnv n) = emit s [Stack (Load sz); Stack (El n)]
and
compile_envref sz s (CCRef n) = emit (compile_envref sz s (CCEnv n)) [Deref]

let rec
compile_varref sz s (CTLet n) = emit s [Stack (Load (sz - n))]
and
compile_varref sz s (CTEnv x) = compile_envref sz s x

(* calling convention:
 * before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
 * thus, since env = stack[sz], argk should be CTArg (2 + n - k)
 * after:  retval,
 *)

(* closure representation:
 * Block 3 [CodePtr f; Env]
 * where Env = Number 0 for empty, or else
 * Block 3 [v1,...,vk]
 * with a value for each free variable
 * (some values may be RefPtrs to other (mutrec) closures)
 *)

(* closure construction, for a bundle of nz names, nk defs:
 * - push nz refptrs
 * - push nk CodePtrs, each pointing to the appropriate body
 * - for each def, load its CodePtr, load its environment, cons them up, and
     store them where its CodePtr was
   - for each name, load the refptr and update it with the closure
   - for each name, store the refptr back where it was
 *)

let rec
emit_ceenv env (sz,s) fv = (sz+1,compile_varref sz s (List.nth env fv))

let rec
(* sz                                                                                         z *)
(* e, ..., e, CodePtr_k, CodePtr nk, ..., CodePtr k, ..., cl_1, RefPtr_nz 0, ..., RefPtr_1 0,   *)
emit_ceref nz z (sz,s) j = (sz+1,emit s [Stack (Load (sz-z-(nz-j)))])

let rec
push_lab d (s,ecs) (Inl _) = (s,([],[])::ecs) (* should not happen *)
and
push_lab d (s,ecs) (Inr l) =
  (emit s [PushPtr (Lab l)],(Pmap.find l d).ceenv::ecs)

let rec
cons_closure env0 sz0 sz1 nk (s,k) (refs,envs) =
  (* sz1                                                                  sz0 *)
  (* CodePtr nk, ..., CodePtr k, ..., cl_1, RefPtr_nk 0, ..., RefPtr_1 0,     *)
  let s = emit s [Stack (Load (nk - k))] in
  (* CodePtr_k, CodePtr nk, ..., CodePtr k, ..., cl_1, RefPtr_nk 0, ..., RefPtr_1 0, *)
  let (z,s) = List.fold_left (emit_ceref nk sz0) (sz1+1,s) refs in
  let (z,s) = List.fold_left (emit_ceenv env0) (z,s) envs in
  (* e_kj, ..., e_k1, CodePtr_k, CodePtr nk, ..., CodePtr k, ..., cl_1, RefPtr_nk 0, ..., RefPtr_1 0, *)
  let s = emit s [Stack (Cons 0 (List.length refs + List.length envs))] in
  (* env_k, CodePtr_k, CodePtr nk, ..., CodePtr k, ..., cl_1, RefPtr_nk 0, ..., RefPtr_1 0, *)
  let s = emit s [Stack (Cons closure_tag 2)] in
  (* cl_k, CodePtr nk, ..., CodePtr k, ..., cl_1, RefPtr_nk 0, ..., RefPtr_1 0, *)
  let s = emit s [Stack (Store (nk - k))] in
  (* CodePtr nk, ..., cl_k, ..., cl_1, RefPtr_nk 0, ..., RefPtr_1 0, *)
  (s,k+1)

let rec
update_refptr nk (s,k) =
  (* nk = nz *)
  (* cl_nk, ..., cl_1, RefPtr_nz 0, ..., RefPtr_k 0, ..., RefPtr_1 cl_1, *)
  let s = emit s [Stack (Load (nk + nk - k))] in
  (* RefPtr_k 0, cl_nk, ..., cl_1, RefPtr_nz 0, ..., RefPtr_k 0, ..., RefPtr_1 cl_1, *)
  let s = emit s [Stack (Load (1 + nk - k))] in
  (* cl_k, RefPtr_k 0, cl_nk, ..., cl_1, RefPtr_nz 0, ..., RefPtr_k 0, ..., RefPtr_1 cl_1, *)
  let s = emit s [Update] in
  (* cl_nk, ..., cl_1, RefPtr_nz 0, ..., RefPtr_k cl_k, ..., RefPtr_1 cl_1, *)
  (s,k+1)

let rec
compile_closures d env sz s defs =
  let nk = List.length defs in
  let s = num_fold (fun s -> emit s [Stack (PushInt i0); Ref]) s nk in
  (* RefPtr_nk 0, ..., RefPtr_2 0, RefPtr_1 0, *)
  let (s,ecs) = List.fold_left (push_lab d) (s,[]) defs in
  (* CodePtr nk, ..., CodePtr 2, CodePtr 1, RefPtr_nk 0, ..., RefPtr_1 0, *)
  let (s,_k) = List.fold_left (cons_closure env sz (sz+nk+nk) nk) (s,1) (List.rev ecs) in
  (* Block 3 [CodePtr nk, env_nk], ..., Block 3 [CodePtr 1, env_1], RefPtr_nk 0, ..., RefPtr_1 0, *)
  let (s,_k) = num_fold (update_refptr nk) (s,1) nk in
  (* cl_nk, ..., cl_1, RefPtr_nk cl_nk, ..., RefPtr_1 cl_1, *)
  let k = nk - 1 in
  num_fold (fun s -> emit s [Stack (Store k)]) s nk
  (* cl_nk, ..., cl_1, *)

let rec
compile_decl env1 =
  List.fold_left
    (fun (s,sz,i,env,bvs) (v,bv) ->
      match find_index bv bvs 1 with
      | None ->
          (compile_varref sz s (List.nth env1 v)
          ,sz+1
          ,i+1
          ,(CTLet i)::env
          ,bv::bvs
          )
      | Some j ->
          (emit (compile_varref sz s (List.nth env1 v)) [Stack (Store ((sz+j)-i))]
          ,sz
          ,i
          ,env
          ,bvs
          )
      end)

let rec
pushret (TCNonTail _) s = s
and
pushret (TCTail j k) s =
 (* val, vk, ..., v1, env, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c; env], *)
  emit s [Stack (Pops (k+1));
 (* val, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c; env], *)
          Stack (Load 1);
 (* CodePtr ret, val, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c; env], *)
          Stack (Store (j+2));
 (* val, CodePtr ret, argj, ..., arg1, CodePtr ret, *)
          Stack (Pops (j+1));
 (* val, CodePtr ret, *)
          Return]

let rec
compile _ env t sz s (CDecl vs) =
  match t with TCNonTail true ->
  match s.decl with (env0,sz0,bvs0) ->
  let k = sz - sz0 in
  let (s,sz,i,env,bvs) = compile_decl env (s,sz,sz0+1,env0,bvs0) vs in
  let s = emit s [Stack (Shift (i-(sz0+1)) k)] in
  <| s with decl = (env,sz-k,bvs) |>
  end | _ -> pushret t (emit s [Stack (PushInt i2); PopExc]) (* should not happen *) end
and
compile _ _ t _ s (CRaise err) =
  pushret t (emit s [Stack (PushInt (error_to_int err)); PopExc])
and
compile d env t sz s (CHandle e1 e2) = compile d env t sz s e1
and
compile _ _ t _ s (CLit (IntLit i)) =
  pushret t (emit s [Stack (PushInt i)])
and
compile _ _ t _ s (CLit (Bool b)) =
  pushret t (emit s [Stack (Cons (bool_to_tag b) 0)])
and
compile _ _ t _ s (CLit Unit) =
  pushret t (emit s [Stack (Cons unit_tag 0)])
and
compile _ env t sz s (CVar vn) = pushret t (compile_varref sz s (List.nth env vn))
and
compile d env t sz s (CCon n es) =
  pushret t (emit (compile_nts d env sz s es) [Stack (Cons (n+block_tag) (List.length es))])
and
compile d env t sz s (CTagEq e n) =
  pushret t (emit (compile d env (TCNonTail false) sz s e) [Stack (TagEq (n+block_tag))])
and
compile d env t sz s (CProj e n) =
  pushret t (emit (compile d env (TCNonTail false) sz s e) [Stack (El n)])
and
compile d env t sz s (CLet e eb) =
  compile_bindings d env t sz eb 0 (compile d env (TCNonTail false) sz s e) 1
and
compile d env t sz s (CLetrec defs eb) =
  let s = compile_closures d env sz s defs in
  compile_bindings d env t sz eb 0 s (List.length defs)
and
compile d env t sz s (CFun cb) =
  pushret t (compile_closures d env sz s [cb])
and
compile d env t sz s (CCall e es) =
  let n = List.length es in
  let s = compile_nts d env sz s (e::es) in
  match t with
  | TCNonTail _ ->
    (* argn, ..., arg2, arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [Stack (Load n); Stack (El 1)] in
    (* env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [Stack (Load (n+1)); Stack (El 0)] in
    (* CodePtr c, env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    emit s [CallPtr]
    (* before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    (* after:  retval, *)
  | TCTail j k ->
    (* argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+1+k+1))] in
    (* CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+1)); Stack (El 1)] in
    (* env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+2)); Stack (El 0)] in
    (* CodePtr c, env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Shift (1+1+1+n+1) (k+1+1+j+1))] in
    emit s [JumpPtr]
  end
and
compile d env t sz s (CPrim1 uop e) =
  pushret t (emit (compile d env (TCNonTail false) sz s e) [prim1_to_bc uop])
and
compile d env t sz s (CPrim2 op e1 e2) = (* TODO: need to detect div by zero? *)
  pushret t (emit (compile_nts d env sz s [e1;e2]) [Stack (prim2_to_bc op)])
and
compile d env t sz s (CUpd e1 e2) =
  pushret t (emit (compile_nts d env sz s [e1;e2]) [Update; Stack (Cons unit_tag 0)])
and
compile d env t sz s (CIf e1 e2 e3) =
  let s = compile d env (TCNonTail false) sz s e1 in
  let (s,labs) = get_labels 2 s in
  let n0 = List.nth labs 0 in
  let n1 = List.nth labs 1 in
  match t with
  | TCNonTail _ ->
    let (s,labs) = get_labels 1 s in
    let n2 = List.nth labs 0 in
    let s = emit s [(JumpIf (Lab n0)); (Jump (Lab n1)); Label n0] in
    let s = compile d env t sz s e2 in
    let s = emit s [Jump (Lab n2); Label n1] in
    let s = compile d env t sz s e3 in
    emit s [Label n2]
  | TCTail _ _ ->
    let s = emit s [(JumpIf (Lab n0)); (Jump (Lab n1)); Label n0] in
    let s = compile d env t sz s e2 in
    let s = emit s [Label n1] in
    compile d env t sz s e3
  end
and
compile_bindings d env t sz e n s m =
  if m = 0 then
    match t with
    | TCTail j k -> compile d env (TCTail j (k+n)) (sz+n) s e
    | TCNonTail false ->
      emit (compile d env t (sz+n) s e) [Stack (Pops n)]
    | TCNonTail true ->
      compile d env t (sz+n) s e
    end
  else
    compile_bindings d ((CTLet (sz+(n+1)))::env) t sz e (n+1) s (m-1)
and
compile_nts d env sz s [] = s
and
compile_nts d env sz s (e::es) =
  compile_nts d env (sz+1) (compile d env (TCNonTail false) sz s e) es

(* code env to bytecode *)

let rec
cce_aux d s (l,cd) =
  let s = emit s [Label l] in
  compile d (List.map CTEnv cd.ccenv) (TCTail cd.az 0) 0 s cd.body

let rec
compile_code_env d s c =
  let (s,ls) = get_labels 1 s in
  let l = List.nth ls 0 in
  let s = emit s [Jump (Lab l)] in
  let s = List.fold_left (cce_aux d) s c in
  emit s [Label l]

(* replace labels in bytecode with addresses *)

let rec
calculate_labels il m n a [] = (m,n,a)
and
calculate_labels il m n a (Label l::lbc) =
  calculate_labels il (Pmap.add l n m) n a lbc
and
calculate_labels il m n a (i::lbc) =
  calculate_labels il m (n + il i + 1) (i::a) lbc

let rec
replace_labels m a [] = a
and
replace_labels m a (Jump (Lab l)::bc) =
  replace_labels m (Jump (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (JumpIf (Lab l)::bc) =
  replace_labels m (JumpIf (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (Call (Lab l)::bc) =
  replace_labels m (Call (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (PushPtr (Lab l)::bc) =
  replace_labels m (PushPtr (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (i::bc) =
  replace_labels m (i::a) bc

let rec
compile_labels il lbc =
  let (m,n,bc) = calculate_labels il Pmap.empty 0 [] lbc in
    replace_labels m [] bc

(* repl *)

type contab = Pmap.map conN num * Pmap.map num conN * num
val cmap : contab -> Pmap.map conN num
let rec cmap (m,_,_) = m

type repl_state =
  <| contab : contab
   ; rbvars : list string
   ; renv : ctenv
   ; rsz  : num
   ; rnext_label : num
   |>

val etC : repl_state -> exp_to_Cexp_state
let etC rs = <| bvars = rs.rbvars; cnmap = cmap rs.contab |>

let init_repl_state =
  <| contab = (Pmap.empty, Pmap.empty, 0)
   ; rbvars = []
   ; renv = []
   ; rsz  = 0
   ; rnext_label = 0
   |>

let compile_Cexp rs decl Ce =
  let (Ce,n,c) = repeat_label_closures Ce rs.rnext_label [] in
  let d = alist_to_fmap c in
  let cs = <| out = []; next_label = n
            ; decl = (rs.renv,rs.rsz,rs.rbvars) |> in
  let cs = compile_code_env d cs c in
  let cs = compile d rs.renv (TCNonTail decl) rs.rsz cs Ce in
  let rs = if decl then match cs.decl with
    | (env,sz,bvars) -> <| rs with renv = env; rsz = sz; rbvars = bvars |>
    end else rs in
  let rs = <| rs with rnext_label = cs.next_label |> in
  (rs, List.rev cs.out)

let rec
number_constructors [] ct = ct
and
number_constructors ((c,_)::cs) (m,w,n) =
  number_constructors cs (Pmap.add c n m, Pmap.add n c w, n+1)

let rec
repl_dec rs (Dtype []) = (rs,[])
and
repl_dec rs (Dtype ((_,_,cs)::ts)) =
  let ct = number_constructors cs rs.contab in
  repl_dec <| rs with contab = ct |> (Dtype ts)
and
repl_dec rs (Dletrec _ defs) =
  let m = etC rs in
  let fns = List.rev (List.map (fun (n,_,_,_,_) -> n) defs) in
  let m = <| m with bvars = fns @ m.bvars |> in
  let Cdefs = defs_to_Cdefs m defs in
  compile_Cexp rs true (CLetrec Cdefs (CDecl (List.combine (genlist (fun i -> i) (List.length fns)) fns)))
and
repl_dec rs (Dlet _ p e) =
  let m = etC rs in
  let Ce = exp_to_Cexp m e in
  let (m,Cp) = pat_to_Cpat <| m with bvars = [] |> p in
  let vs = m.bvars in
  let Cpes = [(Cp,CDecl (List.combine (genlist (fun i -> i) (List.length vs)) vs))] in
  compile_Cexp rs true (CLet Ce (remove_mat_var 0 Cpes))

let repl_exp s exp = compile_Cexp s false (exp_to_Cexp (etC s) exp)

(* Correctness *)

(* observable values *)

type ov =
  | OLit of lit
  | OConv of conN * list ov
  | OFn
  | OLoc of num (* machine, not semantic, address *)

let rec
v_to_ov s (Litv l) = OLit l
and
v_to_ov s (Conv cn vs) = OConv cn (List.map (v_to_ov s) vs)
and
v_to_ov s (Closure _ _ _ _) = OFn
and
v_to_ov s (Recclosure _ _ _) = OFn
and
v_to_ov s (Loc n) = OLoc (Pmap.find n s)

let rec
Cv_to_ov m s (CLitv l) = OLit l
and
Cv_to_ov m s (CConv cn vs) = OConv (Pmap.find cn m) (List.map (Cv_to_ov m s) vs)
and
Cv_to_ov m s (CRecClos _ _ _) = OFn
and
Cv_to_ov m s (CLoc n) = OLoc (Pmap.find n s)

let rec
bv_to_ov m (Number i) = OLit (IntLit i)
and
bv_to_ov m (Block n vs) =
  if n = (bool_to_tag false) then OLit (Bool false) else
  if n = (bool_to_tag true) then OLit (Bool true) else
  if n = unit_tag then OLit Unit else
  if n = closure_tag then OFn else
  OConv (Pmap.find (n-block_tag) m) (List.map (bv_to_ov m) vs)
and
bv_to_ov m (RefPtr n) = OLoc n

(* source to intermediate values *)

let rec
v_to_Cv m (Litv l) = CLitv l
and
v_to_Cv m (Conv cn vs) =
  CConv (Pmap.find cn m) (vs_to_Cvs m vs)
and
v_to_Cv m (Closure env vn _ e) =
  let Cenv = env_to_Cenv m env in
  let m = <| bvars = List.map fst env ; cnmap = m |> in
  let Ce = exp_to_Cexp (cbv m vn) e in
  CRecClos Cenv [(Inl (1,shift 1 1 Ce))] 0
and
v_to_Cv m (Recclosure env defs vn) =
  let Cenv = env_to_Cenv m env in
  let m = <| bvars = List.map fst env ; cnmap = m |> in
  let fns = List.map (fun (n,_,_,_,_) -> n) defs in
  let m = <| m with bvars = fns @ m.bvars |> in
  let Cdefs = List.rev (defs_to_Cdefs m defs) in
  CRecClos Cenv Cdefs (the (find_index vn (List.rev fns) 0))
and
v_to_Cv m (Loc n) = CLoc n
and
vs_to_Cvs m [] = []
and
vs_to_Cvs m (v::vs) = v_to_Cv m v :: vs_to_Cvs m vs
and
env_to_Cenv m [] = []
and
env_to_Cenv m ((_,(v,_))::env) =
  (v_to_Cv m v)::(env_to_Cenv m env)

(* intermediate to target values *)

(*
let rec
Cv_to_bv (CLitv (IntLit i)) = Number i
and
Cv_to_bv (CLitv (Bool b)) = Number (bool_to_int b)
and
Cv_to_bv (CConv n vs) = Block n (Cvs_to_bvs vs)
and
Cv_to_bv (CRecClos env ns defs n) = Block 0 [CodePtr ?, ?]
and
Cvs_to_bvs [] = []
and
Cvs_to_bvs (v::vs) = Cv_to_bv v :: Cvs_to_bvs vs
*)

(*
indreln
forall il c cc.
true
==>
bc_code_prefix il (List.append c cc) 0 c
and
forall il p i c cc.
bc_code_prefix il cc p c
==>
bc_code_prefix il (i::cc) (p + il i) c

let rec
body_cs env xs =
  <| env = env; sz = 0; out = []; next_label = 0;
     tail = TCTail (List.length xs) 0; decl = None |>

let rec
body_env ns xs j fvs =
  let (n,env,(nec,ec)) =
    Set.fold (bind_fv ns xs (List.length xs) j) fvs (0,Pmap.empty,(0,[])) in
  (env,ec)

indreln
forall il c i.
true
==>
bceqv il c (CLitv (IntLit i)) (Number i)
and
forall il c b.
true
==>
bceqv il c (CLitv (Bool b)) (Number (bool_to_int b))
and
forall il c n vs bvs.
List.for_all2 (bceqv il c) vs bvs
==>
bceqv il c (CConv n vs) (Block n bvs)
and
forall il c env ns defs n j xs e cenv ec f bvs.
find_index n ns 0 = Some j &&
List.nth defs j = (xs,e) &&
(cenv,ec) = body_env ns xs j (free_vars Pmap.empty e) &&
List.length bvs = List.length ec &&
(forall i. i < List.length ec -->
    (exists fv. List.nth ec i = CEEnv fv &&
                bceqv il c (Pmap.find fv env) (List.nth bvs i)) ||
    (exists k kxs ke kenv kec g.
        List.nth ec i = CERef k &&
        List.nth defs k = (kxs,ke) &&
        (kenv,kec) = body_env ns xs k (free_vars ke) &&
        bc_code_prefix il c g
          (List.rev (compile (body_cs kenv kxs) ke).out))) &&
bc_code_prefix il c f (List.rev (compile (body_cs cenv xs) e).out)
==>
bceqv il c (CRecClos env ns defs n)
  (Block 0 [CodePtr f; if bvs = [] then Number i0 else Block 0 bvs])
*)


(* relating source to intermediate language *)

(*
indreln
forall m c l.
true
==>
v_Cv m c (Litv l) (CLitv l)
and
forall m c cn vs Cvs.
List.for_all2 (v_Cv m c) vs Cvs
==>
v_Cv m c (Conv cn vs) (CConv (Pmap.find cn m) Cvs)
and
forall m c env vn e fn l.
env_Cenv m c env Cenv &&

==>
v_Cv m c (Closure env vn e) (CRecClos Cenv [fn] [([vn],l)] fn)
and
==>
v_Cv m c (Recclosure env defs fn) (CRecClos Cenv fns Cdefs fn)
and
forall c env1 env2 ns defs d.
List.for_all
  (fun (xs,b) ->
    (forall v. v IN (cbod_fvs c b \ (Set.from_list ns union
                                     Set.from_list xs))
      --> (optrel (syneq c)) (flookup env1 v) (flookup env2 v)))
  defs
==>
v_Cv m c (CRecClos env1 ns defs d) (CRecClos env2 ns defs d)
*)

(*
indreln
forall G cm env Cenv err.
true
==>
exp_Cexp G cm env Cenv (Raise err) (CRaise err)
and
forall G cm env Cenv l.
true
==>
exp_Cexp G cm env Cenv (Lit l) (CLit l)
and
forall G cm env Cenv cn es Ces.
Pmap.mem cn cm &&
List.for_all2 (exp_Cexp G cm env Cenv) es Ces
==>
exp_Cexp G cm env Cenv (Con cn es) (CCon (Pmap.find cn cm) Ces)
and
forall G cm env Cenv vn v Cvn.
lookup vn env = Some v &&
Pmap.mem Cvn Cenv &&
G cm v (Pmap.find Cvn Cenv)
==>
exp_Cexp G cm env Cenv (Var vn) (CVar Cvn)
and
forall G cm env Cenv vn e n Ce.
(forall v Cv. G cm v Cv -->
  exp_Cexp G cm (bind vn v env) (Pmap.add n Cv Cenv) e Ce)
==>
exp_Cexp G cm env Cenv (Fun vn e) (CFun [n] Ce)

indreln
forall G cm l.
true
==>
v_Cv G cm (Litv l) (CLitv l)
and
forall G cm cn vs Cvs.
Pmap.mem cn cm &&
List.for_all2 (v_Cv G cm) vs Cvs
==>
v_Cv G cm (Conv cn vs) (CConv (Pmap.find cn cm) Cvs)
*)

(*
indreln
forall cm env Cenv err.
true
==>
exp_Cexp cm env Cenv (Raise err) (CRaise err)
and
forall cm env Cenv v Cv.
v_Cv cm v Cv
==>
exp_Cexp cm env Cenv (Val v) (CVal Cv)
and
forall cm env Cenv cn es Ces.
List.for_all2 (exp_Cexp cm env Cenv) es Ces
==>
exp_Cexp cm env Cenv (Con cn es) (CCon (Pmap.find cn cm) Ces)
and
forall cm env Cenv vn v Cvn Cv.
lookup vn env = Some v &&
Pmap.mem Cvn Cenv && Pmap.find Cvn Cenv = Cv && (* TODO: lookup *)
v_Cv cm v Cv
==>
exp_Cexp cm env Cenv (Var vn) (CVar Cvn)
and
forall cm env Cenv vn e n Ce.
(* but what to do here without a context of equal variables? *)
(* (see comments in v_Cv below) *)
==>
exp_Cexp cm env Cenv (Fun vn e) (CFun n Ce)
and
forall cm l.
true
==>
v_Cv cm (Lit l) (CLit l)
and
forall cm cn vs Cvs.
List.for_all2 (v_Cv cm) vs Cvs
==>
v_Cv cm (Conv cn vs) (CConv (Pmap.find cn cm) Cvs)
and
forall cm env vn e Cenv n Ce.
(* can't do this because it's a negative occurrence of v_Cv,
 * leading to a non-monotonic rule
(forall v Cv. v_Cv cm v Cv -->
 exp_Cexp cm (bind vn v env) (Pmap.add n Cv (alist_to_fmap Cenv)) e Ce)
*)
(* obviously this is incorrect (requires the functions to be equivalent on
 * arbitrary pairs of arguments)
 * options for extension include:
   * normal form (open): use the same free variable as the argument
     * but does this distinguish too many pairs of terms?
   * carry around a context of equal values/variables
     * but how does this relate with the environments in closures?
     * probably just have to have both independently
   * parameterise by a "global knowledge" relation of equal values *)
(forall v Cv. exp_Cexp cm (bind vn v env) (Pmap.add n Cv (alist_to_fmap Cenv)) e Ce)
==>
v_Cv cm (Closure env vn e) (CClosure Cenv [n] Ce)
*)

(*
let rec
Cv_to_bv (CLitv (IntLit i)) = Number i
and
Cv_to_bv (CLitv (Bool b)) = Number (bool_to_int b)
and
Cv_to_bv (CConv n vs) = Block n (Cvs_to_bvs vs)
and
Cv_to_bv (CClosure env vs b) = Block 0 [CodePtr ?, ?]
and
Cv_to_bv (CRecClos env ns defs n) = Block 0 [CodePtr ?, ?]
and
Cvs_to_bvs [] = []
and
Cvs_to_bvs (v::vs) = Cv_to_bv v :: Cvs_to_bvs vs
*)
