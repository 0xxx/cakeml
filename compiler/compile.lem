(* TODO: compile Raise and Handle properly; requires changes to bytecode *)
(* TODO: simple type system and checker *)
(* TODO: map_Cexp? *)
(* TODO: use Pmap.peek instead of mem when it becomes available *)
(* TODO: collapse nested functions *)
(* TODO: collapse nested lets *)
(* TODO: Letfun introduction and reordering *)
(* TODO: let floating *)
(* TODO: removal of redundant expressions *)
(* TODO: simplification (e.g., constant folding) *)
(* TODO: avoid Shifts when possible *)
(* TODO: registers, register allocation, greedy shuffling? *)
(* TODO: bytecode optimizer: repeated Pops, unreachable code (e.g. after a Jump) *)
(* TODO: more efficient pattern-matching method? *)
(* TODO: store type information on CMat nodes (for pattern matching compilation) *)
(* TODO: typechecking *)
(* TODO: printing *)

(* TODO: move to lem *)
val fold_left2 : forall 'a 'b 'c. ('a -> 'b -> 'c -> 'a) -> 'a -> list 'b -> list 'c -> 'a
let inline {hol} fold_left2 f a lb lc =
  (* TODO: LEM internal error:
  List.fold_left (fun a -> Hol.UNCURRY (f a)) a (List.combine lb lc)
  *)
  (* TODO: LEM internal error:
  List.fold_left (fun a (b,c) -> f a b c) a (List.combine lb lc)
  *)
  Hol.FOLDL2 f a lb lc
(* TODO: lem library should use this for List.for_all2 *)
val every2 : forall 'a 'b. ('a -> 'b -> bool) -> list 'a -> list 'b -> bool
let inline {hol} every2 = Hol.EVERY2
val least : (num -> bool) -> num
let inline {hol} least = Hol.LEAST
val num_to_string : num -> string
let inline {hol} num_to_string = Hol.num_to_hex_string
val int_to_num : int -> num
let inline {hol} int_to_num = Hol.Num
val alist_to_fmap : forall 'a 'b. list ('a * 'b) -> Pmap.map 'a 'b
let inline {hol} alist_to_fmap = Hol.alist_to_fmap
val optrel : forall 'a 'b 'c 'd. ('a -> 'b -> bool) -> 'c -> 'd -> bool
let inline {hol} optrel = Hol.OPTREL
val flookup : forall 'a 'b 'c. Pmap.map 'a 'b -> 'a -> 'c
let inline {hol} flookup = Hol.FLOOKUP
val domsub : forall 'a 'b. Pmap.map 'a 'b -> 'a -> Pmap.map 'a 'b
let inline {hol} domsub = Hol.DOMSUB
val genlist : forall 'a. (num -> 'a) -> num -> list 'a
let inline {hol} genlist = Hol.GENLIST
open MiniML
val return : forall 'a 'b. 'a -> 'b -> 'a * 'b
let inline {hol} return = Hol.UNIT
val bind : forall 'a 'b 'c. ('a -> 'b * 'a) -> ('b -> 'a -> 'c * 'a) -> 'a -> 'c * 'a
let inline {hol} bind = Hol.BIND
val ubind : forall 'a 'b 'c. ('a -> 'b * 'a) -> ('a -> 'c * 'a) -> 'a -> 'c * 'a
let inline {hol} ubind = Hol.IGNORE_BIND

(* TODO: Misc. helpers *)

let rec
find_index y [] _ = None
and
find_index y (x::xs) n = if x = y then Some n else find_index y xs (n+1)

let fresh_var s =
  num_to_string (least (fun n -> not (num_to_string n IN s)))

let rec num_fold f a n = if n = 0 then a else num_fold f (f a) (n-1)

let rec
map_result f (Rval v) = Rval (f v)
and
map_result f (Rerr e) = Rerr e

let rec
every_result  P (Rerr _) = true
and
every_result P (Rval v) = P v

let i0 = Bytecode.int_of_num 0
let i1 = Bytecode.int_of_num 1
let i2 = Bytecode.int_of_num 2

let rec
error_to_int Bind_error = i0
and
error_to_int Div_error = i1
and
error_to_int (Int_error n) = Int.(+) i2 n

let rec
num_to_bool 0 = false
and
num_to_bool 1 = true

(* Intermediate language for MiniML compiler *)

(* Syntax *)
(* (real definitions in CexpTypesTheory) *)
type (+) 'a 'b = INL of 'a | INR of 'b (* TODO: move to lem *)

(* applicative primitives with bytecode counterparts *)
type Cprim1 = CRef | CDer
type Cprim2 = CAdd | CSub | CMul | CDiv | CMod | CLt | CEq | CUpd

type Cpat =
  | CPvar of string
  | CPlit of lit
  | CPcon of num * list Cpat
  | CPref of Cpat

type Cexp =
  | CDecl of list string
  | CRaise of error
  | CHandle of Cexp * string * Cexp
  | CVar of string
  | CLit of lit
  | CCon of num * list Cexp
  | CTagEq of Cexp * num
  | CProj of Cexp * num
  | CLet of string * Cexp * Cexp
  | CLetfun of bool * list string * list (list string * ((+) Cexp num)) * Cexp
  | CFun of list string * ((+) Cexp num)
  | CCall of Cexp * list Cexp
  | CPrim1 of Cprim1 * Cexp
  | CPrim2 of Cprim2 * Cexp * Cexp
  | CIf of Cexp * Cexp * Cexp

type def = list string * ((+) Cexp num)

type Cv =
  | CLitv of lit
  | CConv of num * list Cv
  | CRecClos of Pmap.map string Cv * list string * list def * string
  | CLoc of num

(* Semantics *)

let rec
Cpat_vars (CPvar n) = {n}
and
Cpat_vars (CPlit _) = {}
and
Cpat_vars (CPcon _ ps) = List.fold_left (fun s p -> s union Cpat_vars p) {} ps
and
Cpat_vars (CPref p) = Cpat_vars p

let rec
free_vars _ (CDecl xs) = Set.from_list xs
and
free_vars _ (CRaise _) = {}
and
free_vars c (CHandle e1 x e2) = free_vars c e1 union (free_vars c e2 \ {x})
and
free_vars _ (CVar n) = {n}
and
free_vars _ (CLit _) = {}
and
free_vars c (CCon _ es) =
  List.fold_left (fun s e -> s union free_vars c e) {} es
and
free_vars c (CTagEq e _) = free_vars c e
and
free_vars c (CProj e _) = free_vars c e
and
free_vars c (CLet x e eb) =
  free_vars c e union (free_vars c eb \ {x})
and
free_vars c (CLetfun true ns defs e) =
  List.fold_left (fun s (vs,b) ->
    s union (cbod_fvs c b \ (Set.from_list ns union
                             Set.from_list vs)))
  (free_vars c e \ Set.from_list ns) defs
and
free_vars c (CLetfun false ns defs e) =
  List.fold_left (fun s (vs,b) ->
    s union (cbod_fvs c b \ Set.from_list vs))
  (free_vars c e \ Set.from_list ns) defs
and
free_vars c (CFun xs b) = cbod_fvs c b \ (Set.from_list xs)
and
free_vars c (CCall e es) =
  List.fold_left (fun s e -> s union free_vars c e)
  (free_vars c e) es
and
free_vars c (CPrim1 _ e) = free_vars c e
and
free_vars c (CPrim2 _ e1 e2) = free_vars c e1 union free_vars c e2
and
free_vars c (CIf e1 e2 e3) = free_vars c e1 union free_vars c e2 union free_vars c e3
and
cbod_fvs c (INL e) = free_vars c e
and
cbod_fvs c (INR l) = match flookup c l with
  | None -> {}
  | Some e -> free_vars (domsub c l) e
  end

(* Big-step semantics *)

let rec
no_closures (CLitv _) = true
and
no_closures (CConv _ vs) = List.for_all no_closures vs
and
no_closures (CRecClos _ _ _ _) = false

let rec
doPrim2 b ty op s (CLitv (IntLit x)) (CLitv (IntLit y)) =
  if b && y = i0 then (s, Rerr (Rraise Div_error))
  else (s, Rval (CLitv (ty (op x y))))
and
doPrim2 b ty op s _ _ = (s, Rerr Rtype_error)

let rec
CevalPrim2 CAdd = doPrim2 false IntLit Int.(+)
and
CevalPrim2 CSub = doPrim2 false IntLit Int.(-)
and
CevalPrim2 CMul = doPrim2 false IntLit Int.( * )
and
CevalPrim2 CDiv = doPrim2 true IntLit Int.(/)
and
CevalPrim2 CMod = doPrim2 true IntLit Int.(%)
and
CevalPrim2 CLt = doPrim2 false Bool Int.(<)
and
CevalPrim2 CEq = fun s v1 v2 ->
  if no_closures v1 && no_closures v2
  then (s, Rval (CLitv (Bool (v1 = v2))))
  else (s, Rerr Rtype_error)
and
CevalPrim2 CUpd = fun s v1 v2 ->
  match v1 with
  | CLoc n -> if Pmap.mem n s
    then (Pmap.add n v2 s, Rval (CLitv Unit))
    else (s, Rerr Rtype_error)
  | _ -> (s, Rerr Rtype_error)
  end

let rec
CevalPrim1 CRef s v =
  let n = least (fun n -> not (Pmap.mem n s)) in
  (Pmap.add n v s, Rval (CLoc n))
and
CevalPrim1 CDer s (CLoc n) =
  (s, match flookup s n with
      | None -> Rerr Rtype_error
      | Some v -> Rval v
      end)
and
CevalPrim1 _ s _ = (s, Rerr Rtype_error)

let extend_rec_env cenv env rs defs ns vs =
  fold_left2 (fun en n v -> Pmap.add n v en)
    (List.fold_left
        (fun en n -> Pmap.add n
          (CRecClos cenv rs defs n) en)
        env
        rs)
    ns vs

indreln
forall c s env error.
true
==>
Cevaluate c s env (CRaise error) (s, Rerr (Rraise error))

and
forall c s1 env e1 x e2 s2 v.
Cevaluate c s1 env e1 (s2, Rval v)
==>
Cevaluate c s1 env (CHandle e1 x e2) (s2, Rval v)
and
forall c s1 env e1 x e2 s2 n res.
Cevaluate c s1 env e1 (s2, Rerr (Rraise (Int_error n))) &&
Cevaluate c s2 (Pmap.add x (CLitv (IntLit n)) env) e2 res
==>
Cevaluate c s1 env (CHandle e1 x e2) res
and
forall c s1 env e1 x e2 s2 err.
Cevaluate c s1 env e1 (s2, Rerr err) &&
(forall n. not (err = Rraise (Int_error n)))
==>
Cevaluate c s1 env (CHandle e1 x e2) (s2, Rerr err)

and
forall c s env n.
Pmap.mem n env
==>
Cevaluate c s env (CVar n) (s, Rval (Pmap.find n env))

and
forall c s env l.
true
==>
Cevaluate c s env (CLit l) (s, Rval (CLitv l))

and
forall c s env n es s' vs.
Cevaluate_list c s env es (s', Rval vs)
==>
Cevaluate c s env (CCon n es) (s', Rval (CConv n vs))
and
forall c s env n es s' err.
Cevaluate_list c s env es (s', Rerr err)
==>
Cevaluate c s env (CCon n es) (s', Rerr err)

and
forall c s env e n m s' vs.
Cevaluate c s env e (s', Rval (CConv m vs))
==>
Cevaluate c s env (CTagEq e n) (s', Rval (CLitv (Bool (n = m))))
and
forall c s env e n s' err.
Cevaluate c s env e (s', Rerr err)
==>
Cevaluate c s env (CTagEq e n) (s', Rerr err)

and
forall c s env e n m s' vs.
Cevaluate c s env e (s', Rval (CConv m vs)) &&
n < List.length vs
==>
Cevaluate c s env (CProj e n) (s', Rval (List.nth vs n))
and
forall c s env e n s' err.
Cevaluate c s env e (s', Rerr err)
==>
Cevaluate c s env (CProj e n) (s', Rerr err)

and
forall c s env n e b s' v r.
Cevaluate c s env e (s', Rval v) &&
Cevaluate c s' (Pmap.add n v env) b r
==>
Cevaluate c s env (CLet n e b) r
and
forall c s env n e b s' err.
Cevaluate c s env e (s', Rerr err)
==>
Cevaluate c s env (CLet n e b) (s', Rerr err)

and
forall c s env ns defs b r.
List.length ns = List.length defs &&
all_distinct ns &&
(forall xs l. List.mem (xs,INR l) defs --> Pmap.mem l c) &&
Cevaluate c s
  (fold_left2
    (fun env' n (xs,cb) ->
      Pmap.add n (CRecClos env [fresh_var (cbod_fvs c cb)] [(xs,cb)]
                               (fresh_var (cbod_fvs c cb))) env')
    env ns defs)
  b r
==>
Cevaluate c s env (CLetfun false ns defs b) r

and
forall c s env ns defs b r.
List.length ns = List.length defs &&
all_distinct ns &&
(forall xs l. List.mem (xs,INR l) defs --> Pmap.mem l c) &&
Cevaluate c s
  (List.fold_left
     (fun env' n ->
       Pmap.add n (CRecClos env ns defs n) env')
     env ns)
  b r
==>
Cevaluate c s env (CLetfun true ns defs b) r

and
forall c s env xs cb.
(forall l. cb = INR l --> Pmap.mem l c)
==>
Cevaluate c s env (CFun xs cb)
  (s, Rval (CRecClos env [fresh_var (cbod_fvs c cb)] [(xs,cb)]
                         (fresh_var (cbod_fvs c cb))))

and
forall c s env e es s' env' ns' defs n i ns cb b s'' vs r.
Cevaluate c s env e (s', Rval (CRecClos env' ns' defs n)) &&
List.length ns' = List.length defs &&
all_distinct ns' &&
Cevaluate_list c s' env es (s'', Rval vs) &&
find_index n ns' 0 = Some i &&
List.nth defs i = (ns,cb) &&
b = match cb with INL b -> b | INR l -> Pmap.find l c end &&
List.length ns = List.length vs &&
all_distinct ns &&
Cevaluate c s'' (extend_rec_env env' env' ns' defs ns vs) b r
==>
Cevaluate c s env (CCall e es) r
and
forall c s env e s' v es s'' err.
Cevaluate c s env e (s', Rval v) &&
Cevaluate_list c s' env es (s'', Rerr err)
==>
Cevaluate c s env (CCall e es) (s'', Rerr err)

and
forall c s env e es s' err.
Cevaluate c s env e (s', Rerr err)
==>
Cevaluate c s env (CCall e es) (s', Rerr err)

and
forall c s env uop e s' v.
Cevaluate c s env e (s', Rval v)
==>
Cevaluate c s env (CPrim1 uop e) (CevalPrim1 uop s' v)
and
forall c s env uop e s' err.
Cevaluate c s env e (s', Rerr err)
==>
Cevaluate c s env (CPrim1 uop e) (s', Rerr err)

and
forall c s env p2 e1 e2 s' v1 v2.
Cevaluate_list c s env [e1;e2] (s', Rval [v1;v2])
==>
Cevaluate c s env (CPrim2 p2 e1 e2) (CevalPrim2 p2 s' v1 v2)
and
forall c s env p2 e1 e2 s' err.
Cevaluate_list c s env [e1;e2] (s', Rerr err)
==>
Cevaluate c s env (CPrim2 p2 e1 e2) (s', Rerr err)

and
forall c s env e1 e2 e3 s' b1 r.
Cevaluate c s env e1 (s', Rval (CLitv (Bool b1))) &&
Cevaluate c s' env (if b1 then e2 else e3) r
==>
Cevaluate c s env (CIf e1 e2 e3) r
and
forall c s env e1 e2 e3 s' err.
Cevaluate c s env e1 (s', Rerr err)
==>
Cevaluate c s env (CIf e1 e2 e3) (s', Rerr err)

and
forall c s env.
true
==>
Cevaluate_list c s env [] (s, Rval [])
and
forall c s env e es s' v s'' vs.
Cevaluate c s env e (s', Rval v) &&
Cevaluate_list c s' env es (s'', Rval vs)
==>
Cevaluate_list c s env (e::es) (s'', Rval (v::vs))
and
forall c s env e es s' err.
Cevaluate c s env e (s', Rerr err)
==>
Cevaluate_list c s env (e::es) (s', Rerr err)
and
forall c s env e es s' v s'' err.
Cevaluate c s env e (s', Rval v) &&
Cevaluate_list c s' env es (s'', Rerr err)
==>
Cevaluate_list c s env (e::es) (s'', Rerr err)

(* equivalence relations on intermediate language *)

indreln
forall c l.
true
==>
syneq c (CLitv l) (CLitv l)
and
forall c cn vs1 vs2.
every2 (syneq c) vs1 vs2
==>
syneq c (CConv cn vs1) (CConv cn vs2)
and
forall c env1 env2 ns defs d.
List.for_all
  (fun (xs,b) ->
    (forall v. v IN (cbod_fvs c b \ (Set.from_list ns union
                                     Set.from_list xs))
      --> (optrel (syneq c)) (flookup env1 v) (flookup env2 v)))
  defs
==>
syneq c (CRecClos env1 ns defs d) (CRecClos env2 ns defs d)
and
forall c n.
true
==>
syneq c (CLoc n) (CLoc n)

(* Compiler *)

(* source to intermediate expressions *)

(* remove pattern-matching using continuations *)

let rec
pat_to_Cpat m pvs (Pvar vn) = (vn::pvs, CPvar vn)
and
pat_to_Cpat m pvs (Plit l) = (pvs, CPlit l)
and
pat_to_Cpat m pvs (Pcon cn ps) =
  let (pvs,Cps) = pats_to_Cpats m pvs ps in
  (pvs,CPcon (Pmap.find cn m) Cps)
and
pat_to_Cpat m pvs (Pref p) =
  let (pvs,Cp) = pat_to_Cpat m pvs p in
  (pvs,CPref Cp)
and
pats_to_Cpats m pvs [] = (pvs,[])
and
pats_to_Cpats m pvs (p::ps) =
  let (pvs,Cps) = pats_to_Cpats m pvs ps in
  let (pvs,Cp) = pat_to_Cpat m pvs p in
  (pvs,Cp::Cps)

let rec
remove_mat_vp fk sk v (CPvar pv) =
  CLet pv (CVar v) sk
and
remove_mat_vp fk sk v (CPlit l) =
  CIf (CPrim2 CEq (CVar v) (CLit l))
    sk (CCall (CVar fk) [])
and
remove_mat_vp fk sk v (CPcon cn ps) =
  CIf (CTagEq (CVar v) cn)
    (remove_mat_con fk sk v 0 ps)
    (CCall (CVar fk) [])
and
remove_mat_vp fk sk v (CPref p) =
  let v' = fresh_var ({v;fk} union (free_vars Pmap.empty sk) union (Cpat_vars p)) in
  CLet v' (CPrim1 CDer (CVar v))
    (remove_mat_vp fk sk v' p)
and
remove_mat_con fk sk v n [] = sk
and
remove_mat_con fk sk v n (p::ps) =
  let v' = fresh_var ({v;fk} union (free_vars Pmap.empty sk) union (Cpat_vars p)) in
  CLet v' (CProj (CVar v) n)
    (remove_mat_vp fk (remove_mat_con fk sk v (n+1) ps) v' p)

let rec
remove_mat_var v [] = CRaise Bind_error
and
remove_mat_var v ((p,sk)::pes) =
  let fk = fresh_var ({v} union (free_vars Pmap.empty sk) union (Cpat_vars p)) in
  CLetfun false [fk] [([],(INL (remove_mat_var v pes)))]
    (remove_mat_vp fk sk v p)

let Cpes_vars =
  List.fold_left (fun s (p,e) -> s union Cpat_vars p union free_vars Pmap.empty e) {}

let rec
exp_to_Cexp m (Handle e x b) =
  CHandle (exp_to_Cexp m e) x (exp_to_Cexp m b)
and
exp_to_Cexp m (Raise err) = CRaise err
and
exp_to_Cexp m (Lit l) = CLit l
and
exp_to_Cexp m (Con cn es) =
  CCon (Pmap.find cn m) (exps_to_Cexps m es)
and
exp_to_Cexp m (Var vn) = CVar vn
and
exp_to_Cexp m (Fun vn e) =
  CFun [vn] (INL (exp_to_Cexp m e))
and
exp_to_Cexp m (App (Opn opn) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CPrim2 (match opn with
          | Plus   -> CAdd
          | Minus  -> CSub
          | Times  -> CMul
          | Divide -> CDiv
          | Modulo -> CMod
          end)
  Ce1 Ce2
and
exp_to_Cexp m (App (Opb opb) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  match opb with
  | Lt -> CPrim2 CLt Ce1 Ce2
  | Leq -> CPrim2 CLt (CPrim2 CSub Ce1 Ce2) (CLit (IntLit i1))
  | opb ->
      let x1 = fresh_var (free_vars Pmap.empty Ce2) in
      let x2 = fresh_var {x1} in
      CLet x1 Ce1 (
        CLet x2 Ce2 (
          match opb with
          | Gt ->  CPrim2 CLt (CVar x2) (CVar x1)
          | Geq -> CPrim2 CLt (CPrim2 CSub (CVar x2) (CVar x1)) (CLit (IntLit i1))
          end))
  end
and
exp_to_Cexp m (App Equality e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CPrim2 CEq Ce1 Ce2
and
exp_to_Cexp m (App Opapp e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CCall Ce1 [Ce2]
and
exp_to_Cexp m (App Opassign e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CPrim2 CUpd Ce1 Ce2
and
exp_to_Cexp m (Uapp uop e) =
  let Ce = exp_to_Cexp m e in
  CPrim1 (match uop with
          | Opref   -> CRef
          | Opderef -> CDer
          end) Ce
and
exp_to_Cexp m (Log log e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  (match log with
   | And -> CIf Ce1 Ce2 (CLit (Bool false))
   | Or  -> CIf Ce1 (CLit (Bool true)) Ce2
   end)
and
exp_to_Cexp m (If e1 e2 e3) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  let Ce3 = exp_to_Cexp m e3 in
  CIf Ce1 Ce2 Ce3
and
exp_to_Cexp m (Mat e pes) =
  let Cpes = pes_to_Cpes m pes in
  let v = fresh_var (Cpes_vars Cpes) in
  let Ce = exp_to_Cexp m e in
  CLet v Ce (remove_mat_var v Cpes)
and
exp_to_Cexp m (Let vn e b) =
  let Ce = exp_to_Cexp m e in
  let Cb = exp_to_Cexp m b in
  CLet vn Ce Cb
and
exp_to_Cexp m (Letrec defs b) =
  let (fns,Cdefs) = defs_to_Cdefs m defs in
  let Cb = exp_to_Cexp m b in
  CLetfun true fns Cdefs Cb
and
defs_to_Cdefs m [] = ([],[])
and
defs_to_Cdefs m ((d,vn,e)::defs) =
  let Ce = exp_to_Cexp m e in
  let (fns,Cdefs) = defs_to_Cdefs m defs in
  (d::fns,([vn],INL Ce)::Cdefs)
and
pes_to_Cpes m [] = []
and
pes_to_Cpes m ((p,e)::pes) =
  let (_pvs,Cp) = pat_to_Cpat m [] p in
  let Ce = exp_to_Cexp m e in
  let Cpes = pes_to_Cpes m pes in
  (Cp,Ce)::Cpes
and
exps_to_Cexps s [] = []
and
exps_to_Cexps m (e::es) =
  exp_to_Cexp m e :: exps_to_Cexps m es

(* pull closure bodies into code environment *)

type label_closures_state =
  <| lnext_label: num
   ; lcode_env: list (num * Cexp)
   |>

let rec
label_defs (ds:list def) ([]:list def) = return ds
and
label_defs ds ((xs,INR a)::defs) =
  label_defs ((xs,INR a)::ds) defs
and
label_defs ds ((xs,INL b)::defs) = bind
  (fun s -> return s.lnext_label
    (<| s with (* parens: Lem sucks *)
      lnext_label = s.lnext_label+1 ;
      lcode_env = (s.lnext_label,b)::s.lcode_env
     |>) ) (fun n ->
  (label_defs ((xs,INR n)::ds) defs))

let rec
label_closures (CDecl xs) = return (CDecl xs)
and
label_closures (CRaise err) = return (CRaise err)
and
label_closures (CHandle e1 x e2) = bind
  (label_closures e1) (fun e1 -> bind
  (label_closures e2) (fun e2 -> return
  (CHandle e1 x e2)))
and
label_closures (CVar x) = return (CVar x)
and
label_closures (CLit l) = return (CLit l)
and
label_closures (CCon cn es) = bind
  (label_closures_list es) (fun es -> return
  (CCon cn es))
and
label_closures (CTagEq e n) = bind
  (label_closures e) (fun e -> return
  (CTagEq e n))
and
label_closures (CProj e n) = bind
  (label_closures e) (fun e -> return
  (CProj e n))
and
label_closures (CLet x e b) = bind
  (label_closures e) (fun e -> bind
  (label_closures b) (fun b -> return
  (CLet x e b)))
and
label_closures (CLetfun p ns defs e) = bind
  (label_defs [] defs) (fun defs -> bind
  (label_closures e) (fun e -> return
  (CLetfun p ns (List.rev defs) e)))
and
label_closures (CFun xs cb) = bind
  (label_defs [] [(xs,cb)]) (fun defs ->
  let (xs,cb) = List.nth defs 0 in return
  (CFun xs cb))
and
label_closures (CCall e es) = bind
  (label_closures e) (fun e -> bind
  (label_closures_list es) (fun es -> return
  (CCall e es)))
and
label_closures (CPrim1 uop e) = bind
  (label_closures e) (fun e -> return
    (CPrim1 uop e))
and
label_closures (CPrim2 op e1 e2) = bind
  (label_closures e1) (fun e1 -> bind
  (label_closures e2) (fun e2 -> return
  (CPrim2 op e1 e2)))
and
label_closures (CIf e1 e2 e3) = bind
  (label_closures e1) (fun e1 -> bind
  (label_closures e2) (fun e2 -> bind
  (label_closures e3) (fun e3 -> return
  (CIf e1 e2 e3))))
and
label_closures_list [] = return []
and
label_closures_list (e::es) = bind
  (label_closures e) (fun e -> bind
  (label_closures_list es) (fun es -> return
  (e::es)))

let rec
count_unlab [] = 0
and
count_unlab ((_,INL _)::ls) = 1 + count_unlab ls
and
count_unlab ((_,INR _)::ls) = count_unlab ls

(* imm_unlab e = number of unlabeled (INL) bodies, without looking
 * recursively at any of the bodies *)
let rec
imm_unlab (CDecl xs) = 0
and
imm_unlab (CRaise err) = 0
and
imm_unlab (CHandle e1 x e2) = imm_unlab e1 + imm_unlab e2
and
imm_unlab (CVar x) = 0
and
imm_unlab (CLit l) = 0
and
imm_unlab (CCon cn es) = imm_unlab_list es
and
imm_unlab (CTagEq e n) = imm_unlab e
and
imm_unlab (CProj e n) = imm_unlab e
and
imm_unlab (CLet x e b) = imm_unlab e + imm_unlab b
and
imm_unlab (CLetfun p ns defs e) = count_unlab defs + imm_unlab e
and
imm_unlab (CFun xs cb) = count_unlab [(xs,cb)]
and
imm_unlab (CCall e es) = imm_unlab e + imm_unlab_list es
and
imm_unlab (CPrim2 op e1 e2) = imm_unlab e1 + imm_unlab e2
and
imm_unlab (CPrim1 uop e) = imm_unlab e
and
imm_unlab (CIf e1 e2 e3) = imm_unlab e1 + imm_unlab e2 + imm_unlab e3
and
imm_unlab_list [] = 0
and
imm_unlab_list (e::es) = imm_unlab e + imm_unlab_list es

let rec
repeat_label_closures e n ac =
  if imm_unlab e = 0 then (e,n,ac) else
  let s = <| lnext_label = n; lcode_env = [] |> in
  let (e,s) = label_closures e s in
  let (n,ac) = label_code_env s.lnext_label ac s.lcode_env in
  (e,n,ac)
and
label_code_env n ac [] = (n,ac)
and
label_code_env n ac ((l,e)::ls) =
  let (e,n,ac) = repeat_label_closures e n ac in
  label_code_env n ((l,e)::ac) ls

(* extract syntactic defs, to assist code_env construction *)

let rec
defs_to_ldefs [] = []
and
defs_to_ldefs ((xs,INR l)::defs) = (xs,l)::(defs_to_ldefs defs)
and
defs_to_ldefs _ = [] (* should not happen *)

let rec (* including many uneta because Hol_defn sucks *)
calculate_ldefs c ls (CDecl _) = ls
and
calculate_ldefs c ls (CRaise _) = ls
and
calculate_ldefs c ls (CVar _) = ls
and
calculate_ldefs c ls (CLit _) = ls
and
calculate_ldefs c ls (CCon _ es) =
  List.fold_left (fun ls e -> calculate_ldefs c ls e) ls es
and
calculate_ldefs c ls (CTagEq e _) = calculate_ldefs c ls e
and
calculate_ldefs c ls (CProj e _) = calculate_ldefs c ls e
and
calculate_ldefs c ls (CLet _ e b) =
  calculate_ldefs c (calculate_ldefs c ls b) e
and
calculate_ldefs c ls (CLetfun p ns defs e) =
  List.fold_left
    (fun ls (_,cb) ->
      match cb with INR l ->
        match flookup c l with None -> [] (* should not happen *)
        | Some e -> calculate_ldefs (domsub c l) ls e
        end
      | _ -> [] (* should not happen *)
      end)
    ((if p then ns else [],
      defs_to_ldefs defs)
     ::calculate_ldefs c ls e)
    defs
and
calculate_ldefs c ls (CFun xs cb) =
  match cb with INR l ->
    match flookup c l with None -> [] (* should not happen *)
    | Some e -> calculate_ldefs (domsub c l) (([],[(xs,l)])::ls) e
    end
  | _ -> [] (* should not happen *)
  end
and
calculate_ldefs c ls (CCall e es) =
  List.fold_left (fun ls e -> calculate_ldefs c ls e) (calculate_ldefs c ls e) es
and
calculate_ldefs c ls (CPrim2 _ e1 e2) =
  calculate_ldefs c (calculate_ldefs c ls e1) e2
and
calculate_ldefs c ls (CIf e1 e2 e3) =
  calculate_ldefs c (calculate_ldefs c (calculate_ldefs c ls e1) e2) e3

(* intermediate expressions to bytecode *)

open Bytecode

(* values in compile-time environment *)
type ctbind = CTLet of num | CTArg of num | CTEnv of num | CTRef of num
(* CTLet n means stack[sz - n]
   CTArg n means stack[sz + n]
   CTEnv n means El n of the environment, which is at stack[sz]
   CTRef n means El n of the environment, but it's a ref pointer *)

type call_context = TCNonTail | TCTail of num * num

type ctenv = Pmap.map string ctbind

(* helper for reconstructing closure environments *)
type cebind = CEEnv of string | CERef of num

type ecs = num * list cebind (* num is the length of the list *)

type compiler_state =
  <| env: ctenv
   ; sz: num
   ; ecs: Pmap.map num ecs
   ; env_azs: Pmap.map num (ctenv * num)
   ; out: list bc_inst (* reversed code *)
   ; next_label: num
   ; tail: call_context
   (* not modified on return: *)
   ; decl: option (ctenv * num)
   |>

let rec
prim1_to_bc CRef = Ref
and
prim1_to_bc CDer = Deref

let rec
prim2_to_bc CAdd = Stack Add
and
prim2_to_bc CSub = Stack Sub
and
prim2_to_bc CMul = Stack Mult
and
prim2_to_bc CDiv = Stack Div
and
prim2_to_bc CMod = Stack Mod
and
prim2_to_bc CLt = Stack Less
and
prim2_to_bc CEq = Stack Equal
and
prim2_to_bc CUpd = Update

let emit = List.fold_left (fun s i -> <| s with out = i :: s.out |>)

let rec
get_labels n s = (<| s with next_label = s.next_label + n |>,
                  genlist (fun i -> s.next_label + i) n)

let rec
compile_varref s (CTLet n) = emit s [Stack (Load (s.sz - n))]
and
compile_varref s (CTArg n) = emit s [Stack (Load (s.sz + n))]
and
compile_varref s (CTEnv n) = emit s [Stack (Load s.sz); Stack (El n)]
and
compile_varref s (CTRef n) = emit (compile_varref s (CTEnv n)) [Deref]

let incsz s = <| s with sz = s.sz + 1 |>
let decsz s = <| s with sz = s.sz - 1 |>
let sdt s = (<| s with decl = None; tail = TCNonTail |>, (s.decl,s.tail))
let ldt (d,t) s = <| s with decl = d; tail = t |>

let rec
emit_ec z s (CEEnv fv) = incsz (compile_varref s (Pmap.find fv s.env))
and
emit_ec z s (CERef j) = incsz (emit s [Stack (Load (s.sz - z - j))])

(* calling convention:
 * before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
 * thus, since env = stack[sz], argk should be CTArg (2 + n - k)
 * after:  retval,
 *)

(* closure representation:
 * Block 0 [CodePtr f; Env]
 * where Env = Number 0 for empty, or else
 * Block 0 [v1,...,vk]
 * with a value for each free variable
 * (some values may be RefPtrs to other (mutrec) closures)
 *)

(* closure construction, for a bundle of nz names, nk defs:
 * - push nz refptrs
 * - push nk CodePtrs, each pointing to the appropriate body
 * - for each def, load its CodePtr, load its environment, cons them up, and
     store them where its CodePtr was
   - for each name, load the refptr and update it with the closure
   - for each name, store the refptr back where it was
 *)

let rec
push_lab (s,k,ecs) (xs,INL _) = (incsz s,k+1,(0,[])::ecs) (* should not happen *)
and
push_lab (s,k,ecs) (xs,INR l) =
  let s = incsz (emit s [PushPtr (Lab l)]) in
  (s,k+1,(Pmap.find l s.ecs)::ecs)

let rec
cons_closure sz0 nk (s,k) (j,ec) =
  let s = incsz (emit s [Stack (Load (nk - k))]) in
  let s = List.fold_left (emit_ec sz0) s (List.rev ec) in
  let s = emit s [Stack (if j = 0 then PushInt i0 else Cons 0 j)] in
  let s = emit s [Stack (Cons closure_tag 2)] in
  let s = decsz (emit s [Stack (Store (nk - k))]) in
  let s = <| s with sz = s.sz - j |> in
  (s,k+1)

let rec
update_refptr nk (s,k) =
  let s = emit s [Stack (Load (nk + nk - k))] in
  let s = emit s [Stack (Load (nk + 1 - k))] in
  let s = emit s [Update] in
  (s,k+1)

let rec
compile_closures nz s defs =
  let sz0 = s.sz in
  let s = num_fold (fun s -> incsz (emit s [Stack (PushInt i0); Ref])) s nz in
  let nk = List.length defs in
  let (s,k,ecs) = List.fold_left push_lab (s,0,[]) defs in
  let (s,k) = List.fold_left (cons_closure sz0 nk) (s,1) (List.rev ecs) in
  let (s,k) = num_fold (update_refptr nk) (s,1) nz in
  let k = nk - 1 in
  num_fold (fun s -> decsz (emit s [Stack (Store k)])) s nz

let rec
compile_decl env0 =
  List.fold_left
    (fun (s,i,env) v ->
      if Pmap.mem v env0 then
        (match Pmap.find v env0 with
         | CTLet x -> emit (compile_varref s (Pmap.find v s.env))
                           [Stack (Store (s.sz - x))]
         | _ -> emit s [Stack (PushInt i2); Exception] (* should not happen *)
         end, i, env)
      else
        (incsz (compile_varref s (Pmap.find v s.env)),
         i+1,
         Pmap.add v (CTLet i) env))

let rec
compile s (CDecl vs) =
  match s.decl with Some (env0,sz0) ->
  let sz1 = s.sz in
  let k = sz1 - sz0 in
  let (s,i,env) = compile_decl env0 (s,sz0+1,env0) vs in
  let s = emit s [Stack (Shift (i-(sz0+1)) k)] in
  <| s with sz = sz1+1; decl = Some (env,s.sz-k) |>
  | None -> incsz (emit s [Stack (PushInt i2); Exception]) (* should not happen *)
  end
and
compile s (CRaise err) =
  incsz (emit s [Stack (PushInt (error_to_int err)); Exception])
and
compile s (CHandle e1 x e2) =
  let (s,dt) = sdt s in
  ldt dt (compile s e1)
and
compile s (CLit (IntLit i)) =
  incsz (emit s [Stack (PushInt i)])
and
compile s (CLit (Bool b)) =
  incsz (emit s [Stack (Cons (bool_to_tag b) 0)])
and
compile s (CLit Unit) =
  incsz (emit s [Stack (Cons unit_tag 0)])
and
compile s (CVar vn) = incsz (compile_varref s (Pmap.find vn s.env))
and
compile s (CCon n es) =
  let z = s.sz + 1 in
  let (s,dt) = sdt s in
  let s = List.fold_left (fun s e -> compile s e) s es in (* uneta because Hol_defn sucks *)
  let s = emit (ldt dt s) [Stack (Cons (n+block_tag) (List.length es))] in
  <| s with sz = z |>
and
compile s (CTagEq e n) =
  let (s,dt) = sdt s in
  ldt dt (emit (compile s e) [Stack (TagEq (n+block_tag))])
and
compile s (CProj e n) =
  let (s,dt) = sdt s in
  ldt dt (emit (compile s e) [Stack (El n)])
and
compile s (CLet x e eb) =
  let z = s.sz + 1 in
  let (s,dt) = sdt s in
  let s = compile s e in
  compile_bindings s.env z eb 0 (ldt dt s) [x]
and
compile s (CLetfun recp ns defs e) =
  let z = s.sz + 1 in
  let s = compile_closures (if recp then List.length ns else 0) s defs in
  compile_bindings s.env z e 0 s ns
and
compile s (CFun xs cb) =
  compile_closures 0 s [(xs,cb)]
and
compile s (CCall e es) =
  let n = List.length es in
  let t = s.tail in
  let (s,dt) = sdt s in
  let s = match t with
  | TCNonTail ->
    let s = compile s e in
    let s = List.fold_left (fun s e -> compile s e) s es in (* uneta because Hol_defn sucks *)
    (* argn, ..., arg2, arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [Stack (Load n); Stack (El 1)] in
    (* env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [Stack (Load (n+1)); Stack (El 0)] in
    (* CodePtr c, env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    emit s [CallPtr]
    (* before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    (* after:  retval, *)
(* does it make sense to distinguish this case?
  | TCTop sz0 ->
    let k = match s.decl with None -> s.sz - sz0 | Some _ -> 0 end in
    let n1 = 1+1+n+1 in
    let (i,s) = pad k n1 s in
    let s = compile s e in
    let s = List.fold_left (fun s e -> compile s e) s es in (* uneta because Hol_defn sucks *)
    (* argn, ..., arg1, Block 0 [CodePtr c; env], 0i, ..., 01, vk, ..., v1, *)
    let s = emit s [Stack (Load n); Stack (El 1)] in
    (* env, argn, ..., arg1, Block 0 [CodePtr c; env], 0i, ..., 01, vk, ..., v1, *)
    let s = emit s [Stack (Load (n+1)); Stack (El 0)] in
    (* CodePtr c, env, argn, ..., arg1, Block 0 [CodePtr c; env], 0i, ..., 01, vk, ..., v1, *)
    let s = mv (k+i) n1 s in
    (* CodePtr c, env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    emit s [CallPtr]
*)
  | TCTail j k ->
    let s = compile s e in
    let s = List.fold_left (fun s e -> compile s e) s es in (* uneta because Hol_defn sucks *)
    (* argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+1+k+1))] in
    (* CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+1)); Stack (El 1)] in
    (* env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+2)); Stack (El 0)] in
    (* CodePtr c, env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Shift (1+1+1+n+1) (k+1+1+j+1))] in
    emit s [JumpPtr]
  end in
  ldt dt <| s with sz = s.sz - n |>
and
compile s (CPrim1 uop e) =
  let (s,dt) = sdt s in
  let s = compile s e in
  ldt dt (emit s [prim1_to_bc uop])
and
compile s (CPrim2 op e1 e2) =
  let (s,dt) = sdt s in
  let s = compile s e1 in
  let s = compile s e2 in (* TODO: need to detect div by zero *)
  decsz (ldt dt (emit s [prim2_to_bc op]))
and
compile s (CIf e1 e2 e3) =
  let (s,dt) = sdt s in
  let s = ldt dt (compile s e1) in
  let (s,labs) = get_labels 3 s in
  let n0 = List.nth labs 0 in
  let n1 = List.nth labs 1 in
  let n2 = List.nth labs 2 in
  let s = emit s [(JumpIf (Lab n0)); (Jump (Lab n1)); Label n0] in
  let s = compile (decsz s) e2 in
  let s = emit s [(Jump (Lab n2)); Label n1] in
  let s = compile (decsz s) e3 in
  emit s [Label n2]
and
compile_bindings env0 sz1 e n s [] =
  let s = match s.tail with
  | TCTail j k -> compile (<| s with tail = TCTail j (k+n) |>) e
  | TCNonTail -> match s.decl with
    | None -> emit (compile s e) [Stack (Pops n)]
    | Some _ -> compile s e
    end
  end in
  <| s with env = env0 ; sz = sz1 |>
and
compile_bindings env0 sz1 e n s (x::xs) =
  compile_bindings env0 sz1 e
    (n+1) (* parentheses below because Lem sucks *)
    (<| s with env = Pmap.add x (CTLet (sz1 + n)) s.env |>)
    xs

(* code env to bytecode *)

let rec
bind_fv ns xs az k fv (n,env,(ecl,ec)) =
  match find_index fv xs 1 with
  | Some j -> (n, Pmap.add fv (CTArg (2 + az - j)) env, (ecl,ec))
  | None -> match find_index fv ns 0 with
    | None -> (n+1, Pmap.add fv (CTEnv n) env, (ecl+1,CEEnv fv::ec))
    | Some j -> if j = k
                then (n, Pmap.add fv (CTArg (2 + az)) env, (ecl,ec))
                else (n+1, Pmap.add fv (CTRef n) env, (ecl+1,(CERef (j+1))::ec))
    end
  end

let rec
calculate_ecs c =
  List.fold_left
    (fun s (ns,defs) ->
      let (s,k) = List.fold_left
        (fun (s,k) (xs,l) ->
          let az = List.length xs in
          let (n,env,(ecl,ec)) =
            Set.fold (bind_fv ns xs az k) (free_vars c (Pmap.find l c)) (0,Pmap.empty,(0,[])) in
          let s = <| s with
                     env_azs = Pmap.add l (env,az) s.env_azs
                   ; ecs = Pmap.add l (ecl,ec) s.ecs
                   |> in
          (s,k+1))
        (s,0) defs in
      s)

let rec
cce_aux c s (ns,defs) =
  let (s,k) = List.fold_left
    (fun (s,k) (xs,l) ->
      let (env,az) = Pmap.find l s.env_azs in
      let s = emit s [Label l] in
      let s' = <| s with env = env; sz = 0; tail = TCTail az 0 |> in
      let s' = compile s' (Pmap.find l c) in
      let n = match s'.tail with TCNonTail -> 1 | TCTail j k -> k+1 end in
      let s' = emit s' [Stack (Pops n);
                        Stack (Load 1);
                        Stack (Store (az+2));
                        Stack (Pops (az+1));
                        Return] in
      let s = <| s' with env = s.env; sz = s.sz; tail = s.tail |> in
      (s,k+1))
    (s,0) defs in
  s

let rec
compile_code_env c s ldefs =
  let (s,ls) = get_labels 1 s in
  let l = List.nth ls 0 in
  let s = emit s [Jump (Lab l)] in
  let s = List.fold_left (cce_aux c) s ldefs in
  emit s [Label l]

(* replace labels in bytecode with addresses *)

let rec
calculate_labels il m n a [] = (m,n,a)
and
calculate_labels il m n a (Label l::lbc) =
  calculate_labels il (Pmap.add l n m) n a lbc
and
calculate_labels il m n a (i::lbc) =
  calculate_labels il m (n + il i + 1) (i::a) lbc

let rec
replace_labels m a [] = a
and
replace_labels m a (Jump (Lab l)::bc) =
  replace_labels m (Jump (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (JumpIf (Lab l)::bc) =
  replace_labels m (JumpIf (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (Call (Lab l)::bc) =
  replace_labels m (Call (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (PushPtr (Lab l)::bc) =
  replace_labels m (PushPtr (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (i::bc) =
  replace_labels m (i::a) bc

let rec
compile_labels il lbc =
  let (m,n,bc) = calculate_labels il Pmap.empty 0 [] lbc in
    replace_labels m [] bc

(* repl *)

type contab = Pmap.map conN num * Pmap.map num conN * num
val cmap : contab -> Pmap.map conN num
let rec cmap (m,_,_) = m

type repl_state =
  <| contab : contab
   ; renv : ctenv
   ; rsz  : num
   ; rnext_label : num
   |>

let init_repl_state =
  <| contab = (Pmap.empty, Pmap.empty, 0)
   ; renv = Pmap.empty
   ; rsz  = 0
   ; rnext_label = 0
   |>

let compile_Cexp rs decl Ce =
  let (Ce,n,c) = repeat_label_closures Ce rs.rnext_label [] in
  let c = alist_to_fmap c in
  let ldefs = calculate_ldefs c [] Ce in
  let cs = <| env = rs.renv; sz = rs.rsz
            ; ecs = Pmap.empty; env_azs = Pmap.empty
            ; out = []; next_label = n
            ; tail = TCNonTail; decl = decl |> in
  let cs = calculate_ecs c cs ldefs in
  let cs = compile_code_env c cs ldefs in
  let cs = <| cs with env_azs = Pmap.empty |> in
  let cs = compile cs Ce in
  let rs = match cs.decl with
    | None -> rs
    | Some (env,sz) -> <| rs with renv = env ; rsz = sz |>
    end in
  let rs = <| rs with rnext_label = cs.next_label |> in
  (rs, List.rev cs.out)

let rec
number_constructors [] ct = ct
and
number_constructors ((c,_)::cs) (m,w,n) =
  number_constructors cs (Pmap.add c n m, Pmap.add n c w, n+1)

let rec
repl_dec rs (Dtype []) = (rs,[])
and
repl_dec rs (Dtype ((_,_,cs)::ts)) =
  let ct = number_constructors cs rs.contab in
  repl_dec (<| rs with contab = ct |>) (Dtype ts) (* parens: Lem sucks *)
and
repl_dec rs (Dletrec defs) =
  let (fns,Cdefs) = defs_to_Cdefs (cmap rs.contab) defs in
  let decl = Some(rs.renv,rs.rsz) in
  compile_Cexp rs decl (CLetfun true fns Cdefs (CDecl fns))
and
repl_dec rs (Dlet p e) =
  let m = cmap rs.contab in
  let (pvs,Cp) = pat_to_Cpat m [] p in
  let Cpes = [(Cp,CDecl pvs)] in
  let vn = fresh_var (Cpes_vars Cpes) in
  let Ce = exp_to_Cexp m e in
  let decl = Some(rs.renv,rs.rsz) in
  compile_Cexp rs decl (CLet vn Ce (remove_mat_var vn Cpes))

let repl_exp s exp = compile_Cexp s None (exp_to_Cexp (cmap s.contab) exp)

(* Correctness *)

(* observable values *)

type ov =
  | OLit of lit
  | OConv of conN * list ov
  | OFn

let rec
v_to_ov (Litv l) = OLit l
and
v_to_ov (Conv cn vs) = OConv cn (List.map v_to_ov vs)
and
v_to_ov (Closure _ _ _) = OFn
and
v_to_ov (Recclosure _ _ _) = OFn

let rec
Cv_to_ov m (CLitv l) = OLit l
and
Cv_to_ov m (CConv cn vs) = OConv (Pmap.find cn m) (List.map (Cv_to_ov m) vs)
and
Cv_to_ov m (CRecClos _ _ _ _) = OFn

let rec
bv_to_ov m (Number i) = OLit (IntLit i)
and
bv_to_ov m (Block n vs) =
  if n = (bool_to_tag false) then OLit (Bool false) else
  if n = (bool_to_tag true) then OLit (Bool true) else
  if n = unit_tag then OLit Unit else
  if n = closure_tag then OFn else
  OConv (Pmap.find (n-block_tag) m) (List.map (bv_to_ov m) vs)

(* source to intermediate values *)

let rec
v_to_Cv m (Litv l) = CLitv l
and
v_to_Cv m (Conv cn vs) =
  CConv (Pmap.find cn m) (vs_to_Cvs m vs)
and
v_to_Cv m (Closure env vn e) =
  let Cenv = alist_to_fmap (env_to_Cenv m env) in
  let Ce = exp_to_Cexp m e in
  let a = fresh_var (free_vars Pmap.empty Ce) in
  CRecClos Cenv [a] [([vn],INL Ce)] a
and
v_to_Cv m (Recclosure env defs vn) =
  let Cenv = alist_to_fmap (env_to_Cenv m env) in
  let (fns,Cdefs) = defs_to_Cdefs m defs in
  CRecClos Cenv fns Cdefs vn
and
v_to_Cv m (Loc n) = CLoc n
and
vs_to_Cvs m [] = []
and
vs_to_Cvs m (v::vs) = v_to_Cv m v :: vs_to_Cvs m vs
and
env_to_Cenv m [] = []
and
env_to_Cenv m ((x,v)::env) =
  (x, v_to_Cv m v)::(env_to_Cenv m env)

(* intermediate to target values *)

(*
let rec
Cv_to_bv (CLitv (IntLit i)) = Number i
and
Cv_to_bv (CLitv (Bool b)) = Number (bool_to_int b)
and
Cv_to_bv (CConv n vs) = Block n (Cvs_to_bvs vs)
and
Cv_to_bv (CRecClos env ns defs n) = Block 0 [CodePtr ?, ?]
and
Cvs_to_bvs [] = []
and
Cvs_to_bvs (v::vs) = Cv_to_bv v :: Cvs_to_bvs vs
*)

(*
indreln
forall il c cc.
true
==>
bc_code_prefix il (List.append c cc) 0 c
and
forall il p i c cc.
bc_code_prefix il cc p c
==>
bc_code_prefix il (i::cc) (p + il i) c

let rec
body_cs env xs =
  <| env = env; sz = 0; out = []; next_label = 0;
     tail = TCTail (List.length xs) 0; decl = None |>

let rec
body_env ns xs j fvs =
  let (n,env,(nec,ec)) =
    Set.fold (bind_fv ns xs (List.length xs) j) fvs (0,Pmap.empty,(0,[])) in
  (env,ec)

indreln
forall il c i.
true
==>
bceqv il c (CLitv (IntLit i)) (Number i)
and
forall il c b.
true
==>
bceqv il c (CLitv (Bool b)) (Number (bool_to_int b))
and
forall il c n vs bvs.
every2 (bceqv il c) vs bvs
==>
bceqv il c (CConv n vs) (Block n bvs)
and
forall il c env ns defs n j xs e cenv ec f bvs.
find_index n ns 0 = Some j &&
List.nth defs j = (xs,e) &&
(cenv,ec) = body_env ns xs j (free_vars Pmap.empty e) &&
List.length bvs = List.length ec &&
(forall i. i < List.length ec -->
    (exists fv. List.nth ec i = CEEnv fv &&
                bceqv il c (Pmap.find fv env) (List.nth bvs i)) ||
    (exists k kxs ke kenv kec g.
        List.nth ec i = CERef k &&
        List.nth defs k = (kxs,ke) &&
        (kenv,kec) = body_env ns xs k (free_vars ke) &&
        bc_code_prefix il c g
          (List.rev (compile (body_cs kenv kxs) ke).out))) &&
bc_code_prefix il c f (List.rev (compile (body_cs cenv xs) e).out)
==>
bceqv il c (CRecClos env ns defs n)
  (Block 0 [CodePtr f; if bvs = [] then Number i0 else Block 0 bvs])
*)


(* relating source to intermediate language *)

(*
indreln
forall m c l.
true
==>
v_Cv m c (Litv l) (CLitv l)
and
forall m c cn vs Cvs.
every2 (v_Cv m c) vs Cvs
==>
v_Cv m c (Conv cn vs) (CConv (Pmap.find cn m) Cvs)
and
forall m c env vn e fn l.
env_Cenv m c env Cenv &&

==>
v_Cv m c (Closure env vn e) (CRecClos Cenv [fn] [([vn],l)] fn)
and
==>
v_Cv m c (Recclosure env defs fn) (CRecClos Cenv fns Cdefs fn)
and
forall c env1 env2 ns defs d.
List.for_all
  (fun (xs,b) ->
    (forall v. v IN (cbod_fvs c b \ (Set.from_list ns union
                                     Set.from_list xs))
      --> (optrel (syneq c)) (flookup env1 v) (flookup env2 v)))
  defs
==>
v_Cv m c (CRecClos env1 ns defs d) (CRecClos env2 ns defs d)
*)

(*
indreln
forall G cm env Cenv err.
true
==>
exp_Cexp G cm env Cenv (Raise err) (CRaise err)
and
forall G cm env Cenv l.
true
==>
exp_Cexp G cm env Cenv (Lit l) (CLit l)
and
forall G cm env Cenv cn es Ces.
Pmap.mem cn cm &&
every2 (exp_Cexp G cm env Cenv) es Ces
==>
exp_Cexp G cm env Cenv (Con cn es) (CCon (Pmap.find cn cm) Ces)
and
forall G cm env Cenv vn v Cvn.
lookup vn env = Some v &&
Pmap.mem Cvn Cenv &&
G cm v (Pmap.find Cvn Cenv)
==>
exp_Cexp G cm env Cenv (Var vn) (CVar Cvn)
and
forall G cm env Cenv vn e n Ce.
(forall v Cv. G cm v Cv -->
  exp_Cexp G cm (bind vn v env) (Pmap.add n Cv Cenv) e Ce)
==>
exp_Cexp G cm env Cenv (Fun vn e) (CFun [n] Ce)

indreln
forall G cm l.
true
==>
v_Cv G cm (Litv l) (CLitv l)
and
forall G cm cn vs Cvs.
Pmap.mem cn cm &&
every2 (v_Cv G cm) vs Cvs
==>
v_Cv G cm (Conv cn vs) (CConv (Pmap.find cn cm) Cvs)
*)

(*
indreln
forall cm env Cenv err.
true
==>
exp_Cexp cm env Cenv (Raise err) (CRaise err)
and
forall cm env Cenv v Cv.
v_Cv cm v Cv
==>
exp_Cexp cm env Cenv (Val v) (CVal Cv)
and
forall cm env Cenv cn es Ces.
every2 (exp_Cexp cm env Cenv) es Ces
==>
exp_Cexp cm env Cenv (Con cn es) (CCon (Pmap.find cn cm) Ces)
and
forall cm env Cenv vn v Cvn Cv.
lookup vn env = Some v &&
Pmap.mem Cvn Cenv && Pmap.find Cvn Cenv = Cv && (* TODO: lookup *)
v_Cv cm v Cv
==>
exp_Cexp cm env Cenv (Var vn) (CVar Cvn)
and
forall cm env Cenv vn e n Ce.
(* but what to do here without a context of equal variables? *)
(* (see comments in v_Cv below) *)
==>
exp_Cexp cm env Cenv (Fun vn e) (CFun n Ce)
and
forall cm l.
true
==>
v_Cv cm (Lit l) (CLit l)
and
forall cm cn vs Cvs.
every2 (v_Cv cm) vs Cvs
==>
v_Cv cm (Conv cn vs) (CConv (Pmap.find cn cm) Cvs)
and
forall cm env vn e Cenv n Ce.
(* can't do this because it's a negative occurrence of v_Cv,
 * leading to a non-monotonic rule
(forall v Cv. v_Cv cm v Cv -->
 exp_Cexp cm (bind vn v env) (Pmap.add n Cv (alist_to_fmap Cenv)) e Ce)
*)
(* obviously this is incorrect (requires the functions to be equivalent on
 * arbitrary pairs of arguments)
 * options for extension include:
   * normal form (open): use the same free variable as the argument
     * but does this distinguish too many pairs of terms?
   * carry around a context of equal values/variables
     * but how does this relate with the environments in closures?
     * probably just have to have both independently
   * parameterise by a "global knowledge" relation of equal values *)
(forall v Cv. exp_Cexp cm (bind vn v env) (Pmap.add n Cv (alist_to_fmap Cenv)) e Ce)
==>
v_Cv cm (Closure env vn e) (CClosure Cenv [n] Ce)
*)

(*
let rec
Cv_to_bv (CLitv (IntLit i)) = Number i
and
Cv_to_bv (CLitv (Bool b)) = Number (bool_to_int b)
and
Cv_to_bv (CConv n vs) = Block n (Cvs_to_bvs vs)
and
Cv_to_bv (CClosure env vs b) = Block 0 [CodePtr ?, ?]
and
Cv_to_bv (CRecClos env ns defs n) = Block 0 [CodePtr ?, ?]
and
Cvs_to_bvs [] = []
and
Cvs_to_bvs (v::vs) = Cv_to_bv v :: Cvs_to_bvs vs
*)
