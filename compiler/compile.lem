(* Translation from CakeML to Intermediate Language *)

open CompilerLib
open CompilerPrimitives
open SemanticPrimitives
open Ast
open IntLang

let rec
free_vars (CDecl xs) = Set.from_list (List.map (fun (n,m) -> n) xs)
and
free_vars (CRaise _) = {}
and
free_vars (CHandle e1 e2) = free_vars e1 union (image pre (free_vars e2 \ {0}))
and
free_vars (CVar n) = {n}
and
free_vars (CLit _) = {}
and
free_vars (CCon _ es) = free_vars_list es
and
free_vars (CTagEq e _) = free_vars e
and
free_vars (CProj e _) = free_vars e
and
free_vars (CLet e eb) = free_vars e union (image pre (free_vars eb \ {0}))
and
free_vars (CLetrec defs e) =
  let n = List.length defs in
  free_vars_defs n defs union
  (image (fun m -> m - n) (free_vars e \ count n))
and
free_vars (CFun def) = free_vars_def 1 def
and
free_vars (CCall e es) = free_vars e union free_vars_list es
and
free_vars (CPrim1 _ e) = free_vars e
and
free_vars (CPrim2 _ e1 e2) = free_vars e1 union free_vars e2
and
free_vars (CUpd e1 e2) = free_vars e1 union free_vars e2
and
free_vars (CIf e1 e2 e3) = free_vars e1 union free_vars e2 union free_vars e3
and
free_vars_list [] = {}
and
free_vars_list (e::es) = free_vars e union free_vars_list es
and
free_vars_defs n [] = {}
and
free_vars_defs n (d::ds) = free_vars_def n d union free_vars_defs n ds
and
free_vars_def n (None,(k,e)) = image (fun m -> m-(n+k)) (free_vars e \ (count (n+k)))
and
free_vars_def n (Some _,_) = {}

let rec
mkshift f k (CDecl vs) = CDecl (List.map (fun (n,m) -> (if n < k then n else (f (n-k))+k, m)) vs)
and
mkshift f k (CRaise err) = CRaise err
and
mkshift f k (CHandle e1 e2) = CHandle (mkshift f k e1) (mkshift f (k+1) e2)
and
mkshift f k (CVar v) = CVar (if v < k then v else (f (v-k))+k)
and
mkshift f k (CLit l) = CLit l
and
mkshift f k (CCon cn es) = CCon cn (List.map (mkshift f k) es)
and
mkshift f k (CTagEq e m) = CTagEq (mkshift f k e) m
and
mkshift f k (CProj e m) = CProj (mkshift f k e) m
and
mkshift f k (CLet e b) = CLet (mkshift f k e) (mkshift f (k+1) b)
and
mkshift f k (CLetrec defs b) =
  let ns = List.length defs in
  let defs = List.map (fun cb ->
    match cb with | (Some _,_) -> cb | (None,(az,b)) -> (None,(az,mkshift f (k+ns+az) b)) end)
    defs in
  CLetrec defs (mkshift f (k+ns) b)
and
mkshift f k (CFun cb) = CFun
  (match cb with | (Some _,_) -> cb | (None,(az,b)) -> (None,(az,mkshift f (k+1+az) b)) end)
and
mkshift f k (CCall e es) = CCall (mkshift f k e) (List.map (mkshift f k) es)
and
mkshift f k (CPrim1 p1 e) = CPrim1 p1 (mkshift f k e)
and
mkshift f k (CPrim2 p2 e1 e2) = CPrim2 p2 (mkshift f k e1) (mkshift f k e2)
and
mkshift f k (CUpd e1 e2) = CUpd (mkshift f k e1) (mkshift f k e2)
and
mkshift f k (CIf e1 e2 e3) = CIf (mkshift f k e1) (mkshift f k e2) (mkshift f k e3)

let shift n = mkshift (fun v -> v+n)

(* remove pattern-matching using continuations *)

type exp_to_Cexp_state = <| bvars : list string ; cnmap : Pmap.map (id conN) num |>
let rec cbv m v = <| m with bvars = v::m.bvars |>

let rec
pat_to_Cpat m (Pvar vn) = (<|m with bvars = vn::m.bvars|>, CPvar)
and
pat_to_Cpat m (Plit l) = (m, CPlit l)
and
pat_to_Cpat m (Pcon cn ps) =
  let (m,Cps) = pats_to_Cpats m ps in
  (m,CPcon (Pmap.find cn m.cnmap) Cps)
and
pat_to_Cpat m (Pref p) =
  let (m,Cp) = pat_to_Cpat m p in
  (m,CPref Cp)
and
pats_to_Cpats m [] = (m,[])
and
pats_to_Cpats m (p::ps) =
  let (m,Cp) = pat_to_Cpat m p in
  let (m,Cps) = pats_to_Cpats m ps in
  (m,Cp::Cps)

let rec
Cpat_vars CPvar = 1
and
Cpat_vars (CPlit _) = 0
and
Cpat_vars (CPcon _ ps) = Cpat_vars_list ps
and
Cpat_vars (CPref p) = Cpat_vars p
and
Cpat_vars_list [] = 0
and
Cpat_vars_list (p::ps) = (Cpat_vars p)+(Cpat_vars_list ps)

let rec
remove_mat_vp fk sk v CPvar =
  CLet (CVar v) sk
and
remove_mat_vp fk sk v (CPlit l) =
  CIf (CPrim2 CEq (CVar v) (CLit l))
    sk (CCall (CVar fk) [])
and
remove_mat_vp fk sk v (CPcon cn ps) =
  CIf (CTagEq (CVar v) cn)
    (remove_mat_con fk sk v 0 ps)
    (CCall (CVar fk) [])
and
remove_mat_vp fk sk v (CPref p) =
  CLet (CPrim1 CDer (CVar v))
    (remove_mat_vp (fk+1) (shift 1 (Cpat_vars p) sk) 0 p)
and
remove_mat_con fk sk v n [] = sk
and
remove_mat_con fk sk v n (p::ps) =
  let p1 = Cpat_vars p in
  let p2 = Cpat_vars_list ps in
  CLet (CProj (CVar v) n)
    (remove_mat_vp (fk+1)
      (remove_mat_con (fk+1+p1) (shift 1 (p2+p1) sk) (v+1+p1) (n+1) ps)
      0 p)

let rec
remove_mat_var v [] = CRaise Bind_error
and
remove_mat_var v ((p,sk)::pes) =
  CLet (CFun (None, (0,shift 1 0 (remove_mat_var v pes))))
    (remove_mat_vp 0 (shift 1 (Cpat_vars p) sk) (v+1) p)

let rec
exp_to_Cexp m (Handle e x b) =
  CHandle (exp_to_Cexp m e) (exp_to_Cexp (cbv m x) b)
and
exp_to_Cexp m (Raise err) = CRaise err
and
exp_to_Cexp m (Lit l) = CLit l
and
exp_to_Cexp m (Con cn es) =
  CCon (Pmap.find cn m.cnmap) (exps_to_Cexps m es)
and
exp_to_Cexp m (Var (Short vn)) = CVar (the (find_index vn m.bvars 0))
and
exp_to_Cexp m (Var (Long _ _)) = CRaise Bind_error
and
exp_to_Cexp m (Fun vn e) =
  CFun (None,(1,shift 1 1 (exp_to_Cexp (cbv m vn) e)))
and
exp_to_Cexp m (App (Opn opn) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CPrim2 (match opn with
          | Plus   -> CAdd
          | Minus  -> CSub
          | Times  -> CMul
          | Divide -> CDiv
          | Modulo -> CMod
          end)
  Ce1 Ce2
and
exp_to_Cexp m (App (Opb opb) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  match opb with
  | Lt -> CPrim2 CLt Ce1 Ce2
  | Leq -> CPrim2 CLt (CPrim2 CSub Ce1 Ce2) (CLit (IntLit i1))
  | opb ->
      CLet Ce1 (
        CLet (shift 1 0 Ce2) (
          match opb with
          | Gt ->  CPrim2 CLt (CVar 0) (CVar 1)
          | Geq -> CPrim2 CLt (CPrim2 CSub (CVar 0) (CVar 1)) (CLit (IntLit i1))
          end))
  end
and
exp_to_Cexp m (App Equality e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CPrim2 CEq Ce1 Ce2
and
exp_to_Cexp m (App Opapp e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CCall Ce1 [Ce2]
and
exp_to_Cexp m (App Opassign e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CUpd Ce1 Ce2
and
exp_to_Cexp m (Uapp uop e) =
  let Ce = exp_to_Cexp m e in
  CPrim1 (match uop with
          | Opref   -> CRef
          | Opderef -> CDer
          end) Ce
and
exp_to_Cexp m (Log log e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  (match log with
   | And -> CIf Ce1 Ce2 (CLit (Bool false))
   | Or  -> CIf Ce1 (CLit (Bool true)) Ce2
   end)
and
exp_to_Cexp m (If e1 e2 e3) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  let Ce3 = exp_to_Cexp m e3 in
  CIf Ce1 Ce2 Ce3
and
exp_to_Cexp m (Mat e pes) =
  let Ce = exp_to_Cexp m e in
  let Cpes = pes_to_Cpes m pes in
  let Cpes = List.map (fun (p,e) -> (p,shift 1 (Cpat_vars p) e)) Cpes in
  CLet Ce (remove_mat_var 0 Cpes)
and
exp_to_Cexp m (Let vn e b) =
  let Ce = exp_to_Cexp m e in
  let Cb = exp_to_Cexp (cbv m vn) b in
  CLet Ce Cb
and
exp_to_Cexp m (Letrec defs b) =
  let m = <| m with bvars = (List.map (fun (n,_,_) -> n) defs) @ m.bvars |> in
  CLetrec (defs_to_Cdefs m defs) (exp_to_Cexp m b)
and
defs_to_Cdefs m [] = []
and
defs_to_Cdefs m ((_,vn,e)::defs) =
  let Ce = exp_to_Cexp (cbv m vn) e in
  let Cdefs = defs_to_Cdefs m defs in
  (None,(1,Ce))::Cdefs
and
pes_to_Cpes m [] = []
and
pes_to_Cpes m ((p,e)::pes) =
  let Cpes = pes_to_Cpes m pes in
  let (m,Cp) = pat_to_Cpat m p in
  let Ce = exp_to_Cexp m e in
  (Cp,Ce)::Cpes
and
exps_to_Cexps s [] = []
and
exps_to_Cexps m (e::es) =
  exp_to_Cexp m e :: exps_to_Cexps m es

(* pull closure bodies into code environment *)

let rec bind_fv (az,e) nz ix =
  let fvs = free_vars e in
  let recs = List.filter (fun v -> az+v IN fvs && not (v=ix)) (genlist (fun n -> n) nz) in
  let envs = List.filter (fun v -> az+nz <= v) (Hol.QSORT (fun x y -> x < y) (Set.to_list fvs)) in
  let envs = List.map (fun v -> v-(az+nz)) envs in
  let rz = List.length recs+1 in
  let e = mkshift (fun v -> if v < nz then the(find_index v (ix::recs) 0)
                            else the(find_index (v-nz) envs rz))
                  az e in
  let rz = rz-1 in
  ((genlist (fun i -> CCArg (2+i)) (az+1))
   @(genlist CCRef rz)
   @(genlist (fun i -> CCEnv (rz+i)) (List.length envs))
  ,(recs,envs)
  ,e
  )

let rec
label_closures ez j (CDecl xs) = (CDecl xs, j)
and
label_closures ez j (CRaise err) = (CRaise err, j)
and
label_closures ez j (CHandle e1 e2) =
  let (e1,j) = label_closures ez j e1 in
  let (e2,j) = label_closures (ez+1) j e2 in
  (CHandle e1 e2, j)
and
label_closures ez j (CVar x) = (CVar x, j)
and
label_closures ez j (CLit l) = (CLit l, j)
and
label_closures ez j (CCon cn es) =
  let (es,j) = label_closures_list ez j es in
  (CCon cn es,j)
and
label_closures ez j (CTagEq e n) =
  let (e,j) = label_closures ez j e in
  (CTagEq e n,j)
and
label_closures ez j (CProj e n) =
  let (e,j) = label_closures ez j e in
  (CProj e n,j)
and
label_closures ez j (CLet e1 e2) =
  let (e1,j) = label_closures ez j e1 in
  let (e2,j) = label_closures (ez+1) j e2 in
  (CLet e1 e2, j)
and
label_closures ez j (CLetrec defs e) =
  let defs = List.map snd (List.filter (Hol.o Hol.IS_NONE fst) defs) in
  let nz = List.length defs in
  let (defs,j) = label_closures_defs ez j nz 0 defs in
  let (e,j) = label_closures (ez+nz) j e in
  (CLetrec defs e, j)
and
label_closures ez j (CFun (None, def)) =
  let (defs,j) = label_closures_defs ez j 1 0 [def] in
  (CFun (List.nth defs 0), j)
and
label_closures ez j (CFun (Some x,y)) = (CFun (Some x,y),j) (* should not happen *)
and
label_closures ez j (CCall e es) =
  let (e,j) = label_closures ez j e in
  let (es,j) = label_closures_list ez j es in
  (CCall e es,j)
and
label_closures ez j (CPrim1 p1 e) =
  let (e,j) = label_closures ez j e in
  (CPrim1 p1 e, j)
and
label_closures ez j (CPrim2 p2 e1 e2) =
  let (e1,j) = label_closures ez j e1 in
  let (e2,j) = label_closures ez j e2 in
  (CPrim2 p2 e1 e2, j)
and
label_closures ez j (CUpd e1 e2) =
  let (e1,j) = label_closures ez j e1 in
  let (e2,j) = label_closures ez j e2 in
  (CUpd e1 e2, j)
and
label_closures ez j (CIf e1 e2 e3) =
  let (e1,j) = label_closures ez j e1 in
  let (e2,j) = label_closures ez j e2 in
  let (e3,j) = label_closures ez j e3 in
  (CIf e1 e2 e3, j)
and
label_closures_list ez j [] = ([],j)
and
label_closures_list ez j (e::es) =
  let (e,j) = label_closures ez j e in
  let (es,j) = label_closures_list ez j es in
  (e::es,j)
and
label_closures_defs ez j nz k [] = ([], j)
and
label_closures_defs ez ld nz k ((az,b)::defs) =
  let (ccenv,ceenv,b) = bind_fv (az,b) nz k in
  let cz = az + List.length (fst ceenv) + List.length (snd ceenv) + 1 in
  let (b,j) = label_closures cz (ld+1) b in
  let (defs,j) = label_closures_defs ez j nz (k+1) defs in
  ((Some (ld,(ccenv,ceenv)),(az,b))::defs, j)

(* intermediate expressions to bytecode *)

open Bytecode

type call_context = TCNonTail of bool | TCTail of num * num
(* TCTail j k = in tail position,
   * the called function has j arguments, and
   * k let variables have been bound *)
(* TCNonTail b = if b then in tail position, but called from top-level,
 * else not in tail position. *)

type compiler_result =
  <| out: list bc_inst (* reversed code *)
   ; next_label: num
   ; decl: ctenv * num * list string
   |>

let rec
prim1_to_bc CRef = Ref
and
prim1_to_bc CDer = Deref

let rec
prim2_to_bc CAdd = Add
and
prim2_to_bc CSub = Sub
and
prim2_to_bc CMul = Mult
and
prim2_to_bc CDiv = Div
and
prim2_to_bc CMod = Mod
and
prim2_to_bc CLt = Less
and
prim2_to_bc CEq = Equal

let emit = List.fold_left (fun s i -> <| s with out = i :: s.out |>)

let rec
get_labels n s = (<| s with next_label = s.next_label + n |>,
                  genlist (fun i -> s.next_label + i) n)

let rec
compile_envref sz s (CCArg n) = emit s [Stack (Load (sz + n))]
and
compile_envref sz s (CCEnv n) = emit s [Stack (Load sz); Stack (El n)]
and
compile_envref sz s (CCRef n) = emit (compile_envref sz s (CCEnv n)) [Deref]

let rec
compile_varref sz s (CTLet n) = emit s [Stack (Load (sz - n))]
and
compile_varref sz s (CTEnv x) = compile_envref sz s x

(* calling convention:
 * before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
 * thus, since env = stack[sz], argk should be CTArg (2 + n - k)
 * after:  retval,
 *)

(* closure representation:
 * Block 3 [CodePtr f; Env]
 * where Env = Number 0 for empty, or else
 * Block 3 [v1,...,vk]
 * with a value for each free variable
 * (some values may be RefPtrs to other (mutrec) closures)
 *)

(* closure construction, for a bundle of nz names, nk defs:
 * - push nz refptrs
 * - push nk CodePtrs, each pointing to the appropriate body
 * - for each def, load its CodePtr, load its environment, cons them up, and
     store them where its CodePtr was
   - for each name, load the refptr and update it with the closure
   - for each name, store the refptr back where it was
 *)

let rec
emit_ceenv env (sz,s) fv = (sz+1,compile_varref sz s (List.nth env fv))

let rec
(* sz                                                           z                             *)
(* e, ..., e, CodePtr_k, cl_1, ..., CodePtr k, ..., CodePtr nz, RefPtr_1 0, ..., RefPtr_nz 0, *)
emit_ceref z (sz,s) j = (sz+1,emit s [Stack (Load ((sz-z)+j))])

let rec
push_lab (s,ecs) (None,_) = (s,([],[])::ecs) (* should not happen *)
and
push_lab (s,ecs) (Some (l,(_,ceenv)),_) =
  (emit s [PushPtr (Lab l)],ceenv::ecs)

let rec
cons_closure env0 sz nk (s,k) (refs,envs) =
  (*                                                                      sz *)
  (* cl_1, ..., CodePtr_k, ..., CodePtr_nk, RefPtr_1 0, ..., RefPtr_nk 0,    *)
  let s = emit s [Stack (Load k)] in
  (* CodePtr_k, cl_1, ..., CodePtr_k, ..., CodePtr_nk, RefPtr_1 0, ..., RefPtr_nk 0, *)
  let (z,s) = List.fold_left (emit_ceref (sz+nk)) (sz+nk+nk+1,s) refs in
  let (z,s) = List.fold_left (emit_ceenv env0) (z,s) envs in
  (* e_kj, ..., e_k1, CodePtr_k, cl_1, ..., CodePtr_k, ..., CodePtr_nk, RefPtr_1 0, ..., RefPtr_nk 0, *)
  let s = emit s [Stack (Cons 0 (List.length refs + List.length envs))] in
  (* env_k, CodePtr_k, cl_1, ..., CodePtr_k, ..., CodePtr_nk, RefPtr_1 0, ..., RefPtr_nk 0, *)
  let s = emit s [Stack (Cons closure_tag 2)] in
  (* cl_k,  cl_1, ..., CodePtr_k, ..., CodePtr_nk, RefPtr_1 0, ..., RefPtr_nk 0, *)
  let s = emit s [Stack (Store k)] in
  (* cl_1, ..., cl_k, ..., CodePtr_nk, RefPtr_1 0, ..., RefPtr_nk 0, *)
  (s,k+1)

let rec
update_refptr nk (s,k) =
  (* cl_1, ..., cl_nk, RefPtr_1 cl_1, ..., RefPtr_k 0, ..., RefPtr_nk 0, *)
  let s = emit s [Stack (Load (nk + k))] in
  (* RefPtr_k 0, cl_1, ..., cl_nk, RefPtr_1 cl_1, ..., RefPtr_k 0, ..., RefPtr_nk 0, *)
  let s = emit s [Stack (Load (1 + k))] in
  (* cl_k, RefPtr_k 0, cl_1, ..., cl_nk, RefPtr_1 cl_1, ..., RefPtr_k 0, ..., RefPtr_nk 0, *)
  let s = emit s [Update] in
  (* cl_1, ..., cl_nk, RefPtr_1 cl_1, ..., RefPtr_k cl_k, ..., RefPtr_nk 0, *)
  (s,k+1)

let rec
compile_closures env sz s defs =
  let nk = List.length defs in
  let s = num_fold (fun s -> emit s [Stack (PushInt i0); Ref]) s nk in
  (* RefPtr_1 0, ..., RefPtr_nk 0, *)
  let (s,ecs) = List.fold_left push_lab (s,[]) (List.rev defs) in
  (* CodePtr 1, ..., CodePtr nk, RefPtr_1 0, ..., RefPtr_nk 0, *)
  let (s,_k) = List.fold_left (cons_closure env sz nk) (s,0) ecs in
  (* cl_1, ..., cl_nk, RefPtr_1 0, ..., RefPtr_nk 0, *)
  let (s,_k) = num_fold (update_refptr nk) (s,0) nk in
  (* cl_1, ..., cl_nk, RefPtr_1 cl_1, ..., RefPtr_nk cl_nk, *)
  let k = nk - 1 in
  num_fold (fun s -> emit s [Stack (Store k)]) s nk
  (* cl_1, ..., cl_nk, *)

let rec
compile_decl env1 =
  List.fold_left
    (fun (s,sz,i,env,bvs) (v,bv) ->
      match find_index bv bvs 1 with
      | None ->
          (compile_varref sz s (List.nth env1 v)
          ,sz+1
          ,i+1
          ,(CTLet i)::env
          ,bv::bvs
          )
      | Some j ->
          (emit (compile_varref sz s (List.nth env1 v)) [Stack (Store ((sz+j)-i))]
          ,sz
          ,i
          ,env
          ,bvs
          )
      end)

let rec
pushret (TCNonTail _) s = s
and
pushret (TCTail j k) s =
 (* val, vk, ..., v1, env, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c; env], *)
  emit s [Stack (Pops (k+1));
 (* val, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c; env], *)
          Stack (Load 1);
 (* CodePtr ret, val, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c; env], *)
          Stack (Store (j+2));
 (* val, CodePtr ret, argj, ..., arg1, CodePtr ret, *)
          Stack (Pops (j+1));
 (* val, CodePtr ret, *)
          Return]

let rec
compile env t sz s (CDecl vs) =
  match t with TCNonTail true ->
  match s.decl with (env0,sz0,bvs0) ->
  let k = sz - sz0 in
  let (s,sz,i,env,bvs) = compile_decl env (s,sz,sz0+1,env0,bvs0) vs in
  let s = emit s [Stack (Shift (i-(sz0+1)) k)] in
  <| s with decl = (env,sz-k,bvs) |>
  end | _ -> pushret t (emit s [Stack (PushInt i2); PopExc]) (* should not happen *) end
and
compile _ t _ s (CRaise err) =
  pushret t (emit s [Stack (PushInt (error_to_int err)); PopExc])
and
compile env t sz s (CHandle e1 e2) = compile env t sz s e1
and
compile _ t _ s (CLit (IntLit i)) =
  pushret t (emit s [Stack (PushInt i)])
and
compile _ t _ s (CLit (Bool b)) =
  pushret t (emit s [Stack (Cons (bool_to_tag b) 0)])
and
compile _ t _ s (CLit Unit) =
  pushret t (emit s [Stack (Cons unit_tag 0)])
and
compile env t sz s (CVar vn) = pushret t (compile_varref sz s (List.nth env vn))
and
compile env t sz s (CCon n es) =
  pushret t (emit (compile_nts env sz s es) [Stack (Cons (n+block_tag) (List.length es))])
and
compile env t sz s (CTagEq e n) =
  pushret t (emit (compile env (TCNonTail false) sz s e) [Stack (TagEq (n+block_tag))])
and
compile env t sz s (CProj e n) =
  pushret t (emit (compile env (TCNonTail false) sz s e) [Stack (El n)])
and
compile env t sz s (CLet e eb) =
  compile_bindings env t sz eb 0 (compile env (TCNonTail false) sz s e) 1
and
compile env t sz s (CLetrec defs eb) =
  let s = compile_closures env sz s defs in
  compile_bindings env t sz eb 0 s (List.length defs)
and
compile env t sz s (CFun cb) =
  pushret t (compile_closures env sz s [cb])
and
compile env t sz s (CCall e es) =
  let n = List.length es in
  let s = compile_nts env sz s (e::es) in
  match t with
  | TCNonTail _ ->
    (* argn, ..., arg2, arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [Stack (Load n); Stack (El 1)] in
    (* env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [Stack (Load (n+1)); Stack (El 0)] in
    (* CodePtr c, env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    emit s [CallPtr]
    (* before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    (* after:  retval, *)
  | TCTail j k ->
    (* argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+1+k+1))] in
    (* CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+1)); Stack (El 1)] in
    (* env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+2)); Stack (El 0)] in
    (* CodePtr c, env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Shift (1+1+1+n+1) (k+1+1+j+1))] in
    emit s [JumpPtr]
  end
and
compile env t sz s (CPrim1 uop e) =
  pushret t (emit (compile env (TCNonTail false) sz s e) [prim1_to_bc uop])
and
compile env t sz s (CPrim2 op e1 e2) = (* TODO: need to detect div by zero? *)
  pushret t (emit (compile_nts env sz s [e1;e2]) [Stack (prim2_to_bc op)])
and
compile env t sz s (CUpd e1 e2) =
  pushret t (emit (compile_nts env sz s [e1;e2]) [Update; Stack (Cons unit_tag 0)])
and
compile env t sz s (CIf e1 e2 e3) =
  let s = compile env (TCNonTail false) sz s e1 in
  let (s,labs) = get_labels 2 s in
  let n0 = List.nth labs 0 in
  let n1 = List.nth labs 1 in
  match t with
  | TCNonTail _ ->
    let (s,labs) = get_labels 1 s in
    let n2 = List.nth labs 0 in
    let s = emit s [(JumpIf (Lab n0)); (Jump (Lab n1)); Label n0] in
    let s = compile env t sz s e2 in
    let s = emit s [Jump (Lab n2); Label n1] in
    let s = compile env t sz s e3 in
    emit s [Label n2]
  | TCTail _ _ ->
    let s = emit s [(JumpIf (Lab n0)); (Jump (Lab n1)); Label n0] in
    let s = compile env t sz s e2 in
    let s = emit s [Label n1] in
    compile env t sz s e3
  end
and
compile_bindings env t sz e n s 0 =
  match t with
  | TCTail j k -> compile env (TCTail j (k+n)) (sz+n) s e
  | TCNonTail false ->
    emit (compile env t (sz+n) s e) [Stack (Pops n)]
  | TCNonTail true ->
    compile env t (sz+n) s e
  end
and
compile_bindings env t sz e n s m =
  compile_bindings ((CTLet (sz+(n+1)))::env) t sz e (n+1) s (m-1)
and
compile_nts env sz s [] = s
and
compile_nts env sz s (e::es) =
  compile_nts env (sz+1) (compile env (TCNonTail false) sz s e) es

(* code env to bytecode *)

(* edit free_labs to include Some/None, ez, nz, and ix, and add a free_labs_defs
 * constant, and then use free_labs as the basis for both good_code_env and
 * code_env_code *)

let rec
free_labs ez (CDecl _) = []
and
free_labs ez (CRaise _) = []
and
free_labs ez (CHandle e1 e2) = free_labs ez e1 @ free_labs (ez+1) e2
and
free_labs ez (CVar _) = []
and
free_labs ez (CLit _) = []
and
free_labs ez (CCon _ es) = free_labs_list ez es
and
free_labs ez (CTagEq e _) = free_labs ez e
and
free_labs ez (CProj e _) = free_labs ez e
and
free_labs ez (CLet e b) = free_labs ez e @ free_labs (ez+1) b
and
free_labs ez (CLetrec defs e) =
  free_labs_defs ez (List.length defs) 0 defs @
  free_labs (ez+List.length defs) e
and
free_labs ez (CFun def) = free_labs_def ez 1 0 def
and
free_labs ez (CCall e es) = free_labs ez e @ free_labs_list ez es
and
free_labs ez (CPrim2 _ e1 e2) = free_labs ez e1 @ free_labs ez e2
and
free_labs ez (CUpd e1 e2) = free_labs ez e1 @ free_labs ez e2
and
free_labs ez (CPrim1 _ e) = free_labs ez e
and
free_labs ez (CIf e1 e2 e3) = free_labs ez e1 @ free_labs ez e2 @ free_labs ez e3
and
free_labs_list ez [] = []
and
free_labs_list ez (e::es) = free_labs ez e @ free_labs_list ez es
and
free_labs_defs ez nz ix [] = []
and
free_labs_defs ez nz ix (d::ds) = free_labs_def ez nz ix d @ free_labs_defs ez nz (ix+1) ds
and
free_labs_def ez nz ix (Some (l,(cc,(re,ev))),(az,b)) =
  (((ez,nz,ix),((l,(cc,(re,ev))),(az,b)))::(free_labs (1 + List.length re + List.length ev + az) b))
and
free_labs_def ez nz ix (None,(az,b)) = (free_labs (ez+nz+az) b)

let rec
no_labs (CDecl _) = true
and
no_labs (CRaise _) = true
and
no_labs (CHandle e1 e2) = no_labs e1 && no_labs e2
and
no_labs (CVar _) = true
and
no_labs (CLit _) = true
and
no_labs (CCon _ es) = no_labs_list es
and
no_labs (CTagEq e _) = no_labs e
and
no_labs (CProj e _) = no_labs e
and
no_labs (CLet e b) = no_labs e && no_labs b
and
no_labs (CLetrec defs e) = no_labs_defs defs && no_labs e
and
no_labs (CFun def) = no_labs_def def
and
no_labs (CCall e es) = no_labs e && no_labs_list es
and
no_labs (CPrim2 _ e1 e2) = no_labs e1 && no_labs e2
and
no_labs (CUpd e1 e2) = no_labs e1 && no_labs e2
and
no_labs (CPrim1 _ e) = no_labs e
and
no_labs (CIf e1 e2 e3) = no_labs e1 && no_labs e2 && no_labs e3
and
no_labs_list [] = true
and
no_labs_list (e::es) = no_labs e && no_labs_list es
and
no_labs_defs [] = true
and
no_labs_defs (d::ds) = no_labs_def d && no_labs_defs ds
and
no_labs_def (Some _,_) = false
and
no_labs_def (None,(az,b)) = no_labs b

let rec
all_labs (CDecl _) = true
and
all_labs (CRaise _) = true
and
all_labs (CHandle e1 e2) = all_labs e1 && all_labs e2
and
all_labs (CVar _) = true
and
all_labs (CLit _) = true
and
all_labs (CCon _ es) = all_labs_list es
and
all_labs (CTagEq e _) = all_labs e
and
all_labs (CProj e _) = all_labs e
and
all_labs (CLet e b) = all_labs e && all_labs b
and
all_labs (CLetrec defs e) = all_labs_defs defs && all_labs e
and
all_labs (CFun def) = all_labs_def def
and
all_labs (CCall e es) = all_labs e && all_labs_list es
and
all_labs (CPrim2 _ e1 e2) = all_labs e1 && all_labs e2
and
all_labs (CUpd e1 e2) = all_labs e1 && all_labs e2
and
all_labs (CPrim1 _ e) = all_labs e
and
all_labs (CIf e1 e2 e3) = all_labs e1 && all_labs e2 && all_labs e3
and
all_labs_list [] = true
and
all_labs_list (e::es) = all_labs e && all_labs_list es
and
all_labs_defs [] = true
and
all_labs_defs (d::ds) = all_labs_def d && all_labs_defs ds
and
all_labs_def (Some _,(az,b)) = all_labs b
and
all_labs_def (None,(az,b)) = false

let rec cce_aux s ((l,(ccenv,_)),(az,b)) =
  compile (List.map CTEnv ccenv) (TCTail az 0) 0 (emit s [Label l]) b

let rec
compile_code_env s e =
  let (s,ls) = get_labels 1 s in
  let l = List.nth ls 0 in
  let s = emit s [Jump (Lab l)] in
  let s = List.fold_left cce_aux s (List.map snd (free_labs 0 e)) in
  emit s [Label l]

(* replace labels in bytecode with addresses *)

let rec
calculate_labels il m n a [] = (m,n,a)
and
calculate_labels il m n a (Label l::lbc) =
  calculate_labels il (Pmap.add l n m) n a lbc
and
calculate_labels il m n a (i::lbc) =
  calculate_labels il m (n + il i + 1) (i::a) lbc

let rec
replace_labels m a [] = a
and
replace_labels m a (Jump (Lab l)::bc) =
  replace_labels m (Jump (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (JumpIf (Lab l)::bc) =
  replace_labels m (JumpIf (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (Call (Lab l)::bc) =
  replace_labels m (Call (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (PushPtr (Lab l)::bc) =
  replace_labels m (PushPtr (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (i::bc) =
  replace_labels m (i::a) bc

let rec
compile_labels il lbc =
  let (m,n,bc) = calculate_labels il Pmap.empty 0 [] lbc in
    replace_labels m [] bc

(* repl *)

type contab = Pmap.map (id conN) num * Pmap.map num (id conN) * num
val cmap : contab -> Pmap.map (id conN) num
let rec cmap (m,_,_) = m

type repl_state =
  <| contab : contab
   ; rbvars : list string
   ; renv : ctenv
   ; rsz  : num
   ; rnext_label : num
   |>

val etC : repl_state -> exp_to_Cexp_state
let etC rs = <| bvars = rs.rbvars; cnmap = cmap rs.contab |>

let init_repl_state =
  <| contab = (Pmap.empty, Pmap.empty, 0)
   ; rbvars = []
   ; renv = []
   ; rsz  = 0
   ; rnext_label = 0
   |>

let compile_Cexp rs decl Ce =
  let (Ce,n) = label_closures (List.length rs.rbvars) rs.rnext_label Ce in
  let cs = <| out = []; next_label = n
            ; decl = (rs.renv,rs.rsz,rs.rbvars) |> in
  let cs = compile_code_env cs Ce in
  let cs = compile rs.renv (TCNonTail decl) rs.rsz cs Ce in
  let rs = if decl then match cs.decl with
    | (env,sz,bvars) -> <| rs with renv = env; rsz = sz; rbvars = bvars |>
    end else <| rs with rsz = rs.rsz + 1 |> in
  let rs = <| rs with rnext_label = cs.next_label |> in
  (rs, List.rev cs.out)

let rec
number_constructors [] ct = ct
and
number_constructors ((c,_)::cs) (m,w,n) =
  number_constructors cs (Pmap.add (Short c) n m, Pmap.add n (Short c) w, n+1)

let rec
repl_dec rs (Dtype []) = (rs,[])
and
repl_dec rs (Dtype ((_,_,cs)::ts)) =
  let ct = number_constructors cs rs.contab in
  repl_dec <| rs with contab = ct |> (Dtype ts)
and
repl_dec rs (Dletrec defs) =
  let m = etC rs in
  let fns = List.map (fun (n,_,_) -> n) defs in
  let m = <| m with bvars = fns @ m.bvars |> in
  let Cdefs = defs_to_Cdefs m defs in
  compile_Cexp rs true (CLetrec Cdefs (CDecl (List.combine (genlist (fun i -> i) (List.length fns)) fns)))
and
repl_dec rs (Dlet p e) =
  let m = etC rs in
  let Ce = exp_to_Cexp m e in
  let (m,Cp) = pat_to_Cpat <| m with bvars = [] |> p in
  let vs = m.bvars in
  let Cpes = [(Cp,CDecl (List.combine (genlist (fun i -> i) (List.length vs)) vs))] in
  compile_Cexp rs true (CLet Ce (remove_mat_var 0 Cpes))

let repl_exp s exp = compile_Cexp s false (exp_to_Cexp (etC s) exp)

(* Correctness *)

(* observable values *)

type ov =
  | OLit of lit
  | OConv of id conN * list ov
  | OFn
  | OLoc of num (* machine, not semantic, address *)

let rec
v_to_ov s (Litv l) = OLit l
and
v_to_ov s (Conv cn vs) = OConv cn (List.map (v_to_ov s) vs)
and
v_to_ov s (Closure _ _ _) = OFn
and
v_to_ov s (Recclosure _ _ _) = OFn
and
v_to_ov s (Loc n) = OLoc (List.nth s n)

let rec
Cv_to_ov m s (CLitv l) = OLit l
and
Cv_to_ov m s (CConv cn vs) = OConv (Pmap.find cn m) (List.map (Cv_to_ov m s) vs)
and
Cv_to_ov m s (CRecClos _ _ _) = OFn
and
Cv_to_ov m s (CLoc n) = OLoc (List.nth s n)

let rec
bv_to_ov m (Number i) = OLit (IntLit i)
and
bv_to_ov m (Block n vs) =
  if n = (bool_to_tag false) then OLit (Bool false) else
  if n = (bool_to_tag true) then OLit (Bool true) else
  if n = unit_tag then OLit Unit else
  if n = closure_tag then OFn else
  OConv (Pmap.find (n-block_tag) m) (List.map (bv_to_ov m) vs)
and
bv_to_ov m (RefPtr n) = OLoc n

(* source to intermediate values *)

let rec
v_to_Cv m (Litv l) = CLitv l
and
v_to_Cv m (Conv cn vs) =
  CConv (Pmap.find cn m) (vs_to_Cvs m vs)
and
v_to_Cv m (Closure env vn e) =
  let Cenv = env_to_Cenv m env in
  let m = <| bvars = List.map fst env ; cnmap = m |> in
  let Ce = exp_to_Cexp (cbv m vn) e in
  CRecClos Cenv [(None, (1,shift 1 1 Ce))] 0
and
v_to_Cv m (Recclosure env defs vn) =
  let Cenv = env_to_Cenv m env in
  let m = <| bvars = List.map fst env ; cnmap = m |> in
  let fns = List.map (fun (n,_,_) -> n) defs in
  let m = <| m with bvars = fns @ m.bvars |> in
  let Cdefs = defs_to_Cdefs m defs in
  CRecClos Cenv Cdefs (the (find_index vn fns 0))
and
v_to_Cv m (Loc n) = CLoc n
and
vs_to_Cvs m [] = []
and
vs_to_Cvs m (v::vs) = v_to_Cv m v :: vs_to_Cvs m vs
and
env_to_Cenv m [] = []
and
env_to_Cenv m ((_,v)::env) =
  (v_to_Cv m v)::(env_to_Cenv m env)

(* TODO: compile Raise and Handle properly *)
(* TODO: simple type system and checker? *)
(* TODO: map_Cexp? *)
(* TODO: use Pmap.peek instead of mem when it becomes available *)
(* TODO: collapse nested functions *)
(* TODO: collapse nested lets *)
(* TODO: Letfun introduction and reordering *)
(* TODO: let floating *)
(* TODO: removal of redundant expressions *)
(* TODO: simplification (e.g., constant folding) *)
(* TODO: avoid Shifts when possible *)
(* TODO: registers, register allocation, greedy shuffling? *)
(* TODO: bytecode optimizer: repeated Pops, unreachable code (e.g. after a Jump) *)
(* TODO: more efficient pattern-matching *)
(* TODO: store type information on CMat nodes (for pattern matching compilation)? *)
