open SemanticPrimitives
open Ast
open CompilerLib
open IntLang
open ToIntLang
open Bytecode
open ToBytecode

let rec
no_labs (CDecl _) = true
and
no_labs (CRaise _) = true
and
no_labs (CHandle e1 e2) = no_labs e1 && no_labs e2
and
no_labs (CVar _) = true
and
no_labs (CLit _) = true
and
no_labs (CCon _ es) = no_labs_list es
and
no_labs (CTagEq e _) = no_labs e
and
no_labs (CProj e _) = no_labs e
and
no_labs (CLet e b) = no_labs e && no_labs b
and
no_labs (CLetrec defs e) = no_labs_defs defs && no_labs e
and
no_labs (CFun def) = no_labs_def def
and
no_labs (CCall e es) = no_labs e && no_labs_list es
and
no_labs (CPrim2 _ e1 e2) = no_labs e1 && no_labs e2
and
no_labs (CUpd e1 e2) = no_labs e1 && no_labs e2
and
no_labs (CPrim1 _ e) = no_labs e
and
no_labs (CIf e1 e2 e3) = no_labs e1 && no_labs e2 && no_labs e3
and
no_labs_list [] = true
and
no_labs_list (e::es) = no_labs e && no_labs_list es
and
no_labs_defs [] = true
and
no_labs_defs (d::ds) = no_labs_def d && no_labs_defs ds
and
no_labs_def (Some _,_) = false
and
no_labs_def (None,(az,b)) = no_labs b

let rec
all_labs (CDecl _) = true
and
all_labs (CRaise _) = true
and
all_labs (CHandle e1 e2) = all_labs e1 && all_labs e2
and
all_labs (CVar _) = true
and
all_labs (CLit _) = true
and
all_labs (CCon _ es) = all_labs_list es
and
all_labs (CTagEq e _) = all_labs e
and
all_labs (CProj e _) = all_labs e
and
all_labs (CLet e b) = all_labs e && all_labs b
and
all_labs (CLetrec defs e) = all_labs_defs defs && all_labs e
and
all_labs (CFun def) = all_labs_def def
and
all_labs (CCall e es) = all_labs e && all_labs_list es
and
all_labs (CPrim2 _ e1 e2) = all_labs e1 && all_labs e2
and
all_labs (CUpd e1 e2) = all_labs e1 && all_labs e2
and
all_labs (CPrim1 _ e) = all_labs e
and
all_labs (CIf e1 e2 e3) = all_labs e1 && all_labs e2 && all_labs e3
and
all_labs_list [] = true
and
all_labs_list (e::es) = all_labs e && all_labs_list es
and
all_labs_defs [] = true
and
all_labs_defs (d::ds) = all_labs_def d && all_labs_defs ds
and
all_labs_def (Some _,(az,b)) = all_labs b
and
all_labs_def (None,(az,b)) = false

(* repl *)

type contab = Pmap.map (id conN) num * Pmap.map num (id conN) * num
val cmap : contab -> Pmap.map (id conN) num
let rec cmap (m,_,_) = m

type repl_state =
  <| contab : contab
   ; rbvars : list string
   ; renv : ctenv
   ; rsz  : num
   ; rnext_label : num
   |>

val etC : repl_state -> exp_to_Cexp_state
let etC rs = <| bvars = rs.rbvars; cnmap = cmap rs.contab |>

let init_repl_state =
  <| contab = (Pmap.empty, Pmap.empty, 0)
   ; rbvars = []
   ; renv = []
   ; rsz  = 0
   ; rnext_label = 0
   |>

let compile_Cexp rs decl Ce =
  let (Ce,n) = label_closures (List.length rs.rbvars) rs.rnext_label Ce in
  let cs = <| out = []; next_label = n
            ; decl = (rs.renv,rs.rsz,rs.rbvars) |> in
  let cs = compile_code_env cs Ce in
  let cs = compile rs.renv (TCNonTail decl) rs.rsz cs Ce in
  let rs = if decl then match cs.decl with
    | (env,sz,bvars) -> <| rs with renv = env; rsz = sz; rbvars = bvars |>
    end else <| rs with rsz = rs.rsz + 1 |> in
  let rs = <| rs with rnext_label = cs.next_label |> in
  (rs, List.rev cs.out)

let rec
number_constructors [] ct = ct
and
number_constructors ((c,_)::cs) (m,w,n) =
  number_constructors cs (Pmap.add (Short c) n m, Pmap.add n (Short c) w, n+1)

let rec
repl_dec rs (Dtype []) = (rs,[])
and
repl_dec rs (Dtype ((_,_,cs)::ts)) =
  let ct = number_constructors cs rs.contab in
  repl_dec <| rs with contab = ct |> (Dtype ts)
and
repl_dec rs (Dletrec defs) =
  let m = etC rs in
  let fns = List.map (fun (n,_,_) -> n) defs in
  let m = <| m with bvars = fns @ m.bvars |> in
  let Cdefs = defs_to_Cdefs m defs in
  compile_Cexp rs true (CLetrec Cdefs (CDecl (List.combine (genlist (fun i -> i) (List.length fns)) fns)))
and
repl_dec rs (Dlet p e) =
  let m = etC rs in
  let Ce = exp_to_Cexp m e in
  let (m,Cp) = pat_to_Cpat <| m with bvars = [] |> p in
  let vs = m.bvars in
  let Cpes = [(Cp,CDecl (List.combine (genlist (fun i -> i) (List.length vs)) vs))] in
  compile_Cexp rs true (CLet Ce (remove_mat_var 0 Cpes))

let repl_exp s exp = compile_Cexp s false (exp_to_Cexp (etC s) exp)

(* Correctness *)

(* observable values *)

type ov =
  | OLit of lit
  | OConv of id conN * list ov
  | OFn
  | OLoc of num (* machine, not semantic, address *)

let rec
v_to_ov s (Litv l) = OLit l
and
v_to_ov s (Conv cn vs) = OConv cn (List.map (v_to_ov s) vs)
and
v_to_ov s (Closure _ _ _) = OFn
and
v_to_ov s (Recclosure _ _ _) = OFn
and
v_to_ov s (Loc n) = OLoc (List.nth s n)

let rec
Cv_to_ov m s (CLitv l) = OLit l
and
Cv_to_ov m s (CConv cn vs) = OConv (Pmap.find cn m) (List.map (Cv_to_ov m s) vs)
and
Cv_to_ov m s (CRecClos _ _ _) = OFn
and
Cv_to_ov m s (CLoc n) = OLoc (List.nth s n)

let rec
bv_to_ov m (Number i) = OLit (IntLit i)
and
bv_to_ov m (Block n vs) =
  if n = (bool_to_tag false) then OLit (Bool false) else
  if n = (bool_to_tag true) then OLit (Bool true) else
  if n = unit_tag then OLit Unit else
  if n = closure_tag then OFn else
  OConv (Pmap.find (n-block_tag) m) (List.map (bv_to_ov m) vs)
and
bv_to_ov m (RefPtr n) = OLoc n

(* source to intermediate values *)

let rec
v_to_Cv m (Litv l) = CLitv l
and
v_to_Cv m (Conv cn vs) =
  CConv (Pmap.find cn m) (vs_to_Cvs m vs)
and
v_to_Cv m (Closure env vn e) =
  let Cenv = env_to_Cenv m env in
  let m = <| bvars = List.map fst env ; cnmap = m |> in
  let Ce = exp_to_Cexp (cbv m vn) e in
  CRecClos Cenv [(None, (1,shift 1 1 Ce))] 0
and
v_to_Cv m (Recclosure env defs vn) =
  let Cenv = env_to_Cenv m env in
  let m = <| bvars = List.map fst env ; cnmap = m |> in
  let fns = List.map (fun (n,_,_) -> n) defs in
  let m = <| m with bvars = fns @ m.bvars |> in
  let Cdefs = defs_to_Cdefs m defs in
  CRecClos Cenv Cdefs (the (find_index vn fns 0))
and
v_to_Cv m (Loc n) = CLoc n
and
vs_to_Cvs m [] = []
and
vs_to_Cvs m (v::vs) = v_to_Cv m v :: vs_to_Cvs m vs
and
env_to_Cenv m [] = []
and
env_to_Cenv m ((_,v)::env) =
  (v_to_Cv m v)::(env_to_Cenv m env)

(* TODO: compile Raise and Handle properly *)
(* TODO: simple type system and checker? *)
(* TODO: map_Cexp? *)
(* TODO: use Pmap.peek instead of mem when it becomes available *)
(* TODO: collapse nested functions *)
(* TODO: collapse nested lets *)
(* TODO: Letfun introduction and reordering *)
(* TODO: let floating *)
(* TODO: removal of redundant expressions *)
(* TODO: simplification (e.g., constant folding) *)
(* TODO: avoid Shifts when possible *)
(* TODO: registers, register allocation, greedy shuffling? *)
(* TODO: bytecode optimizer: repeated Pops, unreachable code (e.g. after a Jump) *)
(* TODO: more efficient pattern-matching *)
(* TODO: store type information on CMat nodes (for pattern matching compilation)? *)
