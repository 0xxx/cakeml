(* The second intermediate language (IL2). Removes named datatype constructors.
 *
 * The AST of IL2 differs from IL1 by using numbered tags instead of
 * constructor name identifiers for all data constructor patterns and
 * expressions. Also type and exception declarations are removed.
 *
 * The values of IL2 differ in that the closures do not contain a constructor
 * name environment.
 *
 * The semantics of IL2 differ in that there is no constructor name
 * environment.
 *
 * The translator to IL2 keeps a mapping of constructors to their tags. The
 * tuple constructor is always 0. Div, Bind, and Eq are always 1, 2, and 3.
 * Cond and nil are always 4 and 5. It also keeps a reverse mapping for use by
 * the REPL printer.
 *
 *)

open import Pervasives
open import Lib
open import Ast
open import SemanticPrimitives
open import List_extra
open import BigStep
open import IntLang1

val tuple_tag : nat
let tuple_tag = 0

val div_tag : nat
let div_tag = 1

val bind_tag : nat
let bind_tag = 2

val eq_tag : nat
let eq_tag = 3

val cons_tag : nat
let cons_tag = 4

val nil_tag : nat
let nil_tag = 5


type pat_i2 =
  | Pvar_i2 of varN
  | Plit_i2 of lit
  | Pcon_i2 of nat * list pat_i2
  | Pref_i2 of pat_i2

type exp_i2 =
  | Raise_i2 of exp_i2
  | Handle_i2 of exp_i2 * list (pat_i2 * exp_i2)
  | Lit_i2 of lit
  | Con_i2 of nat * list exp_i2
  | Var_local_i2 of varN
  | Var_global_i2 of nat
  | Fun_i2 of varN * exp_i2
  | Uapp_i2 of uop * exp_i2
  | App_i2 of op * exp_i2 * exp_i2
  | If_i2 of exp_i2 * exp_i2 * exp_i2
  | Mat_i2 of exp_i2 * list (pat_i2 * exp_i2)
  | Let_i2 of varN * exp_i2 * exp_i2
  | Letrec_i2 of list (varN * varN * exp_i2) * exp_i2

type dec_i2 =
  | Dlet_i2 of nat * exp_i2
  | Dletrec_i2 of list (varN * varN * exp_i2)

type prompt_i2 =
  | Prompt_i2 of list dec_i2

type v_i2 =
  | Litv_i2 of lit
  | Conv_i2 of nat * list v_i2 
  | Closure_i2 of env varN v_i2 * varN * exp_i2
  | Recclosure_i2 of env varN v_i2 * list (varN * varN * exp_i2) * varN
  | Loc_i2 of nat

val pat_bindings_i2 : pat_i2 -> list varN -> list varN
let rec
pat_bindings_i2 (Pvar_i2 n) already_bound =
  n::already_bound
and
pat_bindings_i2 (Plit_i2 l) already_bound =
  already_bound
and
pat_bindings_i2 (Pcon_i2 _ ps) already_bound =
  pats_bindings_i2 ps already_bound
and
pat_bindings_i2 (Pref_i2 p) already_bound =
  pat_bindings_i2 p already_bound
and
pats_bindings_i2 [] already_bound =
  already_bound
and
pats_bindings_i2 (p::ps) already_bound =
  pats_bindings_i2 ps (pat_bindings_i2 p already_bound)

(* The constructor names that are in scope, the global mapping of constructor
 * names (with types so that they are unique, and its inverse *)
type cenv_mapping = nat * map (id conN) nat * map (maybe modN * tid_or_exn * conN) nat * map nat (maybe modN * tid_or_exn * conN)

val lookup_tag : maybe (id conN) -> cenv_mapping -> nat
let lookup_tag cn (next,cenv,val_cenv,inv) = 
  match cn with
    | Nothing -> tuple_tag
    | Just id ->
        match Map.lookup id cenv with
                | Nothing -> 0 (* Can't happen *)
                | Just n -> n
        end
  end

val pat_to_i2 : cenv_mapping -> pat -> pat_i2
let rec
pat_to_i2 cenv (Pvar x) = Pvar_i2 x
and 
pat_to_i2 cenv (Plit l) = Plit_i2 l
and 
pat_to_i2 cenv (Pcon con_id ps) = 
  Pcon_i2 (lookup_tag con_id cenv) (List.map (pat_to_i2 cenv) ps)
and 
pat_to_i2 cenv (Pref p) = Pref_i2 (pat_to_i2 cenv p)

val exp_to_i2 : cenv_mapping -> exp_i1 -> exp_i2
val exps_to_i2 : cenv_mapping -> list exp_i1 -> list exp_i2
val pat_exp_to_i2 : cenv_mapping -> list (pat * exp_i1) -> list (pat_i2 * exp_i2)
val funs_to_i2 : cenv_mapping -> list (varN * varN * exp_i1) -> list (varN * varN * exp_i2)
let rec 
exp_to_i2 cenv (Raise_i1 e) = 
  Raise_i2 (exp_to_i2 cenv e)
and
exp_to_i2 cenv (Handle_i1 e pes) = 
  Handle_i2 (exp_to_i2 cenv e) (pat_exp_to_i2 cenv pes)
and
exp_to_i2 cenv (Lit_i1 l) = 
  Lit_i2 l 
and
exp_to_i2 cenv (Con_i1 cn es) = 
  Con_i2 (lookup_tag cn cenv) (exps_to_i2 cenv es)
and
exp_to_i2 cenv (Var_local_i1 x) = Var_local_i2 x
and
exp_to_i2 cenv (Var_global_i1 x) = Var_global_i2 x
and
exp_to_i2 cenv (Fun_i1 x e) =
  Fun_i2 x (exp_to_i2 cenv e) 
and
exp_to_i2 cenv (Uapp_i1 uop e) =
  Uapp_i2 uop (exp_to_i2 cenv e)
and
exp_to_i2 cenv (App_i1 op e1 e2) =
  App_i2 op (exp_to_i2 cenv e1) (exp_to_i2 cenv e2)
and
exp_to_i2 cenv (If_i1 e1 e2 e3) =
  If_i2 (exp_to_i2 cenv e1) (exp_to_i2 cenv e2) (exp_to_i2 cenv e3)
and
exp_to_i2 cenv (Mat_i1 e pes) =
  Mat_i2 (exp_to_i2 cenv e) (pat_exp_to_i2 cenv pes)
and
exp_to_i2 cenv (Let_i1 x e1 e2) =
  Let_i2 x (exp_to_i2 cenv e1) (exp_to_i2 cenv e2)
and
exp_to_i2 cenv (Letrec_i1 funs e) =
  Letrec_i2 (funs_to_i2 cenv funs) 
            (exp_to_i2 cenv e)
and
exps_to_i2 cenv [] = []
and
exps_to_i2 cenv (e::es) =
  exp_to_i2 cenv e :: exps_to_i2 cenv es
and
pat_exp_to_i2 cenv [] = []
and
pat_exp_to_i2 cenv ((p,e)::pes) =
  (pat_to_i2 cenv p, exp_to_i2 cenv e) :: pat_exp_to_i2 cenv pes
and
funs_to_i2 cenv [] = []
and
funs_to_i2 cenv ((f,x,e)::funs) =
  (f,x,exp_to_i2 cenv e) :: funs_to_i2 cenv funs

val alloc_tag : maybe modN -> tid_or_exn -> conN -> cenv_mapping -> cenv_mapping
let alloc_tag mn tn cn (next, cenv,val_cenv,inv) =
  (next+1,Map.insert (mk_id mn cn) next cenv, Map.insert (mn,tn,cn) next val_cenv, Map.insert next (mn,tn,cn) inv)

val alloc_tags : maybe modN -> cenv_mapping -> type_def -> cenv_mapping
let rec 
alloc_tags mn cenv [] = cenv
and
alloc_tags mn cenv ((tvs,tn,constrs)::types) = 
  let cenv' =
    List.foldr (fun (cn,ts) cenv' -> alloc_tag mn (TypeId (mk_id mn tn)) cn cenv') cenv constrs
  in
    alloc_tags mn cenv' types

declare termination_argument alloc_tags = automatic

val decs_to_i2 : cenv_mapping -> list dec_i1 -> cenv_mapping * list dec_i2
let rec 
decs_to_i2 cenv [] = (cenv,[])
and
decs_to_i2 cenv (d::ds) =
  match d with
    | Dlet_i1 n e -> 
        let (cenv', ds') = decs_to_i2 cenv ds in
          (cenv', Dlet_i2 n (exp_to_i2 cenv e)::ds')
    | Dletrec_i1 funs ->
        let (cenv', ds') = decs_to_i2 cenv ds in
          (cenv', Dletrec_i2 (funs_to_i2 cenv funs)::ds')
    | Dtype_i1 mn type_def ->
        decs_to_i2 (alloc_tags mn cenv type_def) ds
    | Dexn_i1 mn cn ts ->
        decs_to_i2 (alloc_tag mn (TypeExn mn) cn cenv) ds
  end

declare termination_argument decs_to_i2 = automatic

val prompt_to_i2 : cenv_mapping -> prompt_i1 -> cenv_mapping * prompt_i2
let prompt_to_i2 cenv prompt =
  match prompt with
    | Prompt_i1 mn ds ->
        let (cenv', ds') = decs_to_i2 cenv ds in
          (cenv', Prompt_i2 ds')
  end

val prog_to_i2 : cenv_mapping -> list prompt_i1 -> cenv_mapping * list prompt_i2
let rec 
prog_to_i2 cenv [] = (cenv, [])
and 
prog_to_i2 cenv (p::ps) = 
  let (cenv',p') = prompt_to_i2 cenv p in
  let (cenv'',ps') = prog_to_i2 cenv' ps in
    (cenv'',p'::ps')

declare termination_argument prog_to_i2 = automatic

val do_uapp_i2 : store v_i2 -> uop -> v_i2 -> maybe (store v_i2 * v_i2)
let do_uapp_i2 s uop v =
  match uop with
    | Opderef ->
        match v with
          | Loc_i2 n ->
              match store_lookup n s with
                | Just v -> Just (s,v)
                | Nothing -> Nothing
              end
          | _ -> Nothing
        end
    | Opref ->
        let (s',n) = store_alloc v s in
          Just (s', Loc_i2 n)
  end

val build_rec_env_i2 : list (varN * varN * exp_i2) -> env varN v_i2 -> env varN v_i2 -> env varN v_i2
let build_rec_env_i2 funs cl_env add_to_env =
  foldr 
    (fun (f,x,e) env' -> bind f (Recclosure_i2 cl_env funs f) env') 
    add_to_env 
    funs

val do_eq_i2 : v_i2 -> v_i2 -> eq_result
let rec 
do_eq_i2 (Litv_i2 l1) (Litv_i2 l2) = 
  Eq_val (l1 = l2)
and
do_eq_i2 (Loc_i2 l1) (Loc_i2 l2) = Eq_val (l1 = l2)
and
do_eq_i2 (Conv_i2 tag1 vs1) (Conv_i2 tag2 vs2) =
  if tag1 = tag2 && (List.length vs1 = List.length vs2) then
    do_eq_list_i2 vs1 vs2
  else
    Eq_val false
and
do_eq_i2 (Closure_i2 _ _ _) (Closure_i2 _ _ _) = Eq_closure
and
do_eq_i2 (Closure_i2 _ _ _) (Recclosure_i2 _ _ _) = Eq_closure
and
do_eq_i2 (Recclosure_i2 _ _ _) (Closure_i2 _ _ _) = Eq_closure
and
do_eq_i2 (Recclosure_i2 _ _ _) (Recclosure_i2 _ _ _) = Eq_closure
and
do_eq_i2 _ _ = Eq_type_error
and
do_eq_list_i2 [] [] = Eq_val true
and
do_eq_list_i2 (v1::vs1) (v2::vs2) = 
  match do_eq_i2 v1 v2 with
    | Eq_closure -> Eq_closure
    | Eq_type_error -> Eq_type_error
    | Eq_val r -> 
        if not r then
          Eq_val false
        else
          do_eq_list_i2 vs1 vs2
  end
and
do_eq_list_i2 _ _ = Eq_val false

type all_env_i2 = (list v_i2 * env varN v_i2)

let all_env_i2_to_genv (genv,env) = genv
let all_env_i2_to_env (genv,env) = env

val exn_env_i2 : list v_i2 -> all_env_i2
let exn_env_i2 genv = (genv, emp)

val do_app_i2 : all_env_i2 -> store v_i2 -> op -> v_i2 -> v_i2 -> maybe (all_env_i2 * store v_i2 * exp_i2)
let do_app_i2 env' s op v1 v2 =
  match (op, v1, v2) with
    | (Opapp, Closure_i2 env n e, v) ->
        Just ((all_env_i2_to_genv env', bind n v env), s, e)
    | (Opapp, Recclosure_i2 env funs n, v) ->
        match find_recfun n funs with
          | Just (n,e) -> Just ((all_env_i2_to_genv env', bind n v (build_rec_env_i2 funs env env)), s, e)
          | Nothing -> Nothing
        end
    | (Opn op, Litv_i2 (IntLit n1), Litv_i2 (IntLit n2)) ->
        if (op = Divide || (op = Modulo)) && (n2 = 0) then
          Just (exn_env_i2 (all_env_i2_to_genv env'), s, Raise_i2 (Con_i2 div_tag []))
        else
          Just (env', s, Lit_i2 (IntLit (opn_lookup op n1 n2)))
    | (Opb op, Litv_i2 (IntLit n1), Litv_i2 (IntLit n2)) ->
        Just (env', s, Lit_i2 (Bool (opb_lookup op n1 n2)))
    | (Equality, v1, v2) ->
        match do_eq_i2 v1 v2 with
          | Eq_type_error -> Nothing
          | Eq_closure -> Just (exn_env_i2 (all_env_i2_to_genv env'), s, Raise_i2 (Con_i2 eq_tag []))
          | Eq_val b -> Just (env', s, Lit_i2 (Bool b))
        end
    | (Opassign, (Loc_i2 lnum), v) ->
        match store_assign lnum v s with
        | Just st -> Just (env', st, Lit_i2 Unit)
        | Nothing -> Nothing
        end
    | _ -> Nothing
  end

val do_if_i2 : v_i2 -> exp_i2 -> exp_i2 -> maybe exp_i2
let do_if_i2 v e1 e2 =
  if v = Litv_i2 (Bool true) then
    Just e1
  else if v = Litv_i2 (Bool false) then
    Just e2
  else
    Nothing

val pmatch_i2 : store v_i2 -> pat_i2 -> v_i2 -> env varN v_i2 -> match_result (env varN v_i2)
let rec
pmatch_i2 s (Pvar_i2 x) v' env = Match (bind x v' env)
and
pmatch_i2 s (Plit_i2 l) (Litv_i2 l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error
and
pmatch_i2 s (Pcon_i2 tag1 ps) (Conv_i2 tag2 vs) env =
  if tag1 = tag2 then
    if List.length ps = List.length vs then
      pmatch_list_i2 s ps vs env
    else 
      Match_type_error
  else
    No_match
and
pmatch_i2 s (Pref_i2 p) (Loc_i2 lnum) env =
  match store_lookup lnum s with
    | Just v -> pmatch_i2 s p v env
    | Nothing -> Match_type_error
  end
and
pmatch_i2 _ _ _ env = Match_type_error
and
pmatch_list_i2 s [] [] env = Match env
and
pmatch_list_i2 s (p::ps) (v::vs) env =
  match pmatch_i2 s p v env with
    | No_match -> No_match
    | Match_type_error -> Match_type_error
    | Match env' -> pmatch_list_i2 s ps vs env'
  end
and
pmatch_list_i2 s _ _ env = Match_type_error

indreln [evaluate_i2 : bool -> all_env_i2 -> count_store v_i2 -> exp_i2 -> count_store v_i2 * result v_i2 v_i2 -> bool]
and [evaluate_list_i2 : bool -> all_env_i2 -> count_store v_i2 -> list exp_i2 -> count_store v_i2 * result (list v_i2) v_i2 -> bool]
and [evaluate_match_i2 : bool -> all_env_i2 -> count_store v_i2 -> v_i2 -> list (pat_i2 * exp_i2) -> v_i2 -> count_store v_i2 * result v_i2 v_i2 -> bool]

lit : forall ck env l s.
true
==>
evaluate_i2 ck env s (Lit_i2 l) (s, Rval (Litv_i2 l))

and

raise1 : forall ck env e s1 s2 v.
evaluate_i2 ck s1 env e (s2, Rval v)
==>
evaluate_i2 ck s1 env (Raise_i2 e) (s2, Rerr (Rraise v))

and

raise2 : forall ck env e s1 s2 err.
evaluate_i2 ck s1 env e (s2, Rerr err)
==>
evaluate_i2 ck s1 env (Raise_i2 e) (s2, Rerr err)

and

handle1 : forall ck s1 s2 env e v pes.
evaluate_i2 ck s1 env e (s2, Rval v)
==>
evaluate_i2 ck s1 env (Handle_i2 e pes) (s2, Rval v)

and

handle2 : forall ck s1 s2 env e pes v bv.
evaluate_i2 ck env s1 e (s2, Rerr (Rraise v)) &&
evaluate_match_i2 ck env s2 v pes v bv
==>
evaluate_i2 ck env s1 (Handle_i2 e pes) bv

and

handle3 : forall ck s1 s2 env e pes err.
evaluate_i2 ck env s1 e (s2, Rerr err) &&
(err = Rtimeout_error || (err = Rtype_error))
==>
evaluate_i2 ck env s1 (Handle_i2 e pes) (s2, Rerr err)

and

con1 : forall ck env tag es vs s s'.
evaluate_list_i2 ck env s es (s', Rval vs)
==>
evaluate_i2 ck env s (Con_i2 tag es) (s', Rval (Conv_i2 tag vs))

and

con3 : forall ck env tag es err s s'.
evaluate_list_i2 ck env s es (s', Rerr err)
==>
evaluate_i2 ck env s (Con_i2 tag es) (s', Rerr err)

and

var1 : forall ck env n v s.
(lookup n (all_env_i2_to_env env) = Just v)
==>
evaluate_i2 ck env s (Var_local_i2 n) (s, Rval v)

and

var2 : forall ck env n s.
(lookup n (all_env_i2_to_env env) = Nothing)
==>
evaluate_i2 ck env s (Var_local_i2 n) (s, Rerr Rtype_error)
and

var3 : forall ck env n v s.
(List.length (all_env_i2_to_genv env) > n) &&
(List_extra.nth (all_env_i2_to_genv env) n = v)
==>
evaluate_i2 ck env s (Var_global_i2 n) (s, Rval v)

and

var4 : forall ck env n s.
not (List.length (all_env_i2_to_genv env) > n)
==>
evaluate_i2 ck env s (Var_global_i2 n) (s, Rerr Rtype_error)

and

fn : forall ck env n e s.
true
==>
evaluate_i2 ck env s (Fun_i2 n e) (s, Rval (Closure_i2 (all_env_i2_to_env env) n e))

and

uapp1 : forall ck env uop e v v' s1 s2 count s3.
evaluate_i2 ck env s1 e ((count,s2), Rval v) &&
(do_uapp_i2 s2 uop v = Just (s3,v'))
==>
evaluate_i2 ck env s1 (Uapp_i2 uop e) ((count,s3), Rval v')

and

uapp2 : forall ck env uop e v s1 s2 count.
evaluate_i2 ck env s1 e ((count,s2), Rval v) &&
(do_uapp_i2 s2 uop v = Nothing)
==>
evaluate_i2 ck env s1 (Uapp_i2 uop e) ((count,s2), Rerr Rtype_error)

and

uapp3 : forall ck env uop e err s s'.
evaluate_i2 ck env s e (s', Rerr err)
==>
evaluate_i2 ck env s (Uapp_i2 uop e) (s', Rerr err)

and

app1 : forall ck env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 count s4.
evaluate_i2 ck env s1 e1 (s2, Rval v1) &&
evaluate_i2 ck env s2 e2 ((count,s3), Rval v2) &&
do_app_i2 env s3 op v1 v2 = Just (env', s4, e3) &&
((ck && (op = Opapp)) --> count <> 0) &&
evaluate_i2 ck env' ((if ck then dec_count op count else count),s4) e3 bv
==>
evaluate_i2 ck env s1 (App_i2 op e1 e2) bv

and

app2 : forall ck env op e1 e2 v1 v2 env' e3 s1 s2 s3 count s4.
evaluate_i2 ck env s1 e1 (s2, Rval v1) &&
evaluate_i2 ck env s2 e2 ((count,s3), Rval v2) &&
do_app_i2 env s3 op v1 v2 = Just (env', s4, e3) &&
count = 0 &&
op = Opapp &&
ck
==>
evaluate_i2 ck env s1 (App_i2 op e1 e2) ((0,s4), Rerr Rtimeout_error)

and

app3 : forall ck env op e1 e2 v1 v2 s1 s2 s3 count.
evaluate_i2 ck env s1 e1 (s2, Rval v1) &&
evaluate_i2 ck env s2 e2 ((count,s3), Rval v2) &&
do_app_i2 env s3 op v1 v2 = Nothing
==>
evaluate_i2 ck env s1 (App_i2 op e1 e2) ((count,s3), Rerr Rtype_error)

and

app4 : forall ck env op e1 e2 v1 err s1 s2 s3.
evaluate_i2 ck env s1 e1 (s2, Rval v1) &&
evaluate_i2 ck env s2 e2 (s3, Rerr err)
==>
evaluate_i2 ck env s1 (App_i2 op e1 e2) (s3, Rerr err)

and

app5 : forall ck env op e1 e2 err s s'.
evaluate_i2 ck env s e1 (s', Rerr err)
==>
evaluate_i2 ck env s (App_i2 op e1 e2) (s', Rerr err)

and

if1 : forall ck env e1 e2 e3 v e' bv s1 s2.
evaluate_i2 ck env s1 e1 (s2, Rval v) &&
do_if_i2 v e2 e3 = Just e' &&
evaluate_i2 ck env s2 e' bv
==>
evaluate_i2 ck env s1 (If_i2 e1 e2 e3) bv

and

if2 : forall ck env e1 e2 e3 v s1 s2.
evaluate_i2 ck env s1 e1 (s2, Rval v) &&
do_if_i2 v e2 e3 = Nothing
==>
evaluate_i2 ck env s1 (If_i2 e1 e2 e3) (s2, Rerr Rtype_error)

and

if3 : forall ck env e1 e2 e3 err s s'.
evaluate_i2 ck env s e1 (s', Rerr err)
==>
evaluate_i2 ck env s (If_i2 e1 e2 e3) (s', Rerr err)

and

mat1 : forall ck env e pes v bv s1 s2.
evaluate_i2 ck env s1 e (s2, Rval v) &&
evaluate_match_i2 ck env s2 v pes (Conv_i2 bind_tag []) bv
==>
evaluate_i2 ck env s1 (Mat_i2 e pes) bv

and

mat2 : forall ck env e pes err s s'.
evaluate_i2 ck env s e (s', Rerr err)
==>
evaluate_i2 ck env s (Mat_i2 e pes) (s', Rerr err)

and

let1 : forall ck genv env n e1 e2 v bv s1 s2.
evaluate_i2 ck (genv,env) s1 e1 (s2, Rval v) &&
evaluate_i2 ck (genv,bind n v env) s2 e2 bv
==>
evaluate_i2 ck (genv,env) s1 (Let_i2 n e1 e2) bv

and

let2 : forall ck env n e1 e2 err s s'.
evaluate_i2 ck env s e1 (s', Rerr err)
==>
evaluate_i2 ck env s (Let_i2 n e1 e2) (s', Rerr err)

and

letrec1 : forall ck genv env funs e bv s.
all_distinct (List.map (fun (x,y,z) -> x) funs) &&
evaluate_i2 ck (genv,build_rec_env_i2 funs env env) s e bv
==>
evaluate_i2 ck (genv,env) s (Letrec_i2 funs e) bv

and

letrec2 : forall ck env funs e s.
not (all_distinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate_i2 ck env s (Letrec_i2 funs e) (s, Rerr Rtype_error)

and

empty : forall ck env s.
true
==>
evaluate_list_i2 ck env s [] (s, Rval [])

and

cons1 : forall ck env e es v vs s1 s2 s3.
evaluate_i2 ck env s1 e (s2, Rval v) &&
evaluate_list_i2 ck env s2 es (s3, Rval vs)
==>
evaluate_list_i2 ck env s1 (e::es) (s3, Rval (v::vs))

and

cons2 : forall ck env e es err s s'.
evaluate_i2 ck env s e (s', Rerr err)
==>
evaluate_list_i2 ck env s (e::es) (s', Rerr err)

and

cons3 : forall ck env e es v err s1 s2 s3.
evaluate_i2 ck env s1 e (s2, Rval v) &&
evaluate_list_i2 ck env s2 es (s3, Rerr err)
==>
evaluate_list_i2 ck env s1 (e::es) (s3, Rerr err)

and

mat_empty : forall ck env v err_v s.
true
==>
evaluate_match_i2 ck env s v [] err_v (s, Rerr (Rraise err_v))

and

mat_cons1 : forall ck genv env env' v p pes e bv err_v s count.
all_distinct (pat_bindings_i2 p []) &&
(pmatch_i2 s p v env = Match env') &&
evaluate_i2 ck (genv,env') (count,s) e bv
==>
evaluate_match_i2 ck (genv,env) (count,s) v ((p,e)::pes) err_v bv

and

mat_cons2 : forall ck genv env v p e pes bv s count err_v.
all_distinct (pat_bindings_i2 p []) &&
(pmatch_i2 s p v env = No_match) &&
evaluate_match_i2 ck (genv,env) (count,s) v pes err_v bv
==>
evaluate_match_i2 ck (genv,env) (count,s) v ((p,e)::pes) err_v bv

and

mat_cons3 : forall ck genv env v p e pes s count err_v.
(pmatch_i2 s p v env = Match_type_error)
==>
evaluate_match_i2 ck (genv,env) (count,s) v ((p,e)::pes) err_v ((count,s), Rerr Rtype_error)

and

mat_cons4 : forall ck env v p e pes s err_v.
not (all_distinct (pat_bindings_i2 p []))
==>
evaluate_match_i2 ck env s v ((p,e)::pes) err_v (s, Rerr Rtype_error)

indreln [evaluate_dec_i2 : list v_i2 -> store v_i2 -> dec_i2 -> store v_i2 * result (list v_i2) v_i2 -> bool]

dlet1 : forall genv n e vs s1 s2 count.
evaluate_i2 false (genv,emp) (0,s1) e ((count,s2), Rval (Conv_i2 tuple_tag vs)) &&
List.length vs = n
==>
evaluate_dec_i2 genv s1 (Dlet_i2 n e) (s2, Rval vs)

and

dlet3 : forall genv n e vs s1 s2 count.
evaluate_i2 false (genv,emp) (0,s1) e ((count,s2), Rval (Conv_i2 tuple_tag vs)) &&
List.length vs <> n
==>
evaluate_dec_i2 genv s1 (Dlet_i2 n e) (s2, Rerr Rtype_error)

and

dlet4 : forall genv n e v s1 s2 count.
evaluate_i2 false (genv,emp) (0,s1) e ((count,s2), Rval v) &&
not (exists vs. v = Conv_i2 tuple_tag vs)
==>
evaluate_dec_i2 genv s1 (Dlet_i2 n e) (s2, Rerr Rtype_error)

and

dlet5 : forall genv n e err s count s'.
evaluate_i2 false (genv,emp) (0,s) e ((count,s'), Rerr err)
==>
evaluate_dec_i2 genv s (Dlet_i2 n e) (s', Rerr err)

and

dletrec1 : forall genv funs s.
true
==>
evaluate_dec_i2 genv s (Dletrec_i2 funs) (s, Rval (List.map (fun (f,x,e) -> Closure_i2 [] x e) funs))

indreln [evaluate_decs_i2 : list v_i2 -> store v_i2 -> list dec_i2 -> store v_i2 * list v_i2 * maybe (error_result v_i2) -> bool]

empty : forall genv s.
true
==>
evaluate_decs_i2 genv s [] (s, [], Nothing)

and

cons1 : forall s1 s2 genv d ds e.
evaluate_dec_i2 genv s1 d (s2, Rerr e)
==>
evaluate_decs_i2 genv s1 (d::ds) (s2, [], Just e)

and

cons2 : forall s1 s2 s3 genv d ds new_env new_env' r.
evaluate_dec_i2 genv s1 d (s2, Rval new_env) &&
evaluate_decs_i2 (genv ++ new_env) s2 ds (s3, new_env', r)
==>
evaluate_decs_i2 genv s1 (d::ds) (s3, new_env ++ new_env', r)

let rec
dec_to_dummy_env_i2 (Dlet_i2 n e) = n
and
dec_to_dummy_env_i2 (Dletrec_i2 funs) = List.length funs

let rec
decs_to_dummy_env_i2 [] = 0
and
decs_to_dummy_env_i2 (d::ds) = decs_to_dummy_env_i2 ds + dec_to_dummy_env_i2 d

declare termination_argument decs_to_dummy_env_i2 = automatic

indreln [evaluate_prompt_i2 : list v_i2 -> store v_i2 -> prompt_i2 -> store v_i2 * list v_i2 * maybe (error_result v_i2) -> bool]

prompt_val : forall genv s1 ds s2 env.
evaluate_decs_i2 genv s1 ds (s2,env,Nothing)
==>
evaluate_prompt_i2 genv s1 (Prompt_i2 ds) (s2, env, Nothing)

and

prompt_err1 : forall genv s1 ds s2 env err.
evaluate_decs_i2 genv s1 ds (s2,env,Just err)
==>
evaluate_prompt_i2 genv s1 (Prompt_i2 ds) (s2, 
                                           env ++ List.genlist (fun _ -> Litv_i2 Unit) (decs_to_dummy_env_i2 ds - List.length env),
                                           Just err)

indreln [evaluate_prog_i2 : list v_i2 -> store v_i2 -> list prompt_i2 -> store v_i2 * list v_i2 * maybe (error_result v_i2) -> bool]

prog_empty : forall genv s.
true
==>
evaluate_prog_i2 genv s [] (s, [], Nothing)

and

prog_cons_var : forall genv s1 prompt prompts s2 env2 s3 env3 r.
evaluate_prompt_i2 genv s1 prompt (s2, env2, Nothing) &&
evaluate_prog_i2 (genv++env2) s2 prompts (s3, env3, r)
==>
evaluate_prog_i2 genv s1 (prompt::prompts) (s3, env2++env3, r)

and

prog_cons_err : forall genv s1 prompt prompts s2 env2 err.
evaluate_prompt_i2 genv s1 prompt (s2, env2, Just err)
==>
evaluate_prog_i2 genv s1 (prompt::prompts) (s2, env2, Just err)

val init_cenv_mapping : cenv_mapping
let init_cenv_mapping =
  (6,
   Map.fromList [(Short "Div", div_tag); 
                 (Short "Bind", bind_tag); 
                 (Short "Eq", eq_tag); 
                 (Short "::", cons_tag);
                 (Short "nil", nil_tag)],
   Map.fromList [((Nothing, TypeExn Nothing, "Div"), div_tag); 
                 ((Nothing, TypeExn Nothing, "Bind"), bind_tag); 
                 ((Nothing, TypeExn Nothing, "Eq"), eq_tag); 
                 ((Nothing, TypeId (Short "list"), "::"), cons_tag);
                 ((Nothing, TypeId (Short "list"), "nil"), nil_tag)],
   Map.fromList [(div_tag, (Nothing, TypeExn Nothing, "Div")); 
                 (bind_tag, (Nothing, TypeExn Nothing, "Bind")); 
                 (eq_tag, (Nothing, TypeExn Nothing, "Eq")); 
                 (cons_tag, (Nothing, TypeId (Short "list"), "::"));
                 (nil_tag, (Nothing, TypeId (Short "list"), "nil"))])



