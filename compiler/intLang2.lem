(* The second intermediate language (IL2). Removes named datatype constructors.
 *
 * The AST of IL2 differs from IL1 by using numbered tags instead of
 * constructor name identifiers for all data constructor patterns and
 * expressions. Also type and exception declarations are removed.
 *
 * The values of IL2 differ in that the closures do not contain a constructor
 * name environment.
 *
 * The semantics of IL2 differ in that there is no constructor name
 * environment.
 *
 * The translator to IL2 keeps a mapping of constructors to their tags. The
 * tuple constructor is always 0. Div, Bind, and Eq are always 1, 2, and 3.
 * Cond and nil are always 4 and 5. It also keeps a reverse mapping for use by
 * the REPL printer.
 *
 * The expressions include the unary operation for initialising the global
 * store, even though it can't be used until IL3. However, including it here
 * means that the IL2->IL3 translation can just be (\x.x). Also includes the
 * expression for extending the global store
 *
 *)

open import Pervasives
open import Lib
open import Ast
open import SemanticPrimitives
open import List_extra
open import BigStep
open import IntLang1

val tuple_tag : nat
let tuple_tag = 0

val div_tag : nat
let div_tag = 1

val bind_tag : nat
let bind_tag = 2

val eq_tag : nat
let eq_tag = 3

val cons_tag : nat
let cons_tag = 4

val nil_tag : nat
let nil_tag = 5

type uop_i2 = 
  | Opderef_i2
  | Opref_i2
  | Init_global_var_i2 of nat

type pat_i2 =
  | Pvar_i2 of varN
  | Plit_i2 of lit
  | Pcon_i2 of nat * list pat_i2
  | Pref_i2 of pat_i2

type exp_i2 =
  | Raise_i2 of exp_i2
  | Handle_i2 of exp_i2 * list (pat_i2 * exp_i2)
  | Lit_i2 of lit
  | Con_i2 of nat * list exp_i2
  | Var_local_i2 of varN
  | Var_global_i2 of nat
  | Fun_i2 of varN * exp_i2
  | Uapp_i2 of uop_i2 * exp_i2
  | App_i2 of op * exp_i2 * exp_i2
  | If_i2 of exp_i2 * exp_i2 * exp_i2
  | Mat_i2 of exp_i2 * list (pat_i2 * exp_i2)
  | Let_i2 of varN * exp_i2 * exp_i2
  | Letrec_i2 of list (varN * varN * exp_i2) * exp_i2
  | Extend_global_i2 of nat

type dec_i2 =
  | Dlet_i2 of nat * exp_i2
  | Dletrec_i2 of list (varN * varN * exp_i2)

type prompt_i2 =
  | Prompt_i2 of list dec_i2

type v_i2 =
  | Litv_i2 of lit
  | Conv_i2 of nat * list v_i2 
  | Closure_i2 of env varN v_i2 * varN * exp_i2
  | Recclosure_i2 of env varN v_i2 * list (varN * varN * exp_i2) * varN
  | Loc_i2 of nat

val pat_bindings_i2 : pat_i2 -> list varN -> list varN
let rec
pat_bindings_i2 (Pvar_i2 n) already_bound =
  n::already_bound
and
pat_bindings_i2 (Plit_i2 l) already_bound =
  already_bound
and
pat_bindings_i2 (Pcon_i2 _ ps) already_bound =
  pats_bindings_i2 ps already_bound
and
pat_bindings_i2 (Pref_i2 p) already_bound =
  pat_bindings_i2 p already_bound
and
pats_bindings_i2 [] already_bound =
  already_bound
and
pats_bindings_i2 (p::ps) already_bound =
  pats_bindings_i2 ps (pat_bindings_i2 p already_bound)

type flat_tag_env = Map.map conN nat
type tag_env = Map.map modN flat_tag_env * flat_tag_env

val lookup_tag_flat : conN -> flat_tag_env -> nat
let lookup_tag_flat cn ftagenv =
  match Map.lookup cn ftagenv with
    | Nothing -> tuple_tag
    | Just n -> n
  end

val lookup_tag_env : maybe (id conN) -> tag_env -> nat
let lookup_tag_env id (mtagenv,tagenv) =
  match id with
    | Nothing -> tuple_tag
    | Just (Short x) -> lookup_tag_flat x tagenv
    | Just (Long x y) ->
        match Map.lookup x mtagenv with
          | Nothing -> tuple_tag
          | Just tagenv -> lookup_tag_flat y tagenv
        end
  end

val pat_to_i2 : tag_env -> pat -> pat_i2
let rec
pat_to_i2 tagenv (Pvar x) = Pvar_i2 x
and 
pat_to_i2 tagenv (Plit l) = Plit_i2 l
and 
pat_to_i2 tagenv (Pcon con_id ps) = 
  Pcon_i2 (lookup_tag_env con_id tagenv) (List.map (pat_to_i2 tagenv) ps)
and 
pat_to_i2 tagenv (Pref p) = Pref_i2 (pat_to_i2 tagenv p)

val uop_to_i2 : uop -> uop_i2
let uop_to_i2 uop = 
  match uop with
    | Opderef -> Opderef_i2
    | Opref -> Opref_i2
  end

val exp_to_i2 : tag_env -> exp_i1 -> exp_i2
val exps_to_i2 : tag_env -> list exp_i1 -> list exp_i2
val pat_exp_to_i2 : tag_env -> list (pat * exp_i1) -> list (pat_i2 * exp_i2)
val funs_to_i2 : tag_env -> list (varN * varN * exp_i1) -> list (varN * varN * exp_i2)
let rec 
exp_to_i2 tagenv (Raise_i1 e) = 
  Raise_i2 (exp_to_i2 tagenv e)
and
exp_to_i2 tagenv (Handle_i1 e pes) = 
  Handle_i2 (exp_to_i2 tagenv e) (pat_exp_to_i2 tagenv pes)
and
exp_to_i2 tagenv (Lit_i1 l) = 
  Lit_i2 l 
and
exp_to_i2 tagenv (Con_i1 cn es) = 
  Con_i2 (lookup_tag_env cn tagenv) (exps_to_i2 tagenv es)
and
exp_to_i2 tagenv (Var_local_i1 x) = Var_local_i2 x
and
exp_to_i2 tagenv (Var_global_i1 x) = Var_global_i2 x
and
exp_to_i2 tagenv (Fun_i1 x e) =
  Fun_i2 x (exp_to_i2 tagenv e) 
and
exp_to_i2 tagenv (Uapp_i1 uop e) =
  Uapp_i2 (uop_to_i2 uop) (exp_to_i2 tagenv e)
and
exp_to_i2 tagenv (App_i1 op e1 e2) =
  App_i2 op (exp_to_i2 tagenv e1) (exp_to_i2 tagenv e2)
and
exp_to_i2 tagenv (If_i1 e1 e2 e3) =
  If_i2 (exp_to_i2 tagenv e1) (exp_to_i2 tagenv e2) (exp_to_i2 tagenv e3)
and
exp_to_i2 tagenv (Mat_i1 e pes) =
  Mat_i2 (exp_to_i2 tagenv e) (pat_exp_to_i2 tagenv pes)
and
exp_to_i2 tagenv (Let_i1 x e1 e2) =
  Let_i2 x (exp_to_i2 tagenv e1) (exp_to_i2 tagenv e2)
and
exp_to_i2 tagenv (Letrec_i1 funs e) =
  Letrec_i2 (funs_to_i2 tagenv funs) 
            (exp_to_i2 tagenv e)
and
exps_to_i2 tagenv [] = []
and
exps_to_i2 tagenv (e::es) =
  exp_to_i2 tagenv e :: exps_to_i2 tagenv es
and
pat_exp_to_i2 tagenv [] = []
and
pat_exp_to_i2 tagenv ((p,e)::pes) =
  (pat_to_i2 tagenv p, exp_to_i2 tagenv e) :: pat_exp_to_i2 tagenv pes
and
funs_to_i2 tagenv [] = []
and
funs_to_i2 tagenv ((f,x,e)::funs) =
  (f,x,exp_to_i2 tagenv e) :: funs_to_i2 tagenv funs

(* The constructor names that are in scope, the global mapping of constructor
 * names (with types so that they are unique), and its inverse. *)
type tagenv_state = nat * tag_env * map nat (conN * tid_or_exn) * list (conN * nat)

let get_tagenv (next,tagenv,inv,acc) = tagenv

val insert_tag_env : conN -> nat -> tag_env -> tag_env
let insert_tag_env cn tag (mtagenv,ftagenv) =
  (mtagenv,Map.insert cn tag ftagenv)

val alloc_tag : tid_or_exn -> conN -> tagenv_state -> tagenv_state
let alloc_tag tn cn (next,tagenv,inv,acc) =
  (next+1,insert_tag_env cn next tagenv, Map.insert next (cn,tn) inv, (cn,next)::acc)

val alloc_tags : maybe modN -> tagenv_state -> type_def -> tagenv_state
let rec 
alloc_tags mn st [] = st
and
alloc_tags mn st ((tvs,tn,constrs)::types) = 
  let st' =
    List.foldl (fun st' (cn,ts) -> alloc_tag (TypeId (mk_id mn tn)) cn st') st constrs
  in
    alloc_tags mn st' types

declare termination_argument alloc_tags = automatic

val decs_to_i2 : tagenv_state -> list dec_i1 -> tagenv_state * list dec_i2
let rec 
decs_to_i2 st [] = (st,[])
and
decs_to_i2 st (d::ds) =
  match d with
    | Dlet_i1 n e -> 
        let (st', ds') = decs_to_i2 st ds in
          (st', Dlet_i2 n (exp_to_i2 (get_tagenv st) e)::ds')
    | Dletrec_i1 funs ->
        let (st', ds') = decs_to_i2 st ds in
          (st', Dletrec_i2 (funs_to_i2 (get_tagenv st) funs)::ds')
    | Dtype_i1 mn type_def ->
        decs_to_i2 (alloc_tags mn st type_def) ds
    | Dexn_i1 mn cn ts ->
        decs_to_i2 (alloc_tag (TypeExn (mk_id mn cn)) cn st) ds
  end

declare termination_argument decs_to_i2 = automatic

val mod_tagenv : maybe modN -> list (conN * nat) -> tag_env -> tag_env
let mod_tagenv mn l (mtagenv,tagenv) =
  match mn with
    | Nothing -> (mtagenv,List.foldl (fun env (k,v) -> Map.insert k v env) tagenv l)
    | Just mn -> (Map.insert mn (Map.fromList l) mtagenv,tagenv)
  end

val prompt_to_i2 : (nat * tag_env * map nat (conN * tid_or_exn)) -> prompt_i1 -> (nat * tag_env * map nat (conN * tid_or_exn)) * prompt_i2
let prompt_to_i2 (next,tagenv,inv) prompt =
  match prompt with
    | Prompt_i1 mn ds ->
        let ((next',tagenv',inv',acc'), ds') = decs_to_i2 (next,tagenv,inv,[]) ds in
          ((next',mod_tagenv mn acc' tagenv',inv'), Prompt_i2 ds')
  end

val prog_to_i2 : (nat * tag_env * map nat (conN * tid_or_exn)) -> list prompt_i1 -> (nat * tag_env * map nat (conN * tid_or_exn)) * list prompt_i2
let rec 
prog_to_i2 st [] = (st, [])
and 
prog_to_i2 st (p::ps) = 
  let (st',p') = prompt_to_i2 st p in
  let (st'',ps') = prog_to_i2 st' ps in
    (st'',p'::ps')

declare termination_argument prog_to_i2 = automatic

val do_uapp_i2 : store v_i2 -> uop_i2 -> v_i2 -> maybe (store v_i2 * v_i2)
let do_uapp_i2 s uop v =
  match uop with
    | Opderef_i2 ->
        match v with
          | Loc_i2 n ->
              match store_lookup n s with
                | Just v -> Just (s,v)
                | Nothing -> Nothing
              end
          | _ -> Nothing
        end
    | Opref_i2 ->
        let (s',n) = store_alloc v s in
          Just (s', Loc_i2 n)
    | Init_global_var_i2 idx -> Nothing
  end

val build_rec_env_i2 : list (varN * varN * exp_i2) -> env varN v_i2 -> env varN v_i2 -> env varN v_i2
let build_rec_env_i2 funs cl_env add_to_env =
  foldr 
    (fun (f,x,e) env' -> bind f (Recclosure_i2 cl_env funs f) env') 
    add_to_env 
    funs

val do_eq_i2 : v_i2 -> v_i2 -> eq_result
let rec 
do_eq_i2 (Litv_i2 l1) (Litv_i2 l2) = 
  Eq_val (l1 = l2)
and
do_eq_i2 (Loc_i2 l1) (Loc_i2 l2) = Eq_val (l1 = l2)
and
do_eq_i2 (Conv_i2 tag1 vs1) (Conv_i2 tag2 vs2) =
  if tag1 = tag2 && (List.length vs1 = List.length vs2) then
    do_eq_list_i2 vs1 vs2
  else
    Eq_val false
and
do_eq_i2 (Closure_i2 _ _ _) (Closure_i2 _ _ _) = Eq_closure
and
do_eq_i2 (Closure_i2 _ _ _) (Recclosure_i2 _ _ _) = Eq_closure
and
do_eq_i2 (Recclosure_i2 _ _ _) (Closure_i2 _ _ _) = Eq_closure
and
do_eq_i2 (Recclosure_i2 _ _ _) (Recclosure_i2 _ _ _) = Eq_closure
and
do_eq_i2 _ _ = Eq_type_error
and
do_eq_list_i2 [] [] = Eq_val true
and
do_eq_list_i2 (v1::vs1) (v2::vs2) = 
  match do_eq_i2 v1 v2 with
    | Eq_closure -> Eq_closure
    | Eq_type_error -> Eq_type_error
    | Eq_val r -> 
        if not r then
          Eq_val false
        else
          do_eq_list_i2 vs1 vs2
  end
and
do_eq_list_i2 _ _ = Eq_val false

type all_env_i2 = (list (maybe v_i2) * env varN v_i2)

let all_env_i2_to_genv (genv,env) = genv
let all_env_i2_to_env (genv,env) = env

val exn_env_i2 : env varN v_i2
let exn_env_i2 = emp

val do_app_i2 : env varN v_i2 -> store v_i2 -> op -> v_i2 -> v_i2 -> maybe (env varN v_i2 * store v_i2 * exp_i2)
let do_app_i2 env' s op v1 v2 =
  match (op, v1, v2) with
    | (Opapp, Closure_i2 env n e, v) ->
        Just (bind n v env, s, e)
    | (Opapp, Recclosure_i2 env funs n, v) ->
        match find_recfun n funs with
          | Just (n,e) -> Just (bind n v (build_rec_env_i2 funs env env), s, e)
          | Nothing -> Nothing
        end
    | (Opn op, Litv_i2 (IntLit n1), Litv_i2 (IntLit n2)) ->
        if (op = Divide || (op = Modulo)) && (n2 = 0) then
          Just (exn_env_i2, s, Raise_i2 (Con_i2 div_tag []))
        else
          Just (env', s, Lit_i2 (IntLit (opn_lookup op n1 n2)))
    | (Opb op, Litv_i2 (IntLit n1), Litv_i2 (IntLit n2)) ->
        Just (env', s, Lit_i2 (Bool (opb_lookup op n1 n2)))
    | (Equality, v1, v2) ->
        match do_eq_i2 v1 v2 with
          | Eq_type_error -> Nothing
          | Eq_closure -> Just (exn_env_i2, s, Raise_i2 (Con_i2 eq_tag []))
          | Eq_val b -> Just (env', s, Lit_i2 (Bool b))
        end
    | (Opassign, (Loc_i2 lnum), v) ->
        match store_assign lnum v s with
        | Just st -> Just (env', st, Lit_i2 Unit)
        | Nothing -> Nothing
        end
    | _ -> Nothing
  end

val do_if_i2 : v_i2 -> exp_i2 -> exp_i2 -> maybe exp_i2
let do_if_i2 v e1 e2 =
  if v = Litv_i2 (Bool true) then
    Just e1
  else if v = Litv_i2 (Bool false) then
    Just e2
  else
    Nothing

val pmatch_i2 : store v_i2 -> pat_i2 -> v_i2 -> env varN v_i2 -> match_result (env varN v_i2)
let rec
pmatch_i2 s (Pvar_i2 x) v' env = Match (bind x v' env)
and
pmatch_i2 s (Plit_i2 l) (Litv_i2 l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error
and
pmatch_i2 s (Pcon_i2 tag1 ps) (Conv_i2 tag2 vs) env =
  if tag1 = tag2 then
    if List.length ps = List.length vs then
      pmatch_list_i2 s ps vs env
    else 
      Match_type_error
  else
    No_match
and
pmatch_i2 s (Pref_i2 p) (Loc_i2 lnum) env =
  match store_lookup lnum s with
    | Just v -> pmatch_i2 s p v env
    | Nothing -> Match_type_error
  end
and
pmatch_i2 _ _ _ env = Match_type_error
and
pmatch_list_i2 s [] [] env = Match env
and
pmatch_list_i2 s (p::ps) (v::vs) env =
  match pmatch_i2 s p v env with
    | No_match -> No_match
    | Match_type_error -> Match_type_error
    | Match env' -> pmatch_list_i2 s ps vs env'
  end
and
pmatch_list_i2 s _ _ env = Match_type_error

indreln [evaluate_i2 : bool -> all_env_i2 -> count_store v_i2 -> exp_i2 -> count_store v_i2 * result v_i2 v_i2 -> bool]
and [evaluate_list_i2 : bool -> all_env_i2 -> count_store v_i2 -> list exp_i2 -> count_store v_i2 * result (list v_i2) v_i2 -> bool]
and [evaluate_match_i2 : bool -> all_env_i2 -> count_store v_i2 -> v_i2 -> list (pat_i2 * exp_i2) -> v_i2 -> count_store v_i2 * result v_i2 v_i2 -> bool]

lit : forall ck env l s.
true
==>
evaluate_i2 ck env s (Lit_i2 l) (s, Rval (Litv_i2 l))

and

raise1 : forall ck env e s1 s2 v.
evaluate_i2 ck s1 env e (s2, Rval v)
==>
evaluate_i2 ck s1 env (Raise_i2 e) (s2, Rerr (Rraise v))

and

raise2 : forall ck env e s1 s2 err.
evaluate_i2 ck s1 env e (s2, Rerr err)
==>
evaluate_i2 ck s1 env (Raise_i2 e) (s2, Rerr err)

and

handle1 : forall ck s1 s2 env e v pes.
evaluate_i2 ck s1 env e (s2, Rval v)
==>
evaluate_i2 ck s1 env (Handle_i2 e pes) (s2, Rval v)

and

handle2 : forall ck s1 s2 env e pes v bv.
evaluate_i2 ck env s1 e (s2, Rerr (Rraise v)) &&
evaluate_match_i2 ck env s2 v pes v bv
==>
evaluate_i2 ck env s1 (Handle_i2 e pes) bv

and

handle3 : forall ck s1 s2 env e pes err.
evaluate_i2 ck env s1 e (s2, Rerr err) &&
(err = Rtimeout_error || (err = Rtype_error))
==>
evaluate_i2 ck env s1 (Handle_i2 e pes) (s2, Rerr err)

and

con1 : forall ck env tag es vs s s'.
evaluate_list_i2 ck env s es (s', Rval vs)
==>
evaluate_i2 ck env s (Con_i2 tag es) (s', Rval (Conv_i2 tag vs))

and

con3 : forall ck env tag es err s s'.
evaluate_list_i2 ck env s es (s', Rerr err)
==>
evaluate_i2 ck env s (Con_i2 tag es) (s', Rerr err)

and

var1 : forall ck env n v s.
(lookup n (all_env_i2_to_env env) = Just v)
==>
evaluate_i2 ck env s (Var_local_i2 n) (s, Rval v)

and

var2 : forall ck env n s.
(lookup n (all_env_i2_to_env env) = Nothing)
==>
evaluate_i2 ck env s (Var_local_i2 n) (s, Rerr Rtype_error)

and

var3 : forall ck env n v s.
(List.length (all_env_i2_to_genv env) > n) &&
(List_extra.nth (all_env_i2_to_genv env) n = Just v)
==>
evaluate_i2 ck env s (Var_global_i2 n) (s, Rval v)

and

var4 : forall ck env n s.
(List.length (all_env_i2_to_genv env) > n) &&
(List_extra.nth (all_env_i2_to_genv env) n = Nothing)
==>
evaluate_i2 ck env s (Var_global_i2 n) (s, Rerr Rtype_error)

and

var5 : forall ck env n s.
not (List.length (all_env_i2_to_genv env) > n)
==>
evaluate_i2 ck env s (Var_global_i2 n) (s, Rerr Rtype_error)

and

fn : forall ck env n e s.
true
==>
evaluate_i2 ck env s (Fun_i2 n e) (s, Rval (Closure_i2 (all_env_i2_to_env env) n e))

and

uapp1 : forall ck env uop e v v' s1 s2 count s3.
evaluate_i2 ck env s1 e ((count,s2), Rval v) &&
(do_uapp_i2 s2 uop v = Just (s3,v'))
==>
evaluate_i2 ck env s1 (Uapp_i2 uop e) ((count,s3), Rval v')

and

uapp2 : forall ck env uop e v s1 s2 count.
evaluate_i2 ck env s1 e ((count,s2), Rval v) &&
(do_uapp_i2 s2 uop v = Nothing)
==>
evaluate_i2 ck env s1 (Uapp_i2 uop e) ((count,s2), Rerr Rtype_error)

and

uapp3 : forall ck env uop e err s s'.
evaluate_i2 ck env s e (s', Rerr err)
==>
evaluate_i2 ck env s (Uapp_i2 uop e) (s', Rerr err)

and

app1 : forall ck genv env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 count s4.
evaluate_i2 ck (genv,env) s1 e1 (s2, Rval v1) &&
evaluate_i2 ck (genv,env) s2 e2 ((count,s3), Rval v2) &&
do_app_i2 env s3 op v1 v2 = Just (env', s4, e3) &&
((ck && (op = Opapp)) --> count <> 0) &&
evaluate_i2 ck (genv,env') ((if ck then dec_count op count else count),s4) e3 bv
==>
evaluate_i2 ck (genv,env) s1 (App_i2 op e1 e2) bv

and

app2 : forall ck genv env op e1 e2 v1 v2 env' e3 s1 s2 s3 count s4.
evaluate_i2 ck (genv,env) s1 e1 (s2, Rval v1) &&
evaluate_i2 ck (genv,env) s2 e2 ((count,s3), Rval v2) &&
do_app_i2 env s3 op v1 v2 = Just (env', s4, e3) &&
count = 0 &&
op = Opapp &&
ck
==>
evaluate_i2 ck (genv,env) s1 (App_i2 op e1 e2) ((0,s4), Rerr Rtimeout_error)

and

app3 : forall ck genv env op e1 e2 v1 v2 s1 s2 s3 count.
evaluate_i2 ck (genv,env) s1 e1 (s2, Rval v1) &&
evaluate_i2 ck (genv,env) s2 e2 ((count,s3), Rval v2) &&
do_app_i2 env s3 op v1 v2 = Nothing
==>
evaluate_i2 ck (genv,env) s1 (App_i2 op e1 e2) ((count,s3), Rerr Rtype_error)

and

app4 : forall ck env op e1 e2 v1 err s1 s2 s3.
evaluate_i2 ck env s1 e1 (s2, Rval v1) &&
evaluate_i2 ck env s2 e2 (s3, Rerr err)
==>
evaluate_i2 ck env s1 (App_i2 op e1 e2) (s3, Rerr err)

and

app5 : forall ck env op e1 e2 err s s'.
evaluate_i2 ck env s e1 (s', Rerr err)
==>
evaluate_i2 ck env s (App_i2 op e1 e2) (s', Rerr err)

and

if1 : forall ck env e1 e2 e3 v e' bv s1 s2.
evaluate_i2 ck env s1 e1 (s2, Rval v) &&
do_if_i2 v e2 e3 = Just e' &&
evaluate_i2 ck env s2 e' bv
==>
evaluate_i2 ck env s1 (If_i2 e1 e2 e3) bv

and

if2 : forall ck env e1 e2 e3 v s1 s2.
evaluate_i2 ck env s1 e1 (s2, Rval v) &&
do_if_i2 v e2 e3 = Nothing
==>
evaluate_i2 ck env s1 (If_i2 e1 e2 e3) (s2, Rerr Rtype_error)

and

if3 : forall ck env e1 e2 e3 err s s'.
evaluate_i2 ck env s e1 (s', Rerr err)
==>
evaluate_i2 ck env s (If_i2 e1 e2 e3) (s', Rerr err)

and

mat1 : forall ck env e pes v bv s1 s2.
evaluate_i2 ck env s1 e (s2, Rval v) &&
evaluate_match_i2 ck env s2 v pes (Conv_i2 bind_tag []) bv
==>
evaluate_i2 ck env s1 (Mat_i2 e pes) bv

and

mat2 : forall ck env e pes err s s'.
evaluate_i2 ck env s e (s', Rerr err)
==>
evaluate_i2 ck env s (Mat_i2 e pes) (s', Rerr err)

and

let1 : forall ck genv env n e1 e2 v bv s1 s2.
evaluate_i2 ck (genv,env) s1 e1 (s2, Rval v) &&
evaluate_i2 ck (genv,bind n v env) s2 e2 bv
==>
evaluate_i2 ck (genv,env) s1 (Let_i2 n e1 e2) bv

and

let2 : forall ck env n e1 e2 err s s'.
evaluate_i2 ck env s e1 (s', Rerr err)
==>
evaluate_i2 ck env s (Let_i2 n e1 e2) (s', Rerr err)

and

letrec1 : forall ck genv env funs e bv s.
List.allDistinct (List.map (fun (x,y,z) -> x) funs) &&
evaluate_i2 ck (genv,build_rec_env_i2 funs env env) s e bv
==>
evaluate_i2 ck (genv,env) s (Letrec_i2 funs e) bv

and

letrec2 : forall ck env funs e s.
not (List.allDistinct (List.map (fun (x,y,z) -> x) funs))
==>
evaluate_i2 ck env s (Letrec_i2 funs e) (s, Rerr Rtype_error)

and

extend : forall ck env n s.
true
==>
evaluate_i2 ck env s (Extend_global_i2 n) (s, Rerr Rtype_error)

and

empty : forall ck env s.
true
==>
evaluate_list_i2 ck env s [] (s, Rval [])

and

cons1 : forall ck env e es v vs s1 s2 s3.
evaluate_i2 ck env s1 e (s2, Rval v) &&
evaluate_list_i2 ck env s2 es (s3, Rval vs)
==>
evaluate_list_i2 ck env s1 (e::es) (s3, Rval (v::vs))

and

cons2 : forall ck env e es err s s'.
evaluate_i2 ck env s e (s', Rerr err)
==>
evaluate_list_i2 ck env s (e::es) (s', Rerr err)

and

cons3 : forall ck env e es v err s1 s2 s3.
evaluate_i2 ck env s1 e (s2, Rval v) &&
evaluate_list_i2 ck env s2 es (s3, Rerr err)
==>
evaluate_list_i2 ck env s1 (e::es) (s3, Rerr err)

and

mat_empty : forall ck env v err_v s.
true
==>
evaluate_match_i2 ck env s v [] err_v (s, Rerr (Rraise err_v))

and

mat_cons1 : forall ck genv env env' v p pes e bv err_v s count.
List.allDistinct (pat_bindings_i2 p []) &&
(pmatch_i2 s p v env = Match env') &&
evaluate_i2 ck (genv,env') (count,s) e bv
==>
evaluate_match_i2 ck (genv,env) (count,s) v ((p,e)::pes) err_v bv

and

mat_cons2 : forall ck genv env v p e pes bv s count err_v.
List.allDistinct (pat_bindings_i2 p []) &&
(pmatch_i2 s p v env = No_match) &&
evaluate_match_i2 ck (genv,env) (count,s) v pes err_v bv
==>
evaluate_match_i2 ck (genv,env) (count,s) v ((p,e)::pes) err_v bv

and

mat_cons3 : forall ck genv env v p e pes s count err_v.
(pmatch_i2 s p v env = Match_type_error)
==>
evaluate_match_i2 ck (genv,env) (count,s) v ((p,e)::pes) err_v ((count,s), Rerr Rtype_error)

and

mat_cons4 : forall ck env v p e pes s err_v.
not (List.allDistinct (pat_bindings_i2 p []))
==>
evaluate_match_i2 ck env s v ((p,e)::pes) err_v (s, Rerr Rtype_error)

indreln [evaluate_dec_i2 : list (maybe v_i2) -> store v_i2 -> dec_i2 -> store v_i2 * result (list v_i2) v_i2 -> bool]

dlet1 : forall genv n e vs s1 s2 count.
evaluate_i2 false (genv,emp) (0,s1) e ((count,s2), Rval (Conv_i2 tuple_tag vs)) &&
List.length vs = n
==>
evaluate_dec_i2 genv s1 (Dlet_i2 n e) (s2, Rval vs)

and

dlet3 : forall genv n e vs s1 s2 count.
evaluate_i2 false (genv,emp) (0,s1) e ((count,s2), Rval (Conv_i2 tuple_tag vs)) &&
List.length vs <> n
==>
evaluate_dec_i2 genv s1 (Dlet_i2 n e) (s2, Rerr Rtype_error)

and

dlet4 : forall genv n e v s1 s2 count.
evaluate_i2 false (genv,emp) (0,s1) e ((count,s2), Rval v) &&
not (exists vs. v = Conv_i2 tuple_tag vs)
==>
evaluate_dec_i2 genv s1 (Dlet_i2 n e) (s2, Rerr Rtype_error)

and

dlet5 : forall genv n e err s count s'.
evaluate_i2 false (genv,emp) (0,s) e ((count,s'), Rerr err)
==>
evaluate_dec_i2 genv s (Dlet_i2 n e) (s', Rerr err)

and

dletrec1 : forall genv funs s.
true
==>
evaluate_dec_i2 genv s (Dletrec_i2 funs) (s, Rval (List.map (fun (f,x,e) -> Closure_i2 [] x e) funs))

indreln [evaluate_decs_i2 : list (maybe v_i2) -> store v_i2 -> list dec_i2 -> store v_i2 * list v_i2 * maybe (error_result v_i2) -> bool]

empty : forall genv s.
true
==>
evaluate_decs_i2 genv s [] (s, [], Nothing)

and

cons1 : forall s1 s2 genv d ds e.
evaluate_dec_i2 genv s1 d (s2, Rerr e)
==>
evaluate_decs_i2 genv s1 (d::ds) (s2, [], Just e)

and

cons2 : forall s1 s2 s3 genv d ds new_env new_env' r.
evaluate_dec_i2 genv s1 d (s2, Rval new_env) &&
evaluate_decs_i2 (genv ++ List.map Just new_env) s2 ds (s3, new_env', r)
==>
evaluate_decs_i2 genv s1 (d::ds) (s3, new_env ++ new_env', r)

let rec
dec_to_dummy_env_i2 (Dlet_i2 n e) = n
and
dec_to_dummy_env_i2 (Dletrec_i2 funs) = List.length funs

let rec
decs_to_dummy_env_i2 [] = 0
and
decs_to_dummy_env_i2 (d::ds) = decs_to_dummy_env_i2 ds + dec_to_dummy_env_i2 d

declare termination_argument decs_to_dummy_env_i2 = automatic

indreln [evaluate_prompt_i2 : list (maybe v_i2) -> store v_i2 -> prompt_i2 -> store v_i2 * list v_i2 * maybe (error_result v_i2) -> bool]

prompt_val : forall genv s1 ds s2 env.
evaluate_decs_i2 genv s1 ds (s2,env,Nothing)
==>
evaluate_prompt_i2 genv s1 (Prompt_i2 ds) (s2, env, Nothing)

and

prompt_err1 : forall genv s1 ds s2 env err.
evaluate_decs_i2 genv s1 ds (s2,env,Just err)
==>
evaluate_prompt_i2 genv s1 (Prompt_i2 ds) (s2, 
                                           env ++ List.genlist (fun _ -> Litv_i2 Unit) (decs_to_dummy_env_i2 ds - List.length env),
                                           Just err)

indreln [evaluate_prog_i2 : list (maybe v_i2) -> store v_i2 -> list prompt_i2 -> store v_i2 * list v_i2 * maybe (error_result v_i2) -> bool]

prog_empty : forall genv s.
true
==>
evaluate_prog_i2 genv s [] (s, [], Nothing)

and

prog_cons_var : forall genv s1 prompt prompts s2 env2 s3 env3 r.
evaluate_prompt_i2 genv s1 prompt (s2, env2, Nothing) &&
evaluate_prog_i2 (genv++List.map Just env2) s2 prompts (s3, env3, r)
==>
evaluate_prog_i2 genv s1 (prompt::prompts) (s3, env2++env3, r)

and

prog_cons_err : forall genv s1 prompt prompts s2 env2 err.
evaluate_prompt_i2 genv s1 prompt (s2, env2, Just err)
==>
evaluate_prog_i2 genv s1 (prompt::prompts) (s2, env2, Just err)

val init_tagenv_state : (nat * tag_env * map nat (conN * tid_or_exn))
let init_tagenv_state =
  (6,
   (Map.empty,
    Map.fromList [("Div", div_tag); 
                  ("Bind", bind_tag); 
                  ("Eq", eq_tag); 
                  ("::", cons_tag);
                  ("nil", nil_tag)]),
   Map.fromList [(div_tag, ("Div", TypeExn (Short "Div"))); 
                 (bind_tag, ("Bind", TypeExn (Short "Bind"))); 
                 (eq_tag, ("Eq", TypeExn (Short "Eq"))); 
                 (cons_tag, ("::", TypeId (Short "list")));
                 (nil_tag, ("nil", TypeId (Short "list")))])



