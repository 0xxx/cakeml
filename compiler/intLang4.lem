(* The fourth intermediate language (IL4). Removes pattern-matching and
 * variable names.
 *
 * The AST of IL4 differs from IL3 in that it uses de Bruijn indices, there are
 * no Mat expressions, Handle expressions are simplified to catch and bind any
 * exception without matching on it, and there are new Tag_eq and El
 * expressions for checking the constructor of a compound value and retrieving
 * its arguments. 
 *
 * The values and semantics of IL4 are the same as IL3, modulo the changes to
 * expressions.
 *
 *)

open import Pervasives
open import SemanticPrimitives
open import Ast
open import BigStep
open import IntLang2
open import IntLang3
open import CompilerLib
(*
open import Lib
open import List_extra
*)

(* TODO: Lem's builtin find index has a different type *)
val find_index : forall 'a. 'a -> list 'a -> nat -> maybe nat
declare hol target_rep function find_index = `misc$find_index` (* to pick up the definition in miscTheory *)

(* TODO: move *)
type store_genv 'a = store 'a * list (maybe 'a)

type uop_i4 =
  | Opderef_i4
  | Opref_i4
  | Init_global_var_i4 of nat
  | Tag_eq_i4 of nat
  | El_i4 of nat

type exp_i4 =
  | Raise_i4 of exp_i4
  | Handle_i4 of exp_i4 * exp_i4
  | Lit_i4 of lit
  | Con_i4 of nat * list exp_i4
  | Var_local_i4 of nat
  | Var_global_i4 of nat
  | Fun_i4 of exp_i4
  | Uapp_i4 of uop_i4 * exp_i4
  | App_i4 of op * exp_i4 * exp_i4
  | If_i4 of exp_i4 * exp_i4 * exp_i4
  | Let_i4 of exp_i4 * exp_i4
  | Letrec_i4 of list exp_i4 * exp_i4
  | Extend_global_i4 of nat

type v_i4 =
  | Litv_i4 of lit
  | Conv_i4 of nat * list v_i4
  | Closure_i4 of list v_i4 * exp_i4
  | Recclosure_i4 of list v_i4 * list exp_i4 * nat
  | Loc_i4 of nat

val uop_to_i4 : uop_i2 -> uop_i4
let rec
uop_to_i4 Opderef_i2 = Opderef_i4
and
uop_to_i4 Opref_i2 = Opref_i4
and
uop_to_i4 (Init_global_var_i2 n) = Init_global_var_i4 n

val sIf_i4 : exp_i4 -> exp_i4 -> exp_i4 -> exp_i4
let
sIf_i4 e1 e2 e3 =
  if e2 = Lit_i4 (Bool true) && e3 = Lit_i4 (Bool false) then e1 else
  match e1 with
  | Lit_i4 (Bool b) -> if b then e2 else e3
  | _ -> If_i4 e1 e2 e3
  end

val pure_uop_i4 : uop_i4 -> bool
let rec
pure_uop_i4 Opderef_i4 = true
and
pure_uop_i4 Opref_i4 = false
and
pure_uop_i4 (Init_global_var_i4 _) = false
and
pure_uop_i4 (Tag_eq_i4 _) = true
and
pure_uop_i4 (El_i4 _) = true

val pure_op : op -> bool
let rec
pure_op (Opn opn) = opn <> Divide && opn <> Modulo
and
pure_op (Opb _) = true
and
pure_op Equality = true
and
pure_op Opapp = false
and
pure_op Opassign = false

val pure_i4 : exp_i4 -> bool
let rec
pure_i4 (Raise_i4 _) = false
and
pure_i4 (Handle_i4 e1 _) = pure_i4 e1
and
pure_i4 (Lit_i4 _) = true
and
pure_i4 (Con_i4 _ es) = pure_list_i4 es
and
pure_i4 (Var_local_i4 _) = true
and
pure_i4 (Var_global_i4 _) = true
and
pure_i4 (Fun_i4 _) = true
and
pure_i4 (Uapp_i4 uop e) = pure_uop_i4 uop && pure_i4 e
and
pure_i4 (App_i4 op e1 e2) = pure_op op && pure_i4 e1 && pure_i4 e2
and
pure_i4 (If_i4 e1 e2 e3) = pure_i4 e1 && pure_i4 e2 && pure_i4 e3
and
pure_i4 (Let_i4 e1 e2) = pure_i4 e1 && pure_i4 e2
and
pure_i4 (Letrec_i4 _ e) = pure_i4 e
and
pure_i4 (Extend_global_i4 _) = false
and
pure_list_i4 [] = true
and
pure_list_i4 (e::es) = pure_i4 e && pure_list_i4 es
declare termination_argument pure_i4 = automatic
declare termination_argument pure_list_i4 = automatic

val ground_i4 : nat -> exp_i4 -> bool
let rec
ground_i4 n (Raise_i4 e) = ground_i4 n e
and
ground_i4 n (Handle_i4 e1 e2) = ground_i4 n e1 && ground_i4 (n+1) e2
and
ground_i4 _ (Lit_i4 _) = true
and
ground_i4 n (Con_i4 _ es) = ground_list_i4 n es
and
ground_i4 n (Var_local_i4 k) = k < n
and
ground_i4 _ (Var_global_i4 _) = true
and
ground_i4 n (Fun_i4 e) = ground_i4 (n+1) e
and
ground_i4 n (Uapp_i4 _ e) = ground_i4 n e
and
ground_i4 n (App_i4 _ e1 e2) = ground_i4 n e1 && ground_i4 n e2
and
ground_i4 n (If_i4 e1 e2 e3) = ground_i4 n e1 && ground_i4 n e2 && ground_i4 n e3
and
ground_i4 n (Let_i4 e1 e2) = ground_i4 n e1 && ground_i4 (n+1) e2
and
ground_i4 n (Letrec_i4 es e) = ground_list_i4 (n+List.length es+1) es && ground_i4 (n+List.length es) e
and
ground_i4 _ (Extend_global_i4 _) = true
and
ground_list_i4 _ [] = true
and
ground_list_i4 n (e::es) = ground_i4 n e && ground_list_i4 n es
declare termination_argument ground_i4 = automatic
declare termination_argument ground_list_i4 = automatic

val sLet_i4 : exp_i4 -> exp_i4 -> exp_i4
let rec
sLet_i4 e1 (Var_local_i4 0) = e1
and
sLet_i4 e1 e2 =
  if pure_i4 e1 && ground_i4 0 e2
  then e2
  else Let_i4 e1 e2

(* bind elements 0..k of the variable n in reverse order above e (first element
 * becomes most recently bound) *)
val Let_Els_i4 : nat -> nat -> exp_i4 -> exp_i4
let rec
Let_Els_i4 _ 0 e = e
and
Let_Els_i4 n k e =
  sLet_i4 (Uapp_i4 (El_i4 (k-1)) (Var_local_i4 n))
     (Let_Els_i4 (n+1) (k-1) e)

(* return an expression that evaluates to whether the pattern matches the most
 * recently bound variable *)
val pat_to_i4 : pat_i2 -> exp_i4
(* return an expression that evaluates to whether all the m patterns match the
 * m most recently bound variables; n counts 0..m *)
val pats_to_i4 : nat -> list pat_i2 -> exp_i4
let rec
pat_to_i4 (Pvar_i2 _) = Lit_i4 (Bool true)
and
pat_to_i4 (Plit_i2 l) = App_i4 Equality (Var_local_i4 0) (Lit_i4 l)
and
pat_to_i4 (Pcon_i2 tag []) =
  App_i4 Equality (Var_local_i4 0) (Con_i4 tag [])
and
pat_to_i4 (Pcon_i2 tag ps) =
  sIf_i4 (Uapp_i4 (Tag_eq_i4 tag) (Var_local_i4 0))
    (Let_Els_i4 0 (List.length ps) (pats_to_i4 0 ps))
    (Lit_i4 (Bool false))
and
pat_to_i4 (Pref_i2 p) =
  sLet_i4 (Uapp_i4 Opderef_i4 (Var_local_i4 0))
    (pat_to_i4 p)
and
pats_to_i4 _ [] = Lit_i4 (Bool true)
and
pats_to_i4 n (p::ps) =
  sIf_i4 (sLet_i4 (Var_local_i4 n) (pat_to_i4 p))
    (pats_to_i4 (n+1) ps)
    (Lit_i4 (Bool false))

(* given a pattern in a context of bound variables where the most recently
 * bound variable is the value to be matched, return a function that binds new
 * variables (including all the pattern variables) over an expression and the
 * new context of bound variables for the expression as well as the number of
 * newly bound variables *)
val row_to_i4 : list (maybe varN) -> pat_i2 -> list (maybe varN) * nat * (exp_i4 -> exp_i4)
val cols_to_i4 : list (maybe varN) -> nat -> nat -> list pat_i2 -> list (maybe varN) * nat * (exp_i4 -> exp_i4)
let rec
row_to_i4 (Nothing::bvs) (Pvar_i2 x) = (Just x::bvs, 0, fun e -> e)
and
row_to_i4 bvs (Plit_i2 _) = (bvs, 0, fun e -> e)
and
row_to_i4 bvs (Pcon_i2 _ ps) = cols_to_i4 bvs 0 0 ps
and
row_to_i4 bvs (Pref_i2 p) =
  let (bvs,m,f) = row_to_i4 (Nothing::bvs) p in
    (bvs, 1+m, fun e -> sLet_i4 (Uapp_i4 Opderef_i4 (Var_local_i4 0)) (f e))
and
row_to_i4 _ _ = ([], 0, fun e -> e) (* should not happen *)
and
cols_to_i4 bvs _ _ [] = (bvs, 0, fun e -> e)
and
cols_to_i4 bvs n k (p::ps) =
  let (bvs,m,f) = row_to_i4 (Nothing::bvs) p in
  let (bvs,ms,fs) = cols_to_i4 bvs (n+1+m) (k+1) ps in
    (bvs, 1+m+ms,
       fun e ->
           sLet_i4 (Uapp_i4 (El_i4 k) (Var_local_i4 n))
             (f (fs e)))

(* translate to i4 under a context of bound variables *)
val exp_to_i4 : list (maybe varN) -> exp_i2 -> exp_i4
val exps_to_i4 : list (maybe varN) -> list exp_i2 -> list exp_i4
val funs_to_i4 : list (maybe varN) -> list (varN * varN * exp_i2) -> list exp_i4
(* assumes the value being matched is most recently bound *)
val pes_to_i4 : list (maybe varN) -> list (pat_i2 * exp_i2) -> exp_i4
let rec
exp_to_i4 bvs (Raise_i2 e) = Raise_i4 (exp_to_i4 bvs e)
and
exp_to_i4 bvs (Handle_i2 e1 pes) =
  Handle_i4 (exp_to_i4 bvs e1) (pes_to_i4 (Nothing::bvs) pes)
and
exp_to_i4 _ (Lit_i2 l) = Lit_i4 l
and
exp_to_i4 bvs (Con_i2 tag es) = Con_i4 tag (exps_to_i4 bvs es)
and
exp_to_i4 bvs (Var_local_i2 x) = Var_local_i4 (the 0 (find_index (Just x) bvs 0))
and
exp_to_i4 _ (Var_global_i2 n) = Var_global_i4 n
and
exp_to_i4 bvs (Fun_i2 x e) = Fun_i4 (exp_to_i4 (Just x::bvs) e)
and
exp_to_i4 bvs (Uapp_i2 uop e) = Uapp_i4 (uop_to_i4 uop) (exp_to_i4 bvs e)
and
exp_to_i4 bvs (App_i2 op e1 e2) =
  App_i4 op (exp_to_i4 bvs e1) (exp_to_i4 bvs e2)
and
exp_to_i4 bvs (If_i2 e1 e2 e3) =
  sIf_i4 (exp_to_i4 bvs e1) (exp_to_i4 bvs e2) (exp_to_i4 bvs e3)
and
exp_to_i4 bvs (Mat_i2 e pes) =
  sLet_i4 (exp_to_i4 bvs e) (pes_to_i4 (Nothing::bvs) pes)
and
exp_to_i4 bvs (Let_i2 x e1 e2) =
  sLet_i4 (exp_to_i4 bvs e1) (exp_to_i4 (Just x::bvs) e2)
and
exp_to_i4 bvs (Letrec_i2 funs e) =
  let bvs = (List.map (fun (f,_,_) -> Just f) funs) ++ bvs in
  Letrec_i4 (funs_to_i4 bvs funs) (exp_to_i4 bvs e)
and
exp_to_i4 _ (Extend_global_i2 n) = Extend_global_i4 n
and
exps_to_i4 _ [] = []
and
exps_to_i4 bvs (e::es) =
  exp_to_i4 bvs e :: exps_to_i4 bvs es
and
funs_to_i4 _ [] = []
and
funs_to_i4 bvs ((_,x,e)::funs) =
  exp_to_i4 (Just x::bvs) e :: funs_to_i4 bvs funs
and
pes_to_i4 bvs [(p,e)] =
  let (bvs,_,f) = row_to_i4 bvs p in f (exp_to_i4 bvs e)
and
pes_to_i4 bvs ((p,e)::pes) =
  sIf_i4 (pat_to_i4 p)
    (let (bvs,_,f) = row_to_i4 bvs p in f (exp_to_i4 bvs e))
    (pes_to_i4 bvs pes)
and
pes_to_i4 _ _ = Var_local_i4 0 (* should not happen *)

val do_uapp_i4 : store_genv v_i4 -> uop_i4 -> v_i4 -> maybe (store_genv v_i4 * v_i4)
let do_uapp_i4 (s,genv) uop v =
  match uop with
    | Opderef_i4 ->
        match v with
          | Loc_i4 n ->
              match store_lookup n s with
                | Just v -> Just ((s,genv),v)
                | Nothing -> Nothing
              end
          | _ -> Nothing
        end
    | Opref_i4 ->
        let (s',n) = store_alloc v s in
          Just ((s',genv), Loc_i4 n)
    | Init_global_var_i4 idx ->
        if idx < List.length genv then
          match List_extra.nth genv idx with
            | Nothing -> Just ((s, List.update genv idx (Just v)), Litv_i4 Unit)
            | Just _ -> Nothing
          end
        else
          Nothing
    | Tag_eq_i4 n ->
        match v with
          | Conv_i4 tag _ ->
              Just ((s,genv), Litv_i4 (Bool (tag = n)))
          | _ -> Nothing
        end
    | El_i4 n ->
        match v with
          | Conv_i4 _ vs ->
              if n < List.length vs then
                Just ((s,genv), List_extra.nth vs n)
              else
                Nothing
          | _ -> Nothing
        end
  end

val build_rec_env_i4 : list exp_i4 -> list v_i4 -> list v_i4
let build_rec_env_i4 funs cl_env =
  List.genlist (Recclosure_i4 cl_env funs) (List.length funs)

val exn_env_i4 : list v_i4
let exn_env_i4 = []

val do_eq_i4 : v_i4 -> v_i4 -> eq_result
let rec
do_eq_i4 (Litv_i4 l1) (Litv_i4 l2) =
  Eq_val (l1 = l2)
and
do_eq_i4 (Loc_i4 l1) (Loc_i4 l2) = Eq_val (l1 = l2)
and
do_eq_i4 (Conv_i4 tag1 vs1) (Conv_i4 tag2 vs2) =
  if tag1 = tag2 && (List.length vs1 = List.length vs2) then
    do_eq_list_i4 vs1 vs2
  else
    Eq_val false
and
do_eq_i4 (Closure_i4 _ _) (Closure_i4 _ _) = Eq_closure
and
do_eq_i4 (Closure_i4 _ _) (Recclosure_i4 _ _ _) = Eq_closure
and
do_eq_i4 (Recclosure_i4 _ _ _) (Closure_i4 _ _) = Eq_closure
and
do_eq_i4 (Recclosure_i4 _ _ _) (Recclosure_i4 _ _ _) = Eq_closure
and
do_eq_i4 _ _ = Eq_type_error
and
do_eq_list_i4 [] [] = Eq_val true
and
do_eq_list_i4 (v1::vs1) (v2::vs2) =
  match do_eq_i4 v1 v2 with
    | Eq_closure -> Eq_closure
    | Eq_type_error -> Eq_type_error
    | Eq_val r ->
        if not r then
          Eq_val false
        else
          do_eq_list_i4 vs1 vs2
  end
and
do_eq_list_i4 _ _ = Eq_val false

val do_app_i4 : list v_i4 -> store v_i4 -> op -> v_i4 -> v_i4 -> maybe (list v_i4 * store v_i4 * exp_i4)
let do_app_i4 env' s op v1 v2 =
  match (op, v1, v2) with
    | (Opapp, Closure_i4 env e, v) ->
        Just (v::env, s, e)
    | (Opapp, Recclosure_i4 env funs n, v) ->
        if n < List.length funs then
          Just (v::(build_rec_env_i4 funs env)++env, s, List_extra.nth funs n)
        else
          Nothing
    | (Opn op, Litv_i4 (IntLit n1), Litv_i4 (IntLit n2)) ->
        if (op = Divide || (op = Modulo)) && (n2 = 0) then
          Just (exn_env_i4, s, Raise_i4 (Con_i4 div_tag []))
        else
          Just (env', s, Lit_i4 (IntLit (opn_lookup op n1 n2)))
    | (Opb op, Litv_i4 (IntLit n1), Litv_i4 (IntLit n2)) ->
        Just (env', s, Lit_i4 (Bool (opb_lookup op n1 n2)))
    | (Equality, v1, v2) ->
        match do_eq_i4 v1 v2 with
          | Eq_type_error -> Nothing
          | Eq_closure -> Just (exn_env_i4, s, Raise_i4 (Con_i4 eq_tag []))
          | Eq_val b -> Just (env', s, Lit_i4 (Bool b))
        end
    | (Opassign, (Loc_i4 lnum), v) ->
        match store_assign lnum v s with
        | Just st -> Just (env', st, Lit_i4 Unit)
        | Nothing -> Nothing
        end
    | _ -> Nothing
  end

val do_if_i4 : v_i4 -> exp_i4 -> exp_i4 -> maybe exp_i4
let do_if_i4 v e1 e2 =
  if v = Litv_i4 (Bool true) then
    Just e1
  else if v = Litv_i4 (Bool false) then
    Just e2
  else
    Nothing

indreln [evaluate_i4 : bool -> list v_i4 -> count_store_genv v_i4 -> exp_i4 -> count_store_genv v_i4 * result v_i4 v_i4 -> bool]
and [evaluate_list_i4 : bool -> list v_i4 -> count_store_genv v_i4 -> list exp_i4 -> count_store_genv v_i4 * result (list v_i4) v_i4 -> bool]

lit : forall ck env l s.
true
==>
evaluate_i4 ck env s (Lit_i4 l) (s, Rval (Litv_i4 l))

and

raise1 : forall ck env e s1 s2 v.
evaluate_i4 ck s1 env e (s2, Rval v)
==>
evaluate_i4 ck s1 env (Raise_i4 e) (s2, Rerr (Rraise v))

and

raise2 : forall ck env e s1 s2 err.
evaluate_i4 ck s1 env e (s2, Rerr err)
==>
evaluate_i4 ck s1 env (Raise_i4 e) (s2, Rerr err)

and

handle1 : forall ck s1 s2 env e1 v e2.
evaluate_i4 ck s1 env e1 (s2, Rval v)
==>
evaluate_i4 ck s1 env (Handle_i4 e1 e2) (s2, Rval v)

and

handle2 : forall ck s1 s2 env e1 e2 v bv.
evaluate_i4 ck env s1 e1 (s2, Rerr (Rraise v)) &&
evaluate_i4 ck (v::env) s2 e2 bv
==>
evaluate_i4 ck env s1 (Handle_i4 e1 e2) bv

and

handle3 : forall ck s1 s2 env e1 e2 err.
evaluate_i4 ck env s1 e1 (s2, Rerr err) &&
(err = Rtimeout_error || (err = Rtype_error))
==>
evaluate_i4 ck env s1 (Handle_i4 e1 e2) (s2, Rerr err)

and

con1 : forall ck env tag es vs s s'.
evaluate_list_i4 ck env s es (s', Rval vs)
==>
evaluate_i4 ck env s (Con_i4 tag es) (s', Rval (Conv_i4 tag vs))

and

con3 : forall ck env tag es err s s'.
evaluate_list_i4 ck env s es (s', Rerr err)
==>
evaluate_i4 ck env s (Con_i4 tag es) (s', Rerr err)

and

var1 : forall ck env n s.
List.length env > n
==>
evaluate_i4 ck env s (Var_local_i4 n) (s, Rval (List_extra.nth env n))

and

var2 : forall ck env n s.
not (List.length env > n)
==>
evaluate_i4 ck env s (Var_local_i4 n) (s, Rerr Rtype_error)

and

var3 : forall ck env n v s genv.
(List.length genv > n) &&
(List_extra.nth genv n = Just v)
==>
evaluate_i4 ck env (s,genv) (Var_global_i4 n) ((s,genv), Rval v)

and

var4 : forall ck env n s genv.
(List.length genv > n) &&
(List_extra.nth genv n = Nothing)
==>
evaluate_i4 ck env (s,genv) (Var_global_i4 n) ((s,genv), Rerr Rtype_error)

and

var5 : forall ck env n s genv.
not (List.length genv > n)
==>
evaluate_i4 ck env (s,genv) (Var_global_i4 n) ((s,genv), Rerr Rtype_error)

and

fn : forall ck env e s.
true
==>
evaluate_i4 ck env s (Fun_i4 e) (s, Rval (Closure_i4 env e))

and

uapp1 : forall ck env uop e v v' s1 s2 count s3 genv2 genv3.
evaluate_i4 ck env s1 e (((count,s2),genv2), Rval v) &&
(do_uapp_i4 (s2,genv2) uop v = Just ((s3,genv3),v'))
==>
evaluate_i4 ck env s1 (Uapp_i4 uop e) (((count,s3),genv3), Rval v')

and

uapp2 : forall ck env uop e v s1 s2 count genv2.
evaluate_i4 ck env s1 e (((count,s2),genv2), Rval v) &&
(do_uapp_i4 (s2,genv2) uop v = Nothing)
==>
evaluate_i4 ck env s1 (Uapp_i4 uop e) (((count,s2),genv2), Rerr Rtype_error)

and

uapp3 : forall ck env uop e err s s'.
evaluate_i4 ck env s e (s', Rerr err)
==>
evaluate_i4 ck env s (Uapp_i4 uop e) (s', Rerr err)

and

app1 : forall ck env op e1 e2 v1 v2 env' e3 bv s1 s2 s3 count s4 genv3.
evaluate_i4 ck env s1 e1 (s2, Rval v1) &&
evaluate_i4 ck env s2 e2 (((count,s3),genv3), Rval v2) &&
do_app_i4 env s3 op v1 v2 = Just (env', s4, e3) &&
((ck && (op = Opapp)) --> count <> 0) &&
evaluate_i4 ck env' (((if ck then BigStep.dec_count op count else count),s4),genv3) e3 bv
==>
evaluate_i4 ck env s1 (App_i4 op e1 e2) bv

and

app2 : forall ck env op e1 e2 v1 v2 env' e3 s1 s2 s3 count s4 genv3.
evaluate_i4 ck env s1 e1 (s2, Rval v1) &&
evaluate_i4 ck env s2 e2 (((count,s3),genv3), Rval v2) &&
do_app_i4 env s3 op v1 v2 = Just (env', s4, e3) &&
count = 0 &&
op = Opapp &&
ck
==>
evaluate_i4 ck env s1 (App_i4 op e1 e2) (((0,s4),genv3),Rerr Rtimeout_error)

and

app3 : forall ck env op e1 e2 v1 v2 s1 s2 s3 count genv3.
evaluate_i4 ck env s1 e1 (s2, Rval v1) &&
evaluate_i4 ck env s2 e2 (((count,s3),genv3),Rval v2) &&
do_app_i4 env s3 op v1 v2 = Nothing
==>
evaluate_i4 ck env s1 (App_i4 op e1 e2) (((count,s3),genv3), Rerr Rtype_error)

and

app4 : forall ck env op e1 e2 v1 err s1 s2 s3.
evaluate_i4 ck env s1 e1 (s2, Rval v1) &&
evaluate_i4 ck env s2 e2 (s3, Rerr err)
==>
evaluate_i4 ck env s1 (App_i4 op e1 e2) (s3, Rerr err)

and

app5 : forall ck env op e1 e2 err s s'.
evaluate_i4 ck env s e1 (s', Rerr err)
==>
evaluate_i4 ck env s (App_i4 op e1 e2) (s', Rerr err)

and

if1 : forall ck env e1 e2 e3 v e' bv s1 s2.
evaluate_i4 ck env s1 e1 (s2, Rval v) &&
do_if_i4 v e2 e3 = Just e' &&
evaluate_i4 ck env s2 e' bv
==>
evaluate_i4 ck env s1 (If_i4 e1 e2 e3) bv

and

if2 : forall ck env e1 e2 e3 v s1 s2.
evaluate_i4 ck env s1 e1 (s2, Rval v) &&
do_if_i4 v e2 e3 = Nothing
==>
evaluate_i4 ck env s1 (If_i4 e1 e2 e3) (s2, Rerr Rtype_error)

and

if3 : forall ck env e1 e2 e3 err s s'.
evaluate_i4 ck env s e1 (s', Rerr err)
==>
evaluate_i4 ck env s (If_i4 e1 e2 e3) (s', Rerr err)

and

let1 : forall ck env e1 e2 v bv s1 s2.
evaluate_i4 ck env s1 e1 (s2, Rval v) &&
evaluate_i4 ck (v::env) s2 e2 bv
==>
evaluate_i4 ck env s1 (Let_i4 e1 e2) bv

and

let2 : forall ck env e1 e2 err s s'.
evaluate_i4 ck env s e1 (s', Rerr err)
==>
evaluate_i4 ck env s (Let_i4 e1 e2) (s', Rerr err)

and

letrec1 : forall ck env funs e bv s.
evaluate_i4 ck ((build_rec_env_i4 funs env)++env) s e bv
==>
evaluate_i4 ck env s (Letrec_i4 funs e) bv

and

extend : forall ck env n s genv.
true
==>
evaluate_i4 ck env (s,genv) (Extend_global_i4 n) ((s,genv++List.genlist (fun _ -> Nothing) n), Rval (Litv_i4 Unit))

and

empty : forall ck env s.
true
==>
evaluate_list_i4 ck env s [] (s, Rval [])

and

cons1 : forall ck env e es v vs s1 s2 s3.
evaluate_i4 ck env s1 e (s2, Rval v) &&
evaluate_list_i4 ck env s2 es (s3, Rval vs)
==>
evaluate_list_i4 ck env s1 (e::es) (s3, Rval (v::vs))

and

cons2 : forall ck env e es err s s'.
evaluate_i4 ck env s e (s', Rerr err)
==>
evaluate_list_i4 ck env s (e::es) (s', Rerr err)

and

cons3 : forall ck env e es v err s1 s2 s3.
evaluate_i4 ck env s1 e (s2, Rval v) &&
evaluate_list_i4 ck env s2 es (s3, Rerr err)
==>
evaluate_list_i4 ck env s1 (e::es) (s3, Rerr err)
