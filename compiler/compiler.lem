open SemanticPrimitives
open Ast
open CompilerLib
open IntLang
open ToIntLang
open ToBytecode
open Bytecode

type contab = Pmap.map (id conN) num * list (num * id conN) * num
val cmap : contab -> Pmap.map (id conN) num
let rec cmap (m,_,_) = m

type compiler_state =
  <| contab : contab
   ; renv : list (string * num)
   ; rmenv : Pmap.map string (list (string * num))
   ; rsz : num
   ; rnext_label : num
   |>

val cpam : compiler_state -> list (num * id conN)
let rec cpam s = match s.contab with (_,w,_) -> w end

let init_compiler_state =
  <| contab = (Pmap.add (Short "") tuple_cn Pmap.empty
              ,[(tuple_cn,Short "")]
              ,3)
   ; renv = []
   ; rmenv = Pmap.empty
   ; rsz = 0
   ; rnext_label = 0
   |>

let compile_Cexp ex rsz menv env nl Ce =
  let (Ce,nl) = label_closures (List.length env) nl Ce in
  let cs = <| out = []; next_label = nl |> in
  let cs = if ex then emit cs [PushPtr (Addr 0); PushExc] else cs in
  let cs = compile_code_env menv cs Ce in
  compile menv env TCNonTail (if ex then rsz+2 else rsz) cs Ce

let rec
number_constructors _ [] ac = ac
and
number_constructors mn ((c,_)::cs) ((m,w,n),ls) =
  number_constructors mn cs ((Pmap.add (mk_id mn c) n m, (n,mk_id mn c)::w, n+1)
                            ,(Hol.CONCAT[id_to_string(mk_id mn c);" = <constructor>"])::ls)

let rec
compile_news _ cs i [] = cs
and
compile_news print cs i (v::vs) =
  let cs = emit cs (List.map Stack [Load 0; Load 0; El i]) in
  let cs = if print then
      let cs = emit cs (List.map PrintC (Hol.EXPLODE (Hol.CONCAT["val ";v;" = "]))) in
      emit cs [Stack(Load 0); Print]
    else cs in
  let cs = emit cs [Stack (Store 1)] in
  compile_news print cs (i+1) vs

let compile_fake_exp top rs vs e =
  let m = <| bvars = List.map fst rs.renv
           ; mvars = Hol.o_f (List.map fst) rs.rmenv
           ; cnmap = cmap rs.contab
           |> in
  let Ce = exp_to_Cexp m (e (Con (Short "") (List.map (fun v -> Var (Short v)) vs))) in
  let menv = Hol.o_f (List.map snd) rs.rmenv in
  let env = List.map (Hol.o CTDec snd) rs.renv in
  let cs = compile_Cexp top rs.rsz menv env rs.rnext_label Ce in
  let cs = if top then emit cs [PopExc; Stack (Pops 1)] else cs in
  let cs = compile_news top cs 0 vs in
  let cs = emit cs [Stack Pop] in
  (rs.contab
  ,List.combine vs (genlist(fun i -> rs.rsz+i)(List.length vs))
  ,cs.next_label
  ,cs.out
  )

let rec
dec_to_contab mn ct (Dtype ts) =
  List.fold_left (fun ac (_,_,cs) -> number_constructors mn cs ac) (ct,[]) ts
and
dec_to_contab _ ct _ = (ct,[])

let rec
decs_to_contab mn ct [] = ct
and
decs_to_contab mn ct (d::ds) = decs_to_contab mn (fst (dec_to_contab mn ct d)) ds

let rec
compile_dec mn rs (Dtype ts) =
  let (ct,ls) = dec_to_contab mn rs.contab (Dtype ts) in
  (ct,[],rs.rnext_label
  ,if (Hol.IS_NONE mn) then List.rev(List.map PrintC (Hol.EXPLODE (Hol.CONCAT (List.rev ls)))) else [])
and
compile_dec mn rs (Dletrec defs) =
  let vs = List.map (fun (n,_,_) -> n) defs in
  compile_fake_exp (Hol.IS_NONE mn) rs vs (fun b -> Letrec defs b)
and
compile_dec mn rs (Dlet p e) =
  let vs = pat_bindings p [] in
  compile_fake_exp (Hol.IS_NONE mn) rs vs (fun b -> Mat e [(p,b)])

let rec
compile_decs _ [] ac = ac
and
compile_decs mn (dec::decs) (rs,code) =
  let (ct,env,nl,code') = compile_dec (Some mn) rs dec in
  compile_decs mn decs
    (<| rs with
        contab = ct
      ; renv = env@rs.renv
      ; rsz = rs.rsz + List.length env
      ; rnext_label = nl |>
    ,code'@code)

let rec
compile_top rs (Tmod mn _ decs) =
  let (mrs,code) = compile_decs mn decs (<|rs with rsz = rs.rsz+2|>,[PushExc; PushPtr (Addr 0)]) in
  let env = Hol.BUTLASTN (List.length rs.renv) mrs.renv in
  let str = Hol.CONCAT["structure ";mn;" = <structure>"] in
  let clean1 = [Stack (Cons tuple_cn (List.length env));PopExc;Stack(Pops 1)] in
  let clean2 = List.rev(compile_news false <|out = []; next_label = 0|> 0 (List.map fst env)).out in
  (<| mrs with
      renv = rs.renv
    ; rmenv = Pmap.add mn (List.map (fun (x,i) -> (x,i-2)) env) rs.rmenv |>
  ,<| rs with
      contab = decs_to_contab (Some mn) rs.contab decs
    ; rnext_label = mrs.rnext_label
    ; rmenv = Pmap.add mn [] rs.rmenv |>
  ,(List.rev code)@clean1@clean2@(Stack Pop)::(List.map PrintC (Hol.EXPLODE str)))
and
compile_top rs (Tdec dec) =
  let (ct,env,nl,code) = compile_dec None rs dec in
  (<| rs with
      contab = ct
    ; renv = env@rs.renv
    ; rsz = rs.rsz + List.length env
    ; rnext_label = nl |>
  ,<| rs with rnext_label = nl |>
  ,List.rev code)
