open SemanticPrimitives
open Ast
open CompilerLib
open IntLang
open ToIntLang
open ToBytecode
open Bytecode

type contab = Pmap.map (id conN) num * list (num * id conN) * num
val cmap : contab -> Pmap.map (id conN) num
let rec cmap (m,_,_) = m

type compiler_state =
  <| contab : contab
   ; renv : list (string * num)
   ; rmenv : Pmap.map string (list (string * num))
   ; rsz : num
   ; rnext_label : num
   |>

val cpam : compiler_state -> list (num * id conN)
let rec cpam s = match s.contab with (_,w,_) -> w end

let init_compiler_state =
  <| contab = (Pmap.add (Short "") tuple_cn Pmap.empty
              ,[(tuple_cn,Short "")]
              ,3)
   ; renv = []
   ; rmenv = Pmap.empty
   ; rsz = 0
   ; rnext_label = 0
   |>

let rec
number_constructors _ [] ct = ct
and
number_constructors mn ((c,_)::cs) (m,w,n) =
  number_constructors mn cs (Pmap.add (mk_id mn c) n m, (n,mk_id mn c)::w, n+1)

let rec
dec_to_contab mn ct (Dtype ts) =
  List.fold_left (fun ct (_,_,cs) -> number_constructors mn cs ct) ct ts
and
dec_to_contab _ ct _ = ct

let rec
decs_to_contab _ ct [] = ct
and
decs_to_contab mn ct (d::ds) = decs_to_contab mn (dec_to_contab mn ct d) ds

let rec
compile_news _ cs _ [] = emit cs [Stack Pop]
and
compile_news print cs i (v::vs) =
  let cs = emit cs (List.map Stack [Load 0; Load 0; El i]) in
  let cs = if print then
      let cs = emit cs (List.map PrintC (Hol.EXPLODE (Hol.CONCAT["val ";v;" = "]))) in
      emit cs [Stack(Load 0); Print]
    else cs in
  let cs = emit cs [Stack (Store 1)] in
  compile_news print cs (i+1) vs

let compile_Cexp menv env rsz cs Ce =
  let (Ce,nl) = label_closures (List.length env) cs.next_label Ce in
  let cs = compile_code_env menv <| cs with next_label = nl |> Ce in
  compile menv env TCNonTail rsz cs Ce

let compile_fake_exp menv m env rsz cs vs e =
  let Ce = exp_to_Cexp m (e (Con (Short "") (List.map (fun v -> Var (Short v)) vs))) in
  compile_Cexp menv env rsz cs Ce

let rec
compile_dec _ _ _ _ cs (Dtype _) = (None, emit cs [Stack (Cons tuple_cn 0)])
and
compile_dec menv m env rsz cs (Dletrec defs) =
  let vs = List.map (fun (n,_,_) -> n) defs in
  (Some vs, compile_fake_exp menv m env rsz cs vs (fun b -> Letrec defs b))
and
compile_dec menv m env rsz cs (Dlet p e) =
  let vs = pat_bindings p [] in
  (Some vs, compile_fake_exp menv m env rsz cs vs (fun b -> Mat e [(p,b)]))

let rec
compile_decs _ _ ct m _ rsz cs [] = (ct,m,rsz,cs)
and
compile_decs mn menv ct m env rsz cs (dec::decs) =
  let (vso,cs) = compile_dec menv m env rsz cs dec in
  let ct = dec_to_contab mn ct dec in
  let (m,env,rsz,cs) =
    match vso with
    | None -> (<|m with cnmap = cmap ct|>,env,rsz,cs)
    | Some vs ->
        let n = List.length vs in
        (<|m with bvars = vs@m.bvars|>
        ,(genlist (fun i -> CTDec (rsz+i)) n)@env
        ,rsz + n
        ,match mn with None -> cs | _ -> compile_news false cs 0 vs end)
    end in
  compile_decs mn menv ct m env rsz cs decs

let compile_decs_wrap mn rs decs =
  let cs = <| out = []; next_label = rs.rnext_label |> in
  let cs = emit cs [PushPtr (Addr 0); PushExc] in
  let menv = Hol.o_f (List.map snd) rs.rmenv in
  let m = <| bvars = List.map fst rs.renv
           ; mvars = Hol.o_f (List.map fst) rs.rmenv
           ; cnmap = cmap rs.contab
           |> in
  let env = List.map (Hol.o CTDec snd) rs.renv in
  let (ct,m,rsz,cs) = compile_decs mn menv rs.contab m env (rs.rsz+2) cs decs in
  let n = rsz-2-rs.rsz in
  let news = Hol.TAKE n m.bvars in
  let cs = if Hol.IS_NONE mn then cs else emit cs [Stack (Cons tuple_cn n)] in
  let cs = emit cs [PopExc; Stack(Pops 1)] in
  let cs = compile_news (Hol.IS_NONE mn) cs 0 news in
  let env = List.combine news (genlist (fun i -> rs.rsz+i) n) in
  let (renv,rmenv) =
    match mn with
    | None -> (env@rs.renv,rs.rmenv)
    | Some mn -> (rs.renv,Pmap.add mn env rs.rmenv)
    end in
  (<|rs with
     rsz = rs.rsz+n
    ;renv = renv
    ;rmenv = rmenv
    ;rnext_label = cs.next_label
    ;contab = ct
    |>
  ,cs.out)

let rec
compile_print_dec (Dtype ts) code =
  List.fold_left (fun code (_,_,cs) ->
    List.fold_left (fun code (c,_) ->
      (List.rev(List.map PrintC (Hol.EXPLODE (Hol.CONCAT [c;" = <constructor>"]))))@code)
    code cs) code ts
and
compile_print_dec _ code = code

let rec
compile_top rs (Tmod mn _ decs) =
  let (rss,code) = compile_decs_wrap (Some mn) rs decs in
  let str = Hol.CONCAT["structure ";mn;" = <structure>"] in
  (rss
  ,<| rs with
      contab = rss.contab
    ; rnext_label = rss.rnext_label
    ; rmenv = Pmap.add mn [] rs.rmenv |>
  ,List.rev((List.rev(List.map PrintC (Hol.EXPLODE str)))@code))
and
compile_top rs (Tdec dec) =
  let (rss,code) = compile_decs_wrap None rs [dec] in
  (rss
  ,<| rs with
      contab = rss.contab
    ; rnext_label = rss.rnext_label |>
  ,List.rev(compile_print_dec dec code))
