open import Pervasives
open import SemanticPrimitives
open import Ast
open import CompilerLib
open import IntLang
open import ToIntLang
open import ToBytecode
open import Bytecode
open String_extra
open import ModLang
open import ConLang
open import DecLang
open import ExhLang
open import PatLang

type compiler_state =
  <| next_global : nat
   ; globals_env : map modN (map varN nat) * map varN nat
   ; contags_env : nat * tag_env * map nat (conN * tid_or_exn)
   ; exh : exh_ctors_env
   ; rnext_label : nat
   |>

let compile_Cexp env rsz cs Ce =
  let (Ce,nl) = label_closures (List.length env) cs.next_label Ce in
  let cs = compile_code_env <| cs with next_label = nl |> Ce in
  compile env TCNonTail rsz cs Ce

let tystr types v =
  match Map.lookup v types with
    | Just t -> t
    | Nothing -> "<unknown>"
  end

let rec
compile_print_vals _ _ [] s = s
and
compile_print_vals types map (v::vs) s =
  let s = emit s (List.map PrintC (toCharList (String_extra.stringConcat ["val ";v;":"; tystr types v;" = "]))) in
  let s = emit s [Gread (fapply 0 v map); Print] in
  let s = emit s (List.map PrintC (toCharList "\n")) in
    compile_print_vals types map vs s
declare termination_argument compile_print_vals = automatic

let rec
compile_print_ctors [] s = s
and
compile_print_ctors ((c,_)::cs) s =
  compile_print_ctors cs
    (emit s (List.map PrintC (toCharList (String_extra.stringConcat [c;" = <constructor>\n"]))))
declare termination_argument compile_print_ctors = automatic

let rec
compile_print_types [] s = s
and
compile_print_types ((_,_,cs)::ts) s =
  compile_print_types ts (compile_print_ctors (List.reverse cs) s)
declare termination_argument compile_print_types = automatic

let rec
compile_print_dec _ _ (Dtype ts) s = compile_print_types (List.reverse ts) s
and
compile_print_dec _ _ (Dexn c xs) s = compile_print_types [(([]:list tvarN),"exn",[(c,xs)])] s
and
compile_print_dec types map (Dlet p _) s =
  compile_print_vals types map (pat_bindings p []) s
and
compile_print_dec types map (Dletrec defs) s =
  compile_print_vals types map (List.map (fun (n,_,_) -> n) defs) s

let compile_print_err cs =
  let (cs,n) = get_label cs in
  let cs = emit cs [Stack (Load 0);
                    Stack (TagEq (block_tag+none_tag));
                    JumpIf (Lab n);
                    Stack (El 0) ] in
  let cs = emit cs (List.map PrintC (toCharList "raise ")) in
  let cs = emit cs [Print] in
  let cs = emit cs (List.map PrintC (toCharList "\n")) in
  let cs = emit cs [Stop false; Label n; Stack Pop] in
  cs

let compile_print_top types map top cs =
  let cs = compile_print_err cs in
  let cs = match types with | Nothing -> cs | Just types ->
    match top with
    | (Tmod mn _ _) ->
        let str = String_extra.stringConcat["structure ";mn;" = <structure>\n"] in
        emit cs (List.map PrintC (toCharList str))
    | (Tdec dec) -> compile_print_dec types map dec cs
    end    end in
  emit cs [Stop true]

let compile_top types cs top =
  let n = cs.next_global in
  let (m10,m20) = cs.globals_env in
  let (_,m1,m2,p) = top_to_i1 n m10 m20 top in
  let (c,exh,p) = prompt_to_i2 cs.contags_env p in
  let (n,e) = prompt_to_i3 (none_tag, Just (TypeId (Short "option"))) (some_tag, Just (TypeId (Short "option"))) n p in
  let exh = Map.(union) exh cs.exh in
  let e = exp_to_exh exh e in
  let e = exp_to_pat [] e in
  let e = exp_to_Cexp e in
  let r = compile_Cexp [] 0 <| out = []; next_label = cs.rnext_label |> e in
  let r = compile_print_top types m2 top r in
  let cs = <| next_global = n
            ; globals_env = (m1,m2)
            ; contags_env = c
            ; exh = exh
            ; rnext_label = r.next_label
            |> in
  (cs, <| cs with globals_env = (m1,m20) |>, r.out)

let compile_prog init_compiler_state prog =
  let n = init_compiler_state.next_global in
  let (m1,m2) = init_compiler_state.globals_env in
  let (_,_,m2,p) = prog_to_i1 n m1 m2 prog in
  let (_,exh,p) = prog_to_i2 init_compiler_state.contags_env p in
  let (_,e) = prog_to_i3 (none_tag, Just (TypeId (Short "option"))) (some_tag, Just (TypeId (Short "option"))) n p in
  let e = exp_to_exh (Map.(union) exh init_compiler_state.exh) e in
  let e = exp_to_pat [] e in
  let e = exp_to_Cexp e in
  let r = compile_Cexp [] 0 <| out = []; next_label = init_compiler_state.rnext_label |> e in
  let r = compile_print_err r in
  let r = match Map.lookup "it" m2 with
          | Nothing -> r
          | Just n -> let r = emit r [Gread n; Print] in
                        emit r (List.map PrintC (toCharList "\n"))
          end in
  let r = emit r [Stop true] in
  List.reverse (r.out)
