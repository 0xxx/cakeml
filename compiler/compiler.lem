open Ast
open CompilerLib
open IntLang
open ToIntLang
open ToBytecode
open Bytecode

type contab = Pmap.map (id conN) num * list (num * id conN) * num
val cmap : contab -> Pmap.map (id conN) num
let rec cmap (m,_,_) = m

type compiler_state =
  <| contab : contab
   ; renv : list (string * num)
   ; rmenv : Pmap.map string (list (string * num))
   ; rsz : num
   ; rnext_label : num
   |>

val cpam : compiler_state -> list (num * id conN)
let rec cpam s = match s.contab with (_,w,_) -> w end

let init_compiler_state =
  <| contab = (Pmap.add (Short "Div") div_exc_cn
               (Pmap.add (Short "Bind") bind_exc_cn
                (Pmap.add (Short "") tuple_cn Pmap.empty))
              (* TODO: don't need to store n, use length of list? *)
              ,[(tuple_cn,Short "");(bind_exc_cn,Short "Bind");(div_exc_cn,Short "Div")]
              ,3)
   ; renv = []
   ; rmenv = Pmap.empty
   ; rsz = 0
   ; rnext_label = 0
   |>

let compile_Cexp rsz menv env nl Ce =
  let (Ce,n) = label_closures (List.length env) nl Ce in
  let cs = <| out = []; next_label = n |> in
  let (cs,l) = get_label cs in
  let cs = emit cs [PushPtr (Lab l); PushExc] in
  let cs = compile_code_env menv cs Ce in
  (l, compile menv env TCNonTail (rsz+2) cs Ce)

let rec
number_constructors _ [] ct = ct
and
number_constructors mn ((c,_)::cs) (m,w,n) =
  number_constructors mn cs (Pmap.add (mk_id mn c) n m, (n,mk_id mn c)::w, n+1)

let rec
compile_news cs i [] = cs
and
compile_news cs i (_::vs) =
  let cs = emit cs (List.map Stack [Load 0; Load 0; El i; Store 1]) in
  compile_news cs (i+1) vs

let compile_fake_exp rs vs e =
  let m = <| bvars = List.map fst rs.renv
           ; mvars = Hol.o_f (List.map fst) rs.rmenv
           ; cnmap = cmap rs.contab
           |> in
  let Ce = exp_to_Cexp m (e (Con (Short "") (List.map (fun v -> Var (Short v)) vs))) in
  let menv = Hol.o_f (List.map snd) rs.rmenv in
  let env = List.map (Hol.o CTDec snd) rs.renv in
  let (l1,cs) = compile_Cexp rs.rsz menv env rs.rnext_label Ce in
  let cs = emit cs [PopExc; Stack (Pops 1)] in
  let cs = compile_news cs 0 vs in
  let (cs,l2) = get_label cs in
  let cs = emit cs [Stack Pop; Stack (PushInt i0); Jump (Lab l2)
                   ; Label l1; Stack (PushInt i1); Label l2; Stop] in
  (rs.contab
  ,genlist (fun i -> (List.nth vs i, rs.rsz+i)) (List.length vs)
  ,cs.next_label
  ,List.rev cs.out
  )

let rec
compile_dec mn rs (Dtype ts) =
  let ct =
    List.fold_left
      (fun ct (_,_,cs) -> number_constructors mn cs ct)
      rs.contab ts in
  (ct,[],rs.rnext_label,[Stack (PushInt i0); Stop])
and
compile_dec _ rs (Dletrec defs) =
  let vs = List.map (fun (n,_,_) -> n) defs in
  compile_fake_exp rs vs (fun b -> Letrec defs b)
and
compile_dec _ rs (Dlet p e) =
  let vs = pat_bindings p [] in
  compile_fake_exp rs vs (fun b -> Mat e [(p,b)])

let rec
compile_top rs (Tmod mn _ decs) = (rs,rs,[]) (* TODO *)
and
compile_top rs (Tdec dec) =
  let (ct,env,nl,code) = compile_dec None rs dec in
  let n = List.length env in
  (<| rs with
      contab = ct
    ; renv = env@rs.renv
    ; rsz = rs.rsz + n
    ; rnext_label = nl |>
  ,<| rs with rnext_label = nl |>
  ,code)
