open Ast
open CompilerLib
open IntLang
open ToIntLang
open ToBytecode
open Bytecode

type contab = Pmap.map (id conN) num * list (num * string) * num
val cmap : contab -> Pmap.map (id conN) num
let rec cmap (m,_,_) = m

type compiler_state =
  <| contab : contab
   ; rbvars : list string
   ; renv : list num
   ; rsz  : num
   ; rnext_label : num
   |>

val cpam : compiler_state -> list (num * string)
let rec cpam s = match s.contab with (_,w,_) -> w end

val etC : compiler_state -> exp_to_Cexp_state
let etC rs = <| bvars = rs.rbvars; cnmap = cmap rs.contab |>

let init_compiler_state =
  <| contab = (Pmap.empty, [], 0)
   ; rbvars = []
   ; renv = []
   ; rsz  = 0
   ; rnext_label = 0
   |>

let compile_Cexp rs Ce =
  let (Ce,n) = label_closures (List.length rs.rbvars) rs.rnext_label Ce in
  let cs = <| out = []; next_label = n |> in
  let cs = compile_code_env cs Ce in
  compile (List.map CTLet rs.renv) TCNonTail rs.rsz cs Ce

let rec
number_constructors [] ct = ct
and
number_constructors ((c,_)::cs) (m,w,n) =
  number_constructors cs (Pmap.add (Short c) n m, (n,c)::w, n+1)

let compile_decl rs cs vs =
  let (cs,z,_,env,bvs) =
  List.fold_left
    (fun (s,z,i,env,bvs) bv ->
      match find_index bv bvs 1 with
      | None ->
          (emit s (List.map Stack [Load 0; Load 0; El i; Store 1])
          ,z+1
          ,i+1
          ,(rs.rsz+z+1)::env
          ,bv::bvs
          )
      | Some j ->
          (emit s (List.map Stack [Load 0; El i; Store j])
          ,z
          ,i+1
          ,env
          ,bvs
          )
      end) (cs,0,0,rs.renv,rs.rbvars) vs in
  let cs = emit cs [Stack Pop] in
  (<| rs with rsz = rs.rsz+z ; renv = env ; rbvars = bvs
    ; rnext_label = cs.next_label |>
  ,List.rev cs.out)

let rec
compile_dec rs (Dtype ts) =
  (<| rs with contab =
      List.fold_left
        (fun ct (_,_,cs) -> number_constructors cs ct)
        rs.contab ts |>
  ,[])
and
compile_dec rs (Dletrec defs) =
  let m = etC rs in
  let fns = List.map (fun (n,_,_) -> n) defs in
  let m = <| m with bvars = fns @ m.bvars |> in
  let Cdefs = defs_to_Cdefs m defs in
  let cs = compile_Cexp rs (CLetrec Cdefs (CCon 0 (genlist CVar (List.length fns)))) in
  compile_decl rs cs fns
and
compile_dec rs (Dlet p e) =
  let m = etC rs in
  let Ce = exp_to_Cexp m e in
  let (m,Cp) = pat_to_Cpat <| m with bvars = [] |> p in
  let vs = m.bvars in
  let Cpes = [(Cp,CCon 0 (genlist CVar (List.length vs)))] in
  let cs = compile_Cexp rs (CLet Ce (remove_mat_var 0 Cpes)) in
  compile_decl rs cs vs
