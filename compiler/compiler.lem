open import Pervasives
open import SemanticPrimitives
open import Ast
open import CompilerLib
open import IntLang
open import ToIntLang
open import ToBytecode
open import Bytecode
open String_extra
open import ModLang
open import ConLang
open import DecLang
open import ExhLang
open import PatLang

type compiler_state =
  <| next_global : nat
   ; globals_env : map modN (map varN nat) * map varN nat
   ; contags_env : nat * tag_env * map nat (conN * tid_or_exn)
   ; exh : exh_ctors_env
   ; rnext_label : nat
   |>

let init_compiler_state =
  <| next_global = 0
   ; globals_env = (Map.empty, Map.empty)
   ; contags_env = init_tagenv_state
   ; exh = Map.empty
   ; rnext_label = 0
   |>

let compile_Cexp env rsz cs Ce =
  let (Ce,nl) = label_closures (List.length env) cs.next_label Ce in
  let cs = compile_code_env <| cs with next_label = nl |> Ce in
  compile env TCNonTail rsz cs Ce

let tystr types v =
  match Map.lookup v types with
    | Just t -> t
    | Nothing -> "<unknown>"
  end

let rec
compile_print_vals _ _ [] s = s
and
compile_print_vals types n (v::vs) s =
  let s = emit s (List.map PrintC (toCharList (String_extra.stringConcat ["val ";v;":"; tystr types v;" = "]))) in
  let s = emit s [Stack(Load n); Print] in
  let s = emit s (List.map PrintC (toCharList "\n")) in
    compile_print_vals types (n+1) vs s

let rec
compile_print_ctors [] s = s
and
compile_print_ctors ((c,_)::cs) s =
  compile_print_ctors cs
    (emit s (List.map PrintC (toCharList (String_extra.stringConcat [c;" = <constructor>\n"]))))
declare termination_argument compile_print_ctors = automatic

let rec
compile_print_types [] s = s
and
compile_print_types ((_,_,cs)::ts) s =
  compile_print_types ts (compile_print_ctors cs s)
declare termination_argument compile_print_types = automatic

let rec
compile_print_dec _ (Dtype ts) s = compile_print_types ts s
and
compile_print_dec _ (Dexn c xs) s = compile_print_types [(([]:list tvarN),"exn",[(c,xs)])] s
and
compile_print_dec types (Dlet p _) s =
  compile_print_vals types 0 (pat_bindings p []) s
and
compile_print_dec types (Dletrec defs) s =
  compile_print_vals types 0 (List.map (fun (n,_,_) -> n) defs) s

let rec
compile_print_top Nothing _ cs = cs
and
compile_print_top _ (Tmod mn _ _) cs =
  let str = String_extra.stringConcat["structure ";mn;" = <structure>\n"] in
  emit cs (List.map PrintC (toCharList str))
and
compile_print_top (Just types) (Tdec dec) cs =
  compile_print_dec types dec cs

let compile_top types cs top =
  let n = cs.next_global in
  let (m1,m2) = cs.globals_env in
  let (_,m1,m2,p) = top_to_i1 n m1 m2 top in
  let (c,exh,p) = prompt_to_i2 cs.contags_env p in
  let (n,e) = prompt_to_i3 (none_tag, Just (TypeId (Short "option"))) (some_tag, Just (TypeId (Short "option"))) n p in
  let exh = Map.(union) exh cs.exh in
  let e = exp_to_exh exh e in
  let e = exp_to_pat [] e in
  let e = exp_to_Cexp e in
  let r = compile_Cexp [] 0 <| out = []; next_label = cs.rnext_label |> e in
  let r = compile_print_top types top r in
  let cs = <| next_global = n
            ; globals_env = (m1,m2)
            ; contags_env = c
            ; exh = exh
            ; rnext_label = r.next_label
            |> in
  (cs, r.out)

let compile_prog prog =
  let n = init_compiler_state.next_global in
  let (m1,m2) = init_compiler_state.globals_env in
  let (_,_,m2,p) = prog_to_i1 init_compiler_state.next_global m1 m2 prog in
  let (_,exh,p) = prog_to_i2 init_compiler_state.contags_env p in
  let (_,e) = prog_to_i3 (none_tag, Just (TypeId (Short "option"))) (some_tag, Just (TypeId (Short "option"))) n p in
  let e = exp_to_exh exh e in
  let e = exp_to_pat [] e in
  let e = exp_to_Cexp e in
  let r = compile_Cexp [] 0 <| out = []; next_label = init_compiler_state.rnext_label |> e in
  let r = match Map.lookup "it" m2 with
          | Nothing -> r
          | Just n -> let r = emit r [Gread n; Print] in
                        emit r (List.map PrintC (toCharList "\n"))
          end in
  List.reverse (r.out)
