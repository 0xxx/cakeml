open Ast
open CompilerLib
open IntLang
open ToIntLang
open ToBytecode
open Bytecode

type contab = Pmap.map (id conN) num * list (num * string) * num
val cmap : contab -> Pmap.map (id conN) num
let rec cmap (m,_,_) = m

type compiler_state =
  <| contab : contab
   ; rbvars : list (id string)
   ; rnext_label : num
   |>

val cpam : compiler_state -> list (num * string)
let rec cpam s = match s.contab with (_,w,_) -> w end

let menv_cons mv mn s =
  match Hol.FLOOKUP mv mn with
  | None -> Pmap.add mn [s] mv
  | Some ls -> Pmap.add mn (s::ls) mv
  end

val etC : compiler_state -> exp_to_Cexp_state * num * Pmap.map string (list ctbind) * list ctbind
let etC rs =
  let rsz = List.length rs.rbvars in
  let (_,mvars,menv,bvars,env) = List.fold_left
    (fun (i,mvars,menv,bvars,env) id ->
      match id with
      | Short s -> (i-1,mvars,menv,s::bvars,(CTLet i)::env)
      | Long mn s -> (i-1,menv_cons mvars mn s,menv_cons menv mn (CTLet i),bvars,env)
      end)
    (rsz,Pmap.empty,Pmap.empty,[],[]) rs.rbvars in
  (<| bvars = bvars ; mvars = mvars ; cnmap = cmap rs.contab |>
  ,rsz,menv,env)

let init_compiler_state =
  <| contab = (Pmap.add (Short "Div") div_exc_cn
               (Pmap.add (Short "Bind") bind_exc_cn
                (Pmap.add (Short "") tuple_cn Pmap.empty))
              (* TODO: don't need to store n, use length of list? *)
              ,[(tuple_cn,"");(bind_exc_cn,"Bind");(div_exc_cn,"Div")]
              ,3)
   ; rbvars = []
   ; rnext_label = 0
   |>

let compile_Cexp rsz menv env nl Ce =
  let (Ce,n) = label_closures rsz nl Ce in
  let cs = <| out = []; next_label = n |> in
  let (cs,l) = get_label cs in
  let cs = emit cs [PushPtr (Lab l); PushExc] in
  let cs = compile_code_env menv cs Ce in
  (l, compile menv env TCNonTail (rsz+2) cs Ce)

let rec
number_constructors [] ct = ct
and
number_constructors ((c,_)::cs) (m,w,n) =
  number_constructors cs (Pmap.add (Short c) n m, (n,c)::w, n+1)

let rec
compile_shadows bvs cs i [] = cs
and
compile_shadows bvs cs i (v::vs) =
  let j = the 0 (find_index (Short v) bvs 1) in
  let cs = emit cs (List.map Stack [Load 0; El i; Store j]) in
  compile_shadows bvs cs (i+1) vs

let rec
compile_news cs i [] = cs
and
compile_news cs i (_::vs) =
  let cs = emit cs (List.map Stack [Load 0; Load 0; El i; Store 1]) in
  compile_news cs (i+1) vs

let compile_fake_exp rs vs e =
  let (m,rsz,menv,env) = etC rs in
  let (shadows,news) = Hol.PARTITION (fun v -> List.mem (Short v) rs.rbvars) vs in
  let Ce = exp_to_Cexp m (e (Con (Short "") (List.map (fun v -> Var (Short v)) (shadows@news)))) in
  let (l1,cs) = compile_Cexp rsz menv env rs.rnext_label Ce in
  let cs = emit cs [PopExc; Stack (Pops 1)] in
  let cs = compile_shadows rs.rbvars cs 0 shadows in
  let cs = compile_news cs (List.length shadows) news in
  let (cs,l2) = get_label cs in
  let cs = emit cs [Stack Pop; Stack (PushInt i0); Jump (Lab l2)
                   ; Label l1; Stack (PushInt i1); Label l2; Stop] in
  (<| rs with rbvars = (List.rev (List.map Short news))@rs.rbvars
    ; rnext_label = cs.next_label |>
  ,<| rs with rnext_label = cs.next_label |>
  ,List.rev cs.out)

let rec
compile_dec rs (Dtype ts) =
  let rs =
    <| rs with contab =
       List.fold_left
         (fun ct (_,_,cs) -> number_constructors cs ct)
         rs.contab ts |> in
  (rs,rs,[Stack (PushInt i0); Stop])
and
compile_dec rs (Dletrec defs) =
  let vs = List.map (fun (n,_,_) -> n) defs in
  compile_fake_exp rs vs (fun b -> Letrec defs b)
and
compile_dec rs (Dlet p e) =
  let vs = pat_bindings p [] in
  compile_fake_exp rs vs (fun b -> Mat e [(p,b)])
