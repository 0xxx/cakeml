open preamble
open wordLangTheory wordPropsTheory word_allocTheory wordSemTheory
open BasicProvers

val _ = new_theory "word_allocProof";

(*Define syntactic invariants on the conventions*)

val call_arg_convention_def = Define`
  (call_arg_convention (Return x y) = (y=2)) ∧
  (call_arg_convention (Raise y) = (y=2)) ∧
  (call_arg_convention (Call ret dest args h) =
    (case ret of
      NONE => args = GENLIST (\x.2*x) (LENGTH args)
    | SOME (v,cutset,ret_handler,l1,l2) =>
      args = GENLIST (\x.2*(x+1)) (LENGTH args) ∧
      (v = 2) ∧ call_arg_convention ret_handler ∧
    (case h of  (*Does not check the case where Calls are ill-formed*)
      NONE => T
    | SOME (v,prog,l1,l2) =>
      (v = 2) ∧ call_arg_convention prog))) ∧
  (call_arg_convention (Seq s1 s2) =
    (call_arg_convention s1 ∧ call_arg_convention s2)) ∧
  (call_arg_convention (If cmp r1 ri e2 e3) =
    (call_arg_convention e2 ∧
     call_arg_convention e3)) ∧
  (call_arg_convention p = T)`

(*Before allocation, generated by SSA CC*)
val pre_alloc_conventions_def = Define`
  pre_alloc_conventions p =
    (every_stack_var is_stack_var p ∧
    call_arg_convention p)`

(*After allocation, generated by allocator*)
val post_alloc_conventions_def = Define`
  post_alloc_conventions k prog =
    (every_var is_phy_var prog ∧
    every_stack_var (λx. x ≥ 2*k) prog ∧
    call_arg_convention prog)`

val in_clash_sets_def = Define`
  in_clash_sets (ls: ('a num_map) list) x = ∃y. MEM y ls ∧ x ∈ domain y`

val colouring_ok_def = Define`
  (colouring_ok f (Seq s1 s2) live =
    (*Normal live sets*)
    let s2_live = get_live s2 live in
    let s1_live = get_live s1 s2_live in
      INJ f (domain s1_live) UNIV ∧
      (*Internal clash sets*)
      colouring_ok f s2 live ∧ colouring_ok f s1 s2_live) ∧
  (colouring_ok f (If cmp r1 ri e2 e3) live =
    let e2_live = get_live e2 live in
    let e3_live = get_live e3 live in
    let union_live = union e2_live e3_live in
    let merged = case ri of Reg r2 => insert r2 () (insert r1 () union_live)
                      | _ => insert r1 () union_live in
    (*All of them must be live at once*)
      INJ f (domain merged) UNIV ∧
      (*Internal clash sets*)
      colouring_ok f e2 live ∧ colouring_ok f e3 live) ∧
  (colouring_ok f (Call(SOME(v,cutset,ret_handler,l1,l2))dest args h) live =
    let args_set = numset_list_insert args LN in
    INJ f (domain (union cutset args_set)) UNIV ∧
    INJ f (domain (insert v () cutset)) UNIV ∧
    (*returning handler*)
    colouring_ok f ret_handler live ∧
    (*exception handler*)
    (case h of
    | NONE => T
    | SOME(v,prog,l1,l2) =>
        INJ f (domain (insert v () cutset)) UNIV ∧
        colouring_ok f prog live)) ∧
  (colouring_ok f prog live =
    (*live before must be fine, and clash set must be fine*)
    let lset = get_live prog live in
    let iset = union (get_writes prog) live in
      INJ f (domain lset) UNIV ∧ INJ f (domain iset) UNIV)`

(*Alternate*)
val colouring_ok_alt_def = Define`
  colouring_ok_alt f prog live =
    let (hd,ls) = get_clash_sets prog live in
    EVERY (λs. INJ f (domain s) UNIV) ls ∧
    INJ f (domain hd) UNIV`

(*Equivalence on everything except permutation and locals*)
val word_state_eq_rel_def = Define`
  word_state_eq_rel s t ⇔
  t.store = s.store ∧
  t.stack = s.stack ∧
  t.memory = s.memory ∧
  t.mdomain = s.mdomain ∧
  t.gc_fun = s.gc_fun ∧
  t.handler = s.handler ∧
  t.clock = s.clock ∧
  t.code = s.code ∧
  t.io = s.io`

(*tlocs is a supermap of slocs under f for everything in a given
  live set*)
val strong_locals_rel_def = Define`
  strong_locals_rel f ls slocs tlocs ⇔
  ∀n v.
    n ∈ ls ∧ lookup n slocs = SOME v ⇒
    lookup (f n) tlocs = SOME v`

val domain_numset_list_insert = store_thm("domain_numset_list_insert",``
  ∀ls locs.
  domain (numset_list_insert ls locs) = domain locs UNION set ls``,
  Induct>>fs[numset_list_insert_def]>>rw[]>>
  metis_tac[INSERT_UNION_EQ,UNION_COMM])

val strong_locals_rel_get_var = prove(``
  strong_locals_rel f live st.locals cst.locals ∧
  n ∈ live ∧
  get_var n st = SOME x
  ⇒
  get_var (f n) cst = SOME x``,
  fs[get_var_def,strong_locals_rel_def])

val strong_locals_rel_get_var_imm = prove(``
  strong_locals_rel f live st.locals cst.locals ∧
  (case n of Reg n => n ∈ live | _ => T) ∧
  get_var_imm n st = SOME x
  ⇒
  get_var_imm (apply_colour_imm f n) cst = SOME x``,
  Cases_on`n`>>fs[get_var_imm_def]>>
  metis_tac[strong_locals_rel_get_var])

val strong_locals_rel_get_vars = prove(``
  ∀ls y f live st cst.
  strong_locals_rel f live st.locals cst.locals ∧
  (∀x. MEM x ls ⇒ x ∈ live) ∧
  get_vars ls st = SOME y
  ⇒
  get_vars (MAP f ls) cst = SOME y``,
  Induct>>fs[get_vars_def]>>rw[]>>
  Cases_on`get_var h st`>>fs[]>>
  `h ∈ live` by fs[]>>
  imp_res_tac strong_locals_rel_get_var>>fs[]>>
  Cases_on`get_vars ls st`>>fs[]>>
  res_tac>>
  pop_assum(qspec_then`live` mp_tac)>>discharge_hyps
  >-metis_tac[]>>
  fs[])

val domain_FOLDR_delete = prove(``
  ∀ls live. domain (FOLDR delete live ls) =
  (domain live) DIFF (set ls)``,
  Induct>>
  fs[DIFF_INSERT,EXTENSION]>>
  metis_tac[])

val domain_FOLDR_union_subset = prove(``
  !ls a.
  MEM a ls ⇒
  domain (get_live_exp a) ⊆
  domain (FOLDR (λx y.union (get_live_exp x) y) LN ls)``,
  Induct>>rw[]>>fs[domain_union,SUBSET_UNION,SUBSET_DEF]>>
  metis_tac[])

val SUBSET_OF_INSERT = store_thm("SUBSET_OF_INSERT",
``!s x. s ⊆ x INSERT s``,
  rw[SUBSET_DEF])

val INJ_UNION = prove(
``!f A B.
  INJ f (A ∪ B) UNIV ⇒
  INJ f A UNIV ∧
  INJ f B UNIV``,
  rw[]>>
  metis_tac[INJ_SUBSET,SUBSET_DEF,SUBSET_UNION])

val size_tac= (fs[prog_size_def]>>DECIDE_TAC);

val apply_nummap_key_domain = prove(``
  ∀f names.
  domain (apply_nummap_key f names) =
  IMAGE f (domain names)``,
  fs[domain_def,domain_fromAList]>>
  fs[MEM_MAP,MAP_MAP_o,EXTENSION,EXISTS_PROD]>>
  metis_tac[MEM_toAList,domain_lookup])

val cut_env_lemma = store_thm("cut_env_lemma",``
  ∀names sloc tloc x f.
  INJ f (domain names) UNIV ∧
  cut_env names sloc = SOME x ∧
  strong_locals_rel f (domain names) sloc tloc
  ⇒
  ∃y. cut_env (apply_nummap_key f names) tloc = SOME y ∧
      domain y = IMAGE f (domain x) ∧
      strong_locals_rel f (domain names) x y ∧
      INJ f (domain x) UNIV ∧
      domain x = domain names``,
  rpt strip_tac>>
  fs[domain_inter,cut_env_def,apply_nummap_key_domain
    ,strong_locals_rel_def]>>
  CONJ_ASM1_TAC>-
    (fs[SUBSET_DEF,domain_lookup]>>rw[]>>metis_tac[])>>
  CONJ_ASM1_TAC>-
    (Q.ISPECL_THEN[`f`,`names`] assume_tac apply_nummap_key_domain>>
    fs[SUBSET_INTER_ABSORPTION,INTER_COMM]>>
    metis_tac[domain_inter])>>
  rw[]>-
    (rw[]>>fs[lookup_inter]>>
    Cases_on`lookup n sloc`>>fs[]>>
    Cases_on`lookup n names`>>fs[]>>
    res_tac>>
    imp_res_tac MEM_toAList>>
    fs[lookup_fromAList]>>
    EVERY_CASE_TAC>>
    fs[ALOOKUP_NONE,MEM_MAP,FORALL_PROD]>>metis_tac[])
  >>
    fs[domain_inter,SUBSET_INTER_ABSORPTION,INTER_COMM])

val LENGTH_list_rerrange = prove(``
  LENGTH (list_rearrange mover xs) = LENGTH xs``,
  fs[list_rearrange_def]>>
  IF_CASES_TAC>>fs[])

(*For any 2 lists that are permutations of each other,
  We can give a list_rearranger that permutes one to the other*)
val list_rearrange_perm = prove(``
  PERM xs ys
  ⇒
  ∃perm. list_rearrange perm xs = ys``,
  rw[]>>
  imp_res_tac PERM_BIJ>>fs[list_rearrange_def]>>
  qexists_tac`f`>>
  IF_CASES_TAC>>
  fs[BIJ_DEF,INJ_DEF]>>metis_tac[])

val GENLIST_MAP = prove(
  ``!k. (!i. i < LENGTH l ==> m i < LENGTH l) /\ k <= LENGTH l ==>
        GENLIST (\i. EL (m i) (MAP f l)) k =
        MAP f (GENLIST (\i. EL (m i) l) k)``,
  Induct \\ fs [GENLIST] \\ REPEAT STRIP_TAC
  \\ `k < LENGTH l /\ k <= LENGTH l` by DECIDE_TAC
  \\ fs [EL_MAP]);

val list_rearrange_MAP = store_thm ("list_rearrange_MAP",
  ``!l f m. list_rearrange m (MAP f l) = MAP f (list_rearrange m l)``,
  SRW_TAC [] [list_rearrange_def] \\ MATCH_MP_TAC GENLIST_MAP \\
  fs[BIJ_DEF,INJ_DEF]);


val ALL_DISTINCT_FST = prove(``
  ∀ls. ALL_DISTINCT (MAP FST ls) ⇒ ALL_DISTINCT ls``,
  Induct>>fs[FORALL_PROD,MEM_MAP])

(*Main theorem for permute oracle usage!
  This shows that we can push locals that are exactly matching using
  any desired permutation
  and we can choose the final permutation to be anything we want
  (In Alloc we choose it to be cst.permute, in Call something
   given by the IH)
*)

val env_to_list_perm = prove(``
  ∀tperm.
  domain y = IMAGE f (domain x) ∧
  INJ f (domain x) UNIV ∧
  strong_locals_rel f (domain x) x y
  ⇒
  let (l,permute) = env_to_list y perm in
  ∃perm'.
    let(l',permute') = env_to_list x perm' in
      permute' = tperm ∧ (*Just change the first permute*)
      MAP (λx,y.f x,y) l' = l``,
  rw[]>>
  fs[env_to_list_def,LET_THM,strong_locals_rel_def]>>
  qabbrev_tac `xls = QSORT key_val_compare (toAList x)`>>
  qabbrev_tac `yls = QSORT key_val_compare (toAList y)`>>
  qabbrev_tac `ls = list_rearrange (perm 0) yls`>>
  fs[(GEN_ALL o SYM o SPEC_ALL) list_rearrange_MAP]>>
  `PERM (MAP (λx,y.f x,y) xls) yls` by
    (match_mp_tac PERM_ALL_DISTINCT >>rw[]
    >-
      (match_mp_tac ALL_DISTINCT_MAP_INJ>>rw[]
      >-
        (fs[INJ_DEF,Abbr`xls`,QSORT_MEM]>>
        Cases_on`x'`>>Cases_on`y'`>>fs[]>>
        imp_res_tac MEM_toAList>>
        fs[domain_lookup])
      >>
      fs[Abbr`xls`]>>
      metis_tac[QSORT_PERM,ALL_DISTINCT_MAP_FST_toAList
               ,ALL_DISTINCT_FST,ALL_DISTINCT_PERM])
    >-
      metis_tac[QSORT_PERM,ALL_DISTINCT_MAP_FST_toAList
               ,ALL_DISTINCT_FST,ALL_DISTINCT_PERM]
    >>
      unabbrev_all_tac>>
      fs[QSORT_MEM,MEM_MAP]>>
      fs[EQ_IMP_THM]>>rw[]
      >-
        (Cases_on`y'`>>fs[MEM_toAList]>>metis_tac[domain_lookup])
      >>
        Cases_on`x'`>>fs[MEM_toAList]>>
        imp_res_tac domain_lookup>>
        fs[EXTENSION]>>res_tac>>
        qexists_tac`x',r`>>fs[]>>
        fs[MEM_toAList,domain_lookup]>>
        first_x_assum(qspecl_then[`x'`,`v'`] assume_tac)>>rfs[])
  >>
  `PERM yls ls` by
    (fs[list_rearrange_def,Abbr`ls`]>>
    qpat_assum`A=l` (SUBST1_TAC o SYM)>>
    IF_CASES_TAC>>fs[]>>
    match_mp_tac PERM_ALL_DISTINCT>>
    CONJ_ASM1_TAC>-
      metis_tac[QSORT_PERM,ALL_DISTINCT_MAP_FST_toAList
               ,ALL_DISTINCT_FST,ALL_DISTINCT_PERM]>>
    CONJ_ASM1_TAC>-
      (fs[ALL_DISTINCT_GENLIST]>>rw[]>>
      fs[EL_ALL_DISTINCT_EL_EQ]>>
      `perm 0 i = perm 0 i'` by
        (fs[BIJ_DEF,INJ_DEF]>>
        metis_tac[])>>
      fs[BIJ_DEF,INJ_DEF])
    >>
      fs[MEM_GENLIST,BIJ_DEF,INJ_DEF,SURJ_DEF]>>
      fs[MEM_EL]>>metis_tac[])>>
  imp_res_tac PERM_TRANS>>
  imp_res_tac list_rearrange_perm>>
  qexists_tac`λn. if n = 0:num then perm' else tperm (n-1)`>>
  fs[FUN_EQ_THM])

val mem_list_rearrange = store_thm("mem_list_rearrange",``
  ∀ls x f. MEM x (list_rearrange f ls) ⇔ MEM x ls``,
  fs[MEM_EL]>>rw[list_rearrange_def]>>
  imp_res_tac BIJ_IFF_INV>>
  fs[BIJ_DEF,INJ_DEF,SURJ_DEF]>>
  rw[EQ_IMP_THM]>>fs[EL_GENLIST]
  >- metis_tac[]>>
  qexists_tac `g n`>>fs[])

(*Proves s_val_eq and some extra conditions on the resulting lists*)
val push_env_s_val_eq = store_thm("push_env_s_val_eq",``
  ∀tperm.
  st.handler = cst.handler ∧
  st.stack = cst.stack ∧
  domain y = IMAGE f (domain x) ∧
  INJ f (domain x) UNIV ∧
  strong_locals_rel f (domain x) x y ∧
  (case b of NONE => b' = NONE
         |  SOME(w,h,l1,l2) =>
            (case b' of NONE => F
            |  SOME(a,b,c,d) => c = l1 ∧ d = l2))
  ⇒
  ?perm.
  (let (l,permute) = env_to_list y cst.permute in
  let(l',permute') = env_to_list x perm in
      permute' = tperm ∧
      MAP (λx,y.f x,y) l' = l ∧
      (∀x y. MEM x (MAP FST l') ∧ MEM y (MAP FST l')
        ∧ f x = f y ⇒ x = y) ) ∧
  s_val_eq (push_env x b (st with permute:=perm)).stack
           (push_env y b' cst).stack``,
  rw[]>>Cases_on`b`>>
  TRY(PairCases_on`x'`>>Cases_on`b'`>>fs[]>>PairCases_on`x'`>>fs[])>>
  (fs[push_env_def]>>
  imp_res_tac env_to_list_perm>>
  pop_assum(qspecl_then[`tperm`,`cst.permute`]assume_tac)>>fs[LET_THM]>>
  Cases_on`env_to_list y cst.permute`>>
  fs[]>>
  qexists_tac`perm'`>>
  Cases_on`env_to_list x perm'`>>
  fs[env_to_list_def,LET_THM]>>
  fs[s_val_eq_def,s_val_eq_refl]>>
  rw[]>-
    (fs[INJ_DEF,MEM_MAP]>>
    imp_res_tac mem_list_rearrange>>
    fs[QSORT_MEM]>>
    Cases_on`y'''`>>Cases_on`y''`>>fs[MEM_toAList]>>
    metis_tac[domain_lookup])>>
  fs[s_frame_val_eq_def]>>
  qpat_abbrev_tac `q = list_rearrange A
    (QSORT key_val_compare (toAList x))`>>
  `MAP SND (MAP (λx,y.f x,y) q) = MAP SND q` by
    (fs[MAP_MAP_o]>>AP_THM_TAC>>AP_TERM_TAC>>fs[FUN_EQ_THM]>>
    rw[]>>Cases_on`x'`>>fs[])>>
  metis_tac[]))

val INJ_less = prove(``
  INJ f s' UNIV ∧ s ⊆ s'
  ⇒
  INJ f s UNIV``,
  metis_tac[INJ_DEF,SUBSET_DEF])

(*TODO: Maybe move to props?
gc doesn't touch other components*)
val gc_frame = store_thm("gc_frame",``
  gc st = SOME st'
  ⇒
  st'.mdomain = st.mdomain ∧
  st'.gc_fun = st.gc_fun ∧
  st'.handler = st.handler ∧
  st'.clock = st.clock ∧
  st'.code = st.code ∧
  st'.locals = st.locals ∧
  st'.io = st.io ∧
  st'.permute = st.permute``,
  fs[gc_def,LET_THM]>>EVERY_CASE_TAC>>
  fs[state_component_equality])

val ZIP_MAP_FST_SND_EQ = prove(``
  ∀ls. ZIP (MAP FST ls,MAP SND ls) = ls``,
  Induct>>fs[])

(*Convenient rewrite for pop_env*)
val s_key_eq_val_eq_pop_env = store_thm("s_key_eq_val_eq_pop_env",``
  pop_env s = SOME s' ∧
  s_key_eq s.stack ((StackFrame ls opt)::keys) ∧
  s_val_eq s.stack vals
  ⇒
  ∃ls' rest.
  vals = StackFrame ls' opt :: rest ∧
  s'.locals = fromAList (ZIP (MAP FST ls,MAP SND ls')) ∧
  s_key_eq s'.stack keys ∧
  s_val_eq s'.stack rest ∧
  case opt of NONE => s'.handler = s.handler
            | SOME (h,l1,l2) => s'.handler = h``,
  strip_tac>>
  fs[pop_env_def]>>
  EVERY_CASE_TAC>>
  Cases_on`vals`>>
  fs[s_val_eq_def,s_key_eq_def]>>
  Cases_on`h`>>Cases_on`o'`>>
  fs[s_frame_key_eq_def,s_frame_val_eq_def]>>
  fs[state_component_equality]>>
  metis_tac[ZIP_MAP_FST_SND_EQ])

(*Less powerful form*)
val ALOOKUP_key_remap_2 = store_thm("ALOOKUP_key_remap_2",``
  ∀ls vals f.
    (∀x y. MEM x ls ∧ MEM y ls ∧ f x = f y ⇒ x = y) ∧
    LENGTH ls = LENGTH vals ∧
    ALOOKUP (ZIP (ls,vals)) n = SOME v
    ⇒
    ALOOKUP (ZIP (MAP f ls,vals)) (f n) = SOME v``,
  Induct>>rw[]>>
  Cases_on`vals`>>fs[]>>
  Cases_on`h=n`>>fs[]>>
  `MEM n ls` by
    (imp_res_tac ALOOKUP_MEM>>
    imp_res_tac MEM_ZIP>>
    fs[]>>
    metis_tac[MEM_EL])>>
  first_assum(qspecl_then[`h`,`n`] assume_tac)>>
  IF_CASES_TAC>>fs[])

val lookup_list_insert = store_thm("lookup_list_insert",
  ``!x (y:'a word_loc list) t (z:num). LENGTH x = LENGTH y ==>
    (lookup z (alist_insert x y t) =
    case ALOOKUP (ZIP(x,y)) z of SOME a => SOME a | NONE => lookup z t)``,
    ho_match_mp_tac alist_insert_ind>>
    rw[]>-
      (Cases_on`y`>>
      fs[LENGTH,alist_insert_def]) >>
    Cases_on`z=x`>>
      rw[lookup_def,alist_insert_def]>>
    fs[lookup_insert])

val strong_locals_rel_subset = prove(``
  s ⊆ s' ∧
  strong_locals_rel f s' st.locals cst.locals
  ⇒
  strong_locals_rel f s st.locals cst.locals``,
  rw[strong_locals_rel_def]>>
  metis_tac[SUBSET_DEF])

val env_to_list_keys = prove(``
  let (l,permute) = env_to_list x perm in
  set (MAP FST l) = domain x``,
  fs[LET_THM,env_to_list_def,EXTENSION,MEM_MAP,EXISTS_PROD]>>
  rw[EQ_IMP_THM]
  >-
    (imp_res_tac mem_list_rearrange>>
    fs[QSORT_MEM,MEM_toAList,domain_lookup])
  >>
    fs[mem_list_rearrange,QSORT_MEM,MEM_toAList,domain_lookup])

val list_rearrange_keys = store_thm("list_rearrange_keys",``
  list_rearrange perm ls = e ⇒
  set(MAP FST e) = set(MAP FST ls)``,
  fs[LET_THM,EXTENSION]>>rw[EQ_IMP_THM]>>
  metis_tac[MEM_toAList,mem_list_rearrange,MEM_MAP])

val push_env_pop_env_s_key_eq = store_thm("push_env_pop_env_s_key_eq",
  ``∀s t x b. s_key_eq (push_env x b s).stack t.stack ⇒
       ∃l ls opt.
              t.stack = (StackFrame l opt)::ls ∧
              ∃y. (pop_env t = SOME y ∧
                   y.locals = fromAList l ∧
                   domain x = domain y.locals ∧
                   s_key_eq s.stack y.stack)``,
  rw[]>>Cases_on`b`>>TRY(PairCases_on`x'`)>>fs[push_env_def]>>
  fs[LET_THM,env_to_list_def]>>Cases_on`t.stack`>>
  fs[s_key_eq_def,pop_env_def]>>BasicProvers.EVERY_CASE_TAC>>
  fs[domain_fromAList,s_frame_key_eq_def]>>
  qpat_assum `A = MAP FST l` (SUBST1_TAC o SYM)>>
  fs[EXTENSION,mem_list_rearrange,MEM_MAP,QSORT_MEM,MEM_toAList
    ,EXISTS_PROD,domain_lookup])

val pop_env_frame = store_thm("pop_env_frame",
  ``s_val_eq r'.stack st' ∧
    s_key_eq y'.stack y''.stack ∧
    pop_env (r' with stack:= st') = SOME y'' ∧
    pop_env r' = SOME y'
    ⇒
    word_state_eq_rel y' y''``,
    fs[pop_env_def]>>EVERY_CASE_TAC>>
    fs[s_val_eq_def,s_frame_val_eq_def,word_state_eq_rel_def
      ,state_component_equality]>>
    rw[]>>rfs[]>>
    metis_tac[s_val_and_key_eq])

val key_map_implies = store_thm("key_map_implies",
 ``MAP (λx,y.f x,y) l' = l
 ⇒ MAP f (MAP FST l') = MAP FST l``,
 rw[]>>match_mp_tac LIST_EQ>>
 rw[EL_MAP]>>
 Cases_on`EL x l'`>>fs[])

(*Main proof of liveness theorem starts here*)

val apply_colour_exp_lemma = prove(
  ``∀st w cst f res.
    word_exp st w = SOME res ∧
    word_state_eq_rel st cst ∧
    strong_locals_rel f (domain (get_live_exp w)) st.locals cst.locals
    ⇒
    word_exp cst (apply_colour_exp f w) = SOME res``,
  ho_match_mp_tac word_exp_ind>>rw[]>>
  fs[word_exp_def,apply_colour_exp_def,strong_locals_rel_def
    ,get_live_exp_def,word_state_eq_rel_def]
  >-
    (EVERY_CASE_TAC>>fs[])
  >-
    (Cases_on`word_exp st w`>>fs[]>>
    `mem_load x st = mem_load x cst` by
      fs[mem_load_def]>>fs[])
  >-
    (fs[LET_THM]>>
    `MAP (\a.word_exp st a) wexps =
     MAP (\a.word_exp cst a) (MAP (\a. apply_colour_exp f a) wexps)` by
       (simp[MAP_MAP_o] >>
       simp[MAP_EQ_f] >>
       gen_tac >>
       strip_tac >>
       first_assum(fn th => first_x_assum(mp_tac o C MATCH_MP th)) >>
       fs[EVERY_MEM,MEM_MAP,PULL_EXISTS
         ,miscTheory.IS_SOME_EXISTS] >>
       first_assum(fn th => first_x_assum(mp_tac o C MATCH_MP th)) >>
       strip_tac >>
       disch_then(qspecl_then[`cst`,`f`,`x`]mp_tac) >>
       discharge_hyps
       >-
         (fs[]>>
         imp_res_tac domain_FOLDR_union_subset>>
         rw[]>>
         metis_tac[SUBSET_DEF])>>
       fs[]) >>
     pop_assum(SUBST1_TAC o SYM) >>
     simp[EQ_SYM_EQ])
  >>
    EVERY_CASE_TAC>>fs[]>>res_tac>>fs[]>>
    metis_tac[])

val get_vars_length_lemma = store_thm("get_vars_length_lemma",
  ``!ls s y. get_vars ls s = SOME y ==>
           LENGTH y = LENGTH ls``,
  Induct>>fs[get_vars_def]>>
  Cases_on`get_var h s`>>fs[]>>
  Cases_on`get_vars ls s`>>fs[]>>
  metis_tac[LENGTH])

(*Frequently used tactics*)
val exists_tac = qexists_tac`cst.permute`>>
    fs[evaluate_def,LET_THM,word_state_eq_rel_def
      ,get_live_def,colouring_ok_def];

val exists_tac_2 =
    Cases_on`word_exp st e`>>fs[word_exp_perm]>>
    imp_res_tac apply_colour_exp_lemma>>
    pop_assum (qspecl_then[`f`,`cst`] mp_tac)>>
    discharge_hyps
    >-
      metis_tac[SUBSET_OF_INSERT,domain_union,SUBSET_UNION
               ,strong_locals_rel_subset];

val setup_tac = Cases_on`word_exp st exp`>>fs[]>>
      imp_res_tac apply_colour_exp_lemma>>
      pop_assum(qspecl_then[`f`,`cst`]mp_tac)>>unabbrev_all_tac;

(*liveness theorem*)
val evaluate_apply_colour = store_thm("evaluate_apply_colour",
``∀prog st cst f live.
  colouring_ok f prog live ∧
  word_state_eq_rel st cst ∧
  strong_locals_rel f (domain (get_live prog live)) st.locals cst.locals
  ⇒
  ∃perm'.
  let (res,rst) = evaluate(prog,st with permute:=perm') in
  if (res = SOME Error) then T else
  let (res',rcst) = evaluate(apply_colour f prog,cst) in
    res = res' ∧
    word_state_eq_rel rst rcst ∧
    (case res of
      NONE => strong_locals_rel f (domain live)
              rst.locals rcst.locals
    | _    => T )``,
  (*Induct on size of program*)
  completeInduct_on`prog_size (K 0) prog`>>
  rpt strip_tac>>
  fs[PULL_FORALL,evaluate_def]>>
  Cases_on`prog`
  >- (*Skip*)
    exists_tac
  >- (*Move*)
    (exists_tac>>
    fs[MAP_ZIP,get_writes_def,domain_union,domain_numset_list_insert]>>
    Cases_on`ALL_DISTINCT (MAP FST l)`>>fs[]>>
    `ALL_DISTINCT (MAP f (MAP FST l))` by
      (match_mp_tac ALL_DISTINCT_MAP_INJ>>rw[]>>
      FULL_SIMP_TAC bool_ss [INJ_DEF]>>
      first_x_assum(qspecl_then[`x`,`y`] assume_tac)>>
      simp[])>>
    fs[MAP_MAP_o,get_vars_perm] >>
    Cases_on`get_vars (MAP SND l) st`>>fs[]>>
    `get_vars (MAP f (MAP SND l)) cst = SOME x` by
      (imp_res_tac strong_locals_rel_get_vars>>
      first_x_assum(qspec_then `MAP SND ls` mp_tac)>>fs[])>>
    fs[set_vars_def,MAP_MAP_o]>>
    fs[strong_locals_rel_def]>>rw[]>>
    `LENGTH l = LENGTH x` by
      metis_tac[LENGTH_MAP,get_vars_length_lemma]>>
    fs[lookup_list_insert]>>
    Cases_on`ALOOKUP (ZIP (MAP FST l,x)) n'`>>fs[]
    >-
    (*NONE:
      Therefore n is not in l but it is in live and so it is not deleted
     *)
      (`n' ∈ domain (FOLDR delete live (MAP FST l))` by
        (fs[domain_FOLDR_delete]>>
        fs[ALOOKUP_NONE]>>rfs[MAP_ZIP])>>
      EVERY_CASE_TAC>>fs[]>>
      imp_res_tac ALOOKUP_MEM>>
      pop_assum mp_tac>>
      fs[MEM_ZIP]>>strip_tac>>
      rfs[EL_MAP,ALOOKUP_NONE]>>
      rfs[MAP_ZIP]>>
      `n' = FST (EL n'' l)` by
        (FULL_SIMP_TAC bool_ss [INJ_DEF]>>
        first_assum(qspecl_then[`n'`,`FST (EL n'' l)`] mp_tac)>>
        discharge_hyps>-
          (rw[]>>DISJ1_TAC>>
          metis_tac[MEM_MAP,MEM_EL])>>
        metis_tac[])>>
      metis_tac[MEM_EL,MEM_MAP])
    >>
      imp_res_tac ALOOKUP_MEM>>
      `ALOOKUP (ZIP (MAP (f o FST) l ,x)) (f n') = SOME v'` by
        (match_mp_tac ALOOKUP_ALL_DISTINCT_MEM>>
        pop_assum mp_tac>>
        fs[MAP_ZIP,MEM_ZIP,LENGTH_MAP]>>strip_tac>>fs[]>>
        HINT_EXISTS_TAC>>fs[EL_MAP])>>
      fs[])
  >- (*Inst*)
    (exists_tac>>
    Cases_on`i`>> (TRY (Cases_on`a`))>> (TRY(Cases_on`m`))>>
    fs[get_live_def,get_live_inst_def,inst_def,assign_def
      ,word_exp_perm]
    >-
      (Cases_on`word_exp st (Const c)`>>
      fs[word_exp_def,set_var_def,strong_locals_rel_def,get_writes_def
        ,get_writes_inst_def,domain_union,lookup_insert]>>
      rw[]>>
      FULL_SIMP_TAC bool_ss [INJ_DEF]>>
      first_x_assum(qspecl_then [`n'`,`n`] assume_tac)>>fs[])
    >-
      (Cases_on`r`>>fs[]>>
      qpat_abbrev_tac `exp = (Op b [Var n0;B])`>>setup_tac>>
      (discharge_hyps
      >-
        (fs[get_live_exp_def,domain_union]>>
        `{n0} ⊆ (n0 INSERT domain live DELETE n)` by fs[SUBSET_DEF]>>
        TRY(`{n0} ∪ {n'} ⊆ (n0 INSERT n' INSERT domain live DELETE n)` by
          fs[SUBSET_DEF])>>
        metis_tac[strong_locals_rel_subset])
      >>
      fs[apply_colour_exp_def,word_state_eq_rel_def]>>
      fs[set_var_def,strong_locals_rel_def,lookup_insert,get_writes_def
        ,get_writes_inst_def]>>
      rw[]>>
      TRY(qpat_abbrev_tac `n''=n'`)>>
      Cases_on`n''=n`>>fs[]>>
      `f n'' ≠ f n` by
        (fs[domain_union]>>
        FULL_SIMP_TAC bool_ss [INJ_DEF]>>
        first_x_assum(qspecl_then[`n''`,`n`] mp_tac)>>
        discharge_hyps>-
          rw[]>>
        metis_tac[])>>
      fs[]))
    >-
      (qpat_abbrev_tac`exp = (Shift s (Var n0) B)`>>
      setup_tac>>
      discharge_hyps>-
        (fs[get_live_exp_def]>>
        `{n0} ⊆ n0 INSERT domain live DELETE n` by fs[SUBSET_DEF]>>
        metis_tac[SUBSET_OF_INSERT,strong_locals_rel_subset])>>
      fs[word_exp_def,word_state_eq_rel_def,set_var_def]>>
      Cases_on`lookup n0 st.locals`>>fs[strong_locals_rel_def]>>
      res_tac>>
      fs[lookup_insert]>>
      rw[]>>
      Cases_on`n=n'`>>fs[]>>
      `f n' ≠ f n` by
        (fs[domain_union,get_writes_inst_def,get_writes_def]>>
        FULL_SIMP_TAC bool_ss [INJ_DEF]>>
        first_x_assum(qspecl_then[`n'`,`n`]mp_tac)>>
        discharge_hyps>-rw[]>>
        metis_tac[])>>
      fs[])
    >-
      (qpat_abbrev_tac`exp=(Load (Op Add [Var n';A]))`>>
      setup_tac>>
      discharge_hyps>-
        (fs[get_live_exp_def]>>
        `{n'} ⊆ n' INSERT domain live DELETE n` by fs[SUBSET_DEF]>>
        metis_tac[strong_locals_rel_subset])>>
      fs[word_state_eq_rel_def,LET_THM,set_var_def]>>
      rw[strong_locals_rel_def]>>
      fs[lookup_insert]>>
      Cases_on`n''=n`>>fs[]>>
      `f n'' ≠ f n` by
        (fs[domain_union,get_writes_def,get_writes_inst_def]>>
        FULL_SIMP_TAC bool_ss [INJ_DEF]>>
        first_x_assum(qspecl_then[`n''`,`n`]mp_tac)>>
        discharge_hyps>-rw[]>>
        metis_tac[])>>
      fs[strong_locals_rel_def])
    >>
      (qpat_abbrev_tac`exp=Op Add [Var n';A]`>>
      setup_tac>>
      discharge_hyps>-
        (fs[get_live_exp_def]>>
        `{n'} ⊆ n' INSERT n INSERT domain live` by fs[SUBSET_DEF]>>
        metis_tac[strong_locals_rel_subset])>>
      fs[word_state_eq_rel_def,LET_THM,set_var_def]>>
      rw[get_var_perm]>>
      Cases_on`get_var n st`>>fs[]>>
      imp_res_tac strong_locals_rel_get_var>>
      Cases_on`mem_store x x' st`>>fs[mem_store_def,strong_locals_rel_def]))
  >- (*Assign*)
    (exists_tac>>exists_tac_2>>
    rw[word_state_eq_rel_def,set_var_perm,set_var_def]>>
    fs[strong_locals_rel_def]>>rw[]>>
    fs[lookup_insert]>>Cases_on`n=n'`>>fs[get_writes_def]>>
    `f n' ≠ f n` by
      (FULL_SIMP_TAC bool_ss [INJ_DEF]>>
      first_x_assum(qspecl_then [`n`,`n'`] mp_tac)>>
      rw[domain_union,domain_delete])>>
    fs[domain_union])
  >- (*Get*)
    (exists_tac>>
    EVERY_CASE_TAC>>
    fs[colouring_ok_def,set_var_def,strong_locals_rel_def,get_live_def]>>
    fs[LET_THM,get_writes_def]>>rw[]>>
    fs[lookup_insert]>>Cases_on`n'=n`>>fs[]>>
    `f n' ≠ f n` by
      (FULL_SIMP_TAC bool_ss [INJ_DEF,domain_union,domain_insert]>>
      first_x_assum(qspecl_then[`n`,`n'`] assume_tac)>>
      rfs[])>>
    fs[])
  >- (*Set*)
    (exists_tac>>exists_tac_2>>
    rw[]>>
    rfs[set_store_def,word_state_eq_rel_def,get_var_perm]>>
    metis_tac[SUBSET_OF_INSERT,strong_locals_rel_subset
             ,domain_union,SUBSET_UNION])
  >-
    (*Store*)
    (exists_tac>>exists_tac_2>>
    rw[]>>
    rfs[set_store_def,word_state_eq_rel_def,get_var_perm]>>
    Cases_on`get_var n st`>>fs[]>>
    imp_res_tac strong_locals_rel_get_var>>
    fs[mem_store_def]>>
    EVERY_CASE_TAC>>fs[]>>
    metis_tac[SUBSET_OF_INSERT,strong_locals_rel_subset
             ,domain_union,SUBSET_UNION])
  >- (*Call*)
    (fs[evaluate_def,LET_THM,colouring_ok_def,get_live_def,get_vars_perm]>>
    Cases_on`get_vars l st`>>fs[]>>
    imp_res_tac strong_locals_rel_get_vars>>
    pop_assum kall_tac>>
    pop_assum mp_tac>>discharge_hyps>-
      (rw[domain_numset_list_insert]>>
      EVERY_CASE_TAC>>fs[domain_numset_list_insert,domain_union])>>
    pop_assum kall_tac>>rw[]>>
    Cases_on`find_code o1 x st.code`>>fs[word_state_eq_rel_def]>>
    Cases_on`x'`>>fs[]>>
    FULL_CASE_TAC
    >-
    (*Tail call*)
      (Cases_on`o0`>>fs[]>>
      qexists_tac`cst.permute`>>fs[]>>
      Cases_on`st.clock=0`>-fs[call_env_def]>>
      fs[]>>
      `call_env q (dec_clock cst) =
       call_env q (dec_clock(st with permute:= cst.permute))` by
        fs[call_env_def,dec_clock_def,state_component_equality]>>
      rfs[]>>EVERY_CASE_TAC>>
      fs[])
    >>
    (*Returning calls*)
    PairCases_on`x'`>>fs[]>>
    Cases_on`cut_env x'1 st.locals`>>fs[]>>
    imp_res_tac cut_env_lemma>>
    pop_assum kall_tac>>
    pop_assum (qspecl_then [`cst.locals`,`f`] mp_tac)>>
    discharge_hyps>-
      fs[strong_locals_rel_def,domain_union]>>
    discharge_hyps>-
      (fs[colouring_ok_def,LET_THM,domain_union]>>
      `domain x'1 ⊆ x'0 INSERT domain x'1` by fs[SUBSET_DEF]>>
      metis_tac[SUBSET_UNION,INJ_less,INSERT_UNION_EQ])>>
    rw[]>>fs[]>>
    Cases_on`st.clock=0`>>fs[call_env_def]>>
    qpat_abbrev_tac`f_o0=
      case o0 of NONE => NONE
      | SOME (v,prog,l1,l2) => SOME (f v,apply_colour f prog,l1,l2)`>>
    Q.ISPECL_THEN[
      `y`,`x'`,`st with clock := st.clock-1`,
      `f`,`cst with clock := st.clock-1`,`f_o0`,`o0`,`λn. cst.permute (n+1)`]
      mp_tac (GEN_ALL push_env_s_val_eq)>>
    discharge_hyps>-
      (rfs[LET_THM,Abbr`f_o0`]>>EVERY_CASE_TAC>>fs[])>>
    rw[]>>
    rfs[LET_THM,env_to_list_def,dec_clock_def]>>
    qabbrev_tac `envx = push_env x' o0
            (st with <|permute := perm; clock := st.clock − 1|>) with
          locals := fromList2 (Loc x'3 x'4::q)`>>
    qpat_abbrev_tac `envy = (push_env y A B) with locals := C`>>
    assume_tac evaluate_stack_swap>>
    pop_assum(qspecl_then [`r`,`envx`] mp_tac)>>
    ntac 2 FULL_CASE_TAC>-
      (rw[]>>qexists_tac`perm`>>fs[dec_clock_def])>>
    `envx with stack := envy.stack = envy` by
      (unabbrev_all_tac>>
      Cases_on`o0`>>TRY(PairCases_on`x'''`)>>
      fs[push_env_def,state_component_equality]>>
      fs[LET_THM,env_to_list_def,dec_clock_def])>>
    `s_val_eq envx.stack envy.stack` by
      (unabbrev_all_tac>>
       fs[state_component_equality])>>
    FULL_CASE_TAC
    >-
    (*Result*)
    (strip_tac>>pop_assum(qspec_then`envy.stack` mp_tac)>>
    discharge_hyps>-
      (unabbrev_all_tac>>
       fs[state_component_equality,dec_clock_def])>>
    strip_tac>>fs[]>>
    rfs[]>>
    IF_CASES_TAC>>fs[]>-
      (qexists_tac`perm`>>fs[])>>
    (*Backwards chaining*)
    fs[Abbr`envy`,Abbr`envx`,state_component_equality]>>
    Q.ISPECL_THEN [`(cst with clock := st.clock-1)`,
                  `r' with stack := st'`,`y`,`f_o0`]
                  mp_tac push_env_pop_env_s_key_eq>>
    discharge_hyps>-
      (unabbrev_all_tac>>fs[])>>
    Q.ISPECL_THEN [`(st with <|permute:=perm;clock := st.clock-1|>)`,
                  `r'`,`x'`,`o0`]
                  mp_tac push_env_pop_env_s_key_eq>>
    discharge_hyps>-
      (unabbrev_all_tac>>fs[])>>
    ntac 2 strip_tac>>
    rfs[]>>
    (*Now we can finally use the IH*)
    last_x_assum(qspecl_then[`x'2`,`set_var x'0 w0 y'`
                            ,`set_var (f x'0) w0 y''`,`f`,`live`]mp_tac)>>
    discharge_hyps>-size_tac>>
    fs[colouring_ok_def]>>
    discharge_hyps>-
      (Cases_on`o0`>>TRY(PairCases_on`x''`)>>fs[]>>
      unabbrev_all_tac>>
      fs[set_var_def,state_component_equality]>>
      `s_key_eq y'.stack y''.stack` by
        metis_tac[s_key_eq_trans,s_key_eq_sym]>>
      assume_tac pop_env_frame>>rfs[word_state_eq_rel_def]>>
      fs[colouring_ok_def,LET_THM,strong_locals_rel_def]>>
      rw[]>>
      fs[push_env_def,LET_THM,env_to_list_def]>>
      fs[s_key_eq_def,s_val_eq_def]>>
      Cases_on`opt`>>TRY(PairCases_on`x''`)>>
      Cases_on`opt'`>>TRY(PairCases_on`x''`)>>
      fs[s_frame_key_eq_def,s_frame_val_eq_def]>>
      Cases_on`n=x'0`>>
      fs[lookup_insert]>>
      `f n ≠ f x'0` by
        (imp_res_tac domain_lookup>>
        fs[domain_fromAList]>>
        (*some assumption movements to make this faster*)
        qpat_assum `INJ f (x'0 INSERT A) B` mp_tac>>
        rpt (qpat_assum `INJ f A B` kall_tac)>>
        strip_tac>>
        FULL_SIMP_TAC bool_ss [INJ_DEF]>>
        pop_assum(qspecl_then [`n`,`x'0`] mp_tac)>>
        rw[domain_union])>>
      fs[lookup_fromAList]>>
      imp_res_tac key_map_implies>>
      rfs[]>>
      `l'' = ZIP(MAP FST l'',MAP SND l'')` by fs[ZIP_MAP_FST_SND_EQ]>>
      pop_assum SUBST1_TAC>>
      pop_assum (SUBST1_TAC o SYM)>>
      match_mp_tac ALOOKUP_key_remap_2>>
      fs[]>>CONJ_TAC>>
      metis_tac[LENGTH_MAP,ZIP_MAP_FST_SND_EQ])>>
    strip_tac>>
    qspecl_then[`r`,`push_env x' o0
            (st with <|permute := perm; clock := st.clock − 1|>) with
          locals := fromList2 (Loc x'3 x'4::q)`,`perm'`]
      assume_tac permute_swap_lemma>>
    rfs[LET_THM]>>
    (*"Hot-swap" the suffix of perm, maybe move into lemma*)
    qexists_tac`λn. if n = 0:num then perm 0 else perm'' (n-1)`>>
    qpat_abbrev_tac `env1 = push_env A B C with locals := D`>>
    qpat_assum `A = (SOME B,C)` mp_tac>>
    qpat_abbrev_tac `env2 = push_env A B C with
                    <|locals:=D; permute:=E|>`>>
    strip_tac>>
    Cases_on`o0`>>TRY(PairCases_on`x''`)>>fs[]>>
    `env1 = env2` by
      (unabbrev_all_tac>>
      simp[push_env_def,LET_THM,env_to_list_def
        ,state_component_equality,FUN_EQ_THM])>>
    fs[pop_env_perm,set_var_perm]>>
    EVERY_CASE_TAC>>fs[])
    >-
    (*Exceptions*)
    (fs[]>>strip_tac>>
    imp_res_tac s_val_eq_LAST_N_exists>>
    first_x_assum(qspecl_then[`envy.stack`,`e'`,`ls'`] assume_tac)>>
    rfs[]>>
    Cases_on`o0`
    >-
      (*No handler*)
      (fs[Abbr`f_o0`]>>
      qexists_tac`perm`>>
      `ls=ls'` by
        (unabbrev_all_tac>>
        fs[push_env_def,env_to_list_def,LET_THM]>>
        Cases_on`st.handler < LENGTH st.stack`
        >-
          (imp_res_tac LAST_N_TL>>
          rfs[]>>fs[])
        >>
          `st.handler = LENGTH st.stack` by DECIDE_TAC>>
          rpt (qpat_assum `LAST_N A B = C` mp_tac)>-
          simp[LAST_N_LENGTH_cond])>>
      rfs[]>>
      metis_tac[s_val_and_key_eq,s_key_eq_sym,s_key_eq_trans])
    >>
      (*Handler*)
      PairCases_on`x''`>>fs[]>>
      unabbrev_all_tac>>
      fs[push_env_def,LET_THM,env_to_list_def]>>
      IF_CASES_TAC>-
        (qexists_tac`perm`>>fs[])>>
      rpt (qpat_assum `LAST_N A B = C` mp_tac)>>
      simp[LAST_N_LENGTH_cond]>>
      rpt strip_tac>>
      fs[domain_fromAList]>>
      imp_res_tac list_rearrange_keys>>
      `set (MAP FST lss') = domain y` by
        (qpat_assum`A=MAP FST lss'` (SUBST1_TAC o SYM)>>
        fs[EXTENSION]>>rw[EXISTS_PROD]>>
        simp[MEM_MAP,QSORT_MEM]>>rw[EQ_IMP_THM]
        >-
          (Cases_on`y'`>>
          fs[MEM_toAList]>>
          imp_res_tac domain_lookup>>
          metis_tac[])
        >>
          fs[EXISTS_PROD,MEM_toAList]>>
          metis_tac[domain_lookup])>>
      `domain x' = set (MAP FST lss)` by
        (qpat_assum `A = MAP FST lss` (SUBST1_TAC o SYM)>>
          fs[EXTENSION,MEM_MAP,QSORT_MEM,MEM_toAList
            ,EXISTS_PROD,domain_lookup])>>
      fs[]>>
      qpat_abbrev_tac `cr'=r' with<|locals:= A;stack:=B;handler:=C|>`>>
      (*Use the IH*)
      last_x_assum(qspecl_then[`x''1`,`set_var x''0 w0 r'`
                            ,`set_var (f x''0) w0 cr'`,`f`,`live`]mp_tac)>>
      discharge_hyps>-size_tac>>
      fs[colouring_ok_def]>>
      discharge_hyps>-
      (fs[set_var_def,state_component_equality,Abbr`cr'`]>>
      fs[colouring_ok_def,LET_THM,strong_locals_rel_def]>>
      rw[]>-metis_tac[s_key_eq_trans,s_val_and_key_eq]>>
      Cases_on`n' = x''0`>>fs[lookup_insert]>>
      `f n' ≠ f x''0` by
        (imp_res_tac domain_lookup>>
        fs[domain_fromAList]>>
        qpat_assum `INJ f (q' INSERT A) B` mp_tac>>
        qpat_assum `INJ f A B` kall_tac>>
        `n' ∈ set (MAP FST lss)` by fs[]>>
        FULL_SIMP_TAC bool_ss [INJ_DEF]>>
        strip_tac>>pop_assum(qspecl_then [`n'`,`x''0`] mp_tac)>>
        rw[domain_union]>>
        metis_tac[])>>
      fs[lookup_fromAList]>>
      imp_res_tac key_map_implies>>
      rfs[]>>
      `lss' = ZIP(MAP FST lss',MAP SND lss')` by fs[ZIP_MAP_FST_SND_EQ]>>
      pop_assum SUBST1_TAC>>
      pop_assum (SUBST1_TAC o SYM)>>
      match_mp_tac ALOOKUP_key_remap_2>>
      fs[]>>CONJ_TAC>>
      metis_tac[LENGTH_MAP,ZIP_MAP_FST_SND_EQ])>>
      rw[]>>
      qspecl_then[`r`,`st with <|locals := fromList2 (Loc x'3 x'4::q);
            stack :=
            StackFrame (list_rearrange (perm 0)
              (QSORT key_val_compare ( (toAList x'))))
              (SOME (r'.handler,x''2,x''3))::st.stack;
            permute := (λn. perm (n + 1)); handler := LENGTH st.stack;
            clock := st.clock − 1|>`,`perm'`]
        assume_tac permute_swap_lemma>>
      rfs[LET_THM]>>
      (*"Hot-swap" the suffix of perm, maybe move into lemma*)
      qexists_tac`λn. if n = 0:num then perm 0 else perm'' (n-1)`>>
      `(λn. perm'' n) = perm''` by fs[FUN_EQ_THM]>>
      `domain (fromAList lss) = domain x'1` by
        metis_tac[domain_fromAList]>>
      fs[set_var_perm])
    >>
    (*The rest*)
    rw[]>>qexists_tac`perm`>>fs[]>>
    TRY(pop_assum(qspec_then`envy.stack` mp_tac)>>
      discharge_hyps>-
      (unabbrev_all_tac>>fs[state_component_equality])>>
      rw[]>>fs[]>>NO_TAC)>>
    (*FFIError*)
    cheat)
   >- (*Seq*)
    (rw[]>>fs[evaluate_def,colouring_ok_def,LET_THM,get_live_def]>>
    last_assum(qspecl_then[`p`,`st`,`cst`,`f`,`get_live p0 live`]
      mp_tac)>>
    discharge_hyps>-size_tac>>
    rw[]>>
    Cases_on`evaluate(p,st with permute:=perm')`>>fs[]
    >- (qexists_tac`perm'`>>fs[]) >>
    Cases_on`evaluate(apply_colour f p,cst)`>>fs[]>>
    REVERSE (Cases_on`q`)>>fs[]
    >-
      (qexists_tac`perm'`>>rw[])
    >>
    first_assum(qspecl_then[`p0`,`r`,`r'`,`f`,`live`] mp_tac)>>
    discharge_hyps>- size_tac>>
    rw[]>>
    qspecl_then[`p`,`st with permute:=perm'`,`perm''`]
      assume_tac permute_swap_lemma>>
    rfs[LET_THM]>>
    qexists_tac`perm'''`>>rw[]>>fs[])
  >- (*If*)
    (fs[evaluate_def,colouring_ok_def,LET_THM,get_live_def]>>
    fs[get_var_perm]>>
    Cases_on`get_var n st`>>fs[]>>imp_res_tac strong_locals_rel_get_var>>
    pop_assum kall_tac>>pop_assum mp_tac>>discharge_hyps>-
      (FULL_CASE_TAC>>fs[])
    >>
    rw[]>>
    Cases_on`x`>>fs[]>>
    fs[get_var_imm_perm]>>
    Cases_on`get_var_imm r st`>>fs[]>>
    imp_res_tac strong_locals_rel_get_var_imm>>
    pop_assum kall_tac>>pop_assum mp_tac>>discharge_hyps>-
      (Cases_on`r`>>fs[])>>
    Cases_on`x`>>rw[]>>fs[]
    >-
     (first_assum(qspecl_then[`p`,`st`,`cst`,`f`,`live`] mp_tac)>>
      discharge_hyps>- size_tac>>
      discharge_hyps>-
        (Cases_on`r`>>
        fs[domain_insert,domain_union]>>
        metis_tac[SUBSET_OF_INSERT,SUBSET_UNION,strong_locals_rel_subset])>>
      rw[]>>
      qspecl_then[`w`,`st with permute:=perm'`,`perm''`]
        assume_tac permute_swap_lemma>>
      rfs[LET_THM]>>
      qexists_tac`perm'''`>>rw[get_var_perm]>>fs[])
    >>
      (first_assum(qspecl_then[`p0`,`st`,`cst`,`f`,`live`] mp_tac)>>
      discharge_hyps>- size_tac>>
      discharge_hyps>-
        (Cases_on`r`>>fs[domain_insert,domain_union]>>
        metis_tac[SUBSET_OF_INSERT,SUBSET_UNION,strong_locals_rel_subset])>>
      rw[]>>
      qspecl_then[`p`,`st with permute:=perm'`,`perm''`]
        assume_tac permute_swap_lemma>>
      rfs[LET_THM]>>
      qexists_tac`perm'''`>>rw[get_var_perm]>>fs[]))
  >- (*Alloc*)
    (fs[evaluate_def,colouring_ok_def,get_var_perm,get_live_def]>>
    Cases_on`get_var n st`>>fs[LET_THM]>>
    imp_res_tac strong_locals_rel_get_var>>fs[]>>
    Cases_on`x`>>fs[alloc_def]>>
    Cases_on`cut_env s st.locals`>>fs[]>>
    `domain s ⊆ (n INSERT domain s)` by fs[SUBSET_DEF]>>
    imp_res_tac strong_locals_rel_subset>>
    imp_res_tac cut_env_lemma>>
    pop_assum mp_tac>>discharge_hyps
    >-
      (match_mp_tac (GEN_ALL INJ_less)>>metis_tac[])
    >>
    rw[]>>fs[set_store_def]>>
    assume_tac (GEN_ALL push_env_s_val_eq)>>
    pop_assum (qspecl_then[
      `y`,`x`,`st with store:= st.store |+ (AllocSize,Word c)`,
      `f`,`cst with store:= cst.store |+ (AllocSize,Word c)`,`NONE`,`NONE`,
      `cst.permute`]assume_tac)>>
    rfs[word_state_eq_rel_def]>>
    qexists_tac`perm`>>fs[]>>
    qpat_abbrev_tac `st' = push_env x NONE A`>>
    qpat_abbrev_tac `cst' = push_env y NONE B`>>
    Cases_on`gc st'`>>fs[]>>
    qspecl_then [`st'`,`cst'`,`x'`] mp_tac gc_s_val_eq_gen>>
    discharge_hyps_keep>-
      (unabbrev_all_tac>>
      fs[push_env_def,LET_THM,env_to_list_def,word_state_eq_rel_def]>>
      rfs[])
    >>
    rw[]>>simp[]>>
    unabbrev_all_tac>>
    imp_res_tac gc_frame>>
    imp_res_tac push_env_pop_env_s_key_eq>>
    Cases_on`pop_env x'`>>fs[]>>
    `strong_locals_rel f (domain live) x''.locals y'.locals ∧
     word_state_eq_rel x'' y'` by
      (imp_res_tac gc_s_key_eq>>
      fs[push_env_def,LET_THM,env_to_list_def]>>
      ntac 2(pop_assum mp_tac>>simp[Once s_key_eq_sym])>>
      ntac 2 strip_tac>>
      rpt (qpat_assum `s_key_eq A B` mp_tac)>>
      qpat_abbrev_tac `lsA = list_rearrange (cst.permute 0)
        (QSORT key_val_compare ( (toAList y)))`>>
      qpat_abbrev_tac `lsB = list_rearrange (perm 0)
        (QSORT key_val_compare ( (toAList x)))`>>
      ntac 4 strip_tac>>
      Q.ISPECL_THEN [`x'.stack`,`y'`,`t'`,`NONE:(num#num#num) option`
        ,`lsA`,`cst.stack`] mp_tac (GEN_ALL s_key_eq_val_eq_pop_env)>>
      discharge_hyps
      >-
        (fs[]>>metis_tac[s_key_eq_sym,s_val_eq_sym])
      >>
      Q.ISPECL_THEN [`t'.stack`,`x''`,`x'`,`NONE:(num#num#num) option`
        ,`lsB`,`st.stack`] mp_tac (GEN_ALL s_key_eq_val_eq_pop_env)>>
      discharge_hyps
      >-
        (fs[]>>metis_tac[s_key_eq_sym,s_val_eq_sym])
      >>
      rw[]
      >-
        (simp[]>>
        fs[strong_locals_rel_def,lookup_fromAList]>>
        `MAP SND l = MAP SND ls'` by
          fs[s_val_eq_def,s_frame_val_eq_def]>>
        rw[]>>
        `MAP FST (MAP (λ(x,y). (f x,y)) lsB) =
         MAP f (MAP FST lsB)` by
          fs[MAP_MAP_o,MAP_EQ_f,FORALL_PROD]>>
        fs[]>>
        match_mp_tac ALOOKUP_key_remap_2>>rw[]>>
        metis_tac[s_key_eq_def,s_frame_key_eq_def,LENGTH_MAP])
      >>
        fs[word_state_eq_rel_def,pop_env_def]>>
        rfs[state_component_equality]>>
        metis_tac[s_val_and_key_eq,s_key_eq_sym
          ,s_val_eq_sym,s_key_eq_trans])>>
    fs[word_state_eq_rel_def]>>FULL_CASE_TAC>>fs[has_space_def]>>
    Cases_on`x'''`>>
    EVERY_CASE_TAC>>fs[call_env_def])
    >-
      (exists_tac>>
      Cases_on`get_var n st`>>fs[get_var_perm]>>
      imp_res_tac strong_locals_rel_get_var>>fs[jump_exc_def]>>
      EVERY_CASE_TAC>>fs[])
    >-
      (exists_tac>>
      Cases_on`get_var n st`>>fs[get_var_perm]>>
      Cases_on`get_var n0 st`>>fs[get_var_perm]>>
      imp_res_tac strong_locals_rel_get_var>>
      fs[call_env_def])
    >>
      (exists_tac>>IF_CASES_TAC>>fs[call_env_def,dec_clock_def]))

(*Prove that we can substitute get_clash_sets for get_live*)

(*hd element is just get_live*)
val get_clash_sets_hd = prove(
``∀prog live hd ls.
  get_clash_sets prog live = (hd,ls) ⇒
  get_live prog live = hd``,
  Induct>>rw[get_clash_sets_def]>>fs[LET_THM]
  >-
    (Cases_on`o'`>>fs[get_clash_sets_def,LET_THM]>>
    PairCases_on`x`>>fs[get_clash_sets_def,get_live_def]>>
    fs[LET_THM,UNCURRY]>>
    EVERY_CASE_TAC>>fs[])
  >-
    (Cases_on`get_clash_sets prog' live`>>fs[]>>
    Cases_on`get_clash_sets prog q`>>fs[]>>
    metis_tac[get_live_def])
  >>
    Cases_on`get_clash_sets prog live`>>
    Cases_on`get_clash_sets prog' live`>>
    fs[get_live_def,LET_THM]>>metis_tac[])

(*The liveset passed in at the back is always satisfied*)
val get_clash_sets_tl = prove(
``∀prog live f.
  let (hd,ls) = get_clash_sets prog live in
  EVERY (λs. INJ f (domain s) UNIV) ls ⇒
  INJ f (domain live) UNIV``,
  completeInduct_on`prog_size (K 0) prog`>>
  fs[PULL_FORALL]>>
  rpt strip_tac>>
  Cases_on`prog`>>
  fs[colouring_ok_alt_def,LET_THM,get_clash_sets_def,get_live_def]>>
  fs[get_writes_def]
  >- metis_tac[INJ_UNION,domain_union,INJ_SUBSET,SUBSET_UNION]
  >- metis_tac[INJ_UNION,domain_union,INJ_SUBSET,SUBSET_UNION]
  >- metis_tac[INJ_UNION,domain_union,INJ_SUBSET,SUBSET_UNION]
  >- metis_tac[INJ_UNION,domain_union,INJ_SUBSET,SUBSET_UNION]
  >-
    (Cases_on`o'`>>fs[UNCURRY,get_clash_sets_def,LET_THM]
    >- metis_tac[INJ_UNION,domain_union,INJ_SUBSET,SUBSET_UNION]
    >>
    PairCases_on`x`>>fs[]>>
    first_x_assum(qspecl_then[`x2`,`live`,`f`] mp_tac)>>
    discharge_hyps >- size_tac>>rw[]>>
    fs[get_clash_sets_def,UNCURRY,LET_THM]>>
    Cases_on`o0`>>TRY (PairCases_on`x`)>>fs[])
  >>
    (first_x_assum(qspecl_then[`p0`,`live`,`f`]mp_tac)>>
    discharge_hyps>-size_tac>>rw[]>>
    fs[UNCURRY]))

val colouring_ok_alt_thm = store_thm("colouring_ok_alt_thm",
``∀f prog live.
  colouring_ok_alt f prog live
  ⇒
  colouring_ok f prog live``,
  ho_match_mp_tac (fetch "-" "colouring_ok_ind")>>
  rw[]>>
  fs[get_clash_sets_def,colouring_ok_alt_def,colouring_ok_def,LET_THM]
  >-
    (Cases_on`get_clash_sets prog' live`>>
    Cases_on`get_clash_sets prog q`>>fs[]>>
    imp_res_tac get_clash_sets_hd>>
    fs[]>>
    Q.ISPECL_THEN [`prog`,`q`,`f`] assume_tac get_clash_sets_tl>>
    rfs[LET_THM])
  >-
    (
    Cases_on`get_clash_sets prog live`>>
    Cases_on`get_clash_sets prog' live`>>
    FULL_CASE_TAC>>fs[]>>
    imp_res_tac get_clash_sets_hd>>
    fs[]>>
    metis_tac[INJ_SUBSET,SUBSET_DEF,SUBSET_OF_INSERT,domain_union,SUBSET_UNION])
  >>
    Cases_on`h`>>fs[LET_THM]
    >-
      (Cases_on`get_clash_sets prog live`>>fs[])
    >>
    PairCases_on`x`>>fs[]>>
    Cases_on`get_clash_sets prog live`>>fs[]>>
    Cases_on`get_clash_sets x1 live`>>fs[]>>
    EVERY_CASE_TAC>>
    fs[LET_THM]>>
    Cases_on`get_clash_sets prog live`>>
    fs[UNCURRY])

val fs1 = fs[LET_THM,get_clash_sets_def,every_var_def,get_live_def,domain_numset_list_insert,domain_union,EVERY_MEM,get_writes_def,every_var_inst_def,get_live_inst_def,in_clash_sets_def]

val every_var_exp_get_live_exp = prove(
``∀exp.
  every_var_exp (λx. x ∈ domain (get_live_exp exp)) exp``,
  ho_match_mp_tac get_live_exp_ind>>
  rw[]>>fs[get_live_exp_def,every_var_exp_def]>>
  fs[EVERY_MEM]>>rw[]>>res_tac>>
  match_mp_tac every_var_exp_mono>>
  HINT_EXISTS_TAC>>fs[]>>
  metis_tac[SUBSET_DEF,domain_FOLDR_union_subset])

(*Every variable is in some clash set*)
val every_var_in_get_clash_set = store_thm("every_var_in_get_clash_set",
``∀prog live.
  let (hd,clash_sets) = get_clash_sets prog live in
  let ls = hd::clash_sets in
  (∀x. x ∈ domain live ⇒ in_clash_sets ls x) ∧
  (every_var (in_clash_sets ls) prog)``,
  completeInduct_on`prog_size (K 0) prog`>>
  ntac 2 (fs[Once PULL_FORALL])>>
  rpt strip_tac>>
  Cases_on`prog`>>fs1
  >-
    (*Move*)
    (qpat_abbrev_tac`s1 = numset_list_insert A B`>>
    qpat_abbrev_tac`s2 = union A live`>>
    rw[]
    >-
      (qexists_tac`s2`>>fs[Abbr`s2`,domain_union])
    >-
      (qexists_tac`s2`>>fs[Abbr`s2`,domain_numset_list_insert,domain_union])
    >>
      qexists_tac`s1`>>fs[Abbr`s1`,domain_numset_list_insert,domain_union])
  >-
    (Cases_on`i`>>fs1>>fs[get_writes_inst_def]
    >-
      (rw[]>>qexists_tac`union (insert n () LN) live`>>fs[domain_union])
    >-
      (Cases_on`a`>>fs1>>fs[get_writes_inst_def]>>
      EVERY_CASE_TAC>>rw[]>>
      fs[every_var_imm_def,in_clash_sets_def]>>
      TRY(qexists_tac`union (insert n () LN) live`>>fs[domain_union]>>
          NO_TAC)>>
      TRY(qexists_tac`insert n0 () (insert n' () (delete n live))`>>fs[]>>
          NO_TAC)>>
      qexists_tac`insert n0 () (delete n live)`>>fs[])
    >>
      Cases_on`m`>>Cases_on`a`>>fs1>>fs[get_writes_inst_def]>>rw[]>>
      TRY(qexists_tac`union (insert n () LN) live`>>fs[domain_union]>>
          NO_TAC)>>
      TRY(qexists_tac`insert n' () (delete n live)`>>fs[]>>NO_TAC)>>
      TRY(qexists_tac`insert n' () (insert n () live)`>>fs[]>>NO_TAC)>>
      HINT_EXISTS_TAC>>fs[])
  >-
    (rw[]>>
    TRY(qexists_tac`union (insert n () LN) live`>>fs[domain_union])>>
    Q.ISPEC_THEN `e` assume_tac every_var_exp_get_live_exp>>
    match_mp_tac every_var_exp_mono>>
    HINT_EXISTS_TAC>>rw[in_clash_sets_def]>>
    Cases_on`x=n`
    >-
      (qexists_tac`union (insert n () LN) live`>>fs[domain_union])
    >>
      (qexists_tac`union (get_live_exp e) (delete n live)`>>
      fs[domain_union]))
  >-
    (rw[]>>
    qexists_tac`union(insert n () LN) live`>>fs[domain_union])
  >-
    (rw[]>-(HINT_EXISTS_TAC>>fs[])>>
    Q.ISPEC_THEN `e` assume_tac every_var_exp_get_live_exp>>
    match_mp_tac every_var_exp_mono>>
    HINT_EXISTS_TAC>>rw[in_clash_sets_def]>>
    qexists_tac`union (get_live_exp e) live`>>
    fs[domain_union])
  >-
    (rw[]
    >-
      (HINT_EXISTS_TAC>>fs[])
    >-
      (qexists_tac `insert n () (union (get_live_exp e) live)`>>fs[])
    >>
    Q.ISPEC_THEN `e` assume_tac every_var_exp_get_live_exp>>
    match_mp_tac every_var_exp_mono>>
    HINT_EXISTS_TAC>>rw[in_clash_sets_def]>>
    qexists_tac`insert n () (union (get_live_exp e) live)`>>
    fs[domain_union])
  >-
    (*Call*)
    (Cases_on`o'`>>fs1
    >-
      (rw[]>-(HINT_EXISTS_TAC>>fs[])>>
      qexists_tac`numset_list_insert l LN`>>fs[domain_numset_list_insert])
    >>
      PairCases_on`x`>>Cases_on`o0`>>fs1
      >-
        (first_x_assum(qspecl_then[`x2`,`live`] mp_tac)>>
        discharge_hyps>- (fs[prog_size_def]>>DECIDE_TAC)>>
        Cases_on`get_clash_sets x2 live`>>rw[]
        >-
          (first_x_assum(qspec_then`x'`assume_tac)>>rfs[]>>
          HINT_EXISTS_TAC>>fs[])
        >>
        qpat_abbrev_tac`A = union x1 X`>>
        qpat_abbrev_tac`B = insert x0 () x1`>>
        TRY(qexists_tac`A`>>
          fs[Abbr`A`,domain_union,domain_numset_list_insert]>>NO_TAC)>>
        TRY(qexists_tac`B`>>fs[Abbr`B`]) >>
        match_mp_tac every_var_mono>>
        HINT_EXISTS_TAC>>fs[]>>rw[in_clash_sets_def]>>
        HINT_EXISTS_TAC>>fs[])
      >>
        PairCases_on`x`>>fs[]>>
        first_assum(qspecl_then[`x2`,`live`] mp_tac)>>
        discharge_hyps>- (fs[prog_size_def]>>DECIDE_TAC)>>
        first_x_assum(qspecl_then[`x1'`,`live`] mp_tac)>>
        discharge_hyps>- (fs[prog_size_def]>>DECIDE_TAC)>>
        Cases_on`get_clash_sets x2 live`>>
        Cases_on`get_clash_sets x1' live`>>rw[]
        >-
          (first_x_assum(qspec_then`x'`assume_tac)>>rfs[]>>
          HINT_EXISTS_TAC>>fs[])
        >>
        qpat_abbrev_tac`A = union x1 X`>>
        qpat_abbrev_tac`B = insert x0 () x1`>>
        qpat_abbrev_tac`D = insert x0' () x1`>>
        TRY(qexists_tac`A`>>
          fs[Abbr`A`,domain_union,domain_numset_list_insert]>>NO_TAC)>>
        TRY(qexists_tac`B`>>fs[Abbr`B`]>>NO_TAC) >>
        TRY(qexists_tac`D`>>fs[Abbr`D`]) >>
        match_mp_tac every_var_mono>>
        TRY(HINT_EXISTS_TAC)>>
        TRY(qexists_tac`in_clash_sets (q'::r')`)>>
        fs[]>>rw[in_clash_sets_def]>>
        HINT_EXISTS_TAC>>fs[])
  >-
    (first_assum(qspecl_then[`p0`,`live`] mp_tac)>>discharge_hyps
    >-
      (fs[prog_size_def]>>DECIDE_TAC)
    >>
    Cases_on`get_clash_sets p0 live`>>rw[]>>
    first_x_assum(qspecl_then[`p`,`q`] mp_tac)>>discharge_hyps
    >-
      (fs[prog_size_def]>>DECIDE_TAC)
    >>
    Cases_on`get_clash_sets p q`>>rw[]>>
    TRY (metis_tac[every_var_mono])>>
    match_mp_tac every_var_mono>>
    TRY(pop_assum kall_tac>>HINT_EXISTS_TAC)>>
    TRY HINT_EXISTS_TAC>>
    fs[in_clash_sets_def]>>
    metis_tac[])
  >-
    (first_assum(qspecl_then[`p0`,`live`] mp_tac)>>discharge_hyps
    >-
      (fs[prog_size_def]>>DECIDE_TAC)
    >>
    Cases_on`get_clash_sets p0 live`>>rw[]>>
    first_assum(qspecl_then[`p`,`live`] mp_tac)>>discharge_hyps
    >-
      (fs[prog_size_def]>>DECIDE_TAC)
    >>
    Cases_on`get_clash_sets p live`>>rw[]>>
    Cases_on`r`>>fs[every_var_imm_def]>>
    fs[in_clash_sets_def,domain_union]>>
    TRY(match_mp_tac every_var_mono>>fs[in_clash_sets_def]>>
      HINT_EXISTS_TAC>>rw[]>>fs[in_clash_sets_def])>>
    TRY( match_mp_tac every_var_mono>>fs[in_clash_sets_def]>>
    fs[CONJ_COMM]>>
    first_assum (match_exists_tac o concl)>>rw[]>>fs[in_clash_sets_def])>>
    res_tac>>
    TRY(qexists_tac`insert n' () (insert n () (union q' q))`>>
        fs[domain_union]>>metis_tac[domain_union])>>
    TRY(HINT_EXISTS_TAC>>metis_tac[domain_union])>>
    TRY(qexists_tac`insert n () (union q' q)`>>
        fs[domain_union]>>metis_tac[domain_union]))
  >-
    (rw[]
    >-
      (HINT_EXISTS_TAC>>fs[])
    >>
      qexists_tac`insert n () s`>>fs[])
  >-
    (rw[]>-(HINT_EXISTS_TAC>>fs[])>>
    qexists_tac`insert n () live`>>fs[])
  >>
    (rw[]>-(HINT_EXISTS_TAC>>fs[])>>
    qexists_tac`insert n () (insert n0 () live)`>>fs[]))





